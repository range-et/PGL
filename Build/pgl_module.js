import * as $7jljs$process from "process";

function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}
var $parcel$global =
typeof globalThis !== 'undefined'
  ? globalThis
  : typeof self !== 'undefined'
  ? self
  : typeof window !== 'undefined'
  ? window
  : typeof global !== 'undefined'
  ? global
  : {};
function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}
var $parcel$modules = {};
var $parcel$inits = {};

var parcelRequire = $parcel$global["parcelRequired21f"];
if (parcelRequire == null) {
  parcelRequire = function(id) {
    if (id in $parcel$modules) {
      return $parcel$modules[id].exports;
    }
    if (id in $parcel$inits) {
      var init = $parcel$inits[id];
      delete $parcel$inits[id];
      var module = {id: id, exports: {}};
      $parcel$modules[id] = module;
      init.call(module.exports, module, module.exports);
      return module.exports;
    }
    var err = new Error("Cannot find module '" + id + "'");
    err.code = 'MODULE_NOT_FOUND';
    throw err;
  };

  parcelRequire.register = function register(id, init) {
    $parcel$inits[id] = init;
  };

  $parcel$global["parcelRequired21f"] = parcelRequire;
}
parcelRequire.register("fXQP4", function(module, exports) {

$parcel$export(module.exports, "default", () => $b9f55733e92b0fab$export$2e2bcd8739ae039);

var $3JWOZ = parcelRequire("3JWOZ");

var $je3oj = parcelRequire("je3oj");

var $7T9Wu = parcelRequire("7T9Wu");

var $03PHD = parcelRequire("03PHD");
// draw kamada kawai
async function SimulateKamadaKawai(G, iterations) {
    const adjList = G.get_adjacency();
    // pos map
    const PosMapX = new Map();
    const PosMapY = new Map();
    let rx, ry;
    for (const node of adjList.keys()){
        rx = Math.random() * 200;
        ry = Math.random() * 200;
        PosMapX.set(node, rx);
        PosMapY.set(node, ry);
    }
    // start simulation
    for(let i = 0; i < iterations; i++)// calculate the clustering force
    for (const node1 of adjList.keys()){
        // this chunk is for the attraction force
        // get the node pos
        const neighbours = adjList.get(node1);
        // get the set of x's
        const x_s = [];
        // get the set of y's
        const y_s = [];
        // now iterate through the pos list and append
        neighbours.forEach((n_s)=>{
            const n_pos_x = PosMapX.get(n_s);
            const n_pos_y = PosMapY.get(n_s);
            x_s.push(n_pos_x);
            y_s.push(n_pos_y);
        });
        // now average out the values
        const new_c_xpos = (0, $3JWOZ.default).calculateAverage(x_s);
        const new_c_ypos = (0, $3JWOZ.default).calculateAverage(y_s);
        // this chunk is for the repelling force
        const x_r = [];
        const y_r = [];
        // then find the element
        for (const otherNode of G.nodes.keys())// get the position of all the other nodes
        if (otherNode != node1) {
            // calculate inverse distance
            const distDiffX = PosMapX.get(otherNode) - PosMapX.get(node1);
            const distDiffY = PosMapY.get(otherNode) - PosMapY.get(node1);
            // get the inverse square value
            // add that to the *_r arrays
            x_r.push(distDiffX);
            y_r.push(distDiffY);
        }
        // this is the repulsion value
        const A_mult = 2;
        const new_x_r_pos = A_mult * 1 / ((0, $3JWOZ.default).calculateAverage(x_r) * (0, $3JWOZ.default).calculateAverage(x_r));
        const new_y_r_pos = A_mult * 1 / ((0, $3JWOZ.default).calculateAverage(y_r) * (0, $3JWOZ.default).calculateAverage(y_r));
        // calculate the dispacement amount in c/y pos
        // this is the cohesion value
        const C_mult = 1;
        const new_c_xpos_dispacement = C_mult * (new_c_xpos - PosMapX.get(node1));
        const new_c_ypos_dispacement = C_mult * (new_c_ypos - PosMapY.get(node1));
        // then add the x and y components of the two vectors
        const new_xpos = new_x_r_pos + new_c_xpos_dispacement + PosMapX.get(node1);
        const new_ypos = new_y_r_pos + new_c_ypos_dispacement + PosMapY.get(node1);
        // now set these positions
        PosMapX.set(node1, new_xpos);
        PosMapY.set(node1, new_ypos);
    }
    // return the position
    let PosMap = new Map();
    for (const p of PosMapX.keys())PosMap.set(p, new (0, $7T9Wu.Point)(PosMapX.get(p), 0, PosMapY.get(p)));
    // get / set positions
    // move the points
    // get the average pos
    const sim_x = [];
    const sim_y = [];
    const sim_z = [];
    let interimPoint;
    for (const p1 of PosMap.keys()){
        interimPoint = PosMap.get(p1);
        sim_x.push(interimPoint.x);
        sim_y.push(interimPoint.y);
        sim_z.push(interimPoint.z);
    }
    const x_displacement = calculateAverage(sim_x);
    const y_displacement = calculateAverage(sim_y);
    const z_displacement = calculateAverage(sim_z);
    const dispacementVector = new (0, $7T9Wu.Point)(-x_displacement, -y_displacement, -z_displacement);
    PosMap = movePmap(PosMap, dispacementVector);
    G.apply_position_map(PosMap);
    const lmap = DrawEdgeLines(G, 1);
    const newLmap = await DrawEdgeBundling(lmap, 12, 5);
    return {
        pmap: PosMap,
        emap: newLmap.emap
    };
}
// instanciate a random set of positions 
function InstanciateRandomPositions(G) {
    const adjList = G.get_adjacency();
    const PosMapX = new Map();
    const PosMapY = new Map();
    for (const node of adjList.keys()){
        PosMapX.set(node, Math.random() * 200);
        PosMapY.set(node, Math.random() * 200);
    }
    let PosMap = new Map();
    for (const p of PosMapX.keys())PosMap.set(p, new (0, $7T9Wu.Point)(PosMapX.get(p), 0, PosMapY.get(p)));
    G.apply_position_map(PosMap);
    const lmap = DrawEdgeLines(G, 1);
    return {
        pmap: PosMap,
        emap: lmap
    };
}
// draw the edge representations and then store them in the edge classes
function DrawEdgeLines(G, divDistance) {
    // this is the return map
    const lineMap = new Map();
    for (const key of G.edges.keys()){
        const edge = G.edges.get(key);
        // get the start pos
        const start = G.nodes.get(edge.start).data.pos;
        const end = G.nodes.get(edge.end).data.pos;
        const Line = (0, $je3oj.default).line_from_start_end_distance(start, end, divDistance);
        lineMap.set(key, Line);
    }
    return lineMap;
}
// update edge lines after moving points or something 
function UpdateEdgeLinesDist(G, divDistance) {
    let edge, start, end, line;
    for (const key of G.edges.keys()){
        edge = G.edges.get(key);
        // get the start pos
        start = G.nodes.get(edge.start).data.pos;
        end = G.nodes.get(edge.end).data.pos;
        line = (0, $je3oj.default).line_from_start_end_distance(start, end, divDistance);
        edge.data.ldata = line;
    }
}
// function Update EdgeLines based on the number of divisions 
function UpdateEdgeLinesDivs(G, Divs) {
    let edge, start, end, line;
    for (const key of G.edges.keys()){
        edge = G.edges.get(key);
        // get the start pos
        start = G.nodes.get(edge.start).data.pos;
        end = G.nodes.get(edge.end).data.pos;
        line = (0, $je3oj.default).line_from_start_end_divisions(start, end, Divs);
        edge.data.ldata = line;
    }
}
// now draw out the edge bundling thing
async function DrawEdgeBundling(LineMap, iterations, distance) {
    const returnArray = LineMap;
    // run it for whatever number of iterations
    for(let i = 0; i < iterations; i++)// then iterate through every line
    for (const key of returnArray.keys()){
        // then get the line that we are working with
        const line = returnArray.get(key).data.ldata;
        // then for each point in the line we have to move it closer to the other points
        for(let ii = 1; ii < line.points.length - 1; ii++){
            // then get the point that we need to work with
            const x_s = [];
            const y_s = [];
            const z_s = [];
            const pnt = line.points[ii];
            // then run the point accumulation algoritm
            for (const otherKey of returnArray.keys())if (otherKey != key) {
                // then get the other line
                const otherLine = returnArray.get(otherKey).data.ldata;
                for(let iii = 1; iii < otherLine.points.length - 1; iii++){
                    const otherpoint = otherLine.points[iii];
                    const d = (0, $3JWOZ.default).calculateSquaredDistance(pnt, otherpoint);
                    if (d <= Math.pow(distance, 2)) {
                        const x_d = otherpoint.x - pnt.x;
                        const y_d = otherpoint.y - pnt.y;
                        const z_d = otherpoint.z - pnt.z;
                        x_s.push(x_d);
                        y_s.push(y_d);
                        z_s.push(z_d);
                    }
                }
            }
            // now create a new displacement amount
            const avgx = pnt.x + 0.8 * ((0, $3JWOZ.default).calculateAverage(x_s) || 0);
            const avgy = pnt.y + 0.8 * ((0, $3JWOZ.default).calculateAverage(y_s) || 0);
            const avgz = pnt.z + 0.8 * ((0, $3JWOZ.default).calculateAverage(z_s) || 0);
            const newPoint = new (0, $7T9Wu.Point)(avgx, avgy, avgz);
            line.points[ii] = newPoint;
        }
    }
    // now return that array
    return {
        emap: returnArray
    };
}
// displace the th edges
function DisplaceEdgeInY(LineMap, displacement) {
    for (const key of LineMap.keys()){
        const line = LineMap.get(key);
        // now for all the points in this
        let pnt, ydisval;
        for(let i = 0; i < line.data.ldata.points.length; i++){
            pnt = line.data.ldata.points[i];
            ydisval = displacement * Math.sin(Math.PI * i / (line.data.ldata.points.length - 1));
            pnt.y = pnt.y + ydisval;
        }
    }
}
// displace the graph by some measure 
function DisplaceVertices(nodeMap, parameter, displacement) {
    let max = 0;
    let value, ydisplacement;
    // go through the thing and set the min max values 
    for (const node of nodeMap.values()){
        value = eval("node.data." + parameter);
        if (value >= max) max = value;
    }
    // go through the nodes again and set the values 
    for (const node2 of nodeMap.values()){
        value = eval("node.data." + parameter);
        ydisplacement = value / max * displacement;
        // now filter the values so that we know that the values are between a max and a min
        ydisplacement = Math.max(0, ydisplacement); // this sets the lower bound to be something 
        ydisplacement = Math.min(displacement, ydisplacement); // this sets the upper bound of the thing
        node2.data.pos.y = ydisplacement;
    }
}
// draw the circular vertical packing crypto like drawing
async function HivePlot(G, selectedNode, step, startP) {
    const adj = G.get_adjacency();
    const DijkstraDepth = await (0, $03PHD.default).Dijkstra(G, selectedNode);
    // calculate the number of steps that I am searching through
    const steps = Math.max(...[
        ...DijkstraDepth.values()
    ]);
    // step map
    const stepMap = new Map();
    // now create a stepped ring of stuff
    for(let i = 0; i <= steps; i++){
        const ntier = [];
        for (const nkey of DijkstraDepth.keys())if (i == DijkstraDepth.get(nkey)) ntier.push(nkey);
        stepMap.set(i, ntier);
    }
    // the returning pos map
    const Pmap = new Map();
    // now find the relevant node Positions
    // get the start positions
    const xoff = startP.x || 0;
    const yoff = startP.y || 0;
    const zoff = startP.z || 0;
    // set the positions
    for (const node of adj.keys()){
        const yval = DijkstraDepth.get(node) * step;
        const depthArr = stepMap.get(DijkstraDepth.get(node));
        const angle = 2 * Math.PI * (depthArr.indexOf(node) / depthArr.length);
        const xval = Math.sin(angle) * yval;
        const zval = Math.cos(angle) * yval;
        // construct a new point
        const pnt = new (0, $7T9Wu.Point)(xval + xoff, -yval + yoff, zval + zoff);
        Pmap.set(node, pnt);
    }
    // simulate the lines
    G.apply_position_map(Pmap);
    const lmap = DrawEdgeLines(G, 1);
    const newLmap = await DrawEdgeBundling(lmap, 12, 5);
    return {
        pmap: Pmap,
        emap: newLmap.emap
    };
}
// move graph
function MoveGraph(G, dispacement) {
    const Pmap = G.get_position_map();
    const NewPmap = MovePmap(Pmap, dispacement);
    G.apply_position_map(NewPmap);
}
// move pmap
function MovePmap(Pmap, displacement) {
    const newPmap = new Map();
    for (const node of Pmap.keys()){
        const p = Pmap.get(node);
        p.translate(displacement);
        newPmap.set(node, p);
    }
    return newPmap;
}
var $b9f55733e92b0fab$export$2e2bcd8739ae039 = {
    SimulateKamadaKawai: SimulateKamadaKawai,
    DrawEdgeLines: DrawEdgeLines,
    DrawEdgeBundling: DrawEdgeBundling,
    HivePlot: HivePlot,
    DisplaceEdgeInY: DisplaceEdgeInY,
    MoveGraph: MoveGraph,
    InstanciateRandomPositions: InstanciateRandomPositions,
    DisplaceVertices: DisplaceVertices,
    UpdateEdgeLinesDist: UpdateEdgeLinesDist,
    UpdateEdgeLinesDivs: UpdateEdgeLinesDivs
};

});
parcelRequire.register("3JWOZ", function(module, exports) {

$parcel$export(module.exports, "default", () => $2b9333ccd3e7770b$export$2e2bcd8739ae039);
// Calculate average
function $2b9333ccd3e7770b$var$calculateAverage(arr) {
    let runningSum = 0;
    for(let i = 0; i < arr.length; i++)runningSum = runningSum + arr[i];
    const avg = runningSum / arr.length;
    return avg;
}
// calculate distance between two points
function $2b9333ccd3e7770b$var$calculateDistance(p1, p2) {
    const d = Math.pow(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2) + Math.pow(p1.z - p2.z, 2), 0.5);
    return d;
}
function $2b9333ccd3e7770b$var$calculateSquaredDistance(p1, p2) {
    const d = Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2) + Math.pow(p1.z - p2.z, 2);
    return d;
}
function $2b9333ccd3e7770b$var$getRandomSubset(arr, n) {
    var result = new Array(n), len = arr.length, taken = new Array(len);
    if (n > len) throw new RangeError("getRandom: more elements taken than available");
    while(n--){
        var x = Math.floor(Math.random() * len);
        result[n] = arr[x in taken ? taken[x] : x];
        taken[x] = --len in taken ? taken[len] : len;
    }
    return result;
}
var $2b9333ccd3e7770b$export$2e2bcd8739ae039 = {
    calculateAverage: $2b9333ccd3e7770b$var$calculateAverage,
    calculateDistance: $2b9333ccd3e7770b$var$calculateDistance,
    calculateSquaredDistance: $2b9333ccd3e7770b$var$calculateSquaredDistance,
    getRandomSubset: $2b9333ccd3e7770b$var$getRandomSubset
};

});

parcelRequire.register("je3oj", function(module, exports) {

$parcel$export(module.exports, "default", () => $dff1f486beb1bf4c$export$2e2bcd8739ae039);

var $7T9Wu = parcelRequire("7T9Wu");

var $lJKuM = parcelRequire("lJKuM");

var $3JWOZ = parcelRequire("3JWOZ");
function $dff1f486beb1bf4c$var$line_from_start_end_divisions(start, end, divisions) {
    // create a start and end time 
    const Start = new (0, $7T9Wu.Point)(start.x, start.y, start.z);
    const End = new (0, $7T9Wu.Point)(end.x, end.y, end.z);
    // interpolated points
    const points = [];
    // divisions 
    for(let i = 0; i <= divisions; i++){
        const interVar = i / divisions;
        const newx = interVar * Start.x + (1 - interVar) * End.x;
        const newy = interVar * Start.y + (1 - interVar) * End.y;
        const newz = interVar * Start.z + (1 - interVar) * End.z;
        const newPoint = new (0, $7T9Wu.Point)(newx, newy, newz);
        points.push(newPoint);
    }
    // create a new point 
    const SubdividedLine = new (0, $lJKuM.Line)(points);
    return SubdividedLine;
}
function $dff1f486beb1bf4c$var$line_from_start_end_distance(start, end, distance) {
    const dist = (0, $3JWOZ.default).calculateDistance(start, end);
    const divs = Math.round(dist / distance) + 2;
    const subdivline = $dff1f486beb1bf4c$var$line_from_start_end_divisions(start, end, divs);
    return subdivline;
}
function $dff1f486beb1bf4c$var$centroid(points) {
    let rx = 0;
    let ry = 0;
    let rz = 0;
    points.forEach((element)=>{
        rx += element.x;
        ry += element.y;
        rz += element.z;
    });
    rx = rx / points.length;
    ry = ry / points.length;
    rz = rz / points.length;
    const centroid1 = new (0, $7T9Wu.Point)(rx, ry, rz);
    return centroid1;
}
var $dff1f486beb1bf4c$export$2e2bcd8739ae039 = {
    line_from_start_end_divisions: $dff1f486beb1bf4c$var$line_from_start_end_divisions,
    line_from_start_end_distance: $dff1f486beb1bf4c$var$line_from_start_end_distance,
    Point: $7T9Wu.Point,
    Line: $lJKuM.Line,
    centroid: $dff1f486beb1bf4c$var$centroid
};

});
parcelRequire.register("7T9Wu", function(module, exports) {

$parcel$export(module.exports, "Point", () => $5be561ce1e188a6b$export$baf26146a414f24a);
class $5be561ce1e188a6b$export$baf26146a414f24a {
    constructor(x, y, z){
        this.x = x;
        this.y = y;
        this.z = z;
    }
    translate(Point1) {
        this.x = this.x + Point1.x;
        this.y = this.y + Point1.y;
        this.z = this.z + Point1.z;
    }
}

});

parcelRequire.register("lJKuM", function(module, exports) {

$parcel$export(module.exports, "Line", () => $fd31ddfd8fe8eb05$export$17d680238e50603e);

var $7T9Wu = parcelRequire("7T9Wu");
class $fd31ddfd8fe8eb05$export$17d680238e50603e {
    constructor(points){
        this.points = [];
        points.forEach((p)=>{
            const point = new (0, $7T9Wu.Point)(p.x, p.y, p.z);
            this.points.push(point);
        });
    }
}

});


parcelRequire.register("03PHD", function(module, exports) {

$parcel$export(module.exports, "default", () => $00b8630467633a1d$export$2e2bcd8739ae039);

var $dPfZ4 = parcelRequire("dPfZ4");
// do a BFS Search Starting from some point
// searches the whole graph and returns a map of which node
// was searched from where
async function $00b8630467633a1d$var$BFSSearch(G, node) {
    const adj = G.get_adjacency();
    const exploredFromMap = new Map();
    const explored = [];
    const stack = [];
    // queue the first node
    stack.push(node);
    exploredFromMap.set(node, -1);
    // search through the whole graph
    while(stack.length > 0){
        const currentNode = stack.pop();
        // add this current node to the explored list
        explored.push(currentNode);
        const neighbours = adj.get(currentNode);
        for(let i = 0; i < neighbours.length; i++){
            const neighbour = neighbours[i];
            if (!explored.includes(neighbour)) {
                stack.push(neighbour);
                exploredFromMap.set(neighbour, currentNode);
            }
        }
    }
    // then return the explored from map
    return exploredFromMap;
}
// do a dijkstra Search
async function $00b8630467633a1d$var$Dijkstra(G, Node) {
    const adj = G.get_adjacency();
    const Dmap = new Map();
    // get the explored from map
    const exploredFromMap = await $00b8630467633a1d$var$BFSSearch(G, Node);
    // then for each element in the map go through
    // contact trace where that element came from
    for (const n of adj.keys()){
        let i = 0;
        let exploredFrom = exploredFromMap.get(n);
        while(exploredFrom != -1){
            exploredFrom = exploredFromMap.get(exploredFrom);
            i += 1;
        }
        Dmap.set(n, i);
    }
    // now return this map
    return Dmap;
}
// This file contains basic things like
// Graph searches and stuff
async function $00b8630467633a1d$var$GraphDiameter(graph) {
    // find the diameter of the graph
    // start Dijkstra from some random node
    let seed = Math.floor(Math.random() * graph.nodes.size);
    let Dstart = await $00b8630467633a1d$var$Dijkstra(graph, seed);
    // iterate through all the values and then get
    // the value that is the highest amongst the others
    let currentDistance = -1;
    for (const n of Dstart.keys()){
        const dval = Dstart.get(n);
        if (dval > currentDistance) {
            seed = n;
            currentDistance = dval;
        }
    }
    // then search from there to the furthest point again
    const newStart = seed;
    Dstart = await $00b8630467633a1d$var$Dijkstra(graph, seed);
    // repeat the thing
    currentDistance = -1;
    for (const n1 of Dstart.keys()){
        const dval = Dstart.get(n1);
        if (dval > currentDistance) {
            seed = n1;
            currentDistance = dval;
        }
    }
    const returnObj = {
        start: newStart,
        end: seed,
        distance: currentDistance
    };
    return returnObj;
}
// Select a subrgaph
async function $00b8630467633a1d$var$SelectSubgraph(graph, nodeList) {
    const prunedVertices = new Map();
    const prunedEdges = new Map();
    // set the prunded vertices list
    nodeList.forEach((element)=>{
        // get the element from the graph and set that
        // data element in the  prunded vertices map
        const ndata = graph.nodes.get(element);
        prunedVertices.set(element, ndata);
    });
    // set the pruned edges list
    let i = 0;
    for (const edge of graph.edges.keys()){
        const edgeData = graph.edges.get(edge);
        if (nodeList.includes(edgeData.start) && nodeList.includes(edgeData.end)) {
            prunedEdges.set(i, edgeData);
            i += 1;
        }
    }
    // construct a new graph that represents the new graph
    const newGraph = await (0, $dPfZ4.Graph).create(prunedVertices, prunedEdges);
    return newGraph;
}
var // this is where the exports happen
$00b8630467633a1d$export$2e2bcd8739ae039 = {
    GraphDiameter: $00b8630467633a1d$var$GraphDiameter,
    Dijkstra: $00b8630467633a1d$var$Dijkstra,
    BFSSearch: $00b8630467633a1d$var$BFSSearch,
    SelectSubgraph: $00b8630467633a1d$var$SelectSubgraph
};

});
parcelRequire.register("dPfZ4", function(module, exports) {

$parcel$export(module.exports, "Graph", () => $a10c6fe030ef2f2d$export$614db49f3febe941);
class $a10c6fe030ef2f2d$export$614db49f3febe941 {
    constructor(nodes, edges){
        this.nodes = nodes;
        this.edges = edges;
    // execute Internal methods
    // this.printData();
    }
    // test function
    printData() {
        const message = "This is a graph with " + this.nodes.size + " nodes and " + this.edges.size + " edges";
        console.log(message);
    }
    // initialize
    async initialize() {
        await this.constructAdjacencyList();
    }
    // new create method
    static async create(nodes, edges) {
        const g = new $a10c6fe030ef2f2d$export$614db49f3febe941(nodes, edges);
        await g.initialize();
        return g;
    }
    // construct the adjacency list represntation
    async constructAdjacencyList() {
        // I'm constructing a Graph here so some of the stuff doesnt matter
        this.edges.forEach((edge)=>{
            // get the start point
            const start = edge.start;
            const end = edge.end;
            // set the node property
            if (this.nodes.get(start)) {
                const relevantSNode = this.nodes.get(start);
                relevantSNode.neighbours.push(end);
            } else if (this.nodes.get(end)) {
                const relevantENode = this.nodes.get(end);
                relevantENode.neighbours.push(start);
            }
        });
        // then for each node then get the unique neighbours
        for (const key of this.nodes.keys()){
            const neighs = this.nodes.get(key).neighbours;
            const new_neigh = [
                ...new Set(neighs)
            ];
            const selfIndex = new_neigh.indexOf(key);
            if (selfIndex > -1) new_neigh.splice(selfIndex, 1); // 2nd parameter means remove one item only
            this.nodes.get(key).neighbours = new_neigh;
        }
    }
    // add a node
    add_node(nodeID, data) {
        this.nodes[nodeID] = data;
    }
    // add an edge
    add_edge(start, end, data) {
        const newEdge = new Edge(start, end, data);
        // this is a new edge that we add to the edges
        this.edges.set(this.edges.size, newEdge);
        // also add this to the node neighbours
        const relevantNode = this.nodes.get(start);
        relevantNode.neighbours.push(end);
    }
    // get a sparse reprentation of the graph
    get_adjacency() {
        const SparseMap = new Map();
        // iterate through the node list
        for (const key of this.nodes.keys())SparseMap.set(key, this.nodes.get(key).neighbours);
        return SparseMap;
    }
    // set position based on simulated array
    apply_position_map(data) {
        for (const n of data.keys())this.nodes.get(n).data = {
            ...this.nodes.get(n).data,
            pos: data.get(n)
        };
    }
    // create new edge pos representation
    apply_edge_pos_maps(data) {
        for (const key of data.keys())this.edges.get(key).data = {
            ...this.edges.get(key).data,
            ldata: data.get(key)
        };
    }
    // get the edge reps
    get_edge_lines() {
        const lines = new Map();
        for (const key of this.edges.keys()){
            const edge = this.edges.get(key).data.ldata;
            lines.set(key, edge);
        }
        return lines;
    }
    // graph apply pos and edge map
    apply_drawing_maps(layout) {
        if (layout.pmap) this.apply_position_map(layout.pmap);
        if (layout.emap) this.apply_edge_pos_maps(layout.emap);
    }
    // get the positon map of the graph
    get_position_map() {
        const returnObject = {
            pmap: new Map(),
            emap: new Map()
        };
        for (const node of this.nodes.keys())returnObject.pmap.set(node, this.nodes.get(node).data.pos);
        for (const edge of this.edges.keys())returnObject.emap.set(edge, this.edges.get(edge).data.ldata);
        return returnObject;
    }
}

});



parcelRequire.register("9aLFZ", function(module, exports) {
"use strict";

});


var $dPfZ4 = parcelRequire("dPfZ4");

var $03PHD = parcelRequire("03PHD");
const $c6b6d9334764306a$export$b6cdfb6bd6195507 = {
    "nodes": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        17,
        18,
        19,
        20,
        21,
        22,
        23,
        24,
        25,
        26,
        27,
        28,
        29,
        30,
        31,
        32,
        33
    ],
    "edges": [
        [
            0,
            1
        ],
        [
            0,
            2
        ],
        [
            0,
            3
        ],
        [
            0,
            4
        ],
        [
            0,
            5
        ],
        [
            0,
            6
        ],
        [
            0,
            7
        ],
        [
            0,
            8
        ],
        [
            0,
            10
        ],
        [
            0,
            11
        ],
        [
            0,
            12
        ],
        [
            0,
            13
        ],
        [
            0,
            17
        ],
        [
            0,
            19
        ],
        [
            0,
            21
        ],
        [
            0,
            31
        ],
        [
            1,
            2
        ],
        [
            1,
            3
        ],
        [
            1,
            7
        ],
        [
            1,
            13
        ],
        [
            1,
            17
        ],
        [
            1,
            19
        ],
        [
            1,
            21
        ],
        [
            1,
            30
        ],
        [
            2,
            3
        ],
        [
            2,
            7
        ],
        [
            2,
            8
        ],
        [
            2,
            9
        ],
        [
            2,
            13
        ],
        [
            2,
            27
        ],
        [
            2,
            28
        ],
        [
            2,
            32
        ],
        [
            3,
            7
        ],
        [
            3,
            12
        ],
        [
            3,
            13
        ],
        [
            4,
            6
        ],
        [
            4,
            10
        ],
        [
            5,
            6
        ],
        [
            5,
            10
        ],
        [
            5,
            16
        ],
        [
            6,
            16
        ],
        [
            8,
            30
        ],
        [
            8,
            32
        ],
        [
            8,
            33
        ],
        [
            9,
            33
        ],
        [
            13,
            33
        ],
        [
            14,
            32
        ],
        [
            14,
            33
        ],
        [
            15,
            32
        ],
        [
            15,
            33
        ],
        [
            18,
            32
        ],
        [
            18,
            33
        ],
        [
            19,
            33
        ],
        [
            20,
            32
        ],
        [
            20,
            33
        ],
        [
            22,
            32
        ],
        [
            22,
            33
        ],
        [
            23,
            25
        ],
        [
            23,
            27
        ],
        [
            23,
            29
        ],
        [
            23,
            32
        ],
        [
            23,
            33
        ],
        [
            24,
            25
        ],
        [
            24,
            27
        ],
        [
            24,
            31
        ],
        [
            25,
            31
        ],
        [
            26,
            29
        ],
        [
            26,
            33
        ],
        [
            27,
            33
        ],
        [
            28,
            31
        ],
        [
            28,
            33
        ],
        [
            29,
            32
        ],
        [
            29,
            33
        ],
        [
            30,
            32
        ],
        [
            30,
            33
        ],
        [
            31,
            32
        ],
        [
            31,
            33
        ],
        [
            32,
            33
        ]
    ]
};


const $f1c9d3ba26f93daa$export$aa88f89bcd11f8a9 = {
    nodes: [
        {
            id: 0,
            px: 0.09083423378081436,
            py: 1.164162667707135,
            member: 0
        },
        {
            id: 1,
            px: -0.5395391223661004,
            py: 0.8787097882002372,
            member: 0
        },
        {
            id: 2,
            px: 0.25483951690897244,
            py: -0.011894166387290125,
            member: 0
        },
        {
            id: 3,
            px: 0.5292273814873625,
            py: 0.8137715604013231,
            member: 0
        },
        {
            id: 4,
            px: 0.6759740200024705,
            py: 2.010590015934319,
            member: 3
        },
        {
            id: 5,
            px: 0.6648725961138767,
            py: 2.3765595730406712,
            member: 3
        },
        {
            id: 6,
            px: -0.015476857282255526,
            py: 2.421851366492045,
            member: 3
        },
        {
            id: 7,
            px: 0.9923183157183725,
            py: 0.7358251458599251,
            member: 0
        },
        {
            id: 8,
            px: -0.6148021363450372,
            py: -0.03465499210385469,
            member: 1
        },
        {
            id: 9,
            px: 0.24714516178546894,
            py: -1.012380550604274,
            member: 0
        },
        {
            id: 10,
            px: 1.3293288757439443,
            py: 1.8641805845025743,
            member: 3
        },
        {
            id: 11,
            px: -0.6571791278403557,
            py: 2.2163816367270526,
            member: 0
        },
        {
            id: 12,
            px: 1.5181044222926994,
            py: 1.3282665066698078,
            member: 0
        },
        {
            id: 13,
            px: -0.2979203330003603,
            py: 0.18438685313887027,
            member: 0
        },
        {
            id: 14,
            px: -1.7502345807734376,
            py: -1.0935551887354324,
            member: 1
        },
        {
            id: 15,
            px: -1.630224787934251,
            py: -1.5015879850995024,
            member: 1
        },
        {
            id: 16,
            px: 0.5585243394360673,
            py: 3.5,
            member: 3
        },
        {
            id: 17,
            px: -0.9776584881745712,
            py: 1.799718659872538,
            member: 0
        },
        {
            id: 18,
            px: -1.385649185975611,
            py: -1.870388302312794,
            member: 1
        },
        {
            id: 19,
            px: -0.9638464461397331,
            py: 0.24226946279518707,
            member: 0
        },
        {
            id: 20,
            px: -1.0268125129631975,
            py: -2.1543990524894148,
            member: 1
        },
        {
            id: 21,
            px: -1.3061680833745626,
            py: 1.527228276383933,
            member: 0
        },
        {
            id: 22,
            px: -0.5552461198316926,
            py: -2.2498070887997685,
            member: 1
        },
        {
            id: 23,
            px: 0.8262268914348979,
            py: -1.804253160744954,
            member: 2
        },
        {
            id: 24,
            px: 1.9952840970427212,
            py: -1.0382885070400036,
            member: 2
        },
        {
            id: 25,
            px: 1.9207660053211613,
            py: -0.5823795272244723,
            member: 2
        },
        {
            id: 26,
            px: -0.1664715343791652,
            py: -2.6527209168204373,
            member: 1
        },
        {
            id: 27,
            px: 0.9961959436268844,
            py: -1.0143754028553023,
            member: 2
        },
        {
            id: 28,
            px: 0.6488880579857091,
            py: -1.024671500275854,
            member: 2
        },
        {
            id: 29,
            px: 0.2398196340697841,
            py: -2.171491081802323,
            member: 1
        },
        {
            id: 30,
            px: -1.3348117368940753,
            py: -0.31290471156377053,
            member: 1
        },
        {
            id: 31,
            px: 0.6901260074375327,
            py: -0.2526601933356052,
            member: 2
        },
        {
            id: 32,
            px: -0.6030949145287146,
            py: -1.0927507849665647,
            member: 1
        },
        {
            id: 33,
            px: -0.3533395323856202,
            py: -1.1887389845640028,
            member: 1
        }, 
    ],
    edges: [
        [
            0,
            1
        ],
        [
            0,
            2
        ],
        [
            0,
            3
        ],
        [
            0,
            4
        ],
        [
            0,
            5
        ],
        [
            0,
            6
        ],
        [
            0,
            7
        ],
        [
            0,
            8
        ],
        [
            0,
            10
        ],
        [
            0,
            11
        ],
        [
            0,
            12
        ],
        [
            0,
            13
        ],
        [
            0,
            17
        ],
        [
            0,
            19
        ],
        [
            0,
            21
        ],
        [
            0,
            31
        ],
        [
            1,
            2
        ],
        [
            1,
            3
        ],
        [
            1,
            7
        ],
        [
            1,
            13
        ],
        [
            1,
            17
        ],
        [
            1,
            19
        ],
        [
            1,
            21
        ],
        [
            1,
            30
        ],
        [
            2,
            3
        ],
        [
            2,
            7
        ],
        [
            2,
            8
        ],
        [
            2,
            9
        ],
        [
            2,
            13
        ],
        [
            2,
            27
        ],
        [
            2,
            28
        ],
        [
            2,
            32
        ],
        [
            3,
            7
        ],
        [
            3,
            12
        ],
        [
            3,
            13
        ],
        [
            4,
            6
        ],
        [
            4,
            10
        ],
        [
            5,
            6
        ],
        [
            5,
            10
        ],
        [
            5,
            16
        ],
        [
            6,
            16
        ],
        [
            8,
            30
        ],
        [
            8,
            32
        ],
        [
            8,
            33
        ],
        [
            9,
            33
        ],
        [
            13,
            33
        ],
        [
            14,
            32
        ],
        [
            14,
            33
        ],
        [
            15,
            32
        ],
        [
            15,
            33
        ],
        [
            18,
            32
        ],
        [
            18,
            33
        ],
        [
            19,
            33
        ],
        [
            20,
            32
        ],
        [
            20,
            33
        ],
        [
            22,
            32
        ],
        [
            22,
            33
        ],
        [
            23,
            25
        ],
        [
            23,
            27
        ],
        [
            23,
            29
        ],
        [
            23,
            32
        ],
        [
            23,
            33
        ],
        [
            24,
            25
        ],
        [
            24,
            27
        ],
        [
            24,
            31
        ],
        [
            25,
            31
        ],
        [
            26,
            29
        ],
        [
            26,
            33
        ],
        [
            27,
            33
        ],
        [
            28,
            31
        ],
        [
            28,
            33
        ],
        [
            29,
            32
        ],
        [
            29,
            33
        ],
        [
            30,
            32
        ],
        [
            30,
            33
        ],
        [
            31,
            32
        ],
        [
            31,
            33
        ],
        [
            32,
            33
        ], 
    ]
};



var $dPfZ4 = parcelRequire("dPfZ4");
class $4f62a0545083f26b$export$3e8a3cc8713efbec {
    constructor(data){
        // this data is an arbitrary thing with which I can create any object
        this.data = {
            ...data
        };
        // the neighbours bit is explicity set from the code outside
        this.neighbours = [];
    }
}


class $83a5165462902ef5$export$b9d9805c9b77a56d {
    constructor(start, end, data){
        this.start = start;
        this.end = end;
        this.data = {
            ...data
        };
    }
}


// construct a graph based on an edge list etc
async function $2a82d025d9354169$var$ConstructGraphNodeEdgesList(nodes, edges) {
    // make a node OBJ
    const nodeOBJ = new Map();
    for(let i = 0; i < nodes.length; i++){
        const n = new (0, $4f62a0545083f26b$export$3e8a3cc8713efbec)(nodes[i].data);
        nodeOBJ.set(nodes[i], n);
    }
    // make an edge object
    const edgeOBJ = new Map();
    for(let i1 = 0; i1 < edges.length; i1++){
        const e = new (0, $83a5165462902ef5$export$b9d9805c9b77a56d)(edges[i1][0], edges[i1][1], edges[i1].data);
        edgeOBJ.set(i1, e);
    }
    // make a graph object
    const G = await (0, $dPfZ4.Graph).create(nodeOBJ, edgeOBJ);
    return G;
}
var $2a82d025d9354169$export$2e2bcd8739ae039 = {
    ConstructGraphNodeEdgesList: $2a82d025d9354169$var$ConstructGraphNodeEdgesList
};



var $dPfZ4 = parcelRequire("dPfZ4");

var $7T9Wu = parcelRequire("7T9Wu");



var $fXQP4 = parcelRequire("fXQP4");
async function $1929603c63fa12f5$var$LoadZKC() {
    // load up the dataset representation
    const data = (0, $c6b6d9334764306a$export$b6cdfb6bd6195507);
    const G = await (0, $2a82d025d9354169$export$2e2bcd8739ae039).ConstructGraphNodeEdgesList(data.nodes, data.edges);
    return G;
}
async function $1929603c63fa12f5$var$LoadZKCSimulated() {
    // make a map
    const data = (0, $f1c9d3ba26f93daa$export$aa88f89bcd11f8a9);
    const nodes = new Map();
    const edges = new Map();
    // set the node map
    data.nodes.forEach((node)=>{
        const id = node.id;
        const pos = new (0, $7T9Wu.Point)(node.px * 50, 0, node.py * 50);
        const modularity = node.member;
        const n = new (0, $4f62a0545083f26b$export$3e8a3cc8713efbec)({
            pos: pos,
            size: 10,
            info: "Node Info",
            modularity: modularity
        });
        nodes.set(id, n);
    });
    // set the edge map
    for(let i = 0; i < data.edges.length; i++){
        const edge = data.edges[i];
        const start = edge[0];
        const end = edge[1];
        const e = new (0, $83a5165462902ef5$export$b9d9805c9b77a56d)(start, end, {});
        edges.set(i, e);
    }
    // make a graph object
    const G = await (0, $dPfZ4.Graph).create(nodes, edges);
    const lmap = (0, $fXQP4.default).DrawEdgeLines(G, 10);
    G.apply_edge_pos_maps(lmap);
    return G;
}
var // exports
$1929603c63fa12f5$export$2e2bcd8739ae039 = {
    LoadZKC: $1929603c63fa12f5$var$LoadZKC,
    LoadZKCSimulated: $1929603c63fa12f5$var$LoadZKCSimulated
};




var $fXQP4 = parcelRequire("fXQP4");

var $je3oj = parcelRequire("je3oj");

var $3JWOZ = parcelRequire("3JWOZ");
/**
 * @license
 * Copyright 2010-2022 Three.js Authors
 * SPDX-License-Identifier: MIT
 */ const $084574008ccedf86$export$3545e07a80636437 = "141";
const $084574008ccedf86$export$7177b3e430c2d7ca = {
    LEFT: 0,
    MIDDLE: 1,
    RIGHT: 2,
    ROTATE: 0,
    DOLLY: 1,
    PAN: 2
};
const $084574008ccedf86$export$d46bd3ead7cc759b = {
    ROTATE: 0,
    PAN: 1,
    DOLLY_PAN: 2,
    DOLLY_ROTATE: 3
};
const $084574008ccedf86$export$3237e1f2c1ea1f44 = 0;
const $084574008ccedf86$export$b9a7b4fc5cb15f9b = 1;
const $084574008ccedf86$export$b8058bcc7037d3f3 = 2;
const $084574008ccedf86$export$f24be24dcddeac0d = 3;
const $084574008ccedf86$export$346307dbae2b7447 = 0;
const $084574008ccedf86$export$5813f879eee7cd88 = 1;
const $084574008ccedf86$export$a47c4b43a1be34f0 = 2;
const $084574008ccedf86$export$896ae1ade6c829c4 = 3;
const $084574008ccedf86$export$2ede184fc2998901 = 0;
const $084574008ccedf86$export$d9f0486e75b5ace = 1;
const $084574008ccedf86$export$3b296b6f144d5b03 = 2;
const $084574008ccedf86$export$a62047d29c96d8ff = 1;
const $084574008ccedf86$export$fadb74c06a7f490 = 2;
const $084574008ccedf86$export$63b8d6b580fc65ba = 0;
const $084574008ccedf86$export$5b29a26d96ee6af0 = 1;
const $084574008ccedf86$export$777d8f9551c2216b = 2;
const $084574008ccedf86$export$cdfa06f868e2e467 = 3;
const $084574008ccedf86$export$4138e1c684b46a20 = 4;
const $084574008ccedf86$export$eda4864c68df1fa2 = 5;
const $084574008ccedf86$export$20183a0484ce21a0 = 100;
const $084574008ccedf86$export$73e0df5177988548 = 101;
const $084574008ccedf86$export$28e582859cbec660 = 102;
const $084574008ccedf86$export$c8c1508da8d0600c = 103;
const $084574008ccedf86$export$99948c02fb51055f = 104;
const $084574008ccedf86$export$2110f05edf778d3d = 200;
const $084574008ccedf86$export$8805bad65e24940e = 201;
const $084574008ccedf86$export$7fbe15b28d28cf52 = 202;
const $084574008ccedf86$export$947829af9f2c17f6 = 203;
const $084574008ccedf86$export$d5773124e86cf28c = 204;
const $084574008ccedf86$export$11d468cc7f19e971 = 205;
const $084574008ccedf86$export$a78aed1ca2a87192 = 206;
const $084574008ccedf86$export$5d0fe17fd8773bac = 207;
const $084574008ccedf86$export$ef5f2dd8ffac5574 = 208;
const $084574008ccedf86$export$56b85b2686ab16 = 209;
const $084574008ccedf86$export$c05e2a1fc8609506 = 210;
const $084574008ccedf86$export$69025ce147cee220 = 0;
const $084574008ccedf86$export$7182eb52ea3b3f04 = 1;
const $084574008ccedf86$export$eedccec66ab7ebe = 2;
const $084574008ccedf86$export$296f78a0b892f81a = 3;
const $084574008ccedf86$export$a60d398fc7b7590e = 4;
const $084574008ccedf86$export$7d7234c1240a1fc4 = 5;
const $084574008ccedf86$export$c5e2c52991f30937 = 6;
const $084574008ccedf86$export$2f843afa843d8916 = 7;
const $084574008ccedf86$export$e50ac29801f1774d = 0;
const $084574008ccedf86$export$9f9d94f963c85479 = 1;
const $084574008ccedf86$export$e641dc52bc3494aa = 2;
const $084574008ccedf86$export$9fcb6b4294603b2 = 0;
const $084574008ccedf86$export$98f52c2a46c598ca = 1;
const $084574008ccedf86$export$74b25e54b3bcd548 = 2;
const $084574008ccedf86$export$932b3dd283d4a366 = 3;
const $084574008ccedf86$export$a0d98fe6d7e4af64 = 4;
const $084574008ccedf86$export$2c7b09c1e9abfb5e = 5;
const $084574008ccedf86$export$1beec6768cbb3d2d = 300;
const $084574008ccedf86$export$8759762a6477f2c4 = 301;
const $084574008ccedf86$export$dc59f8aed047f61d = 302;
const $084574008ccedf86$export$d64030b316d3b087 = 303;
const $084574008ccedf86$export$ee99d97d46898098 = 304;
const $084574008ccedf86$export$dbf3e70ff37af79 = 306;
const $084574008ccedf86$export$533346c8e8dac0f5 = 1000;
const $084574008ccedf86$export$9d9334239a5a5e06 = 1001;
const $084574008ccedf86$export$c7e7c00b14f51a4f = 1002;
const $084574008ccedf86$export$727aa5ec3fe39bf0 = 1003;
const $084574008ccedf86$export$d129e38cf6feaa8c = 1004;
const $084574008ccedf86$export$14a4936464a36496 = 1004;
const $084574008ccedf86$export$d2327c1afe5bfdf2 = 1005;
const $084574008ccedf86$export$cbc5b7f5647595d8 = 1005;
const $084574008ccedf86$export$8a72f490b25c56c8 = 1006;
const $084574008ccedf86$export$19a719f377145a13 = 1007;
const $084574008ccedf86$export$dbe96bee3fe9dbf0 = 1007;
const $084574008ccedf86$export$5d8599b6a933fb1b = 1008;
const $084574008ccedf86$export$90d80f1e3506775f = 1008;
const $084574008ccedf86$export$2e8ce08d3f6f5e10 = 1009;
const $084574008ccedf86$export$545fce0311a9796a = 1010;
const $084574008ccedf86$export$88572337f312435f = 1011;
const $084574008ccedf86$export$c63dc51868b06a9d = 1012;
const $084574008ccedf86$export$5c612977753abe2 = 1013;
const $084574008ccedf86$export$c3c7fc4518ebba96 = 1014;
const $084574008ccedf86$export$f6d331659b644596 = 1015;
const $084574008ccedf86$export$2697304443f382bc = 1016;
const $084574008ccedf86$export$b3969b01faf587f2 = 1017;
const $084574008ccedf86$export$18886f8ae33e90de = 1018;
const $084574008ccedf86$export$6c8ea339bfab1301 = 1020;
const $084574008ccedf86$export$988473390501ed4b = 1021;
const $084574008ccedf86$export$7c67423a5ee6f5eb = 1022;
const $084574008ccedf86$export$3f8bb04b555a363c = 1023;
const $084574008ccedf86$export$cc09ccbf6d1ed449 = 1024;
const $084574008ccedf86$export$9053a81c4a69c289 = 1025;
const $084574008ccedf86$export$c1b6b5136be58045 = 1026;
const $084574008ccedf86$export$1e113ac2d0905829 = 1027;
const $084574008ccedf86$export$4e041a7967d15c4b = 1028;
const $084574008ccedf86$export$aa92e870a709d190 = 1029;
const $084574008ccedf86$export$6cdf0b461c7ce8a0 = 1030;
const $084574008ccedf86$export$1ba1c45f9f77d4d7 = 1031;
const $084574008ccedf86$export$c200e7d26f592f21 = 1033;
const $084574008ccedf86$export$21d1799c6d552fc0 = 33776;
const $084574008ccedf86$export$afa304c3e981b668 = 33777;
const $084574008ccedf86$export$d2a1a68024a3e56c = 33778;
const $084574008ccedf86$export$9a79c424327dacf9 = 33779;
const $084574008ccedf86$export$19ada9bbb1af3573 = 35840;
const $084574008ccedf86$export$d0f0355bb3d948e4 = 35841;
const $084574008ccedf86$export$b82296714358084c = 35842;
const $084574008ccedf86$export$b71692456c47b6c3 = 35843;
const $084574008ccedf86$export$6ab91af2d757aee7 = 36196;
const $084574008ccedf86$export$7800993ef8106a6a = 37492;
const $084574008ccedf86$export$23ed8300a860e7d8 = 37496;
const $084574008ccedf86$export$dc5570b4a2b92d48 = 37808;
const $084574008ccedf86$export$68880cd325f8b2fb = 37809;
const $084574008ccedf86$export$7d2c0be323373d95 = 37810;
const $084574008ccedf86$export$22b52da301fc3a3e = 37811;
const $084574008ccedf86$export$c009e2cb4a66485e = 37812;
const $084574008ccedf86$export$118fff5afa255b63 = 37813;
const $084574008ccedf86$export$120713c829ae0667 = 37814;
const $084574008ccedf86$export$c79eeabbf53313e9 = 37815;
const $084574008ccedf86$export$443cf6567cdd6424 = 37816;
const $084574008ccedf86$export$6573984fc9840780 = 37817;
const $084574008ccedf86$export$e7aee563f30091de = 37818;
const $084574008ccedf86$export$2eb8634622ddeab7 = 37819;
const $084574008ccedf86$export$202b1ce7b5d25742 = 37820;
const $084574008ccedf86$export$18ab77abd087e467 = 37821;
const $084574008ccedf86$export$ce40b115e188bc81 = 36492;
const $084574008ccedf86$export$d62fdc9d1b1cccad = 2200;
const $084574008ccedf86$export$dfaf4422ce096e29 = 2201;
const $084574008ccedf86$export$f8f6f2041b78e210 = 2202;
const $084574008ccedf86$export$995b32462a65e855 = 2300;
const $084574008ccedf86$export$30fac1aace31cf4d = 2301;
const $084574008ccedf86$export$198b11ff4c72bb30 = 2302;
const $084574008ccedf86$export$7f795934b84ab523 = 2400;
const $084574008ccedf86$export$24a4ccb5099273b5 = 2401;
const $084574008ccedf86$export$8e8c3ecdcd8e1fee = 2402;
const $084574008ccedf86$export$bcfbbdcf8de7f8cd = 2500;
const $084574008ccedf86$export$d875e029ef558d3 = 2501;
const $084574008ccedf86$export$4c28c87c2dc84758 = 0;
const $084574008ccedf86$export$b23a071aa286eb29 = 1;
const $084574008ccedf86$export$f0d8293634f88842 = 2;
const $084574008ccedf86$export$7207336e4151a112 = 3000;
const $084574008ccedf86$export$f32388edbb32674 = 3001;
const $084574008ccedf86$export$deeb383078690b50 = 3200;
const $084574008ccedf86$export$8f910f4c4f73df11 = 3201;
const $084574008ccedf86$export$2852a58ebdac27b8 = 0;
const $084574008ccedf86$export$9990ad26f9db5b2c = 1;
// Color space string identifiers, matching CSS Color Module Level 4 and WebGPU names where available.
const $084574008ccedf86$export$bfcb490c2dd3db51 = "";
const $084574008ccedf86$export$561f394b24edfcaa = "srgb";
const $084574008ccedf86$export$42429b3acfb233a4 = "srgb-linear";
const $084574008ccedf86$export$69433f11f42d5527 = 0;
const $084574008ccedf86$export$9f542ae4b5baca34 = 7680;
const $084574008ccedf86$export$8a4f28336ef203d3 = 7681;
const $084574008ccedf86$export$2928c0231297c036 = 7682;
const $084574008ccedf86$export$c0e9611c8a15f9a8 = 7683;
const $084574008ccedf86$export$9c2c08927385dcc4 = 34055;
const $084574008ccedf86$export$7c74ea00fa1315e6 = 34056;
const $084574008ccedf86$export$22e2e5726612443 = 5386;
const $084574008ccedf86$export$1343870698229224 = 512;
const $084574008ccedf86$export$8e1d8ed281997fa6 = 513;
const $084574008ccedf86$export$55648a1cde8329a7 = 514;
const $084574008ccedf86$export$2dff107857e6aca2 = 515;
const $084574008ccedf86$export$6f93765ab2f451a2 = 516;
const $084574008ccedf86$export$6f3fb2d2440f2b76 = 517;
const $084574008ccedf86$export$4119cf7b4c98fd5a = 518;
const $084574008ccedf86$export$14cf96713ddd97a8 = 519;
const $084574008ccedf86$export$763e8360f4d7f77d = 35044;
const $084574008ccedf86$export$8505d14ac8546ca = 35048;
const $084574008ccedf86$export$721e63549e51d81e = 35040;
const $084574008ccedf86$export$415731dc4f48e299 = 35045;
const $084574008ccedf86$export$9e809946455f13bc = 35049;
const $084574008ccedf86$export$2ed9499a35b5f832 = 35041;
const $084574008ccedf86$export$32ab2503ea19469a = 35046;
const $084574008ccedf86$export$ab4022c2c3f86315 = 35050;
const $084574008ccedf86$export$ba7f1db36a76a970 = 35042;
const $084574008ccedf86$export$43600cc67fabd9f = "100";
const $084574008ccedf86$export$f63012db5506e7dd = "300 es";
const $084574008ccedf86$export$ca1dce8b5e1de74d = 1035; // fallback for WebGL 1
/**
 * https://github.com/mrdoob/eventdispatcher.js/
 */ class $084574008ccedf86$export$ec8b666c5fe2c75a {
    addEventListener(type, listener) {
        if (this._listeners === undefined) this._listeners = {};
        const listeners = this._listeners;
        if (listeners[type] === undefined) listeners[type] = [];
        if (listeners[type].indexOf(listener) === -1) listeners[type].push(listener);
    }
    hasEventListener(type, listener) {
        if (this._listeners === undefined) return false;
        const listeners = this._listeners;
        return listeners[type] !== undefined && listeners[type].indexOf(listener) !== -1;
    }
    removeEventListener(type, listener) {
        if (this._listeners === undefined) return;
        const listeners = this._listeners;
        const listenerArray = listeners[type];
        if (listenerArray !== undefined) {
            const index = listenerArray.indexOf(listener);
            if (index !== -1) listenerArray.splice(index, 1);
        }
    }
    dispatchEvent(event) {
        if (this._listeners === undefined) return;
        const listeners = this._listeners;
        const listenerArray = listeners[event.type];
        if (listenerArray !== undefined) {
            event.target = this;
            // Make a copy, in case listeners are removed while iterating.
            const array = listenerArray.slice(0);
            for(let i7 = 0, l = array.length; i7 < l; i7++)array[i7].call(this, event);
            event.target = null;
        }
    }
}
const $084574008ccedf86$var$_lut = [];
for(let i = 0; i < 256; i++)$084574008ccedf86$var$_lut[i] = (i < 16 ? "0" : "") + i.toString(16);
let $084574008ccedf86$var$_seed = 1234567;
const $084574008ccedf86$var$DEG2RAD = Math.PI / 180;
const $084574008ccedf86$var$RAD2DEG = 180 / Math.PI;
// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136
function $084574008ccedf86$var$generateUUID() {
    const d0 = Math.random() * 0xffffffff | 0;
    const d1 = Math.random() * 0xffffffff | 0;
    const d2 = Math.random() * 0xffffffff | 0;
    const d3 = Math.random() * 0xffffffff | 0;
    const uuid = $084574008ccedf86$var$_lut[d0 & 0xff] + $084574008ccedf86$var$_lut[d0 >> 8 & 0xff] + $084574008ccedf86$var$_lut[d0 >> 16 & 0xff] + $084574008ccedf86$var$_lut[d0 >> 24 & 0xff] + "-" + $084574008ccedf86$var$_lut[d1 & 0xff] + $084574008ccedf86$var$_lut[d1 >> 8 & 0xff] + "-" + $084574008ccedf86$var$_lut[d1 >> 16 & 0x0f | 0x40] + $084574008ccedf86$var$_lut[d1 >> 24 & 0xff] + "-" + $084574008ccedf86$var$_lut[d2 & 0x3f | 0x80] + $084574008ccedf86$var$_lut[d2 >> 8 & 0xff] + "-" + $084574008ccedf86$var$_lut[d2 >> 16 & 0xff] + $084574008ccedf86$var$_lut[d2 >> 24 & 0xff] + $084574008ccedf86$var$_lut[d3 & 0xff] + $084574008ccedf86$var$_lut[d3 >> 8 & 0xff] + $084574008ccedf86$var$_lut[d3 >> 16 & 0xff] + $084574008ccedf86$var$_lut[d3 >> 24 & 0xff];
    // .toLowerCase() here flattens concatenated strings to save heap memory space.
    return uuid.toLowerCase();
}
function $084574008ccedf86$var$clamp(value, min, max) {
    return Math.max(min, Math.min(max, value));
}
// compute euclidean modulo of m % n
// https://en.wikipedia.org/wiki/Modulo_operation
function $084574008ccedf86$var$euclideanModulo(n, m) {
    return (n % m + m) % m;
}
// Linear mapping from range <a1, a2> to range <b1, b2>
function $084574008ccedf86$var$mapLinear(x, a1, a2, b1, b2) {
    return b1 + (x - a1) * (b2 - b1) / (a2 - a1);
}
// https://www.gamedev.net/tutorials/programming/general-and-gameplay-programming/inverse-lerp-a-super-useful-yet-often-overlooked-function-r5230/
function $084574008ccedf86$var$inverseLerp(x, y, value) {
    if (x !== y) return (value - x) / (y - x);
    else return 0;
}
// https://en.wikipedia.org/wiki/Linear_interpolation
function $084574008ccedf86$var$lerp(x, y, t) {
    return (1 - t) * x + t * y;
}
// http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/
function $084574008ccedf86$var$damp(x, y, lambda, dt) {
    return $084574008ccedf86$var$lerp(x, y, 1 - Math.exp(-lambda * dt));
}
// https://www.desmos.com/calculator/vcsjnyz7x4
function $084574008ccedf86$var$pingpong(x, length = 1) {
    return length - Math.abs($084574008ccedf86$var$euclideanModulo(x, length * 2) - length);
}
// http://en.wikipedia.org/wiki/Smoothstep
function $084574008ccedf86$var$smoothstep(x, min, max) {
    if (x <= min) return 0;
    if (x >= max) return 1;
    x = (x - min) / (max - min);
    return x * x * (3 - 2 * x);
}
function $084574008ccedf86$var$smootherstep(x, min, max) {
    if (x <= min) return 0;
    if (x >= max) return 1;
    x = (x - min) / (max - min);
    return x * x * x * (x * (x * 6 - 15) + 10);
}
// Random integer from <low, high> interval
function $084574008ccedf86$var$randInt(low, high) {
    return low + Math.floor(Math.random() * (high - low + 1));
}
// Random float from <low, high> interval
function $084574008ccedf86$var$randFloat(low, high) {
    return low + Math.random() * (high - low);
}
// Random float from <-range/2, range/2> interval
function $084574008ccedf86$var$randFloatSpread(range) {
    return range * (0.5 - Math.random());
}
// Deterministic pseudo-random float in the interval [ 0, 1 ]
function $084574008ccedf86$var$seededRandom(s) {
    if (s !== undefined) $084574008ccedf86$var$_seed = s;
    // Mulberry32 generator
    let t = $084574008ccedf86$var$_seed += 0x6D2B79F5;
    t = Math.imul(t ^ t >>> 15, t | 1);
    t ^= t + Math.imul(t ^ t >>> 7, t | 61);
    return ((t ^ t >>> 14) >>> 0) / 4294967296;
}
function $084574008ccedf86$var$degToRad(degrees) {
    return degrees * $084574008ccedf86$var$DEG2RAD;
}
function $084574008ccedf86$var$radToDeg(radians) {
    return radians * $084574008ccedf86$var$RAD2DEG;
}
function $084574008ccedf86$var$isPowerOfTwo(value) {
    return (value & value - 1) === 0 && value !== 0;
}
function $084574008ccedf86$var$ceilPowerOfTwo(value) {
    return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));
}
function $084574008ccedf86$var$floorPowerOfTwo(value) {
    return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));
}
function $084574008ccedf86$var$setQuaternionFromProperEuler(q, a, b, c, order) {
    // Intrinsic Proper Euler Angles - see https://en.wikipedia.org/wiki/Euler_angles
    // rotations are applied to the axes in the order specified by 'order'
    // rotation by angle 'a' is applied first, then by angle 'b', then by angle 'c'
    // angles are in radians
    const cos = Math.cos;
    const sin = Math.sin;
    const c2 = cos(b / 2);
    const s2 = sin(b / 2);
    const c13 = cos((a + c) / 2);
    const s13 = sin((a + c) / 2);
    const c1_3 = cos((a - c) / 2);
    const s1_3 = sin((a - c) / 2);
    const c3_1 = cos((c - a) / 2);
    const s3_1 = sin((c - a) / 2);
    switch(order){
        case "XYX":
            q.set(c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13);
            break;
        case "YZY":
            q.set(s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13);
            break;
        case "ZXZ":
            q.set(s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13);
            break;
        case "XZX":
            q.set(c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13);
            break;
        case "YXY":
            q.set(s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13);
            break;
        case "ZYZ":
            q.set(s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13);
            break;
        default:
            console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + order);
    }
}
function $084574008ccedf86$var$denormalize$1(value, array) {
    switch(array.constructor){
        case Float32Array:
            return value;
        case Uint16Array:
            return value / 65535.0;
        case Uint8Array:
            return value / 255.0;
        case Int16Array:
            return Math.max(value / 32767.0, -1);
        case Int8Array:
            return Math.max(value / 127.0, -1);
        default:
            throw new Error("Invalid component type.");
    }
}
function $084574008ccedf86$var$normalize(value, array) {
    switch(array.constructor){
        case Float32Array:
            return value;
        case Uint16Array:
            return Math.round(value * 65535.0);
        case Uint8Array:
            return Math.round(value * 255.0);
        case Int16Array:
            return Math.round(value * 32767.0);
        case Int8Array:
            return Math.round(value * 127.0);
        default:
            throw new Error("Invalid component type.");
    }
}
var $084574008ccedf86$export$6a7ef315a0d1ef07 = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    DEG2RAD: $084574008ccedf86$var$DEG2RAD,
    RAD2DEG: $084574008ccedf86$var$RAD2DEG,
    generateUUID: $084574008ccedf86$var$generateUUID,
    clamp: $084574008ccedf86$var$clamp,
    euclideanModulo: $084574008ccedf86$var$euclideanModulo,
    mapLinear: $084574008ccedf86$var$mapLinear,
    inverseLerp: $084574008ccedf86$var$inverseLerp,
    lerp: $084574008ccedf86$var$lerp,
    damp: $084574008ccedf86$var$damp,
    pingpong: $084574008ccedf86$var$pingpong,
    smoothstep: $084574008ccedf86$var$smoothstep,
    smootherstep: $084574008ccedf86$var$smootherstep,
    randInt: $084574008ccedf86$var$randInt,
    randFloat: $084574008ccedf86$var$randFloat,
    randFloatSpread: $084574008ccedf86$var$randFloatSpread,
    seededRandom: $084574008ccedf86$var$seededRandom,
    degToRad: $084574008ccedf86$var$degToRad,
    radToDeg: $084574008ccedf86$var$radToDeg,
    isPowerOfTwo: $084574008ccedf86$var$isPowerOfTwo,
    ceilPowerOfTwo: $084574008ccedf86$var$ceilPowerOfTwo,
    floorPowerOfTwo: $084574008ccedf86$var$floorPowerOfTwo,
    setQuaternionFromProperEuler: $084574008ccedf86$var$setQuaternionFromProperEuler,
    normalize: $084574008ccedf86$var$normalize,
    denormalize: $084574008ccedf86$var$denormalize$1
});
class $084574008ccedf86$export$c977b3e384af9ae1 {
    constructor(x = 0, y = 0){
        this.isVector2 = true;
        this.x = x;
        this.y = y;
    }
    get width() {
        return this.x;
    }
    set width(value) {
        this.x = value;
    }
    get height() {
        return this.y;
    }
    set height(value) {
        this.y = value;
    }
    set(x, y) {
        this.x = x;
        this.y = y;
        return this;
    }
    setScalar(scalar) {
        this.x = scalar;
        this.y = scalar;
        return this;
    }
    setX(x) {
        this.x = x;
        return this;
    }
    setY(y) {
        this.y = y;
        return this;
    }
    setComponent(index, value) {
        switch(index){
            case 0:
                this.x = value;
                break;
            case 1:
                this.y = value;
                break;
            default:
                throw new Error("index is out of range: " + index);
        }
        return this;
    }
    getComponent(index) {
        switch(index){
            case 0:
                return this.x;
            case 1:
                return this.y;
            default:
                throw new Error("index is out of range: " + index);
        }
    }
    clone() {
        return new this.constructor(this.x, this.y);
    }
    copy(v) {
        this.x = v.x;
        this.y = v.y;
        return this;
    }
    add(v, w) {
        if (w !== undefined) {
            console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
            return this.addVectors(v, w);
        }
        this.x += v.x;
        this.y += v.y;
        return this;
    }
    addScalar(s) {
        this.x += s;
        this.y += s;
        return this;
    }
    addVectors(a, b) {
        this.x = a.x + b.x;
        this.y = a.y + b.y;
        return this;
    }
    addScaledVector(v, s) {
        this.x += v.x * s;
        this.y += v.y * s;
        return this;
    }
    sub(v, w) {
        if (w !== undefined) {
            console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
            return this.subVectors(v, w);
        }
        this.x -= v.x;
        this.y -= v.y;
        return this;
    }
    subScalar(s) {
        this.x -= s;
        this.y -= s;
        return this;
    }
    subVectors(a, b) {
        this.x = a.x - b.x;
        this.y = a.y - b.y;
        return this;
    }
    multiply(v) {
        this.x *= v.x;
        this.y *= v.y;
        return this;
    }
    multiplyScalar(scalar) {
        this.x *= scalar;
        this.y *= scalar;
        return this;
    }
    divide(v) {
        this.x /= v.x;
        this.y /= v.y;
        return this;
    }
    divideScalar(scalar) {
        return this.multiplyScalar(1 / scalar);
    }
    applyMatrix3(m) {
        const x = this.x, y = this.y;
        const e = m.elements;
        this.x = e[0] * x + e[3] * y + e[6];
        this.y = e[1] * x + e[4] * y + e[7];
        return this;
    }
    min(v) {
        this.x = Math.min(this.x, v.x);
        this.y = Math.min(this.y, v.y);
        return this;
    }
    max(v) {
        this.x = Math.max(this.x, v.x);
        this.y = Math.max(this.y, v.y);
        return this;
    }
    clamp(min, max) {
        // assumes min < max, componentwise
        this.x = Math.max(min.x, Math.min(max.x, this.x));
        this.y = Math.max(min.y, Math.min(max.y, this.y));
        return this;
    }
    clampScalar(minVal, maxVal) {
        this.x = Math.max(minVal, Math.min(maxVal, this.x));
        this.y = Math.max(minVal, Math.min(maxVal, this.y));
        return this;
    }
    clampLength(min, max) {
        const length = this.length();
        return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
    }
    floor() {
        this.x = Math.floor(this.x);
        this.y = Math.floor(this.y);
        return this;
    }
    ceil() {
        this.x = Math.ceil(this.x);
        this.y = Math.ceil(this.y);
        return this;
    }
    round() {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        return this;
    }
    roundToZero() {
        this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
        this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
        return this;
    }
    negate() {
        this.x = -this.x;
        this.y = -this.y;
        return this;
    }
    dot(v) {
        return this.x * v.x + this.y * v.y;
    }
    cross(v) {
        return this.x * v.y - this.y * v.x;
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y;
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y);
    }
    normalize() {
        return this.divideScalar(this.length() || 1);
    }
    angle() {
        // computes the angle in radians with respect to the positive x-axis
        const angle = Math.atan2(-this.y, -this.x) + Math.PI;
        return angle;
    }
    distanceTo(v) {
        return Math.sqrt(this.distanceToSquared(v));
    }
    distanceToSquared(v) {
        const dx = this.x - v.x, dy = this.y - v.y;
        return dx * dx + dy * dy;
    }
    manhattanDistanceTo(v) {
        return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);
    }
    setLength(length) {
        return this.normalize().multiplyScalar(length);
    }
    lerp(v, alpha) {
        this.x += (v.x - this.x) * alpha;
        this.y += (v.y - this.y) * alpha;
        return this;
    }
    lerpVectors(v1, v2, alpha) {
        this.x = v1.x + (v2.x - v1.x) * alpha;
        this.y = v1.y + (v2.y - v1.y) * alpha;
        return this;
    }
    equals(v) {
        return v.x === this.x && v.y === this.y;
    }
    fromArray(array, offset = 0) {
        this.x = array[offset];
        this.y = array[offset + 1];
        return this;
    }
    toArray(array = [], offset = 0) {
        array[offset] = this.x;
        array[offset + 1] = this.y;
        return array;
    }
    fromBufferAttribute(attribute, index, offset) {
        if (offset !== undefined) console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute().");
        this.x = attribute.getX(index);
        this.y = attribute.getY(index);
        return this;
    }
    rotateAround(center, angle) {
        const c = Math.cos(angle), s = Math.sin(angle);
        const x = this.x - center.x;
        const y = this.y - center.y;
        this.x = x * c - y * s + center.x;
        this.y = x * s + y * c + center.y;
        return this;
    }
    random() {
        this.x = Math.random();
        this.y = Math.random();
        return this;
    }
    *[Symbol.iterator]() {
        yield this.x;
        yield this.y;
    }
}
class $084574008ccedf86$export$8ff26dafa08918 {
    constructor(){
        this.isMatrix3 = true;
        this.elements = [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1
        ];
        if (arguments.length > 0) console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.");
    }
    set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
        const te = this.elements;
        te[0] = n11;
        te[1] = n21;
        te[2] = n31;
        te[3] = n12;
        te[4] = n22;
        te[5] = n32;
        te[6] = n13;
        te[7] = n23;
        te[8] = n33;
        return this;
    }
    identity() {
        this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
        return this;
    }
    copy(m) {
        const te = this.elements;
        const me = m.elements;
        te[0] = me[0];
        te[1] = me[1];
        te[2] = me[2];
        te[3] = me[3];
        te[4] = me[4];
        te[5] = me[5];
        te[6] = me[6];
        te[7] = me[7];
        te[8] = me[8];
        return this;
    }
    extractBasis(xAxis, yAxis, zAxis) {
        xAxis.setFromMatrix3Column(this, 0);
        yAxis.setFromMatrix3Column(this, 1);
        zAxis.setFromMatrix3Column(this, 2);
        return this;
    }
    setFromMatrix4(m) {
        const me = m.elements;
        this.set(me[0], me[4], me[8], me[1], me[5], me[9], me[2], me[6], me[10]);
        return this;
    }
    multiply(m) {
        return this.multiplyMatrices(this, m);
    }
    premultiply(m) {
        return this.multiplyMatrices(m, this);
    }
    multiplyMatrices(a, b) {
        const ae = a.elements;
        const be = b.elements;
        const te = this.elements;
        const a11 = ae[0], a12 = ae[3], a13 = ae[6];
        const a21 = ae[1], a22 = ae[4], a23 = ae[7];
        const a31 = ae[2], a32 = ae[5], a33 = ae[8];
        const b11 = be[0], b12 = be[3], b13 = be[6];
        const b21 = be[1], b22 = be[4], b23 = be[7];
        const b31 = be[2], b32 = be[5], b33 = be[8];
        te[0] = a11 * b11 + a12 * b21 + a13 * b31;
        te[3] = a11 * b12 + a12 * b22 + a13 * b32;
        te[6] = a11 * b13 + a12 * b23 + a13 * b33;
        te[1] = a21 * b11 + a22 * b21 + a23 * b31;
        te[4] = a21 * b12 + a22 * b22 + a23 * b32;
        te[7] = a21 * b13 + a22 * b23 + a23 * b33;
        te[2] = a31 * b11 + a32 * b21 + a33 * b31;
        te[5] = a31 * b12 + a32 * b22 + a33 * b32;
        te[8] = a31 * b13 + a32 * b23 + a33 * b33;
        return this;
    }
    multiplyScalar(s) {
        const te = this.elements;
        te[0] *= s;
        te[3] *= s;
        te[6] *= s;
        te[1] *= s;
        te[4] *= s;
        te[7] *= s;
        te[2] *= s;
        te[5] *= s;
        te[8] *= s;
        return this;
    }
    determinant() {
        const te = this.elements;
        const a = te[0], b = te[1], c = te[2], d = te[3], e = te[4], f = te[5], g = te[6], h = te[7], i8 = te[8];
        return a * e * i8 - a * f * h - b * d * i8 + b * f * g + c * d * h - c * e * g;
    }
    invert() {
        const te = this.elements, n11 = te[0], n21 = te[1], n31 = te[2], n12 = te[3], n22 = te[4], n32 = te[5], n13 = te[6], n23 = te[7], n33 = te[8], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13, det = n11 * t11 + n21 * t12 + n31 * t13;
        if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
        const detInv = 1 / det;
        te[0] = t11 * detInv;
        te[1] = (n31 * n23 - n33 * n21) * detInv;
        te[2] = (n32 * n21 - n31 * n22) * detInv;
        te[3] = t12 * detInv;
        te[4] = (n33 * n11 - n31 * n13) * detInv;
        te[5] = (n31 * n12 - n32 * n11) * detInv;
        te[6] = t13 * detInv;
        te[7] = (n21 * n13 - n23 * n11) * detInv;
        te[8] = (n22 * n11 - n21 * n12) * detInv;
        return this;
    }
    transpose() {
        let tmp1;
        const m = this.elements;
        tmp1 = m[1];
        m[1] = m[3];
        m[3] = tmp1;
        tmp1 = m[2];
        m[2] = m[6];
        m[6] = tmp1;
        tmp1 = m[5];
        m[5] = m[7];
        m[7] = tmp1;
        return this;
    }
    getNormalMatrix(matrix4) {
        return this.setFromMatrix4(matrix4).invert().transpose();
    }
    transposeIntoArray(r) {
        const m = this.elements;
        r[0] = m[0];
        r[1] = m[3];
        r[2] = m[6];
        r[3] = m[1];
        r[4] = m[4];
        r[5] = m[7];
        r[6] = m[2];
        r[7] = m[5];
        r[8] = m[8];
        return this;
    }
    setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {
        const c = Math.cos(rotation);
        const s = Math.sin(rotation);
        this.set(sx * c, sx * s, -sx * (c * cx + s * cy) + cx + tx, -sy * s, sy * c, -sy * (-s * cx + c * cy) + cy + ty, 0, 0, 1);
        return this;
    }
    scale(sx, sy) {
        const te = this.elements;
        te[0] *= sx;
        te[3] *= sx;
        te[6] *= sx;
        te[1] *= sy;
        te[4] *= sy;
        te[7] *= sy;
        return this;
    }
    rotate(theta) {
        const c = Math.cos(theta);
        const s = Math.sin(theta);
        const te = this.elements;
        const a11 = te[0], a12 = te[3], a13 = te[6];
        const a21 = te[1], a22 = te[4], a23 = te[7];
        te[0] = c * a11 + s * a21;
        te[3] = c * a12 + s * a22;
        te[6] = c * a13 + s * a23;
        te[1] = -s * a11 + c * a21;
        te[4] = -s * a12 + c * a22;
        te[7] = -s * a13 + c * a23;
        return this;
    }
    translate(tx, ty) {
        const te = this.elements;
        te[0] += tx * te[2];
        te[3] += tx * te[5];
        te[6] += tx * te[8];
        te[1] += ty * te[2];
        te[4] += ty * te[5];
        te[7] += ty * te[8];
        return this;
    }
    equals(matrix) {
        const te = this.elements;
        const me = matrix.elements;
        for(let i9 = 0; i9 < 9; i9++){
            if (te[i9] !== me[i9]) return false;
        }
        return true;
    }
    fromArray(array, offset = 0) {
        for(let i10 = 0; i10 < 9; i10++)this.elements[i10] = array[i10 + offset];
        return this;
    }
    toArray(array = [], offset = 0) {
        const te = this.elements;
        array[offset] = te[0];
        array[offset + 1] = te[1];
        array[offset + 2] = te[2];
        array[offset + 3] = te[3];
        array[offset + 4] = te[4];
        array[offset + 5] = te[5];
        array[offset + 6] = te[6];
        array[offset + 7] = te[7];
        array[offset + 8] = te[8];
        return array;
    }
    clone() {
        return new this.constructor().fromArray(this.elements);
    }
}
function $084574008ccedf86$var$arrayNeedsUint32(array) {
    // assumes larger values usually on last
    for(let i11 = array.length - 1; i11 >= 0; --i11){
        if (array[i11] > 65535) return true;
    }
    return false;
}
const $084574008ccedf86$var$TYPED_ARRAYS = {
    Int8Array: Int8Array,
    Uint8Array: Uint8Array,
    Uint8ClampedArray: Uint8ClampedArray,
    Int16Array: Int16Array,
    Uint16Array: Uint16Array,
    Int32Array: Int32Array,
    Uint32Array: Uint32Array,
    Float32Array: Float32Array,
    Float64Array: Float64Array
};
function $084574008ccedf86$var$getTypedArray(type, buffer) {
    return new $084574008ccedf86$var$TYPED_ARRAYS[type](buffer);
}
function $084574008ccedf86$var$createElementNS(name) {
    return document.createElementNS("http://www.w3.org/1999/xhtml", name);
}
function $084574008ccedf86$var$SRGBToLinear(c) {
    return c < 0.04045 ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);
}
function $084574008ccedf86$var$LinearToSRGB(c) {
    return c < 0.0031308 ? c * 12.92 : 1.055 * Math.pow(c, 0.41666) - 0.055;
}
// JavaScript RGB-to-RGB transforms, defined as
// FN[InputColorSpace][OutputColorSpace] callback functions.
const $084574008ccedf86$var$FN = {
    [$084574008ccedf86$export$561f394b24edfcaa]: {
        [$084574008ccedf86$export$42429b3acfb233a4]: $084574008ccedf86$var$SRGBToLinear
    },
    [$084574008ccedf86$export$42429b3acfb233a4]: {
        [$084574008ccedf86$export$561f394b24edfcaa]: $084574008ccedf86$var$LinearToSRGB
    }
};
const $084574008ccedf86$export$5e6fd513f44698c = {
    legacyMode: true,
    get workingColorSpace () {
        return $084574008ccedf86$export$42429b3acfb233a4;
    },
    set workingColorSpace (colorSpace){
        console.warn("THREE.ColorManagement: .workingColorSpace is readonly.");
    },
    convert: function(color, sourceColorSpace, targetColorSpace) {
        if (this.legacyMode || sourceColorSpace === targetColorSpace || !sourceColorSpace || !targetColorSpace) return color;
        if ($084574008ccedf86$var$FN[sourceColorSpace] && $084574008ccedf86$var$FN[sourceColorSpace][targetColorSpace] !== undefined) {
            const fn = $084574008ccedf86$var$FN[sourceColorSpace][targetColorSpace];
            color.r = fn(color.r);
            color.g = fn(color.g);
            color.b = fn(color.b);
            return color;
        }
        throw new Error("Unsupported color space conversion.");
    },
    fromWorkingColorSpace: function(color, targetColorSpace) {
        return this.convert(color, this.workingColorSpace, targetColorSpace);
    },
    toWorkingColorSpace: function(color, sourceColorSpace) {
        return this.convert(color, sourceColorSpace, this.workingColorSpace);
    }
};
const $084574008ccedf86$var$_colorKeywords = {
    "aliceblue": 0xF0F8FF,
    "antiquewhite": 0xFAEBD7,
    "aqua": 0x00FFFF,
    "aquamarine": 0x7FFFD4,
    "azure": 0xF0FFFF,
    "beige": 0xF5F5DC,
    "bisque": 0xFFE4C4,
    "black": 0x000000,
    "blanchedalmond": 0xFFEBCD,
    "blue": 0x0000FF,
    "blueviolet": 0x8A2BE2,
    "brown": 0xA52A2A,
    "burlywood": 0xDEB887,
    "cadetblue": 0x5F9EA0,
    "chartreuse": 0x7FFF00,
    "chocolate": 0xD2691E,
    "coral": 0xFF7F50,
    "cornflowerblue": 0x6495ED,
    "cornsilk": 0xFFF8DC,
    "crimson": 0xDC143C,
    "cyan": 0x00FFFF,
    "darkblue": 0x00008B,
    "darkcyan": 0x008B8B,
    "darkgoldenrod": 0xB8860B,
    "darkgray": 0xA9A9A9,
    "darkgreen": 0x006400,
    "darkgrey": 0xA9A9A9,
    "darkkhaki": 0xBDB76B,
    "darkmagenta": 0x8B008B,
    "darkolivegreen": 0x556B2F,
    "darkorange": 0xFF8C00,
    "darkorchid": 0x9932CC,
    "darkred": 0x8B0000,
    "darksalmon": 0xE9967A,
    "darkseagreen": 0x8FBC8F,
    "darkslateblue": 0x483D8B,
    "darkslategray": 0x2F4F4F,
    "darkslategrey": 0x2F4F4F,
    "darkturquoise": 0x00CED1,
    "darkviolet": 0x9400D3,
    "deeppink": 0xFF1493,
    "deepskyblue": 0x00BFFF,
    "dimgray": 0x696969,
    "dimgrey": 0x696969,
    "dodgerblue": 0x1E90FF,
    "firebrick": 0xB22222,
    "floralwhite": 0xFFFAF0,
    "forestgreen": 0x228B22,
    "fuchsia": 0xFF00FF,
    "gainsboro": 0xDCDCDC,
    "ghostwhite": 0xF8F8FF,
    "gold": 0xFFD700,
    "goldenrod": 0xDAA520,
    "gray": 0x808080,
    "green": 0x008000,
    "greenyellow": 0xADFF2F,
    "grey": 0x808080,
    "honeydew": 0xF0FFF0,
    "hotpink": 0xFF69B4,
    "indianred": 0xCD5C5C,
    "indigo": 0x4B0082,
    "ivory": 0xFFFFF0,
    "khaki": 0xF0E68C,
    "lavender": 0xE6E6FA,
    "lavenderblush": 0xFFF0F5,
    "lawngreen": 0x7CFC00,
    "lemonchiffon": 0xFFFACD,
    "lightblue": 0xADD8E6,
    "lightcoral": 0xF08080,
    "lightcyan": 0xE0FFFF,
    "lightgoldenrodyellow": 0xFAFAD2,
    "lightgray": 0xD3D3D3,
    "lightgreen": 0x90EE90,
    "lightgrey": 0xD3D3D3,
    "lightpink": 0xFFB6C1,
    "lightsalmon": 0xFFA07A,
    "lightseagreen": 0x20B2AA,
    "lightskyblue": 0x87CEFA,
    "lightslategray": 0x778899,
    "lightslategrey": 0x778899,
    "lightsteelblue": 0xB0C4DE,
    "lightyellow": 0xFFFFE0,
    "lime": 0x00FF00,
    "limegreen": 0x32CD32,
    "linen": 0xFAF0E6,
    "magenta": 0xFF00FF,
    "maroon": 0x800000,
    "mediumaquamarine": 0x66CDAA,
    "mediumblue": 0x0000CD,
    "mediumorchid": 0xBA55D3,
    "mediumpurple": 0x9370DB,
    "mediumseagreen": 0x3CB371,
    "mediumslateblue": 0x7B68EE,
    "mediumspringgreen": 0x00FA9A,
    "mediumturquoise": 0x48D1CC,
    "mediumvioletred": 0xC71585,
    "midnightblue": 0x191970,
    "mintcream": 0xF5FFFA,
    "mistyrose": 0xFFE4E1,
    "moccasin": 0xFFE4B5,
    "navajowhite": 0xFFDEAD,
    "navy": 0x000080,
    "oldlace": 0xFDF5E6,
    "olive": 0x808000,
    "olivedrab": 0x6B8E23,
    "orange": 0xFFA500,
    "orangered": 0xFF4500,
    "orchid": 0xDA70D6,
    "palegoldenrod": 0xEEE8AA,
    "palegreen": 0x98FB98,
    "paleturquoise": 0xAFEEEE,
    "palevioletred": 0xDB7093,
    "papayawhip": 0xFFEFD5,
    "peachpuff": 0xFFDAB9,
    "peru": 0xCD853F,
    "pink": 0xFFC0CB,
    "plum": 0xDDA0DD,
    "powderblue": 0xB0E0E6,
    "purple": 0x800080,
    "rebeccapurple": 0x663399,
    "red": 0xFF0000,
    "rosybrown": 0xBC8F8F,
    "royalblue": 0x4169E1,
    "saddlebrown": 0x8B4513,
    "salmon": 0xFA8072,
    "sandybrown": 0xF4A460,
    "seagreen": 0x2E8B57,
    "seashell": 0xFFF5EE,
    "sienna": 0xA0522D,
    "silver": 0xC0C0C0,
    "skyblue": 0x87CEEB,
    "slateblue": 0x6A5ACD,
    "slategray": 0x708090,
    "slategrey": 0x708090,
    "snow": 0xFFFAFA,
    "springgreen": 0x00FF7F,
    "steelblue": 0x4682B4,
    "tan": 0xD2B48C,
    "teal": 0x008080,
    "thistle": 0xD8BFD8,
    "tomato": 0xFF6347,
    "turquoise": 0x40E0D0,
    "violet": 0xEE82EE,
    "wheat": 0xF5DEB3,
    "white": 0xFFFFFF,
    "whitesmoke": 0xF5F5F5,
    "yellow": 0xFFFF00,
    "yellowgreen": 0x9ACD32
};
const $084574008ccedf86$var$_rgb = {
    r: 0,
    g: 0,
    b: 0
};
const $084574008ccedf86$var$_hslA = {
    h: 0,
    s: 0,
    l: 0
};
const $084574008ccedf86$var$_hslB = {
    h: 0,
    s: 0,
    l: 0
};
function $084574008ccedf86$var$hue2rgb(p, q, t) {
    if (t < 0) t += 1;
    if (t > 1) t -= 1;
    if (t < 1 / 6) return p + (q - p) * 6 * t;
    if (t < 0.5) return q;
    if (t < 2 / 3) return p + (q - p) * 6 * (2 / 3 - t);
    return p;
}
function $084574008ccedf86$var$toComponents(source, target) {
    target.r = source.r;
    target.g = source.g;
    target.b = source.b;
    return target;
}
class $084574008ccedf86$export$892596cec99bc70e {
    constructor(r, g, b){
        this.isColor = true;
        this.r = 1;
        this.g = 1;
        this.b = 1;
        if (g === undefined && b === undefined) // r is THREE.Color, hex or string
        return this.set(r);
        return this.setRGB(r, g, b);
    }
    set(value) {
        if (value && value.isColor) this.copy(value);
        else if (typeof value === "number") this.setHex(value);
        else if (typeof value === "string") this.setStyle(value);
        return this;
    }
    setScalar(scalar) {
        this.r = scalar;
        this.g = scalar;
        this.b = scalar;
        return this;
    }
    setHex(hex, colorSpace = $084574008ccedf86$export$561f394b24edfcaa) {
        hex = Math.floor(hex);
        this.r = (hex >> 16 & 255) / 255;
        this.g = (hex >> 8 & 255) / 255;
        this.b = (hex & 255) / 255;
        $084574008ccedf86$export$5e6fd513f44698c.toWorkingColorSpace(this, colorSpace);
        return this;
    }
    setRGB(r, g, b, colorSpace = $084574008ccedf86$export$42429b3acfb233a4) {
        this.r = r;
        this.g = g;
        this.b = b;
        $084574008ccedf86$export$5e6fd513f44698c.toWorkingColorSpace(this, colorSpace);
        return this;
    }
    setHSL(h, s, l, colorSpace = $084574008ccedf86$export$42429b3acfb233a4) {
        // h,s,l ranges are in 0.0 - 1.0
        h = $084574008ccedf86$var$euclideanModulo(h, 1);
        s = $084574008ccedf86$var$clamp(s, 0, 1);
        l = $084574008ccedf86$var$clamp(l, 0, 1);
        if (s === 0) this.r = this.g = this.b = l;
        else {
            const p = l <= 0.5 ? l * (1 + s) : l + s - l * s;
            const q = 2 * l - p;
            this.r = $084574008ccedf86$var$hue2rgb(q, p, h + 1 / 3);
            this.g = $084574008ccedf86$var$hue2rgb(q, p, h);
            this.b = $084574008ccedf86$var$hue2rgb(q, p, h - 1 / 3);
        }
        $084574008ccedf86$export$5e6fd513f44698c.toWorkingColorSpace(this, colorSpace);
        return this;
    }
    setStyle(style, colorSpace = $084574008ccedf86$export$561f394b24edfcaa) {
        function handleAlpha(string) {
            if (string === undefined) return;
            if (parseFloat(string) < 1) console.warn("THREE.Color: Alpha component of " + style + " will be ignored.");
        }
        let m;
        if (m = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(style)) {
            // rgb / hsl
            let color;
            const name = m[1];
            const components = m[2];
            switch(name){
                case "rgb":
                case "rgba":
                    if (color = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
                        // rgb(255,0,0) rgba(255,0,0,0.5)
                        this.r = Math.min(255, parseInt(color[1], 10)) / 255;
                        this.g = Math.min(255, parseInt(color[2], 10)) / 255;
                        this.b = Math.min(255, parseInt(color[3], 10)) / 255;
                        $084574008ccedf86$export$5e6fd513f44698c.toWorkingColorSpace(this, colorSpace);
                        handleAlpha(color[4]);
                        return this;
                    }
                    if (color = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
                        // rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
                        this.r = Math.min(100, parseInt(color[1], 10)) / 100;
                        this.g = Math.min(100, parseInt(color[2], 10)) / 100;
                        this.b = Math.min(100, parseInt(color[3], 10)) / 100;
                        $084574008ccedf86$export$5e6fd513f44698c.toWorkingColorSpace(this, colorSpace);
                        handleAlpha(color[4]);
                        return this;
                    }
                    break;
                case "hsl":
                case "hsla":
                    if (color = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
                        // hsl(120,50%,50%) hsla(120,50%,50%,0.5)
                        const h = parseFloat(color[1]) / 360;
                        const s = parseInt(color[2], 10) / 100;
                        const l = parseInt(color[3], 10) / 100;
                        handleAlpha(color[4]);
                        return this.setHSL(h, s, l, colorSpace);
                    }
                    break;
            }
        } else if (m = /^\#([A-Fa-f\d]+)$/.exec(style)) {
            // hex color
            const hex = m[1];
            const size = hex.length;
            if (size === 3) {
                // #ff0
                this.r = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255;
                this.g = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255;
                this.b = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255;
                $084574008ccedf86$export$5e6fd513f44698c.toWorkingColorSpace(this, colorSpace);
                return this;
            } else if (size === 6) {
                // #ff0000
                this.r = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255;
                this.g = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255;
                this.b = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255;
                $084574008ccedf86$export$5e6fd513f44698c.toWorkingColorSpace(this, colorSpace);
                return this;
            }
        }
        if (style && style.length > 0) return this.setColorName(style, colorSpace);
        return this;
    }
    setColorName(style, colorSpace = $084574008ccedf86$export$561f394b24edfcaa) {
        // color keywords
        const hex = $084574008ccedf86$var$_colorKeywords[style.toLowerCase()];
        if (hex !== undefined) // red
        this.setHex(hex, colorSpace);
        else // unknown color
        console.warn("THREE.Color: Unknown color " + style);
        return this;
    }
    clone() {
        return new this.constructor(this.r, this.g, this.b);
    }
    copy(color) {
        this.r = color.r;
        this.g = color.g;
        this.b = color.b;
        return this;
    }
    copySRGBToLinear(color) {
        this.r = $084574008ccedf86$var$SRGBToLinear(color.r);
        this.g = $084574008ccedf86$var$SRGBToLinear(color.g);
        this.b = $084574008ccedf86$var$SRGBToLinear(color.b);
        return this;
    }
    copyLinearToSRGB(color) {
        this.r = $084574008ccedf86$var$LinearToSRGB(color.r);
        this.g = $084574008ccedf86$var$LinearToSRGB(color.g);
        this.b = $084574008ccedf86$var$LinearToSRGB(color.b);
        return this;
    }
    convertSRGBToLinear() {
        this.copySRGBToLinear(this);
        return this;
    }
    convertLinearToSRGB() {
        this.copyLinearToSRGB(this);
        return this;
    }
    getHex(colorSpace = $084574008ccedf86$export$561f394b24edfcaa) {
        $084574008ccedf86$export$5e6fd513f44698c.fromWorkingColorSpace($084574008ccedf86$var$toComponents(this, $084574008ccedf86$var$_rgb), colorSpace);
        return $084574008ccedf86$var$clamp($084574008ccedf86$var$_rgb.r * 255, 0, 255) << 16 ^ $084574008ccedf86$var$clamp($084574008ccedf86$var$_rgb.g * 255, 0, 255) << 8 ^ $084574008ccedf86$var$clamp($084574008ccedf86$var$_rgb.b * 255, 0, 255) << 0;
    }
    getHexString(colorSpace = $084574008ccedf86$export$561f394b24edfcaa) {
        return ("000000" + this.getHex(colorSpace).toString(16)).slice(-6);
    }
    getHSL(target, colorSpace = $084574008ccedf86$export$42429b3acfb233a4) {
        // h,s,l ranges are in 0.0 - 1.0
        $084574008ccedf86$export$5e6fd513f44698c.fromWorkingColorSpace($084574008ccedf86$var$toComponents(this, $084574008ccedf86$var$_rgb), colorSpace);
        const r = $084574008ccedf86$var$_rgb.r, g = $084574008ccedf86$var$_rgb.g, b = $084574008ccedf86$var$_rgb.b;
        const max = Math.max(r, g, b);
        const min = Math.min(r, g, b);
        let hue, saturation;
        const lightness = (min + max) / 2.0;
        if (min === max) {
            hue = 0;
            saturation = 0;
        } else {
            const delta = max - min;
            saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);
            switch(max){
                case r:
                    hue = (g - b) / delta + (g < b ? 6 : 0);
                    break;
                case g:
                    hue = (b - r) / delta + 2;
                    break;
                case b:
                    hue = (r - g) / delta + 4;
                    break;
            }
            hue /= 6;
        }
        target.h = hue;
        target.s = saturation;
        target.l = lightness;
        return target;
    }
    getRGB(target, colorSpace = $084574008ccedf86$export$42429b3acfb233a4) {
        $084574008ccedf86$export$5e6fd513f44698c.fromWorkingColorSpace($084574008ccedf86$var$toComponents(this, $084574008ccedf86$var$_rgb), colorSpace);
        target.r = $084574008ccedf86$var$_rgb.r;
        target.g = $084574008ccedf86$var$_rgb.g;
        target.b = $084574008ccedf86$var$_rgb.b;
        return target;
    }
    getStyle(colorSpace = $084574008ccedf86$export$561f394b24edfcaa) {
        $084574008ccedf86$export$5e6fd513f44698c.fromWorkingColorSpace($084574008ccedf86$var$toComponents(this, $084574008ccedf86$var$_rgb), colorSpace);
        if (colorSpace !== $084574008ccedf86$export$561f394b24edfcaa) // Requires CSS Color Module Level 4 (https://www.w3.org/TR/css-color-4/).
        return `color(${colorSpace} ${$084574008ccedf86$var$_rgb.r} ${$084574008ccedf86$var$_rgb.g} ${$084574008ccedf86$var$_rgb.b})`;
        return `rgb(${$084574008ccedf86$var$_rgb.r * 255 | 0},${$084574008ccedf86$var$_rgb.g * 255 | 0},${$084574008ccedf86$var$_rgb.b * 255 | 0})`;
    }
    offsetHSL(h, s, l) {
        this.getHSL($084574008ccedf86$var$_hslA);
        $084574008ccedf86$var$_hslA.h += h;
        $084574008ccedf86$var$_hslA.s += s;
        $084574008ccedf86$var$_hslA.l += l;
        this.setHSL($084574008ccedf86$var$_hslA.h, $084574008ccedf86$var$_hslA.s, $084574008ccedf86$var$_hslA.l);
        return this;
    }
    add(color) {
        this.r += color.r;
        this.g += color.g;
        this.b += color.b;
        return this;
    }
    addColors(color1, color2) {
        this.r = color1.r + color2.r;
        this.g = color1.g + color2.g;
        this.b = color1.b + color2.b;
        return this;
    }
    addScalar(s) {
        this.r += s;
        this.g += s;
        this.b += s;
        return this;
    }
    sub(color) {
        this.r = Math.max(0, this.r - color.r);
        this.g = Math.max(0, this.g - color.g);
        this.b = Math.max(0, this.b - color.b);
        return this;
    }
    multiply(color) {
        this.r *= color.r;
        this.g *= color.g;
        this.b *= color.b;
        return this;
    }
    multiplyScalar(s) {
        this.r *= s;
        this.g *= s;
        this.b *= s;
        return this;
    }
    lerp(color, alpha) {
        this.r += (color.r - this.r) * alpha;
        this.g += (color.g - this.g) * alpha;
        this.b += (color.b - this.b) * alpha;
        return this;
    }
    lerpColors(color1, color2, alpha) {
        this.r = color1.r + (color2.r - color1.r) * alpha;
        this.g = color1.g + (color2.g - color1.g) * alpha;
        this.b = color1.b + (color2.b - color1.b) * alpha;
        return this;
    }
    lerpHSL(color, alpha) {
        this.getHSL($084574008ccedf86$var$_hslA);
        color.getHSL($084574008ccedf86$var$_hslB);
        const h = $084574008ccedf86$var$lerp($084574008ccedf86$var$_hslA.h, $084574008ccedf86$var$_hslB.h, alpha);
        const s = $084574008ccedf86$var$lerp($084574008ccedf86$var$_hslA.s, $084574008ccedf86$var$_hslB.s, alpha);
        const l = $084574008ccedf86$var$lerp($084574008ccedf86$var$_hslA.l, $084574008ccedf86$var$_hslB.l, alpha);
        this.setHSL(h, s, l);
        return this;
    }
    equals(c) {
        return c.r === this.r && c.g === this.g && c.b === this.b;
    }
    fromArray(array, offset = 0) {
        this.r = array[offset];
        this.g = array[offset + 1];
        this.b = array[offset + 2];
        return this;
    }
    toArray(array = [], offset = 0) {
        array[offset] = this.r;
        array[offset + 1] = this.g;
        array[offset + 2] = this.b;
        return array;
    }
    fromBufferAttribute(attribute, index) {
        this.r = attribute.getX(index);
        this.g = attribute.getY(index);
        this.b = attribute.getZ(index);
        if (attribute.normalized === true) {
            // assuming Uint8Array
            this.r /= 255;
            this.g /= 255;
            this.b /= 255;
        }
        return this;
    }
    toJSON() {
        return this.getHex();
    }
    *[Symbol.iterator]() {
        yield this.r;
        yield this.g;
        yield this.b;
    }
}
$084574008ccedf86$export$892596cec99bc70e.NAMES = $084574008ccedf86$var$_colorKeywords;
let $084574008ccedf86$var$_canvas;
class $084574008ccedf86$export$698882cf06df44aa {
    static getDataURL(image) {
        if (/^data:/i.test(image.src)) return image.src;
        if (typeof HTMLCanvasElement == "undefined") return image.src;
        let canvas;
        if (image instanceof HTMLCanvasElement) canvas = image;
        else {
            if ($084574008ccedf86$var$_canvas === undefined) $084574008ccedf86$var$_canvas = $084574008ccedf86$var$createElementNS("canvas");
            $084574008ccedf86$var$_canvas.width = image.width;
            $084574008ccedf86$var$_canvas.height = image.height;
            const context = $084574008ccedf86$var$_canvas.getContext("2d");
            if (image instanceof ImageData) context.putImageData(image, 0, 0);
            else context.drawImage(image, 0, 0, image.width, image.height);
            canvas = $084574008ccedf86$var$_canvas;
        }
        if (canvas.width > 2048 || canvas.height > 2048) {
            console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", image);
            return canvas.toDataURL("image/jpeg", 0.6);
        } else return canvas.toDataURL("image/png");
    }
    static sRGBToLinear(image) {
        if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
            const canvas = $084574008ccedf86$var$createElementNS("canvas");
            canvas.width = image.width;
            canvas.height = image.height;
            const context = canvas.getContext("2d");
            context.drawImage(image, 0, 0, image.width, image.height);
            const imageData = context.getImageData(0, 0, image.width, image.height);
            const data = imageData.data;
            for(let i12 = 0; i12 < data.length; i12++)data[i12] = $084574008ccedf86$var$SRGBToLinear(data[i12] / 255) * 255;
            context.putImageData(imageData, 0, 0);
            return canvas;
        } else if (image.data) {
            const data = image.data.slice(0);
            for(let i13 = 0; i13 < data.length; i13++)if (data instanceof Uint8Array || data instanceof Uint8ClampedArray) data[i13] = Math.floor($084574008ccedf86$var$SRGBToLinear(data[i13] / 255) * 255);
            else // assuming float
            data[i13] = $084574008ccedf86$var$SRGBToLinear(data[i13]);
            return {
                data: data,
                width: image.width,
                height: image.height
            };
        } else {
            console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied.");
            return image;
        }
    }
}
class $084574008ccedf86$export$1d2df86270c81ecb {
    constructor(data = null){
        this.isSource = true;
        this.uuid = $084574008ccedf86$var$generateUUID();
        this.data = data;
        this.version = 0;
    }
    set needsUpdate(value) {
        if (value === true) this.version++;
    }
    toJSON(meta) {
        const isRootObject = meta === undefined || typeof meta === "string";
        if (!isRootObject && meta.images[this.uuid] !== undefined) return meta.images[this.uuid];
        const output = {
            uuid: this.uuid,
            url: ""
        };
        const data = this.data;
        if (data !== null) {
            let url;
            if (Array.isArray(data)) {
                // cube texture
                url = [];
                for(let i14 = 0, l = data.length; i14 < l; i14++)if (data[i14].isDataTexture) url.push($084574008ccedf86$var$serializeImage(data[i14].image));
                else url.push($084574008ccedf86$var$serializeImage(data[i14]));
            } else // texture
            url = $084574008ccedf86$var$serializeImage(data);
            output.url = url;
        }
        if (!isRootObject) meta.images[this.uuid] = output;
        return output;
    }
}
function $084574008ccedf86$var$serializeImage(image) {
    if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) // default images
    return $084574008ccedf86$export$698882cf06df44aa.getDataURL(image);
    else {
        if (image.data) // images of DataTexture
        return {
            data: Array.prototype.slice.call(image.data),
            width: image.width,
            height: image.height,
            type: image.data.constructor.name
        };
        else {
            console.warn("THREE.Texture: Unable to serialize Texture.");
            return {};
        }
    }
}
let $084574008ccedf86$var$textureId = 0;
class $084574008ccedf86$export$5431306cf43de24a extends $084574008ccedf86$export$ec8b666c5fe2c75a {
    constructor(image = $084574008ccedf86$export$5431306cf43de24a.DEFAULT_IMAGE, mapping = $084574008ccedf86$export$5431306cf43de24a.DEFAULT_MAPPING, wrapS = $084574008ccedf86$export$9d9334239a5a5e06, wrapT = $084574008ccedf86$export$9d9334239a5a5e06, magFilter = $084574008ccedf86$export$8a72f490b25c56c8, minFilter = $084574008ccedf86$export$5d8599b6a933fb1b, format = $084574008ccedf86$export$3f8bb04b555a363c, type = $084574008ccedf86$export$2e8ce08d3f6f5e10, anisotropy = 1, encoding = $084574008ccedf86$export$7207336e4151a112){
        super();
        this.isTexture = true;
        Object.defineProperty(this, "id", {
            value: $084574008ccedf86$var$textureId++
        });
        this.uuid = $084574008ccedf86$var$generateUUID();
        this.name = "";
        this.source = new $084574008ccedf86$export$1d2df86270c81ecb(image);
        this.mipmaps = [];
        this.mapping = mapping;
        this.wrapS = wrapS;
        this.wrapT = wrapT;
        this.magFilter = magFilter;
        this.minFilter = minFilter;
        this.anisotropy = anisotropy;
        this.format = format;
        this.internalFormat = null;
        this.type = type;
        this.offset = new $084574008ccedf86$export$c977b3e384af9ae1(0, 0);
        this.repeat = new $084574008ccedf86$export$c977b3e384af9ae1(1, 1);
        this.center = new $084574008ccedf86$export$c977b3e384af9ae1(0, 0);
        this.rotation = 0;
        this.matrixAutoUpdate = true;
        this.matrix = new $084574008ccedf86$export$8ff26dafa08918();
        this.generateMipmaps = true;
        this.premultiplyAlpha = false;
        this.flipY = true;
        this.unpackAlignment = 4; // valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)
        // Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.
        //
        // Also changing the encoding after already used by a Material will not automatically make the Material
        // update. You need to explicitly call Material.needsUpdate to trigger it to recompile.
        this.encoding = encoding;
        this.userData = {};
        this.version = 0;
        this.onUpdate = null;
        this.isRenderTargetTexture = false; // indicates whether a texture belongs to a render target or not
        this.needsPMREMUpdate = false; // indicates whether this texture should be processed by PMREMGenerator or not (only relevant for render target textures)
    }
    get image() {
        return this.source.data;
    }
    set image(value) {
        this.source.data = value;
    }
    updateMatrix() {
        this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
    }
    clone() {
        return new this.constructor().copy(this);
    }
    copy(source) {
        this.name = source.name;
        this.source = source.source;
        this.mipmaps = source.mipmaps.slice(0);
        this.mapping = source.mapping;
        this.wrapS = source.wrapS;
        this.wrapT = source.wrapT;
        this.magFilter = source.magFilter;
        this.minFilter = source.minFilter;
        this.anisotropy = source.anisotropy;
        this.format = source.format;
        this.internalFormat = source.internalFormat;
        this.type = source.type;
        this.offset.copy(source.offset);
        this.repeat.copy(source.repeat);
        this.center.copy(source.center);
        this.rotation = source.rotation;
        this.matrixAutoUpdate = source.matrixAutoUpdate;
        this.matrix.copy(source.matrix);
        this.generateMipmaps = source.generateMipmaps;
        this.premultiplyAlpha = source.premultiplyAlpha;
        this.flipY = source.flipY;
        this.unpackAlignment = source.unpackAlignment;
        this.encoding = source.encoding;
        this.userData = JSON.parse(JSON.stringify(source.userData));
        this.needsUpdate = true;
        return this;
    }
    toJSON(meta) {
        const isRootObject = meta === undefined || typeof meta === "string";
        if (!isRootObject && meta.textures[this.uuid] !== undefined) return meta.textures[this.uuid];
        const output = {
            metadata: {
                version: 4.5,
                type: "Texture",
                generator: "Texture.toJSON"
            },
            uuid: this.uuid,
            name: this.name,
            image: this.source.toJSON(meta).uuid,
            mapping: this.mapping,
            repeat: [
                this.repeat.x,
                this.repeat.y
            ],
            offset: [
                this.offset.x,
                this.offset.y
            ],
            center: [
                this.center.x,
                this.center.y
            ],
            rotation: this.rotation,
            wrap: [
                this.wrapS,
                this.wrapT
            ],
            format: this.format,
            type: this.type,
            encoding: this.encoding,
            minFilter: this.minFilter,
            magFilter: this.magFilter,
            anisotropy: this.anisotropy,
            flipY: this.flipY,
            premultiplyAlpha: this.premultiplyAlpha,
            unpackAlignment: this.unpackAlignment
        };
        if (JSON.stringify(this.userData) !== "{}") output.userData = this.userData;
        if (!isRootObject) meta.textures[this.uuid] = output;
        return output;
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        });
    }
    transformUv(uv) {
        if (this.mapping !== $084574008ccedf86$export$1beec6768cbb3d2d) return uv;
        uv.applyMatrix3(this.matrix);
        if (uv.x < 0 || uv.x > 1) switch(this.wrapS){
            case $084574008ccedf86$export$533346c8e8dac0f5:
                uv.x = uv.x - Math.floor(uv.x);
                break;
            case $084574008ccedf86$export$9d9334239a5a5e06:
                uv.x = uv.x < 0 ? 0 : 1;
                break;
            case $084574008ccedf86$export$c7e7c00b14f51a4f:
                if (Math.abs(Math.floor(uv.x) % 2) === 1) uv.x = Math.ceil(uv.x) - uv.x;
                else uv.x = uv.x - Math.floor(uv.x);
                break;
        }
        if (uv.y < 0 || uv.y > 1) switch(this.wrapT){
            case $084574008ccedf86$export$533346c8e8dac0f5:
                uv.y = uv.y - Math.floor(uv.y);
                break;
            case $084574008ccedf86$export$9d9334239a5a5e06:
                uv.y = uv.y < 0 ? 0 : 1;
                break;
            case $084574008ccedf86$export$c7e7c00b14f51a4f:
                if (Math.abs(Math.floor(uv.y) % 2) === 1) uv.y = Math.ceil(uv.y) - uv.y;
                else uv.y = uv.y - Math.floor(uv.y);
                break;
        }
        if (this.flipY) uv.y = 1 - uv.y;
        return uv;
    }
    set needsUpdate(value) {
        if (value === true) {
            this.version++;
            this.source.needsUpdate = true;
        }
    }
}
$084574008ccedf86$export$5431306cf43de24a.DEFAULT_IMAGE = null;
$084574008ccedf86$export$5431306cf43de24a.DEFAULT_MAPPING = $084574008ccedf86$export$1beec6768cbb3d2d;
class $084574008ccedf86$export$fa7daccca11cdbe3 {
    constructor(x = 0, y = 0, z = 0, w = 1){
        this.isVector4 = true;
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
    }
    get width() {
        return this.z;
    }
    set width(value) {
        this.z = value;
    }
    get height() {
        return this.w;
    }
    set height(value) {
        this.w = value;
    }
    set(x, y, z, w) {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
        return this;
    }
    setScalar(scalar) {
        this.x = scalar;
        this.y = scalar;
        this.z = scalar;
        this.w = scalar;
        return this;
    }
    setX(x) {
        this.x = x;
        return this;
    }
    setY(y) {
        this.y = y;
        return this;
    }
    setZ(z) {
        this.z = z;
        return this;
    }
    setW(w) {
        this.w = w;
        return this;
    }
    setComponent(index, value) {
        switch(index){
            case 0:
                this.x = value;
                break;
            case 1:
                this.y = value;
                break;
            case 2:
                this.z = value;
                break;
            case 3:
                this.w = value;
                break;
            default:
                throw new Error("index is out of range: " + index);
        }
        return this;
    }
    getComponent(index) {
        switch(index){
            case 0:
                return this.x;
            case 1:
                return this.y;
            case 2:
                return this.z;
            case 3:
                return this.w;
            default:
                throw new Error("index is out of range: " + index);
        }
    }
    clone() {
        return new this.constructor(this.x, this.y, this.z, this.w);
    }
    copy(v) {
        this.x = v.x;
        this.y = v.y;
        this.z = v.z;
        this.w = v.w !== undefined ? v.w : 1;
        return this;
    }
    add(v, w) {
        if (w !== undefined) {
            console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
            return this.addVectors(v, w);
        }
        this.x += v.x;
        this.y += v.y;
        this.z += v.z;
        this.w += v.w;
        return this;
    }
    addScalar(s) {
        this.x += s;
        this.y += s;
        this.z += s;
        this.w += s;
        return this;
    }
    addVectors(a, b) {
        this.x = a.x + b.x;
        this.y = a.y + b.y;
        this.z = a.z + b.z;
        this.w = a.w + b.w;
        return this;
    }
    addScaledVector(v, s) {
        this.x += v.x * s;
        this.y += v.y * s;
        this.z += v.z * s;
        this.w += v.w * s;
        return this;
    }
    sub(v, w) {
        if (w !== undefined) {
            console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
            return this.subVectors(v, w);
        }
        this.x -= v.x;
        this.y -= v.y;
        this.z -= v.z;
        this.w -= v.w;
        return this;
    }
    subScalar(s) {
        this.x -= s;
        this.y -= s;
        this.z -= s;
        this.w -= s;
        return this;
    }
    subVectors(a, b) {
        this.x = a.x - b.x;
        this.y = a.y - b.y;
        this.z = a.z - b.z;
        this.w = a.w - b.w;
        return this;
    }
    multiply(v) {
        this.x *= v.x;
        this.y *= v.y;
        this.z *= v.z;
        this.w *= v.w;
        return this;
    }
    multiplyScalar(scalar) {
        this.x *= scalar;
        this.y *= scalar;
        this.z *= scalar;
        this.w *= scalar;
        return this;
    }
    applyMatrix4(m) {
        const x = this.x, y = this.y, z = this.z, w = this.w;
        const e = m.elements;
        this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;
        this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;
        this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;
        this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;
        return this;
    }
    divideScalar(scalar) {
        return this.multiplyScalar(1 / scalar);
    }
    setAxisAngleFromQuaternion(q) {
        // http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm
        // q is assumed to be normalized
        this.w = 2 * Math.acos(q.w);
        const s = Math.sqrt(1 - q.w * q.w);
        if (s < 0.0001) {
            this.x = 1;
            this.y = 0;
            this.z = 0;
        } else {
            this.x = q.x / s;
            this.y = q.y / s;
            this.z = q.z / s;
        }
        return this;
    }
    setAxisAngleFromRotationMatrix(m) {
        // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm
        // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
        let angle, x, y, z; // variables for result
        const epsilon = 0.01, epsilon2 = 0.1, te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10];
        if (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {
            // singularity found
            // first check for identity matrix which must have +1 for all terms
            // in leading diagonal and zero in other terms
            if (Math.abs(m12 + m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2) {
                // this singularity is identity matrix so angle = 0
                this.set(1, 0, 0, 0);
                return this; // zero angle, arbitrary axis
            }
            // otherwise this singularity is angle = 180
            angle = Math.PI;
            const xx = (m11 + 1) / 2;
            const yy = (m22 + 1) / 2;
            const zz = (m33 + 1) / 2;
            const xy = (m12 + m21) / 4;
            const xz = (m13 + m31) / 4;
            const yz = (m23 + m32) / 4;
            if (xx > yy && xx > zz) {
                // m11 is the largest diagonal term
                if (xx < epsilon) {
                    x = 0;
                    y = 0.707106781;
                    z = 0.707106781;
                } else {
                    x = Math.sqrt(xx);
                    y = xy / x;
                    z = xz / x;
                }
            } else if (yy > zz) {
                // m22 is the largest diagonal term
                if (yy < epsilon) {
                    x = 0.707106781;
                    y = 0;
                    z = 0.707106781;
                } else {
                    y = Math.sqrt(yy);
                    x = xy / y;
                    z = yz / y;
                }
            } else // m33 is the largest diagonal term so base result on this
            if (zz < epsilon) {
                x = 0.707106781;
                y = 0.707106781;
                z = 0;
            } else {
                z = Math.sqrt(zz);
                x = xz / z;
                y = yz / z;
            }
            this.set(x, y, z, angle);
            return this; // return 180 deg rotation
        }
        // as we have reached here there are no singularities so we can handle normally
        let s = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12)); // used to normalize
        if (Math.abs(s) < 0.001) s = 1;
        // prevent divide by zero, should not happen if matrix is orthogonal and should be
        // caught by singularity test above, but I've left it in just in case
        this.x = (m32 - m23) / s;
        this.y = (m13 - m31) / s;
        this.z = (m21 - m12) / s;
        this.w = Math.acos((m11 + m22 + m33 - 1) / 2);
        return this;
    }
    min(v) {
        this.x = Math.min(this.x, v.x);
        this.y = Math.min(this.y, v.y);
        this.z = Math.min(this.z, v.z);
        this.w = Math.min(this.w, v.w);
        return this;
    }
    max(v) {
        this.x = Math.max(this.x, v.x);
        this.y = Math.max(this.y, v.y);
        this.z = Math.max(this.z, v.z);
        this.w = Math.max(this.w, v.w);
        return this;
    }
    clamp(min, max) {
        // assumes min < max, componentwise
        this.x = Math.max(min.x, Math.min(max.x, this.x));
        this.y = Math.max(min.y, Math.min(max.y, this.y));
        this.z = Math.max(min.z, Math.min(max.z, this.z));
        this.w = Math.max(min.w, Math.min(max.w, this.w));
        return this;
    }
    clampScalar(minVal, maxVal) {
        this.x = Math.max(minVal, Math.min(maxVal, this.x));
        this.y = Math.max(minVal, Math.min(maxVal, this.y));
        this.z = Math.max(minVal, Math.min(maxVal, this.z));
        this.w = Math.max(minVal, Math.min(maxVal, this.w));
        return this;
    }
    clampLength(min, max) {
        const length = this.length();
        return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
    }
    floor() {
        this.x = Math.floor(this.x);
        this.y = Math.floor(this.y);
        this.z = Math.floor(this.z);
        this.w = Math.floor(this.w);
        return this;
    }
    ceil() {
        this.x = Math.ceil(this.x);
        this.y = Math.ceil(this.y);
        this.z = Math.ceil(this.z);
        this.w = Math.ceil(this.w);
        return this;
    }
    round() {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        this.z = Math.round(this.z);
        this.w = Math.round(this.w);
        return this;
    }
    roundToZero() {
        this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
        this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
        this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
        this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w);
        return this;
    }
    negate() {
        this.x = -this.x;
        this.y = -this.y;
        this.z = -this.z;
        this.w = -this.w;
        return this;
    }
    dot(v) {
        return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
    }
    normalize() {
        return this.divideScalar(this.length() || 1);
    }
    setLength(length) {
        return this.normalize().multiplyScalar(length);
    }
    lerp(v, alpha) {
        this.x += (v.x - this.x) * alpha;
        this.y += (v.y - this.y) * alpha;
        this.z += (v.z - this.z) * alpha;
        this.w += (v.w - this.w) * alpha;
        return this;
    }
    lerpVectors(v1, v2, alpha) {
        this.x = v1.x + (v2.x - v1.x) * alpha;
        this.y = v1.y + (v2.y - v1.y) * alpha;
        this.z = v1.z + (v2.z - v1.z) * alpha;
        this.w = v1.w + (v2.w - v1.w) * alpha;
        return this;
    }
    equals(v) {
        return v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w;
    }
    fromArray(array, offset = 0) {
        this.x = array[offset];
        this.y = array[offset + 1];
        this.z = array[offset + 2];
        this.w = array[offset + 3];
        return this;
    }
    toArray(array = [], offset = 0) {
        array[offset] = this.x;
        array[offset + 1] = this.y;
        array[offset + 2] = this.z;
        array[offset + 3] = this.w;
        return array;
    }
    fromBufferAttribute(attribute, index, offset) {
        if (offset !== undefined) console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute().");
        this.x = attribute.getX(index);
        this.y = attribute.getY(index);
        this.z = attribute.getZ(index);
        this.w = attribute.getW(index);
        return this;
    }
    random() {
        this.x = Math.random();
        this.y = Math.random();
        this.z = Math.random();
        this.w = Math.random();
        return this;
    }
    *[Symbol.iterator]() {
        yield this.x;
        yield this.y;
        yield this.z;
        yield this.w;
    }
}
/*
 In options, we can specify:
 * Texture parameters for an auto-generated target texture
 * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
*/ class $084574008ccedf86$export$3c052beb2e51e23f extends $084574008ccedf86$export$ec8b666c5fe2c75a {
    constructor(width, height, options = {}){
        super();
        this.isWebGLRenderTarget = true;
        this.width = width;
        this.height = height;
        this.depth = 1;
        this.scissor = new $084574008ccedf86$export$fa7daccca11cdbe3(0, 0, width, height);
        this.scissorTest = false;
        this.viewport = new $084574008ccedf86$export$fa7daccca11cdbe3(0, 0, width, height);
        const image = {
            width: width,
            height: height,
            depth: 1
        };
        this.texture = new $084574008ccedf86$export$5431306cf43de24a(image, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);
        this.texture.isRenderTargetTexture = true;
        this.texture.flipY = false;
        this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;
        this.texture.internalFormat = options.internalFormat !== undefined ? options.internalFormat : null;
        this.texture.minFilter = options.minFilter !== undefined ? options.minFilter : $084574008ccedf86$export$8a72f490b25c56c8;
        this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
        this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : false;
        this.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;
        this.samples = options.samples !== undefined ? options.samples : 0;
    }
    setSize(width, height, depth = 1) {
        if (this.width !== width || this.height !== height || this.depth !== depth) {
            this.width = width;
            this.height = height;
            this.depth = depth;
            this.texture.image.width = width;
            this.texture.image.height = height;
            this.texture.image.depth = depth;
            this.dispose();
        }
        this.viewport.set(0, 0, width, height);
        this.scissor.set(0, 0, width, height);
    }
    clone() {
        return new this.constructor().copy(this);
    }
    copy(source) {
        this.width = source.width;
        this.height = source.height;
        this.depth = source.depth;
        this.viewport.copy(source.viewport);
        this.texture = source.texture.clone();
        this.texture.isRenderTargetTexture = true;
        // ensure image object is not shared, see #20328
        const image = Object.assign({}, source.texture.image);
        this.texture.source = new $084574008ccedf86$export$1d2df86270c81ecb(image);
        this.depthBuffer = source.depthBuffer;
        this.stencilBuffer = source.stencilBuffer;
        if (source.depthTexture !== null) this.depthTexture = source.depthTexture.clone();
        this.samples = source.samples;
        return this;
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        });
    }
}
class $084574008ccedf86$export$dfac6c8e811406a3 extends $084574008ccedf86$export$5431306cf43de24a {
    constructor(data = null, width = 1, height = 1, depth = 1){
        super(null);
        this.isDataArrayTexture = true;
        this.image = {
            data: data,
            width: width,
            height: height,
            depth: depth
        };
        this.magFilter = $084574008ccedf86$export$727aa5ec3fe39bf0;
        this.minFilter = $084574008ccedf86$export$727aa5ec3fe39bf0;
        this.wrapR = $084574008ccedf86$export$9d9334239a5a5e06;
        this.generateMipmaps = false;
        this.flipY = false;
        this.unpackAlignment = 1;
    }
}
class $084574008ccedf86$export$c77a02c11ed180c7 extends $084574008ccedf86$export$3c052beb2e51e23f {
    constructor(width, height, depth){
        super(width, height);
        this.isWebGLArrayRenderTarget = true;
        this.depth = depth;
        this.texture = new $084574008ccedf86$export$dfac6c8e811406a3(null, width, height, depth);
        this.texture.isRenderTargetTexture = true;
    }
}
class $084574008ccedf86$export$d7a3086320f856db extends $084574008ccedf86$export$5431306cf43de24a {
    constructor(data = null, width = 1, height = 1, depth = 1){
        // We're going to add .setXXX() methods for setting properties later.
        // Users can still set in DataTexture3D directly.
        //
        //	const texture = new THREE.DataTexture3D( data, width, height, depth );
        // 	texture.anisotropy = 16;
        //
        // See #14839
        super(null);
        this.isData3DTexture = true;
        this.image = {
            data: data,
            width: width,
            height: height,
            depth: depth
        };
        this.magFilter = $084574008ccedf86$export$727aa5ec3fe39bf0;
        this.minFilter = $084574008ccedf86$export$727aa5ec3fe39bf0;
        this.wrapR = $084574008ccedf86$export$9d9334239a5a5e06;
        this.generateMipmaps = false;
        this.flipY = false;
        this.unpackAlignment = 1;
    }
}
class $084574008ccedf86$export$7ee06591009639df extends $084574008ccedf86$export$3c052beb2e51e23f {
    constructor(width, height, depth){
        super(width, height);
        this.isWebGL3DRenderTarget = true;
        this.depth = depth;
        this.texture = new $084574008ccedf86$export$d7a3086320f856db(null, width, height, depth);
        this.texture.isRenderTargetTexture = true;
    }
}
class $084574008ccedf86$export$bd934554fb721730 extends $084574008ccedf86$export$3c052beb2e51e23f {
    constructor(width, height, count, options = {}){
        super(width, height, options);
        this.isWebGLMultipleRenderTargets = true;
        const texture = this.texture;
        this.texture = [];
        for(let i15 = 0; i15 < count; i15++){
            this.texture[i15] = texture.clone();
            this.texture[i15].isRenderTargetTexture = true;
        }
    }
    setSize(width, height, depth = 1) {
        if (this.width !== width || this.height !== height || this.depth !== depth) {
            this.width = width;
            this.height = height;
            this.depth = depth;
            for(let i16 = 0, il = this.texture.length; i16 < il; i16++){
                this.texture[i16].image.width = width;
                this.texture[i16].image.height = height;
                this.texture[i16].image.depth = depth;
            }
            this.dispose();
        }
        this.viewport.set(0, 0, width, height);
        this.scissor.set(0, 0, width, height);
        return this;
    }
    copy(source) {
        this.dispose();
        this.width = source.width;
        this.height = source.height;
        this.depth = source.depth;
        this.viewport.set(0, 0, this.width, this.height);
        this.scissor.set(0, 0, this.width, this.height);
        this.depthBuffer = source.depthBuffer;
        this.stencilBuffer = source.stencilBuffer;
        if (source.depthTexture !== null) this.depthTexture = source.depthTexture.clone();
        this.texture.length = 0;
        for(let i17 = 0, il = source.texture.length; i17 < il; i17++){
            this.texture[i17] = source.texture[i17].clone();
            this.texture[i17].isRenderTargetTexture = true;
        }
        return this;
    }
}
class $084574008ccedf86$export$23d6a54f0bbc85a3 {
    constructor(x = 0, y = 0, z = 0, w = 1){
        this.isQuaternion = true;
        this._x = x;
        this._y = y;
        this._z = z;
        this._w = w;
    }
    static slerp(qa, qb, qm, t) {
        console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead.");
        return qm.slerpQuaternions(qa, qb, t);
    }
    static slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {
        // fuzz-free, array-based Quaternion SLERP operation
        let x0 = src0[srcOffset0 + 0], y0 = src0[srcOffset0 + 1], z0 = src0[srcOffset0 + 2], w0 = src0[srcOffset0 + 3];
        const x1 = src1[srcOffset1 + 0], y1 = src1[srcOffset1 + 1], z1 = src1[srcOffset1 + 2], w1 = src1[srcOffset1 + 3];
        if (t === 0) {
            dst[dstOffset + 0] = x0;
            dst[dstOffset + 1] = y0;
            dst[dstOffset + 2] = z0;
            dst[dstOffset + 3] = w0;
            return;
        }
        if (t === 1) {
            dst[dstOffset + 0] = x1;
            dst[dstOffset + 1] = y1;
            dst[dstOffset + 2] = z1;
            dst[dstOffset + 3] = w1;
            return;
        }
        if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
            let s = 1 - t;
            const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1, dir = cos >= 0 ? 1 : -1, sqrSin = 1 - cos * cos;
            // Skip the Slerp for tiny steps to avoid numeric problems:
            if (sqrSin > Number.EPSILON) {
                const sin = Math.sqrt(sqrSin), len = Math.atan2(sin, cos * dir);
                s = Math.sin(s * len) / sin;
                t = Math.sin(t * len) / sin;
            }
            const tDir = t * dir;
            x0 = x0 * s + x1 * tDir;
            y0 = y0 * s + y1 * tDir;
            z0 = z0 * s + z1 * tDir;
            w0 = w0 * s + w1 * tDir;
            // Normalize in case we just did a lerp:
            if (s === 1 - t) {
                const f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
                x0 *= f;
                y0 *= f;
                z0 *= f;
                w0 *= f;
            }
        }
        dst[dstOffset] = x0;
        dst[dstOffset + 1] = y0;
        dst[dstOffset + 2] = z0;
        dst[dstOffset + 3] = w0;
    }
    static multiplyQuaternionsFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1) {
        const x0 = src0[srcOffset0];
        const y0 = src0[srcOffset0 + 1];
        const z0 = src0[srcOffset0 + 2];
        const w0 = src0[srcOffset0 + 3];
        const x1 = src1[srcOffset1];
        const y1 = src1[srcOffset1 + 1];
        const z1 = src1[srcOffset1 + 2];
        const w1 = src1[srcOffset1 + 3];
        dst[dstOffset] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
        dst[dstOffset + 1] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
        dst[dstOffset + 2] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
        dst[dstOffset + 3] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;
        return dst;
    }
    get x() {
        return this._x;
    }
    set x(value) {
        this._x = value;
        this._onChangeCallback();
    }
    get y() {
        return this._y;
    }
    set y(value) {
        this._y = value;
        this._onChangeCallback();
    }
    get z() {
        return this._z;
    }
    set z(value) {
        this._z = value;
        this._onChangeCallback();
    }
    get w() {
        return this._w;
    }
    set w(value) {
        this._w = value;
        this._onChangeCallback();
    }
    set(x, y, z, w) {
        this._x = x;
        this._y = y;
        this._z = z;
        this._w = w;
        this._onChangeCallback();
        return this;
    }
    clone() {
        return new this.constructor(this._x, this._y, this._z, this._w);
    }
    copy(quaternion) {
        this._x = quaternion.x;
        this._y = quaternion.y;
        this._z = quaternion.z;
        this._w = quaternion.w;
        this._onChangeCallback();
        return this;
    }
    setFromEuler(euler, update) {
        if (!(euler && euler.isEuler)) throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
        const x = euler._x, y = euler._y, z = euler._z, order = euler._order;
        // http://www.mathworks.com/matlabcentral/fileexchange/
        // 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
        //	content/SpinCalc.m
        const cos = Math.cos;
        const sin = Math.sin;
        const c1 = cos(x / 2);
        const c2 = cos(y / 2);
        const c3 = cos(z / 2);
        const s1 = sin(x / 2);
        const s2 = sin(y / 2);
        const s3 = sin(z / 2);
        switch(order){
            case "XYZ":
                this._x = s1 * c2 * c3 + c1 * s2 * s3;
                this._y = c1 * s2 * c3 - s1 * c2 * s3;
                this._z = c1 * c2 * s3 + s1 * s2 * c3;
                this._w = c1 * c2 * c3 - s1 * s2 * s3;
                break;
            case "YXZ":
                this._x = s1 * c2 * c3 + c1 * s2 * s3;
                this._y = c1 * s2 * c3 - s1 * c2 * s3;
                this._z = c1 * c2 * s3 - s1 * s2 * c3;
                this._w = c1 * c2 * c3 + s1 * s2 * s3;
                break;
            case "ZXY":
                this._x = s1 * c2 * c3 - c1 * s2 * s3;
                this._y = c1 * s2 * c3 + s1 * c2 * s3;
                this._z = c1 * c2 * s3 + s1 * s2 * c3;
                this._w = c1 * c2 * c3 - s1 * s2 * s3;
                break;
            case "ZYX":
                this._x = s1 * c2 * c3 - c1 * s2 * s3;
                this._y = c1 * s2 * c3 + s1 * c2 * s3;
                this._z = c1 * c2 * s3 - s1 * s2 * c3;
                this._w = c1 * c2 * c3 + s1 * s2 * s3;
                break;
            case "YZX":
                this._x = s1 * c2 * c3 + c1 * s2 * s3;
                this._y = c1 * s2 * c3 + s1 * c2 * s3;
                this._z = c1 * c2 * s3 - s1 * s2 * c3;
                this._w = c1 * c2 * c3 - s1 * s2 * s3;
                break;
            case "XZY":
                this._x = s1 * c2 * c3 - c1 * s2 * s3;
                this._y = c1 * s2 * c3 - s1 * c2 * s3;
                this._z = c1 * c2 * s3 + s1 * s2 * c3;
                this._w = c1 * c2 * c3 + s1 * s2 * s3;
                break;
            default:
                console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + order);
        }
        if (update !== false) this._onChangeCallback();
        return this;
    }
    setFromAxisAngle(axis, angle) {
        // http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm
        // assumes axis is normalized
        const halfAngle = angle / 2, s = Math.sin(halfAngle);
        this._x = axis.x * s;
        this._y = axis.y * s;
        this._z = axis.z * s;
        this._w = Math.cos(halfAngle);
        this._onChangeCallback();
        return this;
    }
    setFromRotationMatrix(m) {
        // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
        // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
        const te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10], trace = m11 + m22 + m33;
        if (trace > 0) {
            const s = 0.5 / Math.sqrt(trace + 1.0);
            this._w = 0.25 / s;
            this._x = (m32 - m23) * s;
            this._y = (m13 - m31) * s;
            this._z = (m21 - m12) * s;
        } else if (m11 > m22 && m11 > m33) {
            const s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);
            this._w = (m32 - m23) / s;
            this._x = 0.25 * s;
            this._y = (m12 + m21) / s;
            this._z = (m13 + m31) / s;
        } else if (m22 > m33) {
            const s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);
            this._w = (m13 - m31) / s;
            this._x = (m12 + m21) / s;
            this._y = 0.25 * s;
            this._z = (m23 + m32) / s;
        } else {
            const s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);
            this._w = (m21 - m12) / s;
            this._x = (m13 + m31) / s;
            this._y = (m23 + m32) / s;
            this._z = 0.25 * s;
        }
        this._onChangeCallback();
        return this;
    }
    setFromUnitVectors(vFrom, vTo) {
        // assumes direction vectors vFrom and vTo are normalized
        let r = vFrom.dot(vTo) + 1;
        if (r < Number.EPSILON) {
            // vFrom and vTo point in opposite directions
            r = 0;
            if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
                this._x = -vFrom.y;
                this._y = vFrom.x;
                this._z = 0;
                this._w = r;
            } else {
                this._x = 0;
                this._y = -vFrom.z;
                this._z = vFrom.y;
                this._w = r;
            }
        } else {
            // crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3
            this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
            this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
            this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
            this._w = r;
        }
        return this.normalize();
    }
    angleTo(q) {
        return 2 * Math.acos(Math.abs($084574008ccedf86$var$clamp(this.dot(q), -1, 1)));
    }
    rotateTowards(q, step) {
        const angle = this.angleTo(q);
        if (angle === 0) return this;
        const t = Math.min(1, step / angle);
        this.slerp(q, t);
        return this;
    }
    identity() {
        return this.set(0, 0, 0, 1);
    }
    invert() {
        // quaternion is assumed to have unit length
        return this.conjugate();
    }
    conjugate() {
        this._x *= -1;
        this._y *= -1;
        this._z *= -1;
        this._onChangeCallback();
        return this;
    }
    dot(v) {
        return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
    }
    lengthSq() {
        return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
    }
    length() {
        return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
    }
    normalize() {
        let l = this.length();
        if (l === 0) {
            this._x = 0;
            this._y = 0;
            this._z = 0;
            this._w = 1;
        } else {
            l = 1 / l;
            this._x = this._x * l;
            this._y = this._y * l;
            this._z = this._z * l;
            this._w = this._w * l;
        }
        this._onChangeCallback();
        return this;
    }
    multiply(q, p) {
        if (p !== undefined) {
            console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.");
            return this.multiplyQuaternions(q, p);
        }
        return this.multiplyQuaternions(this, q);
    }
    premultiply(q) {
        return this.multiplyQuaternions(q, this);
    }
    multiplyQuaternions(a, b) {
        // from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm
        const qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
        const qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;
        this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
        this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
        this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
        this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
        this._onChangeCallback();
        return this;
    }
    slerp(qb, t) {
        if (t === 0) return this;
        if (t === 1) return this.copy(qb);
        const x = this._x, y = this._y, z = this._z, w = this._w;
        // http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/
        let cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;
        if (cosHalfTheta < 0) {
            this._w = -qb._w;
            this._x = -qb._x;
            this._y = -qb._y;
            this._z = -qb._z;
            cosHalfTheta = -cosHalfTheta;
        } else this.copy(qb);
        if (cosHalfTheta >= 1.0) {
            this._w = w;
            this._x = x;
            this._y = y;
            this._z = z;
            return this;
        }
        const sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;
        if (sqrSinHalfTheta <= Number.EPSILON) {
            const s = 1 - t;
            this._w = s * w + t * this._w;
            this._x = s * x + t * this._x;
            this._y = s * y + t * this._y;
            this._z = s * z + t * this._z;
            this.normalize();
            this._onChangeCallback();
            return this;
        }
        const sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
        const halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
        const ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta, ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
        this._w = w * ratioA + this._w * ratioB;
        this._x = x * ratioA + this._x * ratioB;
        this._y = y * ratioA + this._y * ratioB;
        this._z = z * ratioA + this._z * ratioB;
        this._onChangeCallback();
        return this;
    }
    slerpQuaternions(qa, qb, t) {
        return this.copy(qa).slerp(qb, t);
    }
    random() {
        // Derived from http://planning.cs.uiuc.edu/node198.html
        // Note, this source uses w, x, y, z ordering,
        // so we swap the order below.
        const u1 = Math.random();
        const sqrt1u1 = Math.sqrt(1 - u1);
        const sqrtu1 = Math.sqrt(u1);
        const u2 = 2 * Math.PI * Math.random();
        const u3 = 2 * Math.PI * Math.random();
        return this.set(sqrt1u1 * Math.cos(u2), sqrtu1 * Math.sin(u3), sqrtu1 * Math.cos(u3), sqrt1u1 * Math.sin(u2));
    }
    equals(quaternion) {
        return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;
    }
    fromArray(array, offset = 0) {
        this._x = array[offset];
        this._y = array[offset + 1];
        this._z = array[offset + 2];
        this._w = array[offset + 3];
        this._onChangeCallback();
        return this;
    }
    toArray(array = [], offset = 0) {
        array[offset] = this._x;
        array[offset + 1] = this._y;
        array[offset + 2] = this._z;
        array[offset + 3] = this._w;
        return array;
    }
    fromBufferAttribute(attribute, index) {
        this._x = attribute.getX(index);
        this._y = attribute.getY(index);
        this._z = attribute.getZ(index);
        this._w = attribute.getW(index);
        return this;
    }
    _onChange(callback) {
        this._onChangeCallback = callback;
        return this;
    }
    _onChangeCallback() {}
    *[Symbol.iterator]() {
        yield this._x;
        yield this._y;
        yield this._z;
        yield this._w;
    }
}
class $084574008ccedf86$export$64b5c384219d3699 {
    constructor(x = 0, y = 0, z = 0){
        this.isVector3 = true;
        this.x = x;
        this.y = y;
        this.z = z;
    }
    set(x, y, z) {
        if (z === undefined) z = this.z; // sprite.scale.set(x,y)
        this.x = x;
        this.y = y;
        this.z = z;
        return this;
    }
    setScalar(scalar) {
        this.x = scalar;
        this.y = scalar;
        this.z = scalar;
        return this;
    }
    setX(x) {
        this.x = x;
        return this;
    }
    setY(y) {
        this.y = y;
        return this;
    }
    setZ(z) {
        this.z = z;
        return this;
    }
    setComponent(index, value) {
        switch(index){
            case 0:
                this.x = value;
                break;
            case 1:
                this.y = value;
                break;
            case 2:
                this.z = value;
                break;
            default:
                throw new Error("index is out of range: " + index);
        }
        return this;
    }
    getComponent(index) {
        switch(index){
            case 0:
                return this.x;
            case 1:
                return this.y;
            case 2:
                return this.z;
            default:
                throw new Error("index is out of range: " + index);
        }
    }
    clone() {
        return new this.constructor(this.x, this.y, this.z);
    }
    copy(v) {
        this.x = v.x;
        this.y = v.y;
        this.z = v.z;
        return this;
    }
    add(v, w) {
        if (w !== undefined) {
            console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
            return this.addVectors(v, w);
        }
        this.x += v.x;
        this.y += v.y;
        this.z += v.z;
        return this;
    }
    addScalar(s) {
        this.x += s;
        this.y += s;
        this.z += s;
        return this;
    }
    addVectors(a, b) {
        this.x = a.x + b.x;
        this.y = a.y + b.y;
        this.z = a.z + b.z;
        return this;
    }
    addScaledVector(v, s) {
        this.x += v.x * s;
        this.y += v.y * s;
        this.z += v.z * s;
        return this;
    }
    sub(v, w) {
        if (w !== undefined) {
            console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
            return this.subVectors(v, w);
        }
        this.x -= v.x;
        this.y -= v.y;
        this.z -= v.z;
        return this;
    }
    subScalar(s) {
        this.x -= s;
        this.y -= s;
        this.z -= s;
        return this;
    }
    subVectors(a, b) {
        this.x = a.x - b.x;
        this.y = a.y - b.y;
        this.z = a.z - b.z;
        return this;
    }
    multiply(v, w) {
        if (w !== undefined) {
            console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.");
            return this.multiplyVectors(v, w);
        }
        this.x *= v.x;
        this.y *= v.y;
        this.z *= v.z;
        return this;
    }
    multiplyScalar(scalar) {
        this.x *= scalar;
        this.y *= scalar;
        this.z *= scalar;
        return this;
    }
    multiplyVectors(a, b) {
        this.x = a.x * b.x;
        this.y = a.y * b.y;
        this.z = a.z * b.z;
        return this;
    }
    applyEuler(euler) {
        if (!(euler && euler.isEuler)) console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.");
        return this.applyQuaternion($084574008ccedf86$var$_quaternion$4.setFromEuler(euler));
    }
    applyAxisAngle(axis, angle) {
        return this.applyQuaternion($084574008ccedf86$var$_quaternion$4.setFromAxisAngle(axis, angle));
    }
    applyMatrix3(m) {
        const x = this.x, y = this.y, z = this.z;
        const e = m.elements;
        this.x = e[0] * x + e[3] * y + e[6] * z;
        this.y = e[1] * x + e[4] * y + e[7] * z;
        this.z = e[2] * x + e[5] * y + e[8] * z;
        return this;
    }
    applyNormalMatrix(m) {
        return this.applyMatrix3(m).normalize();
    }
    applyMatrix4(m) {
        const x = this.x, y = this.y, z = this.z;
        const e = m.elements;
        const w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);
        this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w;
        this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w;
        this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w;
        return this;
    }
    applyQuaternion(q) {
        const x = this.x, y = this.y, z = this.z;
        const qx = q.x, qy = q.y, qz = q.z, qw = q.w;
        // calculate quat * vector
        const ix = qw * x + qy * z - qz * y;
        const iy = qw * y + qz * x - qx * z;
        const iz = qw * z + qx * y - qy * x;
        const iw = -qx * x - qy * y - qz * z;
        // calculate result * inverse quat
        this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
        this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
        this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
        return this;
    }
    project(camera) {
        return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);
    }
    unproject(camera) {
        return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);
    }
    transformDirection(m) {
        // input: THREE.Matrix4 affine matrix
        // vector interpreted as a direction
        const x = this.x, y = this.y, z = this.z;
        const e = m.elements;
        this.x = e[0] * x + e[4] * y + e[8] * z;
        this.y = e[1] * x + e[5] * y + e[9] * z;
        this.z = e[2] * x + e[6] * y + e[10] * z;
        return this.normalize();
    }
    divide(v) {
        this.x /= v.x;
        this.y /= v.y;
        this.z /= v.z;
        return this;
    }
    divideScalar(scalar) {
        return this.multiplyScalar(1 / scalar);
    }
    min(v) {
        this.x = Math.min(this.x, v.x);
        this.y = Math.min(this.y, v.y);
        this.z = Math.min(this.z, v.z);
        return this;
    }
    max(v) {
        this.x = Math.max(this.x, v.x);
        this.y = Math.max(this.y, v.y);
        this.z = Math.max(this.z, v.z);
        return this;
    }
    clamp(min, max) {
        // assumes min < max, componentwise
        this.x = Math.max(min.x, Math.min(max.x, this.x));
        this.y = Math.max(min.y, Math.min(max.y, this.y));
        this.z = Math.max(min.z, Math.min(max.z, this.z));
        return this;
    }
    clampScalar(minVal, maxVal) {
        this.x = Math.max(minVal, Math.min(maxVal, this.x));
        this.y = Math.max(minVal, Math.min(maxVal, this.y));
        this.z = Math.max(minVal, Math.min(maxVal, this.z));
        return this;
    }
    clampLength(min, max) {
        const length = this.length();
        return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
    }
    floor() {
        this.x = Math.floor(this.x);
        this.y = Math.floor(this.y);
        this.z = Math.floor(this.z);
        return this;
    }
    ceil() {
        this.x = Math.ceil(this.x);
        this.y = Math.ceil(this.y);
        this.z = Math.ceil(this.z);
        return this;
    }
    round() {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        this.z = Math.round(this.z);
        return this;
    }
    roundToZero() {
        this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
        this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
        this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
        return this;
    }
    negate() {
        this.x = -this.x;
        this.y = -this.y;
        this.z = -this.z;
        return this;
    }
    dot(v) {
        return this.x * v.x + this.y * v.y + this.z * v.z;
    }
    // TODO lengthSquared?
    lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z;
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
    }
    normalize() {
        return this.divideScalar(this.length() || 1);
    }
    setLength(length) {
        return this.normalize().multiplyScalar(length);
    }
    lerp(v, alpha) {
        this.x += (v.x - this.x) * alpha;
        this.y += (v.y - this.y) * alpha;
        this.z += (v.z - this.z) * alpha;
        return this;
    }
    lerpVectors(v1, v2, alpha) {
        this.x = v1.x + (v2.x - v1.x) * alpha;
        this.y = v1.y + (v2.y - v1.y) * alpha;
        this.z = v1.z + (v2.z - v1.z) * alpha;
        return this;
    }
    cross(v, w) {
        if (w !== undefined) {
            console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.");
            return this.crossVectors(v, w);
        }
        return this.crossVectors(this, v);
    }
    crossVectors(a, b) {
        const ax = a.x, ay = a.y, az = a.z;
        const bx = b.x, by = b.y, bz = b.z;
        this.x = ay * bz - az * by;
        this.y = az * bx - ax * bz;
        this.z = ax * by - ay * bx;
        return this;
    }
    projectOnVector(v) {
        const denominator = v.lengthSq();
        if (denominator === 0) return this.set(0, 0, 0);
        const scalar = v.dot(this) / denominator;
        return this.copy(v).multiplyScalar(scalar);
    }
    projectOnPlane(planeNormal) {
        $084574008ccedf86$var$_vector$c.copy(this).projectOnVector(planeNormal);
        return this.sub($084574008ccedf86$var$_vector$c);
    }
    reflect(normal) {
        // reflect incident vector off plane orthogonal to normal
        // normal is assumed to have unit length
        return this.sub($084574008ccedf86$var$_vector$c.copy(normal).multiplyScalar(2 * this.dot(normal)));
    }
    angleTo(v) {
        const denominator = Math.sqrt(this.lengthSq() * v.lengthSq());
        if (denominator === 0) return Math.PI / 2;
        const theta = this.dot(v) / denominator;
        // clamp, to handle numerical problems
        return Math.acos($084574008ccedf86$var$clamp(theta, -1, 1));
    }
    distanceTo(v) {
        return Math.sqrt(this.distanceToSquared(v));
    }
    distanceToSquared(v) {
        const dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;
        return dx * dx + dy * dy + dz * dz;
    }
    manhattanDistanceTo(v) {
        return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);
    }
    setFromSpherical(s) {
        return this.setFromSphericalCoords(s.radius, s.phi, s.theta);
    }
    setFromSphericalCoords(radius, phi, theta) {
        const sinPhiRadius = Math.sin(phi) * radius;
        this.x = sinPhiRadius * Math.sin(theta);
        this.y = Math.cos(phi) * radius;
        this.z = sinPhiRadius * Math.cos(theta);
        return this;
    }
    setFromCylindrical(c) {
        return this.setFromCylindricalCoords(c.radius, c.theta, c.y);
    }
    setFromCylindricalCoords(radius, theta, y) {
        this.x = radius * Math.sin(theta);
        this.y = y;
        this.z = radius * Math.cos(theta);
        return this;
    }
    setFromMatrixPosition(m) {
        const e = m.elements;
        this.x = e[12];
        this.y = e[13];
        this.z = e[14];
        return this;
    }
    setFromMatrixScale(m) {
        const sx = this.setFromMatrixColumn(m, 0).length();
        const sy = this.setFromMatrixColumn(m, 1).length();
        const sz = this.setFromMatrixColumn(m, 2).length();
        this.x = sx;
        this.y = sy;
        this.z = sz;
        return this;
    }
    setFromMatrixColumn(m, index) {
        return this.fromArray(m.elements, index * 4);
    }
    setFromMatrix3Column(m, index) {
        return this.fromArray(m.elements, index * 3);
    }
    setFromEuler(e) {
        this.x = e._x;
        this.y = e._y;
        this.z = e._z;
        return this;
    }
    equals(v) {
        return v.x === this.x && v.y === this.y && v.z === this.z;
    }
    fromArray(array, offset = 0) {
        this.x = array[offset];
        this.y = array[offset + 1];
        this.z = array[offset + 2];
        return this;
    }
    toArray(array = [], offset = 0) {
        array[offset] = this.x;
        array[offset + 1] = this.y;
        array[offset + 2] = this.z;
        return array;
    }
    fromBufferAttribute(attribute, index, offset) {
        if (offset !== undefined) console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute().");
        this.x = attribute.getX(index);
        this.y = attribute.getY(index);
        this.z = attribute.getZ(index);
        return this;
    }
    random() {
        this.x = Math.random();
        this.y = Math.random();
        this.z = Math.random();
        return this;
    }
    randomDirection() {
        // Derived from https://mathworld.wolfram.com/SpherePointPicking.html
        const u = (Math.random() - 0.5) * 2;
        const t = Math.random() * Math.PI * 2;
        const f = Math.sqrt(1 - u ** 2);
        this.x = f * Math.cos(t);
        this.y = f * Math.sin(t);
        this.z = u;
        return this;
    }
    *[Symbol.iterator]() {
        yield this.x;
        yield this.y;
        yield this.z;
    }
}
const $084574008ccedf86$var$_vector$c = /*@__PURE__*/ new $084574008ccedf86$export$64b5c384219d3699();
const $084574008ccedf86$var$_quaternion$4 = /*@__PURE__*/ new $084574008ccedf86$export$23d6a54f0bbc85a3();
class $084574008ccedf86$export$6f7d5a9418ab2aa3 {
    constructor(min = new $084574008ccedf86$export$64b5c384219d3699(Infinity, Infinity, Infinity), max = new $084574008ccedf86$export$64b5c384219d3699(-Infinity, -Infinity, -Infinity)){
        this.isBox3 = true;
        this.min = min;
        this.max = max;
    }
    set(min, max) {
        this.min.copy(min);
        this.max.copy(max);
        return this;
    }
    setFromArray(array) {
        let minX = Infinity;
        let minY = Infinity;
        let minZ = Infinity;
        let maxX = -Infinity;
        let maxY = -Infinity;
        let maxZ = -Infinity;
        for(let i18 = 0, l = array.length; i18 < l; i18 += 3){
            const x = array[i18];
            const y = array[i18 + 1];
            const z = array[i18 + 2];
            if (x < minX) minX = x;
            if (y < minY) minY = y;
            if (z < minZ) minZ = z;
            if (x > maxX) maxX = x;
            if (y > maxY) maxY = y;
            if (z > maxZ) maxZ = z;
        }
        this.min.set(minX, minY, minZ);
        this.max.set(maxX, maxY, maxZ);
        return this;
    }
    setFromBufferAttribute(attribute) {
        let minX = Infinity;
        let minY = Infinity;
        let minZ = Infinity;
        let maxX = -Infinity;
        let maxY = -Infinity;
        let maxZ = -Infinity;
        for(let i19 = 0, l = attribute.count; i19 < l; i19++){
            const x = attribute.getX(i19);
            const y = attribute.getY(i19);
            const z = attribute.getZ(i19);
            if (x < minX) minX = x;
            if (y < minY) minY = y;
            if (z < minZ) minZ = z;
            if (x > maxX) maxX = x;
            if (y > maxY) maxY = y;
            if (z > maxZ) maxZ = z;
        }
        this.min.set(minX, minY, minZ);
        this.max.set(maxX, maxY, maxZ);
        return this;
    }
    setFromPoints(points) {
        this.makeEmpty();
        for(let i20 = 0, il = points.length; i20 < il; i20++)this.expandByPoint(points[i20]);
        return this;
    }
    setFromCenterAndSize(center, size) {
        const halfSize = $084574008ccedf86$var$_vector$b.copy(size).multiplyScalar(0.5);
        this.min.copy(center).sub(halfSize);
        this.max.copy(center).add(halfSize);
        return this;
    }
    setFromObject(object, precise = false) {
        this.makeEmpty();
        return this.expandByObject(object, precise);
    }
    clone() {
        return new this.constructor().copy(this);
    }
    copy(box) {
        this.min.copy(box.min);
        this.max.copy(box.max);
        return this;
    }
    makeEmpty() {
        this.min.x = this.min.y = this.min.z = Infinity;
        this.max.x = this.max.y = this.max.z = -Infinity;
        return this;
    }
    isEmpty() {
        // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
        return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
    }
    getCenter(target) {
        return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
    }
    getSize(target) {
        return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);
    }
    expandByPoint(point) {
        this.min.min(point);
        this.max.max(point);
        return this;
    }
    expandByVector(vector) {
        this.min.sub(vector);
        this.max.add(vector);
        return this;
    }
    expandByScalar(scalar) {
        this.min.addScalar(-scalar);
        this.max.addScalar(scalar);
        return this;
    }
    expandByObject(object, precise = false) {
        // Computes the world-axis-aligned bounding box of an object (including its children),
        // accounting for both the object's, and children's, world transforms
        object.updateWorldMatrix(false, false);
        const geometry = object.geometry;
        if (geometry !== undefined) {
            if (precise && geometry.attributes != undefined && geometry.attributes.position !== undefined) {
                const position = geometry.attributes.position;
                for(let i21 = 0, l = position.count; i21 < l; i21++){
                    $084574008ccedf86$var$_vector$b.fromBufferAttribute(position, i21).applyMatrix4(object.matrixWorld);
                    this.expandByPoint($084574008ccedf86$var$_vector$b);
                }
            } else {
                if (geometry.boundingBox === null) geometry.computeBoundingBox();
                $084574008ccedf86$var$_box$3.copy(geometry.boundingBox);
                $084574008ccedf86$var$_box$3.applyMatrix4(object.matrixWorld);
                this.union($084574008ccedf86$var$_box$3);
            }
        }
        const children = object.children;
        for(let i22 = 0, l = children.length; i22 < l; i22++)this.expandByObject(children[i22], precise);
        return this;
    }
    containsPoint(point) {
        return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y || point.z < this.min.z || point.z > this.max.z ? false : true;
    }
    containsBox(box) {
        return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;
    }
    getParameter(point, target) {
        // This can potentially have a divide by zero if the box
        // has a size dimension of 0.
        return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y), (point.z - this.min.z) / (this.max.z - this.min.z));
    }
    intersectsBox(box) {
        // using 6 splitting planes to rule out intersections.
        return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y || box.max.z < this.min.z || box.min.z > this.max.z ? false : true;
    }
    intersectsSphere(sphere) {
        // Find the point on the AABB closest to the sphere center.
        this.clampPoint(sphere.center, $084574008ccedf86$var$_vector$b);
        // If that point is inside the sphere, the AABB and sphere intersect.
        return $084574008ccedf86$var$_vector$b.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;
    }
    intersectsPlane(plane) {
        // We compute the minimum and maximum dot product values. If those values
        // are on the same side (back or front) of the plane, then there is no intersection.
        let min, max;
        if (plane.normal.x > 0) {
            min = plane.normal.x * this.min.x;
            max = plane.normal.x * this.max.x;
        } else {
            min = plane.normal.x * this.max.x;
            max = plane.normal.x * this.min.x;
        }
        if (plane.normal.y > 0) {
            min += plane.normal.y * this.min.y;
            max += plane.normal.y * this.max.y;
        } else {
            min += plane.normal.y * this.max.y;
            max += plane.normal.y * this.min.y;
        }
        if (plane.normal.z > 0) {
            min += plane.normal.z * this.min.z;
            max += plane.normal.z * this.max.z;
        } else {
            min += plane.normal.z * this.max.z;
            max += plane.normal.z * this.min.z;
        }
        return min <= -plane.constant && max >= -plane.constant;
    }
    intersectsTriangle(triangle) {
        if (this.isEmpty()) return false;
        // compute box center and extents
        this.getCenter($084574008ccedf86$var$_center);
        $084574008ccedf86$var$_extents.subVectors(this.max, $084574008ccedf86$var$_center);
        // translate triangle to aabb origin
        $084574008ccedf86$var$_v0$2.subVectors(triangle.a, $084574008ccedf86$var$_center);
        $084574008ccedf86$var$_v1$7.subVectors(triangle.b, $084574008ccedf86$var$_center);
        $084574008ccedf86$var$_v2$3.subVectors(triangle.c, $084574008ccedf86$var$_center);
        // compute edge vectors for triangle
        $084574008ccedf86$var$_f0.subVectors($084574008ccedf86$var$_v1$7, $084574008ccedf86$var$_v0$2);
        $084574008ccedf86$var$_f1.subVectors($084574008ccedf86$var$_v2$3, $084574008ccedf86$var$_v1$7);
        $084574008ccedf86$var$_f2.subVectors($084574008ccedf86$var$_v0$2, $084574008ccedf86$var$_v2$3);
        // test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb
        // make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation
        // axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)
        let axes = [
            0,
            -$084574008ccedf86$var$_f0.z,
            $084574008ccedf86$var$_f0.y,
            0,
            -$084574008ccedf86$var$_f1.z,
            $084574008ccedf86$var$_f1.y,
            0,
            -$084574008ccedf86$var$_f2.z,
            $084574008ccedf86$var$_f2.y,
            $084574008ccedf86$var$_f0.z,
            0,
            -$084574008ccedf86$var$_f0.x,
            $084574008ccedf86$var$_f1.z,
            0,
            -$084574008ccedf86$var$_f1.x,
            $084574008ccedf86$var$_f2.z,
            0,
            -$084574008ccedf86$var$_f2.x,
            -$084574008ccedf86$var$_f0.y,
            $084574008ccedf86$var$_f0.x,
            0,
            -$084574008ccedf86$var$_f1.y,
            $084574008ccedf86$var$_f1.x,
            0,
            -$084574008ccedf86$var$_f2.y,
            $084574008ccedf86$var$_f2.x,
            0
        ];
        if (!$084574008ccedf86$var$satForAxes(axes, $084574008ccedf86$var$_v0$2, $084574008ccedf86$var$_v1$7, $084574008ccedf86$var$_v2$3, $084574008ccedf86$var$_extents)) return false;
        // test 3 face normals from the aabb
        axes = [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1
        ];
        if (!$084574008ccedf86$var$satForAxes(axes, $084574008ccedf86$var$_v0$2, $084574008ccedf86$var$_v1$7, $084574008ccedf86$var$_v2$3, $084574008ccedf86$var$_extents)) return false;
        // finally testing the face normal of the triangle
        // use already existing triangle edge vectors here
        $084574008ccedf86$var$_triangleNormal.crossVectors($084574008ccedf86$var$_f0, $084574008ccedf86$var$_f1);
        axes = [
            $084574008ccedf86$var$_triangleNormal.x,
            $084574008ccedf86$var$_triangleNormal.y,
            $084574008ccedf86$var$_triangleNormal.z
        ];
        return $084574008ccedf86$var$satForAxes(axes, $084574008ccedf86$var$_v0$2, $084574008ccedf86$var$_v1$7, $084574008ccedf86$var$_v2$3, $084574008ccedf86$var$_extents);
    }
    clampPoint(point, target) {
        return target.copy(point).clamp(this.min, this.max);
    }
    distanceToPoint(point) {
        const clampedPoint = $084574008ccedf86$var$_vector$b.copy(point).clamp(this.min, this.max);
        return clampedPoint.sub(point).length();
    }
    getBoundingSphere(target) {
        this.getCenter(target.center);
        target.radius = this.getSize($084574008ccedf86$var$_vector$b).length() * 0.5;
        return target;
    }
    intersect(box) {
        this.min.max(box.min);
        this.max.min(box.max);
        // ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
        if (this.isEmpty()) this.makeEmpty();
        return this;
    }
    union(box) {
        this.min.min(box.min);
        this.max.max(box.max);
        return this;
    }
    applyMatrix4(matrix) {
        // transform of empty box is an empty box.
        if (this.isEmpty()) return this;
        // NOTE: I am using a binary pattern to specify all 2^3 combinations below
        $084574008ccedf86$var$_points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix); // 000
        $084574008ccedf86$var$_points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix); // 001
        $084574008ccedf86$var$_points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix); // 010
        $084574008ccedf86$var$_points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix); // 011
        $084574008ccedf86$var$_points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix); // 100
        $084574008ccedf86$var$_points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix); // 101
        $084574008ccedf86$var$_points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix); // 110
        $084574008ccedf86$var$_points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix); // 111
        this.setFromPoints($084574008ccedf86$var$_points);
        return this;
    }
    translate(offset) {
        this.min.add(offset);
        this.max.add(offset);
        return this;
    }
    equals(box) {
        return box.min.equals(this.min) && box.max.equals(this.max);
    }
}
const $084574008ccedf86$var$_points = [
    /*@__PURE__*/ new $084574008ccedf86$export$64b5c384219d3699(),
    /*@__PURE__*/ new $084574008ccedf86$export$64b5c384219d3699(),
    /*@__PURE__*/ new $084574008ccedf86$export$64b5c384219d3699(),
    /*@__PURE__*/ new $084574008ccedf86$export$64b5c384219d3699(),
    /*@__PURE__*/ new $084574008ccedf86$export$64b5c384219d3699(),
    /*@__PURE__*/ new $084574008ccedf86$export$64b5c384219d3699(),
    /*@__PURE__*/ new $084574008ccedf86$export$64b5c384219d3699(),
    /*@__PURE__*/ new $084574008ccedf86$export$64b5c384219d3699()
];
const $084574008ccedf86$var$_vector$b = /*@__PURE__*/ new $084574008ccedf86$export$64b5c384219d3699();
const $084574008ccedf86$var$_box$3 = /*@__PURE__*/ new $084574008ccedf86$export$6f7d5a9418ab2aa3();
// triangle centered vertices
const $084574008ccedf86$var$_v0$2 = /*@__PURE__*/ new $084574008ccedf86$export$64b5c384219d3699();
const $084574008ccedf86$var$_v1$7 = /*@__PURE__*/ new $084574008ccedf86$export$64b5c384219d3699();
const $084574008ccedf86$var$_v2$3 = /*@__PURE__*/ new $084574008ccedf86$export$64b5c384219d3699();
// triangle edge vectors
const $084574008ccedf86$var$_f0 = /*@__PURE__*/ new $084574008ccedf86$export$64b5c384219d3699();
const $084574008ccedf86$var$_f1 = /*@__PURE__*/ new $084574008ccedf86$export$64b5c384219d3699();
const $084574008ccedf86$var$_f2 = /*@__PURE__*/ new $084574008ccedf86$export$64b5c384219d3699();
const $084574008ccedf86$var$_center = /*@__PURE__*/ new $084574008ccedf86$export$64b5c384219d3699();
const $084574008ccedf86$var$_extents = /*@__PURE__*/ new $084574008ccedf86$export$64b5c384219d3699();
const $084574008ccedf86$var$_triangleNormal = /*@__PURE__*/ new $084574008ccedf86$export$64b5c384219d3699();
const $084574008ccedf86$var$_testAxis = /*@__PURE__*/ new $084574008ccedf86$export$64b5c384219d3699();
function $084574008ccedf86$var$satForAxes(axes, v0, v1, v2, extents) {
    for(let i23 = 0, j = axes.length - 3; i23 <= j; i23 += 3){
        $084574008ccedf86$var$_testAxis.fromArray(axes, i23);
        // project the aabb onto the separating axis
        const r = extents.x * Math.abs($084574008ccedf86$var$_testAxis.x) + extents.y * Math.abs($084574008ccedf86$var$_testAxis.y) + extents.z * Math.abs($084574008ccedf86$var$_testAxis.z);
        // project all 3 vertices of the triangle onto the separating axis
        const p0 = v0.dot($084574008ccedf86$var$_testAxis);
        const p1 = v1.dot($084574008ccedf86$var$_testAxis);
        const p2 = v2.dot($084574008ccedf86$var$_testAxis);
        // actual test, basically see if either of the most extreme of the triangle points intersects r
        if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r) // points of the projected triangle are outside the projected half-length of the aabb
        // the axis is separating and we can exit
        return false;
    }
    return true;
}
const $084574008ccedf86$var$_box$2 = /*@__PURE__*/ new $084574008ccedf86$export$6f7d5a9418ab2aa3();
const $084574008ccedf86$var$_v1$6 = /*@__PURE__*/ new $084574008ccedf86$export$64b5c384219d3699();
const $084574008ccedf86$var$_toFarthestPoint = /*@__PURE__*/ new $084574008ccedf86$export$64b5c384219d3699();
const $084574008ccedf86$var$_toPoint = /*@__PURE__*/ new $084574008ccedf86$export$64b5c384219d3699();
class $084574008ccedf86$export$805e8b72413ccaba {
    constructor(center = new $084574008ccedf86$export$64b5c384219d3699(), radius = -1){
        this.center = center;
        this.radius = radius;
    }
    set(center, radius) {
        this.center.copy(center);
        this.radius = radius;
        return this;
    }
    setFromPoints(points, optionalCenter) {
        const center = this.center;
        if (optionalCenter !== undefined) center.copy(optionalCenter);
        else $084574008ccedf86$var$_box$2.setFromPoints(points).getCenter(center);
        let maxRadiusSq = 0;
        for(let i24 = 0, il = points.length; i24 < il; i24++)maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i24]));
        this.radius = Math.sqrt(maxRadiusSq);
        return this;
    }
    copy(sphere) {
        this.center.copy(sphere.center);
        this.radius = sphere.radius;
        return this;
    }
    isEmpty() {
        return this.radius < 0;
    }
    makeEmpty() {
        this.center.set(0, 0, 0);
        this.radius = -1;
        return this;
    }
    containsPoint(point) {
        return point.distanceToSquared(this.center) <= this.radius * this.radius;
    }
    distanceToPoint(point) {
        return point.distanceTo(this.center) - this.radius;
    }
    intersectsSphere(sphere) {
        const radiusSum = this.radius + sphere.radius;
        return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;
    }
    intersectsBox(box) {
        return box.intersectsSphere(this);
    }
    intersectsPlane(plane) {
        return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;
    }
    clampPoint(point, target) {
        const deltaLengthSq = this.center.distanceToSquared(point);
        target.copy(point);
        if (deltaLengthSq > this.radius * this.radius) {
            target.sub(this.center).normalize();
            target.multiplyScalar(this.radius).add(this.center);
        }
        return target;
    }
    getBoundingBox(target) {
        if (this.isEmpty()) {
            // Empty sphere produces empty bounding box
            target.makeEmpty();
            return target;
        }
        target.set(this.center, this.center);
        target.expandByScalar(this.radius);
        return target;
    }
    applyMatrix4(matrix) {
        this.center.applyMatrix4(matrix);
        this.radius = this.radius * matrix.getMaxScaleOnAxis();
        return this;
    }
    translate(offset) {
        this.center.add(offset);
        return this;
    }
    expandByPoint(point) {
        // from https://github.com/juj/MathGeoLib/blob/2940b99b99cfe575dd45103ef20f4019dee15b54/src/Geometry/Sphere.cpp#L649-L671
        $084574008ccedf86$var$_toPoint.subVectors(point, this.center);
        const lengthSq = $084574008ccedf86$var$_toPoint.lengthSq();
        if (lengthSq > this.radius * this.radius) {
            const length = Math.sqrt(lengthSq);
            const missingRadiusHalf = (length - this.radius) * 0.5;
            // Nudge this sphere towards the target point. Add half the missing distance to radius,
            // and the other half to position. This gives a tighter enclosure, instead of if
            // the whole missing distance were just added to radius.
            this.center.add($084574008ccedf86$var$_toPoint.multiplyScalar(missingRadiusHalf / length));
            this.radius += missingRadiusHalf;
        }
        return this;
    }
    union(sphere) {
        // from https://github.com/juj/MathGeoLib/blob/2940b99b99cfe575dd45103ef20f4019dee15b54/src/Geometry/Sphere.cpp#L759-L769
        // To enclose another sphere into this sphere, we only need to enclose two points:
        // 1) Enclose the farthest point on the other sphere into this sphere.
        // 2) Enclose the opposite point of the farthest point into this sphere.
        if (this.center.equals(sphere.center) === true) $084574008ccedf86$var$_toFarthestPoint.set(0, 0, 1).multiplyScalar(sphere.radius);
        else $084574008ccedf86$var$_toFarthestPoint.subVectors(sphere.center, this.center).normalize().multiplyScalar(sphere.radius);
        this.expandByPoint($084574008ccedf86$var$_v1$6.copy(sphere.center).add($084574008ccedf86$var$_toFarthestPoint));
        this.expandByPoint($084574008ccedf86$var$_v1$6.copy(sphere.center).sub($084574008ccedf86$var$_toFarthestPoint));
        return this;
    }
    equals(sphere) {
        return sphere.center.equals(this.center) && sphere.radius === this.radius;
    }
    clone() {
        return new this.constructor().copy(this);
    }
}
const $084574008ccedf86$var$_vector$a = /*@__PURE__*/ new $084574008ccedf86$export$64b5c384219d3699();
const $084574008ccedf86$var$_segCenter = /*@__PURE__*/ new $084574008ccedf86$export$64b5c384219d3699();
const $084574008ccedf86$var$_segDir = /*@__PURE__*/ new $084574008ccedf86$export$64b5c384219d3699();
const $084574008ccedf86$var$_diff = /*@__PURE__*/ new $084574008ccedf86$export$64b5c384219d3699();
const $084574008ccedf86$var$_edge1 = /*@__PURE__*/ new $084574008ccedf86$export$64b5c384219d3699();
const $084574008ccedf86$var$_edge2 = /*@__PURE__*/ new $084574008ccedf86$export$64b5c384219d3699();
const $084574008ccedf86$var$_normal$1 = /*@__PURE__*/ new $084574008ccedf86$export$64b5c384219d3699();
class $084574008ccedf86$export$a186db52eed6d40e {
    constructor(origin = new $084574008ccedf86$export$64b5c384219d3699(), direction = new $084574008ccedf86$export$64b5c384219d3699(0, 0, -1)){
        this.origin = origin;
        this.direction = direction;
    }
    set(origin, direction) {
        this.origin.copy(origin);
        this.direction.copy(direction);
        return this;
    }
    copy(ray) {
        this.origin.copy(ray.origin);
        this.direction.copy(ray.direction);
        return this;
    }
    at(t, target) {
        return target.copy(this.direction).multiplyScalar(t).add(this.origin);
    }
    lookAt(v) {
        this.direction.copy(v).sub(this.origin).normalize();
        return this;
    }
    recast(t) {
        this.origin.copy(this.at(t, $084574008ccedf86$var$_vector$a));
        return this;
    }
    closestPointToPoint(point, target) {
        target.subVectors(point, this.origin);
        const directionDistance = target.dot(this.direction);
        if (directionDistance < 0) return target.copy(this.origin);
        return target.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
    }
    distanceToPoint(point) {
        return Math.sqrt(this.distanceSqToPoint(point));
    }
    distanceSqToPoint(point) {
        const directionDistance = $084574008ccedf86$var$_vector$a.subVectors(point, this.origin).dot(this.direction);
        // point behind the ray
        if (directionDistance < 0) return this.origin.distanceToSquared(point);
        $084574008ccedf86$var$_vector$a.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
        return $084574008ccedf86$var$_vector$a.distanceToSquared(point);
    }
    distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {
        // from https://github.com/pmjoniak/GeometricTools/blob/master/GTEngine/Include/Mathematics/GteDistRaySegment.h
        // It returns the min distance between the ray and the segment
        // defined by v0 and v1
        // It can also set two optional targets :
        // - The closest point on the ray
        // - The closest point on the segment
        $084574008ccedf86$var$_segCenter.copy(v0).add(v1).multiplyScalar(0.5);
        $084574008ccedf86$var$_segDir.copy(v1).sub(v0).normalize();
        $084574008ccedf86$var$_diff.copy(this.origin).sub($084574008ccedf86$var$_segCenter);
        const segExtent = v0.distanceTo(v1) * 0.5;
        const a01 = -this.direction.dot($084574008ccedf86$var$_segDir);
        const b0 = $084574008ccedf86$var$_diff.dot(this.direction);
        const b1 = -$084574008ccedf86$var$_diff.dot($084574008ccedf86$var$_segDir);
        const c = $084574008ccedf86$var$_diff.lengthSq();
        const det = Math.abs(1 - a01 * a01);
        let s0, s1, sqrDist, extDet;
        if (det > 0) {
            // The ray and segment are not parallel.
            s0 = a01 * b1 - b0;
            s1 = a01 * b0 - b1;
            extDet = segExtent * det;
            if (s0 >= 0) {
                if (s1 >= -extDet) {
                    if (s1 <= extDet) {
                        // region 0
                        // Minimum at interior points of ray and segment.
                        const invDet = 1 / det;
                        s0 *= invDet;
                        s1 *= invDet;
                        sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;
                    } else {
                        // region 1
                        s1 = segExtent;
                        s0 = Math.max(0, -(a01 * s1 + b0));
                        sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                    }
                } else {
                    // region 5
                    s1 = -segExtent;
                    s0 = Math.max(0, -(a01 * s1 + b0));
                    sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                }
            } else {
                if (s1 <= -extDet) {
                    // region 4
                    s0 = Math.max(0, -(-a01 * segExtent + b0));
                    s1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
                    sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                } else if (s1 <= extDet) {
                    // region 3
                    s0 = 0;
                    s1 = Math.min(Math.max(-segExtent, -b1), segExtent);
                    sqrDist = s1 * (s1 + 2 * b1) + c;
                } else {
                    // region 2
                    s0 = Math.max(0, -(a01 * segExtent + b0));
                    s1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
                    sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                }
            }
        } else {
            // Ray and segment are parallel.
            s1 = a01 > 0 ? -segExtent : segExtent;
            s0 = Math.max(0, -(a01 * s1 + b0));
            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
        }
        if (optionalPointOnRay) optionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin);
        if (optionalPointOnSegment) optionalPointOnSegment.copy($084574008ccedf86$var$_segDir).multiplyScalar(s1).add($084574008ccedf86$var$_segCenter);
        return sqrDist;
    }
    intersectSphere(sphere, target) {
        $084574008ccedf86$var$_vector$a.subVectors(sphere.center, this.origin);
        const tca = $084574008ccedf86$var$_vector$a.dot(this.direction);
        const d2 = $084574008ccedf86$var$_vector$a.dot($084574008ccedf86$var$_vector$a) - tca * tca;
        const radius2 = sphere.radius * sphere.radius;
        if (d2 > radius2) return null;
        const thc = Math.sqrt(radius2 - d2);
        // t0 = first intersect point - entrance on front of sphere
        const t0 = tca - thc;
        // t1 = second intersect point - exit point on back of sphere
        const t1 = tca + thc;
        // test to see if both t0 and t1 are behind the ray - if so, return null
        if (t0 < 0 && t1 < 0) return null;
        // test to see if t0 is behind the ray:
        // if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
        // in order to always return an intersect point that is in front of the ray.
        if (t0 < 0) return this.at(t1, target);
        // else t0 is in front of the ray, so return the first collision point scaled by t0
        return this.at(t0, target);
    }
    intersectsSphere(sphere) {
        return this.distanceSqToPoint(sphere.center) <= sphere.radius * sphere.radius;
    }
    distanceToPlane(plane) {
        const denominator = plane.normal.dot(this.direction);
        if (denominator === 0) {
            // line is coplanar, return origin
            if (plane.distanceToPoint(this.origin) === 0) return 0;
            // Null is preferable to undefined since undefined means.... it is undefined
            return null;
        }
        const t = -(this.origin.dot(plane.normal) + plane.constant) / denominator;
        // Return if the ray never intersects the plane
        return t >= 0 ? t : null;
    }
    intersectPlane(plane, target) {
        const t = this.distanceToPlane(plane);
        if (t === null) return null;
        return this.at(t, target);
    }
    intersectsPlane(plane) {
        // check if the ray lies on the plane first
        const distToPoint = plane.distanceToPoint(this.origin);
        if (distToPoint === 0) return true;
        const denominator = plane.normal.dot(this.direction);
        if (denominator * distToPoint < 0) return true;
        // ray origin is behind the plane (and is pointing behind it)
        return false;
    }
    intersectBox(box, target) {
        let tmin, tmax, tymin, tymax, tzmin, tzmax;
        const invdirx = 1 / this.direction.x, invdiry = 1 / this.direction.y, invdirz = 1 / this.direction.z;
        const origin = this.origin;
        if (invdirx >= 0) {
            tmin = (box.min.x - origin.x) * invdirx;
            tmax = (box.max.x - origin.x) * invdirx;
        } else {
            tmin = (box.max.x - origin.x) * invdirx;
            tmax = (box.min.x - origin.x) * invdirx;
        }
        if (invdiry >= 0) {
            tymin = (box.min.y - origin.y) * invdiry;
            tymax = (box.max.y - origin.y) * invdiry;
        } else {
            tymin = (box.max.y - origin.y) * invdiry;
            tymax = (box.min.y - origin.y) * invdiry;
        }
        if (tmin > tymax || tymin > tmax) return null;
        // These lines also handle the case where tmin or tmax is NaN
        // (result of 0 * Infinity). x !== x returns true if x is NaN
        if (tymin > tmin || tmin !== tmin) tmin = tymin;
        if (tymax < tmax || tmax !== tmax) tmax = tymax;
        if (invdirz >= 0) {
            tzmin = (box.min.z - origin.z) * invdirz;
            tzmax = (box.max.z - origin.z) * invdirz;
        } else {
            tzmin = (box.max.z - origin.z) * invdirz;
            tzmax = (box.min.z - origin.z) * invdirz;
        }
        if (tmin > tzmax || tzmin > tmax) return null;
        if (tzmin > tmin || tmin !== tmin) tmin = tzmin;
        if (tzmax < tmax || tmax !== tmax) tmax = tzmax;
        //return point closest to the ray (positive side)
        if (tmax < 0) return null;
        return this.at(tmin >= 0 ? tmin : tmax, target);
    }
    intersectsBox(box) {
        return this.intersectBox(box, $084574008ccedf86$var$_vector$a) !== null;
    }
    intersectTriangle(a, b, c, backfaceCulling, target) {
        // Compute the offset origin, edges, and normal.
        // from https://github.com/pmjoniak/GeometricTools/blob/master/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h
        $084574008ccedf86$var$_edge1.subVectors(b, a);
        $084574008ccedf86$var$_edge2.subVectors(c, a);
        $084574008ccedf86$var$_normal$1.crossVectors($084574008ccedf86$var$_edge1, $084574008ccedf86$var$_edge2);
        // Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
        // E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
        //   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
        //   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
        //   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
        let DdN = this.direction.dot($084574008ccedf86$var$_normal$1);
        let sign1;
        if (DdN > 0) {
            if (backfaceCulling) return null;
            sign1 = 1;
        } else if (DdN < 0) {
            sign1 = -1;
            DdN = -DdN;
        } else return null;
        $084574008ccedf86$var$_diff.subVectors(this.origin, a);
        const DdQxE2 = sign1 * this.direction.dot($084574008ccedf86$var$_edge2.crossVectors($084574008ccedf86$var$_diff, $084574008ccedf86$var$_edge2));
        // b1 < 0, no intersection
        if (DdQxE2 < 0) return null;
        const DdE1xQ = sign1 * this.direction.dot($084574008ccedf86$var$_edge1.cross($084574008ccedf86$var$_diff));
        // b2 < 0, no intersection
        if (DdE1xQ < 0) return null;
        // b1+b2 > 1, no intersection
        if (DdQxE2 + DdE1xQ > DdN) return null;
        // Line intersects triangle, check if ray does.
        const QdN = -sign1 * $084574008ccedf86$var$_diff.dot($084574008ccedf86$var$_normal$1);
        // t < 0, no intersection
        if (QdN < 0) return null;
        // Ray intersects triangle.
        return this.at(QdN / DdN, target);
    }
    applyMatrix4(matrix4) {
        this.origin.applyMatrix4(matrix4);
        this.direction.transformDirection(matrix4);
        return this;
    }
    equals(ray) {
        return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);
    }
    clone() {
        return new this.constructor().copy(this);
    }
}
class $084574008ccedf86$export$2ae72fc923e5eb5 {
    constructor(){
        this.isMatrix4 = true;
        this.elements = [
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1
        ];
        if (arguments.length > 0) console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.");
    }
    set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
        const te = this.elements;
        te[0] = n11;
        te[4] = n12;
        te[8] = n13;
        te[12] = n14;
        te[1] = n21;
        te[5] = n22;
        te[9] = n23;
        te[13] = n24;
        te[2] = n31;
        te[6] = n32;
        te[10] = n33;
        te[14] = n34;
        te[3] = n41;
        te[7] = n42;
        te[11] = n43;
        te[15] = n44;
        return this;
    }
    identity() {
        this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
        return this;
    }
    clone() {
        return new $084574008ccedf86$export$2ae72fc923e5eb5().fromArray(this.elements);
    }
    copy(m) {
        const te = this.elements;
        const me = m.elements;
        te[0] = me[0];
        te[1] = me[1];
        te[2] = me[2];
        te[3] = me[3];
        te[4] = me[4];
        te[5] = me[5];
        te[6] = me[6];
        te[7] = me[7];
        te[8] = me[8];
        te[9] = me[9];
        te[10] = me[10];
        te[11] = me[11];
        te[12] = me[12];
        te[13] = me[13];
        te[14] = me[14];
        te[15] = me[15];
        return this;
    }
    copyPosition(m) {
        const te = this.elements, me = m.elements;
        te[12] = me[12];
        te[13] = me[13];
        te[14] = me[14];
        return this;
    }
    setFromMatrix3(m) {
        const me = m.elements;
        this.set(me[0], me[3], me[6], 0, me[1], me[4], me[7], 0, me[2], me[5], me[8], 0, 0, 0, 0, 1);
        return this;
    }
    extractBasis(xAxis, yAxis, zAxis) {
        xAxis.setFromMatrixColumn(this, 0);
        yAxis.setFromMatrixColumn(this, 1);
        zAxis.setFromMatrixColumn(this, 2);
        return this;
    }
    makeBasis(xAxis, yAxis, zAxis) {
        this.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1);
        return this;
    }
    extractRotation(m) {
        // this method does not support reflection matrices
        const te = this.elements;
        const me = m.elements;
        const scaleX = 1 / $084574008ccedf86$var$_v1$5.setFromMatrixColumn(m, 0).length();
        const scaleY = 1 / $084574008ccedf86$var$_v1$5.setFromMatrixColumn(m, 1).length();
        const scaleZ = 1 / $084574008ccedf86$var$_v1$5.setFromMatrixColumn(m, 2).length();
        te[0] = me[0] * scaleX;
        te[1] = me[1] * scaleX;
        te[2] = me[2] * scaleX;
        te[3] = 0;
        te[4] = me[4] * scaleY;
        te[5] = me[5] * scaleY;
        te[6] = me[6] * scaleY;
        te[7] = 0;
        te[8] = me[8] * scaleZ;
        te[9] = me[9] * scaleZ;
        te[10] = me[10] * scaleZ;
        te[11] = 0;
        te[12] = 0;
        te[13] = 0;
        te[14] = 0;
        te[15] = 1;
        return this;
    }
    makeRotationFromEuler(euler) {
        if (!(euler && euler.isEuler)) console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
        const te = this.elements;
        const x = euler.x, y = euler.y, z = euler.z;
        const a = Math.cos(x), b = Math.sin(x);
        const c = Math.cos(y), d = Math.sin(y);
        const e = Math.cos(z), f = Math.sin(z);
        if (euler.order === "XYZ") {
            const ae = a * e, af = a * f, be = b * e, bf = b * f;
            te[0] = c * e;
            te[4] = -c * f;
            te[8] = d;
            te[1] = af + be * d;
            te[5] = ae - bf * d;
            te[9] = -b * c;
            te[2] = bf - ae * d;
            te[6] = be + af * d;
            te[10] = a * c;
        } else if (euler.order === "YXZ") {
            const ce = c * e, cf = c * f, de = d * e, df = d * f;
            te[0] = ce + df * b;
            te[4] = de * b - cf;
            te[8] = a * d;
            te[1] = a * f;
            te[5] = a * e;
            te[9] = -b;
            te[2] = cf * b - de;
            te[6] = df + ce * b;
            te[10] = a * c;
        } else if (euler.order === "ZXY") {
            const ce = c * e, cf = c * f, de = d * e, df = d * f;
            te[0] = ce - df * b;
            te[4] = -a * f;
            te[8] = de + cf * b;
            te[1] = cf + de * b;
            te[5] = a * e;
            te[9] = df - ce * b;
            te[2] = -a * d;
            te[6] = b;
            te[10] = a * c;
        } else if (euler.order === "ZYX") {
            const ae = a * e, af = a * f, be = b * e, bf = b * f;
            te[0] = c * e;
            te[4] = be * d - af;
            te[8] = ae * d + bf;
            te[1] = c * f;
            te[5] = bf * d + ae;
            te[9] = af * d - be;
            te[2] = -d;
            te[6] = b * c;
            te[10] = a * c;
        } else if (euler.order === "YZX") {
            const ac = a * c, ad = a * d, bc = b * c, bd = b * d;
            te[0] = c * e;
            te[4] = bd - ac * f;
            te[8] = bc * f + ad;
            te[1] = f;
            te[5] = a * e;
            te[9] = -b * e;
            te[2] = -d * e;
            te[6] = ad * f + bc;
            te[10] = ac - bd * f;
        } else if (euler.order === "XZY") {
            const ac = a * c, ad = a * d, bc = b * c, bd = b * d;
            te[0] = c * e;
            te[4] = -f;
            te[8] = d * e;
            te[1] = ac * f + bd;
            te[5] = a * e;
            te[9] = ad * f - bc;
            te[2] = bc * f - ad;
            te[6] = b * e;
            te[10] = bd * f + ac;
        }
        // bottom row
        te[3] = 0;
        te[7] = 0;
        te[11] = 0;
        // last column
        te[12] = 0;
        te[13] = 0;
        te[14] = 0;
        te[15] = 1;
        return this;
    }
    makeRotationFromQuaternion(q) {
        return this.compose($084574008ccedf86$var$_zero, q, $084574008ccedf86$var$_one);
    }
    lookAt(eye, target, up) {
        const te = this.elements;
        $084574008ccedf86$var$_z.subVectors(eye, target);
        if ($084574008ccedf86$var$_z.lengthSq() === 0) // eye and target are in the same position
        $084574008ccedf86$var$_z.z = 1;
        $084574008ccedf86$var$_z.normalize();
        $084574008ccedf86$var$_x.crossVectors(up, $084574008ccedf86$var$_z);
        if ($084574008ccedf86$var$_x.lengthSq() === 0) {
            // up and z are parallel
            if (Math.abs(up.z) === 1) $084574008ccedf86$var$_z.x += 0.0001;
            else $084574008ccedf86$var$_z.z += 0.0001;
            $084574008ccedf86$var$_z.normalize();
            $084574008ccedf86$var$_x.crossVectors(up, $084574008ccedf86$var$_z);
        }
        $084574008ccedf86$var$_x.normalize();
        $084574008ccedf86$var$_y.crossVectors($084574008ccedf86$var$_z, $084574008ccedf86$var$_x);
        te[0] = $084574008ccedf86$var$_x.x;
        te[4] = $084574008ccedf86$var$_y.x;
        te[8] = $084574008ccedf86$var$_z.x;
        te[1] = $084574008ccedf86$var$_x.y;
        te[5] = $084574008ccedf86$var$_y.y;
        te[9] = $084574008ccedf86$var$_z.y;
        te[2] = $084574008ccedf86$var$_x.z;
        te[6] = $084574008ccedf86$var$_y.z;
        te[10] = $084574008ccedf86$var$_z.z;
        return this;
    }
    multiply(m, n) {
        if (n !== undefined) {
            console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.");
            return this.multiplyMatrices(m, n);
        }
        return this.multiplyMatrices(this, m);
    }
    premultiply(m) {
        return this.multiplyMatrices(m, this);
    }
    multiplyMatrices(a, b) {
        const ae = a.elements;
        const be = b.elements;
        const te = this.elements;
        const a11 = ae[0], a12 = ae[4], a13 = ae[8], a14 = ae[12];
        const a21 = ae[1], a22 = ae[5], a23 = ae[9], a24 = ae[13];
        const a31 = ae[2], a32 = ae[6], a33 = ae[10], a34 = ae[14];
        const a41 = ae[3], a42 = ae[7], a43 = ae[11], a44 = ae[15];
        const b11 = be[0], b12 = be[4], b13 = be[8], b14 = be[12];
        const b21 = be[1], b22 = be[5], b23 = be[9], b24 = be[13];
        const b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14];
        const b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15];
        te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
        te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
        te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
        te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
        te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
        te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
        te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
        te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
        te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
        te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
        te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
        te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
        te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
        te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
        te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
        te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
        return this;
    }
    multiplyScalar(s) {
        const te = this.elements;
        te[0] *= s;
        te[4] *= s;
        te[8] *= s;
        te[12] *= s;
        te[1] *= s;
        te[5] *= s;
        te[9] *= s;
        te[13] *= s;
        te[2] *= s;
        te[6] *= s;
        te[10] *= s;
        te[14] *= s;
        te[3] *= s;
        te[7] *= s;
        te[11] *= s;
        te[15] *= s;
        return this;
    }
    determinant() {
        const te = this.elements;
        const n11 = te[0], n12 = te[4], n13 = te[8], n14 = te[12];
        const n21 = te[1], n22 = te[5], n23 = te[9], n24 = te[13];
        const n31 = te[2], n32 = te[6], n33 = te[10], n34 = te[14];
        const n41 = te[3], n42 = te[7], n43 = te[11], n44 = te[15];
        //TODO: make this more efficient
        //( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )
        return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);
    }
    transpose() {
        const te = this.elements;
        let tmp2;
        tmp2 = te[1];
        te[1] = te[4];
        te[4] = tmp2;
        tmp2 = te[2];
        te[2] = te[8];
        te[8] = tmp2;
        tmp2 = te[6];
        te[6] = te[9];
        te[9] = tmp2;
        tmp2 = te[3];
        te[3] = te[12];
        te[12] = tmp2;
        tmp2 = te[7];
        te[7] = te[13];
        te[13] = tmp2;
        tmp2 = te[11];
        te[11] = te[14];
        te[14] = tmp2;
        return this;
    }
    setPosition(x, y, z) {
        const te = this.elements;
        if (x.isVector3) {
            te[12] = x.x;
            te[13] = x.y;
            te[14] = x.z;
        } else {
            te[12] = x;
            te[13] = y;
            te[14] = z;
        }
        return this;
    }
    invert() {
        // based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
        const te = this.elements, n11 = te[0], n21 = te[1], n31 = te[2], n41 = te[3], n12 = te[4], n22 = te[5], n32 = te[6], n42 = te[7], n13 = te[8], n23 = te[9], n33 = te[10], n43 = te[11], n14 = te[12], n24 = te[13], n34 = te[14], n44 = te[15], t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44, t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44, t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44, t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
        const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
        if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        const detInv = 1 / det;
        te[0] = t11 * detInv;
        te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
        te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
        te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
        te[4] = t12 * detInv;
        te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
        te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
        te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
        te[8] = t13 * detInv;
        te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
        te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
        te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
        te[12] = t14 * detInv;
        te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
        te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
        te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
        return this;
    }
    scale(v) {
        const te = this.elements;
        const x = v.x, y = v.y, z = v.z;
        te[0] *= x;
        te[4] *= y;
        te[8] *= z;
        te[1] *= x;
        te[5] *= y;
        te[9] *= z;
        te[2] *= x;
        te[6] *= y;
        te[10] *= z;
        te[3] *= x;
        te[7] *= y;
        te[11] *= z;
        return this;
    }
    getMaxScaleOnAxis() {
        const te = this.elements;
        const scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
        const scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
        const scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
        return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
    }
    makeTranslation(x, y, z) {
        this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1);
        return this;
    }
    makeRotationX(theta) {
        const c = Math.cos(theta), s = Math.sin(theta);
        this.set(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1);
        return this;
    }
    makeRotationY(theta) {
        const c = Math.cos(theta), s = Math.sin(theta);
        this.set(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1);
        return this;
    }
    makeRotationZ(theta) {
        const c = Math.cos(theta), s = Math.sin(theta);
        this.set(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
        return this;
    }
    makeRotationAxis(axis, angle) {
        // Based on http://www.gamedev.net/reference/articles/article1199.asp
        const c = Math.cos(angle);
        const s = Math.sin(angle);
        const t = 1 - c;
        const x = axis.x, y = axis.y, z = axis.z;
        const tx = t * x, ty = t * y;
        this.set(tx * x + c, tx * y - s * z, tx * z + s * y, 0, tx * y + s * z, ty * y + c, ty * z - s * x, 0, tx * z - s * y, ty * z + s * x, t * z * z + c, 0, 0, 0, 0, 1);
        return this;
    }
    makeScale(x, y, z) {
        this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1);
        return this;
    }
    makeShear(xy, xz, yx, yz, zx, zy) {
        this.set(1, yx, zx, 0, xy, 1, zy, 0, xz, yz, 1, 0, 0, 0, 0, 1);
        return this;
    }
    compose(position, quaternion, scale) {
        const te = this.elements;
        const x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;
        const x2 = x + x, y2 = y + y, z2 = z + z;
        const xx = x * x2, xy = x * y2, xz = x * z2;
        const yy = y * y2, yz = y * z2, zz = z * z2;
        const wx = w * x2, wy = w * y2, wz = w * z2;
        const sx = scale.x, sy = scale.y, sz = scale.z;
        te[0] = (1 - (yy + zz)) * sx;
        te[1] = (xy + wz) * sx;
        te[2] = (xz - wy) * sx;
        te[3] = 0;
        te[4] = (xy - wz) * sy;
        te[5] = (1 - (xx + zz)) * sy;
        te[6] = (yz + wx) * sy;
        te[7] = 0;
        te[8] = (xz + wy) * sz;
        te[9] = (yz - wx) * sz;
        te[10] = (1 - (xx + yy)) * sz;
        te[11] = 0;
        te[12] = position.x;
        te[13] = position.y;
        te[14] = position.z;
        te[15] = 1;
        return this;
    }
    decompose(position, quaternion, scale) {
        const te = this.elements;
        let sx = $084574008ccedf86$var$_v1$5.set(te[0], te[1], te[2]).length();
        const sy = $084574008ccedf86$var$_v1$5.set(te[4], te[5], te[6]).length();
        const sz = $084574008ccedf86$var$_v1$5.set(te[8], te[9], te[10]).length();
        // if determine is negative, we need to invert one scale
        const det = this.determinant();
        if (det < 0) sx = -sx;
        position.x = te[12];
        position.y = te[13];
        position.z = te[14];
        // scale the rotation part
        $084574008ccedf86$var$_m1$2.copy(this);
        const invSX = 1 / sx;
        const invSY = 1 / sy;
        const invSZ = 1 / sz;
        $084574008ccedf86$var$_m1$2.elements[0] *= invSX;
        $084574008ccedf86$var$_m1$2.elements[1] *= invSX;
        $084574008ccedf86$var$_m1$2.elements[2] *= invSX;
        $084574008ccedf86$var$_m1$2.elements[4] *= invSY;
        $084574008ccedf86$var$_m1$2.elements[5] *= invSY;
        $084574008ccedf86$var$_m1$2.elements[6] *= invSY;
        $084574008ccedf86$var$_m1$2.elements[8] *= invSZ;
        $084574008ccedf86$var$_m1$2.elements[9] *= invSZ;
        $084574008ccedf86$var$_m1$2.elements[10] *= invSZ;
        quaternion.setFromRotationMatrix($084574008ccedf86$var$_m1$2);
        scale.x = sx;
        scale.y = sy;
        scale.z = sz;
        return this;
    }
    makePerspective(left, right, top, bottom, near, far) {
        if (far === undefined) console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
        const te = this.elements;
        const x = 2 * near / (right - left);
        const y = 2 * near / (top - bottom);
        const a = (right + left) / (right - left);
        const b = (top + bottom) / (top - bottom);
        const c = -(far + near) / (far - near);
        const d = -2 * far * near / (far - near);
        te[0] = x;
        te[4] = 0;
        te[8] = a;
        te[12] = 0;
        te[1] = 0;
        te[5] = y;
        te[9] = b;
        te[13] = 0;
        te[2] = 0;
        te[6] = 0;
        te[10] = c;
        te[14] = d;
        te[3] = 0;
        te[7] = 0;
        te[11] = -1;
        te[15] = 0;
        return this;
    }
    makeOrthographic(left, right, top, bottom, near, far) {
        const te = this.elements;
        const w = 1.0 / (right - left);
        const h = 1.0 / (top - bottom);
        const p = 1.0 / (far - near);
        const x = (right + left) * w;
        const y = (top + bottom) * h;
        const z = (far + near) * p;
        te[0] = 2 * w;
        te[4] = 0;
        te[8] = 0;
        te[12] = -x;
        te[1] = 0;
        te[5] = 2 * h;
        te[9] = 0;
        te[13] = -y;
        te[2] = 0;
        te[6] = 0;
        te[10] = -2 * p;
        te[14] = -z;
        te[3] = 0;
        te[7] = 0;
        te[11] = 0;
        te[15] = 1;
        return this;
    }
    equals(matrix) {
        const te = this.elements;
        const me = matrix.elements;
        for(let i25 = 0; i25 < 16; i25++){
            if (te[i25] !== me[i25]) return false;
        }
        return true;
    }
    fromArray(array, offset = 0) {
        for(let i26 = 0; i26 < 16; i26++)this.elements[i26] = array[i26 + offset];
        return this;
    }
    toArray(array = [], offset = 0) {
        const te = this.elements;
        array[offset] = te[0];
        array[offset + 1] = te[1];
        array[offset + 2] = te[2];
        array[offset + 3] = te[3];
        array[offset + 4] = te[4];
        array[offset + 5] = te[5];
        array[offset + 6] = te[6];
        array[offset + 7] = te[7];
        array[offset + 8] = te[8];
        array[offset + 9] = te[9];
        array[offset + 10] = te[10];
        array[offset + 11] = te[11];
        array[offset + 12] = te[12];
        array[offset + 13] = te[13];
        array[offset + 14] = te[14];
        array[offset + 15] = te[15];
        return array;
    }
}
const $084574008ccedf86$var$_v1$5 = /*@__PURE__*/ new $084574008ccedf86$export$64b5c384219d3699();
const $084574008ccedf86$var$_m1$2 = /*@__PURE__*/ new $084574008ccedf86$export$2ae72fc923e5eb5();
const $084574008ccedf86$var$_zero = /*@__PURE__*/ new $084574008ccedf86$export$64b5c384219d3699(0, 0, 0);
const $084574008ccedf86$var$_one = /*@__PURE__*/ new $084574008ccedf86$export$64b5c384219d3699(1, 1, 1);
const $084574008ccedf86$var$_x = /*@__PURE__*/ new $084574008ccedf86$export$64b5c384219d3699();
const $084574008ccedf86$var$_y = /*@__PURE__*/ new $084574008ccedf86$export$64b5c384219d3699();
const $084574008ccedf86$var$_z = /*@__PURE__*/ new $084574008ccedf86$export$64b5c384219d3699();
const $084574008ccedf86$var$_matrix$1 = /*@__PURE__*/ new $084574008ccedf86$export$2ae72fc923e5eb5();
const $084574008ccedf86$var$_quaternion$3 = /*@__PURE__*/ new $084574008ccedf86$export$23d6a54f0bbc85a3();
class $084574008ccedf86$export$d93cc409a0768c5f {
    constructor(x = 0, y = 0, z = 0, order = $084574008ccedf86$export$d93cc409a0768c5f.DefaultOrder){
        this.isEuler = true;
        this._x = x;
        this._y = y;
        this._z = z;
        this._order = order;
    }
    get x() {
        return this._x;
    }
    set x(value) {
        this._x = value;
        this._onChangeCallback();
    }
    get y() {
        return this._y;
    }
    set y(value) {
        this._y = value;
        this._onChangeCallback();
    }
    get z() {
        return this._z;
    }
    set z(value) {
        this._z = value;
        this._onChangeCallback();
    }
    get order() {
        return this._order;
    }
    set order(value) {
        this._order = value;
        this._onChangeCallback();
    }
    set(x, y, z, order = this._order) {
        this._x = x;
        this._y = y;
        this._z = z;
        this._order = order;
        this._onChangeCallback();
        return this;
    }
    clone() {
        return new this.constructor(this._x, this._y, this._z, this._order);
    }
    copy(euler) {
        this._x = euler._x;
        this._y = euler._y;
        this._z = euler._z;
        this._order = euler._order;
        this._onChangeCallback();
        return this;
    }
    setFromRotationMatrix(m, order = this._order, update = true) {
        // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
        const te = m.elements;
        const m11 = te[0], m12 = te[4], m13 = te[8];
        const m21 = te[1], m22 = te[5], m23 = te[9];
        const m31 = te[2], m32 = te[6], m33 = te[10];
        switch(order){
            case "XYZ":
                this._y = Math.asin($084574008ccedf86$var$clamp(m13, -1, 1));
                if (Math.abs(m13) < 0.9999999) {
                    this._x = Math.atan2(-m23, m33);
                    this._z = Math.atan2(-m12, m11);
                } else {
                    this._x = Math.atan2(m32, m22);
                    this._z = 0;
                }
                break;
            case "YXZ":
                this._x = Math.asin(-$084574008ccedf86$var$clamp(m23, -1, 1));
                if (Math.abs(m23) < 0.9999999) {
                    this._y = Math.atan2(m13, m33);
                    this._z = Math.atan2(m21, m22);
                } else {
                    this._y = Math.atan2(-m31, m11);
                    this._z = 0;
                }
                break;
            case "ZXY":
                this._x = Math.asin($084574008ccedf86$var$clamp(m32, -1, 1));
                if (Math.abs(m32) < 0.9999999) {
                    this._y = Math.atan2(-m31, m33);
                    this._z = Math.atan2(-m12, m22);
                } else {
                    this._y = 0;
                    this._z = Math.atan2(m21, m11);
                }
                break;
            case "ZYX":
                this._y = Math.asin(-$084574008ccedf86$var$clamp(m31, -1, 1));
                if (Math.abs(m31) < 0.9999999) {
                    this._x = Math.atan2(m32, m33);
                    this._z = Math.atan2(m21, m11);
                } else {
                    this._x = 0;
                    this._z = Math.atan2(-m12, m22);
                }
                break;
            case "YZX":
                this._z = Math.asin($084574008ccedf86$var$clamp(m21, -1, 1));
                if (Math.abs(m21) < 0.9999999) {
                    this._x = Math.atan2(-m23, m22);
                    this._y = Math.atan2(-m31, m11);
                } else {
                    this._x = 0;
                    this._y = Math.atan2(m13, m33);
                }
                break;
            case "XZY":
                this._z = Math.asin(-$084574008ccedf86$var$clamp(m12, -1, 1));
                if (Math.abs(m12) < 0.9999999) {
                    this._x = Math.atan2(m32, m22);
                    this._y = Math.atan2(m13, m11);
                } else {
                    this._x = Math.atan2(-m23, m33);
                    this._y = 0;
                }
                break;
            default:
                console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + order);
        }
        this._order = order;
        if (update === true) this._onChangeCallback();
        return this;
    }
    setFromQuaternion(q, order, update) {
        $084574008ccedf86$var$_matrix$1.makeRotationFromQuaternion(q);
        return this.setFromRotationMatrix($084574008ccedf86$var$_matrix$1, order, update);
    }
    setFromVector3(v, order = this._order) {
        return this.set(v.x, v.y, v.z, order);
    }
    reorder(newOrder) {
        // WARNING: this discards revolution information -bhouston
        $084574008ccedf86$var$_quaternion$3.setFromEuler(this);
        return this.setFromQuaternion($084574008ccedf86$var$_quaternion$3, newOrder);
    }
    equals(euler) {
        return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;
    }
    fromArray(array) {
        this._x = array[0];
        this._y = array[1];
        this._z = array[2];
        if (array[3] !== undefined) this._order = array[3];
        this._onChangeCallback();
        return this;
    }
    toArray(array = [], offset = 0) {
        array[offset] = this._x;
        array[offset + 1] = this._y;
        array[offset + 2] = this._z;
        array[offset + 3] = this._order;
        return array;
    }
    _onChange(callback) {
        this._onChangeCallback = callback;
        return this;
    }
    _onChangeCallback() {}
    *[Symbol.iterator]() {
        yield this._x;
        yield this._y;
        yield this._z;
        yield this._order;
    }
    // @deprecated since r138, 02cf0df1cb4575d5842fef9c85bb5a89fe020d53
    toVector3() {
        console.error("THREE.Euler: .toVector3() has been removed. Use Vector3.setFromEuler() instead");
    }
}
$084574008ccedf86$export$d93cc409a0768c5f.DefaultOrder = "XYZ";
$084574008ccedf86$export$d93cc409a0768c5f.RotationOrders = [
    "XYZ",
    "YZX",
    "ZXY",
    "XZY",
    "YXZ",
    "ZYX"
];
class $084574008ccedf86$export$89312ce47c0ca777 {
    constructor(){
        this.mask = 1;
    }
    set(channel) {
        this.mask = (1 << channel | 0) >>> 0;
    }
    enable(channel) {
        this.mask |= 1 << channel | 0;
    }
    enableAll() {
        this.mask = -1;
    }
    toggle(channel) {
        this.mask ^= 1 << channel | 0;
    }
    disable(channel) {
        this.mask &= ~(1 << channel | 0);
    }
    disableAll() {
        this.mask = 0;
    }
    test(layers) {
        return (this.mask & layers.mask) !== 0;
    }
    isEnabled(channel) {
        return (this.mask & (1 << channel | 0)) !== 0;
    }
}
let $084574008ccedf86$var$_object3DId = 0;
const $084574008ccedf86$var$_v1$4 = /*@__PURE__*/ new $084574008ccedf86$export$64b5c384219d3699();
const $084574008ccedf86$var$_q1 = /*@__PURE__*/ new $084574008ccedf86$export$23d6a54f0bbc85a3();
const $084574008ccedf86$var$_m1$1 = /*@__PURE__*/ new $084574008ccedf86$export$2ae72fc923e5eb5();
const $084574008ccedf86$var$_target = /*@__PURE__*/ new $084574008ccedf86$export$64b5c384219d3699();
const $084574008ccedf86$var$_position$3 = /*@__PURE__*/ new $084574008ccedf86$export$64b5c384219d3699();
const $084574008ccedf86$var$_scale$2 = /*@__PURE__*/ new $084574008ccedf86$export$64b5c384219d3699();
const $084574008ccedf86$var$_quaternion$2 = /*@__PURE__*/ new $084574008ccedf86$export$23d6a54f0bbc85a3();
const $084574008ccedf86$var$_xAxis = /*@__PURE__*/ new $084574008ccedf86$export$64b5c384219d3699(1, 0, 0);
const $084574008ccedf86$var$_yAxis = /*@__PURE__*/ new $084574008ccedf86$export$64b5c384219d3699(0, 1, 0);
const $084574008ccedf86$var$_zAxis = /*@__PURE__*/ new $084574008ccedf86$export$64b5c384219d3699(0, 0, 1);
const $084574008ccedf86$var$_addedEvent = {
    type: "added"
};
const $084574008ccedf86$var$_removedEvent = {
    type: "removed"
};
class $084574008ccedf86$export$e4dd07dff30cc924 extends $084574008ccedf86$export$ec8b666c5fe2c75a {
    constructor(){
        super();
        this.isObject3D = true;
        Object.defineProperty(this, "id", {
            value: $084574008ccedf86$var$_object3DId++
        });
        this.uuid = $084574008ccedf86$var$generateUUID();
        this.name = "";
        this.type = "Object3D";
        this.parent = null;
        this.children = [];
        this.up = $084574008ccedf86$export$e4dd07dff30cc924.DefaultUp.clone();
        const position = new $084574008ccedf86$export$64b5c384219d3699();
        const rotation = new $084574008ccedf86$export$d93cc409a0768c5f();
        const quaternion = new $084574008ccedf86$export$23d6a54f0bbc85a3();
        const scale = new $084574008ccedf86$export$64b5c384219d3699(1, 1, 1);
        function onRotationChange() {
            quaternion.setFromEuler(rotation, false);
        }
        function onQuaternionChange() {
            rotation.setFromQuaternion(quaternion, undefined, false);
        }
        rotation._onChange(onRotationChange);
        quaternion._onChange(onQuaternionChange);
        Object.defineProperties(this, {
            position: {
                configurable: true,
                enumerable: true,
                value: position
            },
            rotation: {
                configurable: true,
                enumerable: true,
                value: rotation
            },
            quaternion: {
                configurable: true,
                enumerable: true,
                value: quaternion
            },
            scale: {
                configurable: true,
                enumerable: true,
                value: scale
            },
            modelViewMatrix: {
                value: new $084574008ccedf86$export$2ae72fc923e5eb5()
            },
            normalMatrix: {
                value: new $084574008ccedf86$export$8ff26dafa08918()
            }
        });
        this.matrix = new $084574008ccedf86$export$2ae72fc923e5eb5();
        this.matrixWorld = new $084574008ccedf86$export$2ae72fc923e5eb5();
        this.matrixAutoUpdate = $084574008ccedf86$export$e4dd07dff30cc924.DefaultMatrixAutoUpdate;
        this.matrixWorldNeedsUpdate = false;
        this.layers = new $084574008ccedf86$export$89312ce47c0ca777();
        this.visible = true;
        this.castShadow = false;
        this.receiveShadow = false;
        this.frustumCulled = true;
        this.renderOrder = 0;
        this.animations = [];
        this.userData = {};
    }
    onBeforeRender() {}
    onAfterRender() {}
    applyMatrix4(matrix) {
        if (this.matrixAutoUpdate) this.updateMatrix();
        this.matrix.premultiply(matrix);
        this.matrix.decompose(this.position, this.quaternion, this.scale);
    }
    applyQuaternion(q) {
        this.quaternion.premultiply(q);
        return this;
    }
    setRotationFromAxisAngle(axis, angle) {
        // assumes axis is normalized
        this.quaternion.setFromAxisAngle(axis, angle);
    }
    setRotationFromEuler(euler) {
        this.quaternion.setFromEuler(euler, true);
    }
    setRotationFromMatrix(m) {
        // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
        this.quaternion.setFromRotationMatrix(m);
    }
    setRotationFromQuaternion(q) {
        // assumes q is normalized
        this.quaternion.copy(q);
    }
    rotateOnAxis(axis, angle) {
        // rotate object on axis in object space
        // axis is assumed to be normalized
        $084574008ccedf86$var$_q1.setFromAxisAngle(axis, angle);
        this.quaternion.multiply($084574008ccedf86$var$_q1);
        return this;
    }
    rotateOnWorldAxis(axis, angle) {
        // rotate object on axis in world space
        // axis is assumed to be normalized
        // method assumes no rotated parent
        $084574008ccedf86$var$_q1.setFromAxisAngle(axis, angle);
        this.quaternion.premultiply($084574008ccedf86$var$_q1);
        return this;
    }
    rotateX(angle) {
        return this.rotateOnAxis($084574008ccedf86$var$_xAxis, angle);
    }
    rotateY(angle) {
        return this.rotateOnAxis($084574008ccedf86$var$_yAxis, angle);
    }
    rotateZ(angle) {
        return this.rotateOnAxis($084574008ccedf86$var$_zAxis, angle);
    }
    translateOnAxis(axis, distance) {
        // translate object by distance along axis in object space
        // axis is assumed to be normalized
        $084574008ccedf86$var$_v1$4.copy(axis).applyQuaternion(this.quaternion);
        this.position.add($084574008ccedf86$var$_v1$4.multiplyScalar(distance));
        return this;
    }
    translateX(distance) {
        return this.translateOnAxis($084574008ccedf86$var$_xAxis, distance);
    }
    translateY(distance) {
        return this.translateOnAxis($084574008ccedf86$var$_yAxis, distance);
    }
    translateZ(distance) {
        return this.translateOnAxis($084574008ccedf86$var$_zAxis, distance);
    }
    localToWorld(vector) {
        return vector.applyMatrix4(this.matrixWorld);
    }
    worldToLocal(vector) {
        return vector.applyMatrix4($084574008ccedf86$var$_m1$1.copy(this.matrixWorld).invert());
    }
    lookAt(x, y, z) {
        // This method does not support objects having non-uniformly-scaled parent(s)
        if (x.isVector3) $084574008ccedf86$var$_target.copy(x);
        else $084574008ccedf86$var$_target.set(x, y, z);
        const parent = this.parent;
        this.updateWorldMatrix(true, false);
        $084574008ccedf86$var$_position$3.setFromMatrixPosition(this.matrixWorld);
        if (this.isCamera || this.isLight) $084574008ccedf86$var$_m1$1.lookAt($084574008ccedf86$var$_position$3, $084574008ccedf86$var$_target, this.up);
        else $084574008ccedf86$var$_m1$1.lookAt($084574008ccedf86$var$_target, $084574008ccedf86$var$_position$3, this.up);
        this.quaternion.setFromRotationMatrix($084574008ccedf86$var$_m1$1);
        if (parent) {
            $084574008ccedf86$var$_m1$1.extractRotation(parent.matrixWorld);
            $084574008ccedf86$var$_q1.setFromRotationMatrix($084574008ccedf86$var$_m1$1);
            this.quaternion.premultiply($084574008ccedf86$var$_q1.invert());
        }
    }
    add(object) {
        if (arguments.length > 1) {
            for(let i27 = 0; i27 < arguments.length; i27++)this.add(arguments[i27]);
            return this;
        }
        if (object === this) {
            console.error("THREE.Object3D.add: object can't be added as a child of itself.", object);
            return this;
        }
        if (object && object.isObject3D) {
            if (object.parent !== null) object.parent.remove(object);
            object.parent = this;
            this.children.push(object);
            object.dispatchEvent($084574008ccedf86$var$_addedEvent);
        } else console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", object);
        return this;
    }
    remove(object) {
        if (arguments.length > 1) {
            for(let i28 = 0; i28 < arguments.length; i28++)this.remove(arguments[i28]);
            return this;
        }
        const index = this.children.indexOf(object);
        if (index !== -1) {
            object.parent = null;
            this.children.splice(index, 1);
            object.dispatchEvent($084574008ccedf86$var$_removedEvent);
        }
        return this;
    }
    removeFromParent() {
        const parent = this.parent;
        if (parent !== null) parent.remove(this);
        return this;
    }
    clear() {
        for(let i29 = 0; i29 < this.children.length; i29++){
            const object = this.children[i29];
            object.parent = null;
            object.dispatchEvent($084574008ccedf86$var$_removedEvent);
        }
        this.children.length = 0;
        return this;
    }
    attach(object) {
        // adds object as a child of this, while maintaining the object's world transform
        // Note: This method does not support scene graphs having non-uniformly-scaled nodes(s)
        this.updateWorldMatrix(true, false);
        $084574008ccedf86$var$_m1$1.copy(this.matrixWorld).invert();
        if (object.parent !== null) {
            object.parent.updateWorldMatrix(true, false);
            $084574008ccedf86$var$_m1$1.multiply(object.parent.matrixWorld);
        }
        object.applyMatrix4($084574008ccedf86$var$_m1$1);
        this.add(object);
        object.updateWorldMatrix(false, true);
        return this;
    }
    getObjectById(id) {
        return this.getObjectByProperty("id", id);
    }
    getObjectByName(name) {
        return this.getObjectByProperty("name", name);
    }
    getObjectByProperty(name, value) {
        if (this[name] === value) return this;
        for(let i30 = 0, l = this.children.length; i30 < l; i30++){
            const child = this.children[i30];
            const object = child.getObjectByProperty(name, value);
            if (object !== undefined) return object;
        }
        return undefined;
    }
    getWorldPosition(target) {
        this.updateWorldMatrix(true, false);
        return target.setFromMatrixPosition(this.matrixWorld);
    }
    getWorldQuaternion(target) {
        this.updateWorldMatrix(true, false);
        this.matrixWorld.decompose($084574008ccedf86$var$_position$3, target, $084574008ccedf86$var$_scale$2);
        return target;
    }
    getWorldScale(target) {
        this.updateWorldMatrix(true, false);
        this.matrixWorld.decompose($084574008ccedf86$var$_position$3, $084574008ccedf86$var$_quaternion$2, target);
        return target;
    }
    getWorldDirection(target) {
        this.updateWorldMatrix(true, false);
        const e = this.matrixWorld.elements;
        return target.set(e[8], e[9], e[10]).normalize();
    }
    raycast() {}
    traverse(callback) {
        callback(this);
        const children = this.children;
        for(let i31 = 0, l = children.length; i31 < l; i31++)children[i31].traverse(callback);
    }
    traverseVisible(callback) {
        if (this.visible === false) return;
        callback(this);
        const children = this.children;
        for(let i32 = 0, l = children.length; i32 < l; i32++)children[i32].traverseVisible(callback);
    }
    traverseAncestors(callback) {
        const parent = this.parent;
        if (parent !== null) {
            callback(parent);
            parent.traverseAncestors(callback);
        }
    }
    updateMatrix() {
        this.matrix.compose(this.position, this.quaternion, this.scale);
        this.matrixWorldNeedsUpdate = true;
    }
    updateMatrixWorld(force) {
        if (this.matrixAutoUpdate) this.updateMatrix();
        if (this.matrixWorldNeedsUpdate || force) {
            if (this.parent === null) this.matrixWorld.copy(this.matrix);
            else this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
            this.matrixWorldNeedsUpdate = false;
            force = true;
        }
        // update children
        const children = this.children;
        for(let i33 = 0, l = children.length; i33 < l; i33++)children[i33].updateMatrixWorld(force);
    }
    updateWorldMatrix(updateParents, updateChildren) {
        const parent = this.parent;
        if (updateParents === true && parent !== null) parent.updateWorldMatrix(true, false);
        if (this.matrixAutoUpdate) this.updateMatrix();
        if (this.parent === null) this.matrixWorld.copy(this.matrix);
        else this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
        // update children
        if (updateChildren === true) {
            const children = this.children;
            for(let i34 = 0, l = children.length; i34 < l; i34++)children[i34].updateWorldMatrix(false, true);
        }
    }
    toJSON(meta) {
        // meta is a string when called from JSON.stringify
        const isRootObject = meta === undefined || typeof meta === "string";
        const output = {};
        // meta is a hash used to collect geometries, materials.
        // not providing it implies that this is the root object
        // being serialized.
        if (isRootObject) {
            // initialize meta obj
            meta = {
                geometries: {},
                materials: {},
                textures: {},
                images: {},
                shapes: {},
                skeletons: {},
                animations: {},
                nodes: {}
            };
            output.metadata = {
                version: 4.5,
                type: "Object",
                generator: "Object3D.toJSON"
            };
        }
        // standard Object3D serialization
        const object = {};
        object.uuid = this.uuid;
        object.type = this.type;
        if (this.name !== "") object.name = this.name;
        if (this.castShadow === true) object.castShadow = true;
        if (this.receiveShadow === true) object.receiveShadow = true;
        if (this.visible === false) object.visible = false;
        if (this.frustumCulled === false) object.frustumCulled = false;
        if (this.renderOrder !== 0) object.renderOrder = this.renderOrder;
        if (JSON.stringify(this.userData) !== "{}") object.userData = this.userData;
        object.layers = this.layers.mask;
        object.matrix = this.matrix.toArray();
        if (this.matrixAutoUpdate === false) object.matrixAutoUpdate = false;
        // object specific properties
        if (this.isInstancedMesh) {
            object.type = "InstancedMesh";
            object.count = this.count;
            object.instanceMatrix = this.instanceMatrix.toJSON();
            if (this.instanceColor !== null) object.instanceColor = this.instanceColor.toJSON();
        }
        //
        function serialize(library, element) {
            if (library[element.uuid] === undefined) library[element.uuid] = element.toJSON(meta);
            return element.uuid;
        }
        if (this.isScene) {
            if (this.background) {
                if (this.background.isColor) object.background = this.background.toJSON();
                else if (this.background.isTexture) object.background = this.background.toJSON(meta).uuid;
            }
            if (this.environment && this.environment.isTexture) object.environment = this.environment.toJSON(meta).uuid;
        } else if (this.isMesh || this.isLine || this.isPoints) {
            object.geometry = serialize(meta.geometries, this.geometry);
            const parameters = this.geometry.parameters;
            if (parameters !== undefined && parameters.shapes !== undefined) {
                const shapes = parameters.shapes;
                if (Array.isArray(shapes)) for(let i35 = 0, l = shapes.length; i35 < l; i35++){
                    const shape = shapes[i35];
                    serialize(meta.shapes, shape);
                }
                else serialize(meta.shapes, shapes);
            }
        }
        if (this.isSkinnedMesh) {
            object.bindMode = this.bindMode;
            object.bindMatrix = this.bindMatrix.toArray();
            if (this.skeleton !== undefined) {
                serialize(meta.skeletons, this.skeleton);
                object.skeleton = this.skeleton.uuid;
            }
        }
        if (this.material !== undefined) {
            if (Array.isArray(this.material)) {
                const uuids = [];
                for(let i36 = 0, l = this.material.length; i36 < l; i36++)uuids.push(serialize(meta.materials, this.material[i36]));
                object.material = uuids;
            } else object.material = serialize(meta.materials, this.material);
        }
        //
        if (this.children.length > 0) {
            object.children = [];
            for(let i37 = 0; i37 < this.children.length; i37++)object.children.push(this.children[i37].toJSON(meta).object);
        }
        //
        if (this.animations.length > 0) {
            object.animations = [];
            for(let i38 = 0; i38 < this.animations.length; i38++){
                const animation = this.animations[i38];
                object.animations.push(serialize(meta.animations, animation));
            }
        }
        if (isRootObject) {
            const geometries = extractFromCache(meta.geometries);
            const materials = extractFromCache(meta.materials);
            const textures = extractFromCache(meta.textures);
            const images = extractFromCache(meta.images);
            const shapes = extractFromCache(meta.shapes);
            const skeletons = extractFromCache(meta.skeletons);
            const animations = extractFromCache(meta.animations);
            const nodes = extractFromCache(meta.nodes);
            if (geometries.length > 0) output.geometries = geometries;
            if (materials.length > 0) output.materials = materials;
            if (textures.length > 0) output.textures = textures;
            if (images.length > 0) output.images = images;
            if (shapes.length > 0) output.shapes = shapes;
            if (skeletons.length > 0) output.skeletons = skeletons;
            if (animations.length > 0) output.animations = animations;
            if (nodes.length > 0) output.nodes = nodes;
        }
        output.object = object;
        return output;
        // extract data from the cache hash
        // remove metadata on each item
        // and return as array
        function extractFromCache(cache) {
            const values = [];
            for(const key in cache){
                const data = cache[key];
                delete data.metadata;
                values.push(data);
            }
            return values;
        }
    }
    clone(recursive) {
        return new this.constructor().copy(this, recursive);
    }
    copy(source, recursive = true) {
        this.name = source.name;
        this.up.copy(source.up);
        this.position.copy(source.position);
        this.rotation.order = source.rotation.order;
        this.quaternion.copy(source.quaternion);
        this.scale.copy(source.scale);
        this.matrix.copy(source.matrix);
        this.matrixWorld.copy(source.matrixWorld);
        this.matrixAutoUpdate = source.matrixAutoUpdate;
        this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
        this.layers.mask = source.layers.mask;
        this.visible = source.visible;
        this.castShadow = source.castShadow;
        this.receiveShadow = source.receiveShadow;
        this.frustumCulled = source.frustumCulled;
        this.renderOrder = source.renderOrder;
        this.userData = JSON.parse(JSON.stringify(source.userData));
        if (recursive === true) for(let i39 = 0; i39 < source.children.length; i39++){
            const child = source.children[i39];
            this.add(child.clone());
        }
        return this;
    }
}
$084574008ccedf86$export$e4dd07dff30cc924.DefaultUp = new $084574008ccedf86$export$64b5c384219d3699(0, 1, 0);
$084574008ccedf86$export$e4dd07dff30cc924.DefaultMatrixAutoUpdate = true;
const $084574008ccedf86$var$_v0$1 = /*@__PURE__*/ new $084574008ccedf86$export$64b5c384219d3699();
const $084574008ccedf86$var$_v1$3 = /*@__PURE__*/ new $084574008ccedf86$export$64b5c384219d3699();
const $084574008ccedf86$var$_v2$2 = /*@__PURE__*/ new $084574008ccedf86$export$64b5c384219d3699();
const $084574008ccedf86$var$_v3$1 = /*@__PURE__*/ new $084574008ccedf86$export$64b5c384219d3699();
const $084574008ccedf86$var$_vab = /*@__PURE__*/ new $084574008ccedf86$export$64b5c384219d3699();
const $084574008ccedf86$var$_vac = /*@__PURE__*/ new $084574008ccedf86$export$64b5c384219d3699();
const $084574008ccedf86$var$_vbc = /*@__PURE__*/ new $084574008ccedf86$export$64b5c384219d3699();
const $084574008ccedf86$var$_vap = /*@__PURE__*/ new $084574008ccedf86$export$64b5c384219d3699();
const $084574008ccedf86$var$_vbp = /*@__PURE__*/ new $084574008ccedf86$export$64b5c384219d3699();
const $084574008ccedf86$var$_vcp = /*@__PURE__*/ new $084574008ccedf86$export$64b5c384219d3699();
class $084574008ccedf86$export$5a465592bfe74b48 {
    constructor(a = new $084574008ccedf86$export$64b5c384219d3699(), b = new $084574008ccedf86$export$64b5c384219d3699(), c = new $084574008ccedf86$export$64b5c384219d3699()){
        this.a = a;
        this.b = b;
        this.c = c;
    }
    static getNormal(a, b, c, target) {
        target.subVectors(c, b);
        $084574008ccedf86$var$_v0$1.subVectors(a, b);
        target.cross($084574008ccedf86$var$_v0$1);
        const targetLengthSq = target.lengthSq();
        if (targetLengthSq > 0) return target.multiplyScalar(1 / Math.sqrt(targetLengthSq));
        return target.set(0, 0, 0);
    }
    // static/instance method to calculate barycentric coordinates
    // based on: http://www.blackpawn.com/texts/pointinpoly/default.html
    static getBarycoord(point, a, b, c, target) {
        $084574008ccedf86$var$_v0$1.subVectors(c, a);
        $084574008ccedf86$var$_v1$3.subVectors(b, a);
        $084574008ccedf86$var$_v2$2.subVectors(point, a);
        const dot00 = $084574008ccedf86$var$_v0$1.dot($084574008ccedf86$var$_v0$1);
        const dot01 = $084574008ccedf86$var$_v0$1.dot($084574008ccedf86$var$_v1$3);
        const dot02 = $084574008ccedf86$var$_v0$1.dot($084574008ccedf86$var$_v2$2);
        const dot11 = $084574008ccedf86$var$_v1$3.dot($084574008ccedf86$var$_v1$3);
        const dot12 = $084574008ccedf86$var$_v1$3.dot($084574008ccedf86$var$_v2$2);
        const denom = dot00 * dot11 - dot01 * dot01;
        // collinear or singular triangle
        if (denom === 0) // arbitrary location outside of triangle?
        // not sure if this is the best idea, maybe should be returning undefined
        return target.set(-2, -1, -1);
        const invDenom = 1 / denom;
        const u = (dot11 * dot02 - dot01 * dot12) * invDenom;
        const v = (dot00 * dot12 - dot01 * dot02) * invDenom;
        // barycentric coordinates must always sum to 1
        return target.set(1 - u - v, v, u);
    }
    static containsPoint(point, a, b, c) {
        this.getBarycoord(point, a, b, c, $084574008ccedf86$var$_v3$1);
        return $084574008ccedf86$var$_v3$1.x >= 0 && $084574008ccedf86$var$_v3$1.y >= 0 && $084574008ccedf86$var$_v3$1.x + $084574008ccedf86$var$_v3$1.y <= 1;
    }
    static getUV(point, p1, p2, p3, uv1, uv2, uv3, target) {
        this.getBarycoord(point, p1, p2, p3, $084574008ccedf86$var$_v3$1);
        target.set(0, 0);
        target.addScaledVector(uv1, $084574008ccedf86$var$_v3$1.x);
        target.addScaledVector(uv2, $084574008ccedf86$var$_v3$1.y);
        target.addScaledVector(uv3, $084574008ccedf86$var$_v3$1.z);
        return target;
    }
    static isFrontFacing(a, b, c, direction) {
        $084574008ccedf86$var$_v0$1.subVectors(c, b);
        $084574008ccedf86$var$_v1$3.subVectors(a, b);
        // strictly front facing
        return $084574008ccedf86$var$_v0$1.cross($084574008ccedf86$var$_v1$3).dot(direction) < 0 ? true : false;
    }
    set(a, b, c) {
        this.a.copy(a);
        this.b.copy(b);
        this.c.copy(c);
        return this;
    }
    setFromPointsAndIndices(points, i0, i110, i210) {
        this.a.copy(points[i0]);
        this.b.copy(points[i110]);
        this.c.copy(points[i210]);
        return this;
    }
    setFromAttributeAndIndices(attribute, i0, i111, i211) {
        this.a.fromBufferAttribute(attribute, i0);
        this.b.fromBufferAttribute(attribute, i111);
        this.c.fromBufferAttribute(attribute, i211);
        return this;
    }
    clone() {
        return new this.constructor().copy(this);
    }
    copy(triangle) {
        this.a.copy(triangle.a);
        this.b.copy(triangle.b);
        this.c.copy(triangle.c);
        return this;
    }
    getArea() {
        $084574008ccedf86$var$_v0$1.subVectors(this.c, this.b);
        $084574008ccedf86$var$_v1$3.subVectors(this.a, this.b);
        return $084574008ccedf86$var$_v0$1.cross($084574008ccedf86$var$_v1$3).length() * 0.5;
    }
    getMidpoint(target) {
        return target.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
    }
    getNormal(target) {
        return $084574008ccedf86$export$5a465592bfe74b48.getNormal(this.a, this.b, this.c, target);
    }
    getPlane(target) {
        return target.setFromCoplanarPoints(this.a, this.b, this.c);
    }
    getBarycoord(point, target) {
        return $084574008ccedf86$export$5a465592bfe74b48.getBarycoord(point, this.a, this.b, this.c, target);
    }
    getUV(point, uv1, uv2, uv3, target) {
        return $084574008ccedf86$export$5a465592bfe74b48.getUV(point, this.a, this.b, this.c, uv1, uv2, uv3, target);
    }
    containsPoint(point) {
        return $084574008ccedf86$export$5a465592bfe74b48.containsPoint(point, this.a, this.b, this.c);
    }
    isFrontFacing(direction) {
        return $084574008ccedf86$export$5a465592bfe74b48.isFrontFacing(this.a, this.b, this.c, direction);
    }
    intersectsBox(box) {
        return box.intersectsTriangle(this);
    }
    closestPointToPoint(p, target) {
        const a = this.a, b = this.b, c = this.c;
        let v, w;
        // algorithm thanks to Real-Time Collision Detection by Christer Ericson,
        // published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,
        // under the accompanying license; see chapter 5.1.5 for detailed explanation.
        // basically, we're distinguishing which of the voronoi regions of the triangle
        // the point lies in with the minimum amount of redundant computation.
        $084574008ccedf86$var$_vab.subVectors(b, a);
        $084574008ccedf86$var$_vac.subVectors(c, a);
        $084574008ccedf86$var$_vap.subVectors(p, a);
        const d1 = $084574008ccedf86$var$_vab.dot($084574008ccedf86$var$_vap);
        const d2 = $084574008ccedf86$var$_vac.dot($084574008ccedf86$var$_vap);
        if (d1 <= 0 && d2 <= 0) // vertex region of A; barycentric coords (1, 0, 0)
        return target.copy(a);
        $084574008ccedf86$var$_vbp.subVectors(p, b);
        const d3 = $084574008ccedf86$var$_vab.dot($084574008ccedf86$var$_vbp);
        const d4 = $084574008ccedf86$var$_vac.dot($084574008ccedf86$var$_vbp);
        if (d3 >= 0 && d4 <= d3) // vertex region of B; barycentric coords (0, 1, 0)
        return target.copy(b);
        const vc = d1 * d4 - d3 * d2;
        if (vc <= 0 && d1 >= 0 && d3 <= 0) {
            v = d1 / (d1 - d3);
            // edge region of AB; barycentric coords (1-v, v, 0)
            return target.copy(a).addScaledVector($084574008ccedf86$var$_vab, v);
        }
        $084574008ccedf86$var$_vcp.subVectors(p, c);
        const d5 = $084574008ccedf86$var$_vab.dot($084574008ccedf86$var$_vcp);
        const d6 = $084574008ccedf86$var$_vac.dot($084574008ccedf86$var$_vcp);
        if (d6 >= 0 && d5 <= d6) // vertex region of C; barycentric coords (0, 0, 1)
        return target.copy(c);
        const vb = d5 * d2 - d1 * d6;
        if (vb <= 0 && d2 >= 0 && d6 <= 0) {
            w = d2 / (d2 - d6);
            // edge region of AC; barycentric coords (1-w, 0, w)
            return target.copy(a).addScaledVector($084574008ccedf86$var$_vac, w);
        }
        const va = d3 * d6 - d5 * d4;
        if (va <= 0 && d4 - d3 >= 0 && d5 - d6 >= 0) {
            $084574008ccedf86$var$_vbc.subVectors(c, b);
            w = (d4 - d3) / (d4 - d3 + (d5 - d6));
            // edge region of BC; barycentric coords (0, 1-w, w)
            return target.copy(b).addScaledVector($084574008ccedf86$var$_vbc, w); // edge region of BC
        }
        // face region
        const denom = 1 / (va + vb + vc);
        // u = va * denom
        v = vb * denom;
        w = vc * denom;
        return target.copy(a).addScaledVector($084574008ccedf86$var$_vab, v).addScaledVector($084574008ccedf86$var$_vac, w);
    }
    equals(triangle) {
        return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);
    }
}
let $084574008ccedf86$var$materialId = 0;
class $084574008ccedf86$export$a2d8b23205c25948 extends $084574008ccedf86$export$ec8b666c5fe2c75a {
    constructor(){
        super();
        this.isMaterial = true;
        Object.defineProperty(this, "id", {
            value: $084574008ccedf86$var$materialId++
        });
        this.uuid = $084574008ccedf86$var$generateUUID();
        this.name = "";
        this.type = "Material";
        this.blending = $084574008ccedf86$export$5b29a26d96ee6af0;
        this.side = $084574008ccedf86$export$2ede184fc2998901;
        this.vertexColors = false;
        this.opacity = 1;
        this.transparent = false;
        this.blendSrc = $084574008ccedf86$export$d5773124e86cf28c;
        this.blendDst = $084574008ccedf86$export$11d468cc7f19e971;
        this.blendEquation = $084574008ccedf86$export$20183a0484ce21a0;
        this.blendSrcAlpha = null;
        this.blendDstAlpha = null;
        this.blendEquationAlpha = null;
        this.depthFunc = $084574008ccedf86$export$296f78a0b892f81a;
        this.depthTest = true;
        this.depthWrite = true;
        this.stencilWriteMask = 0xff;
        this.stencilFunc = $084574008ccedf86$export$14cf96713ddd97a8;
        this.stencilRef = 0;
        this.stencilFuncMask = 0xff;
        this.stencilFail = $084574008ccedf86$export$9f542ae4b5baca34;
        this.stencilZFail = $084574008ccedf86$export$9f542ae4b5baca34;
        this.stencilZPass = $084574008ccedf86$export$9f542ae4b5baca34;
        this.stencilWrite = false;
        this.clippingPlanes = null;
        this.clipIntersection = false;
        this.clipShadows = false;
        this.shadowSide = null;
        this.colorWrite = true;
        this.precision = null; // override the renderer's default precision for this material
        this.polygonOffset = false;
        this.polygonOffsetFactor = 0;
        this.polygonOffsetUnits = 0;
        this.dithering = false;
        this.alphaToCoverage = false;
        this.premultipliedAlpha = false;
        this.visible = true;
        this.toneMapped = true;
        this.userData = {};
        this.version = 0;
        this._alphaTest = 0;
    }
    get alphaTest() {
        return this._alphaTest;
    }
    set alphaTest(value) {
        if (this._alphaTest > 0 !== value > 0) this.version++;
        this._alphaTest = value;
    }
    onBuild() {}
    onBeforeRender() {}
    onBeforeCompile() {}
    customProgramCacheKey() {
        return this.onBeforeCompile.toString();
    }
    setValues(values) {
        if (values === undefined) return;
        for(const key in values){
            const newValue = values[key];
            if (newValue === undefined) {
                console.warn("THREE.Material: '" + key + "' parameter is undefined.");
                continue;
            }
            // for backward compatibility if shading is set in the constructor
            if (key === "shading") {
                console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
                this.flatShading = newValue === $084574008ccedf86$export$a62047d29c96d8ff ? true : false;
                continue;
            }
            const currentValue = this[key];
            if (currentValue === undefined) {
                console.warn("THREE." + this.type + ": '" + key + "' is not a property of this material.");
                continue;
            }
            if (currentValue && currentValue.isColor) currentValue.set(newValue);
            else if (currentValue && currentValue.isVector3 && newValue && newValue.isVector3) currentValue.copy(newValue);
            else this[key] = newValue;
        }
    }
    toJSON(meta) {
        const isRootObject = meta === undefined || typeof meta === "string";
        if (isRootObject) meta = {
            textures: {},
            images: {}
        };
        const data1 = {
            metadata: {
                version: 4.5,
                type: "Material",
                generator: "Material.toJSON"
            }
        };
        // standard Material serialization
        data1.uuid = this.uuid;
        data1.type = this.type;
        if (this.name !== "") data1.name = this.name;
        if (this.color && this.color.isColor) data1.color = this.color.getHex();
        if (this.roughness !== undefined) data1.roughness = this.roughness;
        if (this.metalness !== undefined) data1.metalness = this.metalness;
        if (this.sheen !== undefined) data1.sheen = this.sheen;
        if (this.sheenColor && this.sheenColor.isColor) data1.sheenColor = this.sheenColor.getHex();
        if (this.sheenRoughness !== undefined) data1.sheenRoughness = this.sheenRoughness;
        if (this.emissive && this.emissive.isColor) data1.emissive = this.emissive.getHex();
        if (this.emissiveIntensity && this.emissiveIntensity !== 1) data1.emissiveIntensity = this.emissiveIntensity;
        if (this.specular && this.specular.isColor) data1.specular = this.specular.getHex();
        if (this.specularIntensity !== undefined) data1.specularIntensity = this.specularIntensity;
        if (this.specularColor && this.specularColor.isColor) data1.specularColor = this.specularColor.getHex();
        if (this.shininess !== undefined) data1.shininess = this.shininess;
        if (this.clearcoat !== undefined) data1.clearcoat = this.clearcoat;
        if (this.clearcoatRoughness !== undefined) data1.clearcoatRoughness = this.clearcoatRoughness;
        if (this.clearcoatMap && this.clearcoatMap.isTexture) data1.clearcoatMap = this.clearcoatMap.toJSON(meta).uuid;
        if (this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture) data1.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(meta).uuid;
        if (this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture) {
            data1.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(meta).uuid;
            data1.clearcoatNormalScale = this.clearcoatNormalScale.toArray();
        }
        if (this.iridescence !== undefined) data1.iridescence = this.iridescence;
        if (this.iridescenceIOR !== undefined) data1.iridescenceIOR = this.iridescenceIOR;
        if (this.iridescenceThicknessRange !== undefined) data1.iridescenceThicknessRange = this.iridescenceThicknessRange;
        if (this.iridescenceMap && this.iridescenceMap.isTexture) data1.iridescenceMap = this.iridescenceMap.toJSON(meta).uuid;
        if (this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture) data1.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(meta).uuid;
        if (this.map && this.map.isTexture) data1.map = this.map.toJSON(meta).uuid;
        if (this.matcap && this.matcap.isTexture) data1.matcap = this.matcap.toJSON(meta).uuid;
        if (this.alphaMap && this.alphaMap.isTexture) data1.alphaMap = this.alphaMap.toJSON(meta).uuid;
        if (this.lightMap && this.lightMap.isTexture) {
            data1.lightMap = this.lightMap.toJSON(meta).uuid;
            data1.lightMapIntensity = this.lightMapIntensity;
        }
        if (this.aoMap && this.aoMap.isTexture) {
            data1.aoMap = this.aoMap.toJSON(meta).uuid;
            data1.aoMapIntensity = this.aoMapIntensity;
        }
        if (this.bumpMap && this.bumpMap.isTexture) {
            data1.bumpMap = this.bumpMap.toJSON(meta).uuid;
            data1.bumpScale = this.bumpScale;
        }
        if (this.normalMap && this.normalMap.isTexture) {
            data1.normalMap = this.normalMap.toJSON(meta).uuid;
            data1.normalMapType = this.normalMapType;
            data1.normalScale = this.normalScale.toArray();
        }
        if (this.displacementMap && this.displacementMap.isTexture) {
            data1.displacementMap = this.displacementMap.toJSON(meta).uuid;
            data1.displacementScale = this.displacementScale;
            data1.displacementBias = this.displacementBias;
        }
        if (this.roughnessMap && this.roughnessMap.isTexture) data1.roughnessMap = this.roughnessMap.toJSON(meta).uuid;
        if (this.metalnessMap && this.metalnessMap.isTexture) data1.metalnessMap = this.metalnessMap.toJSON(meta).uuid;
        if (this.emissiveMap && this.emissiveMap.isTexture) data1.emissiveMap = this.emissiveMap.toJSON(meta).uuid;
        if (this.specularMap && this.specularMap.isTexture) data1.specularMap = this.specularMap.toJSON(meta).uuid;
        if (this.specularIntensityMap && this.specularIntensityMap.isTexture) data1.specularIntensityMap = this.specularIntensityMap.toJSON(meta).uuid;
        if (this.specularColorMap && this.specularColorMap.isTexture) data1.specularColorMap = this.specularColorMap.toJSON(meta).uuid;
        if (this.envMap && this.envMap.isTexture) {
            data1.envMap = this.envMap.toJSON(meta).uuid;
            if (this.combine !== undefined) data1.combine = this.combine;
        }
        if (this.envMapIntensity !== undefined) data1.envMapIntensity = this.envMapIntensity;
        if (this.reflectivity !== undefined) data1.reflectivity = this.reflectivity;
        if (this.refractionRatio !== undefined) data1.refractionRatio = this.refractionRatio;
        if (this.gradientMap && this.gradientMap.isTexture) data1.gradientMap = this.gradientMap.toJSON(meta).uuid;
        if (this.transmission !== undefined) data1.transmission = this.transmission;
        if (this.transmissionMap && this.transmissionMap.isTexture) data1.transmissionMap = this.transmissionMap.toJSON(meta).uuid;
        if (this.thickness !== undefined) data1.thickness = this.thickness;
        if (this.thicknessMap && this.thicknessMap.isTexture) data1.thicknessMap = this.thicknessMap.toJSON(meta).uuid;
        if (this.attenuationDistance !== undefined) data1.attenuationDistance = this.attenuationDistance;
        if (this.attenuationColor !== undefined) data1.attenuationColor = this.attenuationColor.getHex();
        if (this.size !== undefined) data1.size = this.size;
        if (this.shadowSide !== null) data1.shadowSide = this.shadowSide;
        if (this.sizeAttenuation !== undefined) data1.sizeAttenuation = this.sizeAttenuation;
        if (this.blending !== $084574008ccedf86$export$5b29a26d96ee6af0) data1.blending = this.blending;
        if (this.side !== $084574008ccedf86$export$2ede184fc2998901) data1.side = this.side;
        if (this.vertexColors) data1.vertexColors = true;
        if (this.opacity < 1) data1.opacity = this.opacity;
        if (this.transparent === true) data1.transparent = this.transparent;
        data1.depthFunc = this.depthFunc;
        data1.depthTest = this.depthTest;
        data1.depthWrite = this.depthWrite;
        data1.colorWrite = this.colorWrite;
        data1.stencilWrite = this.stencilWrite;
        data1.stencilWriteMask = this.stencilWriteMask;
        data1.stencilFunc = this.stencilFunc;
        data1.stencilRef = this.stencilRef;
        data1.stencilFuncMask = this.stencilFuncMask;
        data1.stencilFail = this.stencilFail;
        data1.stencilZFail = this.stencilZFail;
        data1.stencilZPass = this.stencilZPass;
        // rotation (SpriteMaterial)
        if (this.rotation !== undefined && this.rotation !== 0) data1.rotation = this.rotation;
        if (this.polygonOffset === true) data1.polygonOffset = true;
        if (this.polygonOffsetFactor !== 0) data1.polygonOffsetFactor = this.polygonOffsetFactor;
        if (this.polygonOffsetUnits !== 0) data1.polygonOffsetUnits = this.polygonOffsetUnits;
        if (this.linewidth !== undefined && this.linewidth !== 1) data1.linewidth = this.linewidth;
        if (this.dashSize !== undefined) data1.dashSize = this.dashSize;
        if (this.gapSize !== undefined) data1.gapSize = this.gapSize;
        if (this.scale !== undefined) data1.scale = this.scale;
        if (this.dithering === true) data1.dithering = true;
        if (this.alphaTest > 0) data1.alphaTest = this.alphaTest;
        if (this.alphaToCoverage === true) data1.alphaToCoverage = this.alphaToCoverage;
        if (this.premultipliedAlpha === true) data1.premultipliedAlpha = this.premultipliedAlpha;
        if (this.wireframe === true) data1.wireframe = this.wireframe;
        if (this.wireframeLinewidth > 1) data1.wireframeLinewidth = this.wireframeLinewidth;
        if (this.wireframeLinecap !== "round") data1.wireframeLinecap = this.wireframeLinecap;
        if (this.wireframeLinejoin !== "round") data1.wireframeLinejoin = this.wireframeLinejoin;
        if (this.flatShading === true) data1.flatShading = this.flatShading;
        if (this.visible === false) data1.visible = false;
        if (this.toneMapped === false) data1.toneMapped = false;
        if (this.fog === false) data1.fog = false;
        if (JSON.stringify(this.userData) !== "{}") data1.userData = this.userData;
        // TODO: Copied from Object3D.toJSON
        function extractFromCache(cache) {
            const values = [];
            for(const key in cache){
                const data = cache[key];
                delete data.metadata;
                values.push(data);
            }
            return values;
        }
        if (isRootObject) {
            const textures = extractFromCache(meta.textures);
            const images = extractFromCache(meta.images);
            if (textures.length > 0) data1.textures = textures;
            if (images.length > 0) data1.images = images;
        }
        return data1;
    }
    clone() {
        return new this.constructor().copy(this);
    }
    copy(source) {
        this.name = source.name;
        this.blending = source.blending;
        this.side = source.side;
        this.vertexColors = source.vertexColors;
        this.opacity = source.opacity;
        this.transparent = source.transparent;
        this.blendSrc = source.blendSrc;
        this.blendDst = source.blendDst;
        this.blendEquation = source.blendEquation;
        this.blendSrcAlpha = source.blendSrcAlpha;
        this.blendDstAlpha = source.blendDstAlpha;
        this.blendEquationAlpha = source.blendEquationAlpha;
        this.depthFunc = source.depthFunc;
        this.depthTest = source.depthTest;
        this.depthWrite = source.depthWrite;
        this.stencilWriteMask = source.stencilWriteMask;
        this.stencilFunc = source.stencilFunc;
        this.stencilRef = source.stencilRef;
        this.stencilFuncMask = source.stencilFuncMask;
        this.stencilFail = source.stencilFail;
        this.stencilZFail = source.stencilZFail;
        this.stencilZPass = source.stencilZPass;
        this.stencilWrite = source.stencilWrite;
        const srcPlanes = source.clippingPlanes;
        let dstPlanes = null;
        if (srcPlanes !== null) {
            const n = srcPlanes.length;
            dstPlanes = new Array(n);
            for(let i40 = 0; i40 !== n; ++i40)dstPlanes[i40] = srcPlanes[i40].clone();
        }
        this.clippingPlanes = dstPlanes;
        this.clipIntersection = source.clipIntersection;
        this.clipShadows = source.clipShadows;
        this.shadowSide = source.shadowSide;
        this.colorWrite = source.colorWrite;
        this.precision = source.precision;
        this.polygonOffset = source.polygonOffset;
        this.polygonOffsetFactor = source.polygonOffsetFactor;
        this.polygonOffsetUnits = source.polygonOffsetUnits;
        this.dithering = source.dithering;
        this.alphaTest = source.alphaTest;
        this.alphaToCoverage = source.alphaToCoverage;
        this.premultipliedAlpha = source.premultipliedAlpha;
        this.visible = source.visible;
        this.toneMapped = source.toneMapped;
        this.userData = JSON.parse(JSON.stringify(source.userData));
        return this;
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        });
    }
    set needsUpdate(value) {
        if (value === true) this.version++;
    }
    // @deprecated since r131, f5803c62cc4a29d90744e9dc7811d086e354c1d8
    get vertexTangents() {
        console.warn("THREE." + this.type + ": .vertexTangents has been removed.");
        return false;
    }
    set vertexTangents(value) {
        console.warn("THREE." + this.type + ": .vertexTangents has been removed.");
    }
}
$084574008ccedf86$export$a2d8b23205c25948.fromType = function() {
    // TODO: Behavior added in Materials.js
    return null;
};
class $084574008ccedf86$export$55cbcc9b622fe1f5 extends $084574008ccedf86$export$a2d8b23205c25948 {
    constructor(parameters){
        super();
        this.isMeshBasicMaterial = true;
        this.type = "MeshBasicMaterial";
        this.color = new $084574008ccedf86$export$892596cec99bc70e(0xffffff); // emissive
        this.map = null;
        this.lightMap = null;
        this.lightMapIntensity = 1.0;
        this.aoMap = null;
        this.aoMapIntensity = 1.0;
        this.specularMap = null;
        this.alphaMap = null;
        this.envMap = null;
        this.combine = $084574008ccedf86$export$e50ac29801f1774d;
        this.reflectivity = 1;
        this.refractionRatio = 0.98;
        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.wireframeLinecap = "round";
        this.wireframeLinejoin = "round";
        this.fog = true;
        this.setValues(parameters);
    }
    copy(source) {
        super.copy(source);
        this.color.copy(source.color);
        this.map = source.map;
        this.lightMap = source.lightMap;
        this.lightMapIntensity = source.lightMapIntensity;
        this.aoMap = source.aoMap;
        this.aoMapIntensity = source.aoMapIntensity;
        this.specularMap = source.specularMap;
        this.alphaMap = source.alphaMap;
        this.envMap = source.envMap;
        this.combine = source.combine;
        this.reflectivity = source.reflectivity;
        this.refractionRatio = source.refractionRatio;
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        this.wireframeLinecap = source.wireframeLinecap;
        this.wireframeLinejoin = source.wireframeLinejoin;
        this.fog = source.fog;
        return this;
    }
}
const $084574008ccedf86$var$_vector$9 = /*@__PURE__*/ new $084574008ccedf86$export$64b5c384219d3699();
const $084574008ccedf86$var$_vector2$1 = /*@__PURE__*/ new $084574008ccedf86$export$c977b3e384af9ae1();
class $084574008ccedf86$export$8dea267bd6bde117 {
    constructor(array, itemSize, normalized){
        if (Array.isArray(array)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
        this.isBufferAttribute = true;
        this.name = "";
        this.array = array;
        this.itemSize = itemSize;
        this.count = array !== undefined ? array.length / itemSize : 0;
        this.normalized = normalized === true;
        this.usage = $084574008ccedf86$export$763e8360f4d7f77d;
        this.updateRange = {
            offset: 0,
            count: -1
        };
        this.version = 0;
    }
    onUploadCallback() {}
    set needsUpdate(value) {
        if (value === true) this.version++;
    }
    setUsage(value) {
        this.usage = value;
        return this;
    }
    copy(source) {
        this.name = source.name;
        this.array = new source.array.constructor(source.array);
        this.itemSize = source.itemSize;
        this.count = source.count;
        this.normalized = source.normalized;
        this.usage = source.usage;
        return this;
    }
    copyAt(index1, attribute, index2) {
        index1 *= this.itemSize;
        index2 *= attribute.itemSize;
        for(let i41 = 0, l = this.itemSize; i41 < l; i41++)this.array[index1 + i41] = attribute.array[index2 + i41];
        return this;
    }
    copyArray(array) {
        this.array.set(array);
        return this;
    }
    copyColorsArray(colors) {
        const array = this.array;
        let offset = 0;
        for(let i42 = 0, l = colors.length; i42 < l; i42++){
            let color = colors[i42];
            if (color === undefined) {
                console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", i42);
                color = new $084574008ccedf86$export$892596cec99bc70e();
            }
            array[offset++] = color.r;
            array[offset++] = color.g;
            array[offset++] = color.b;
        }
        return this;
    }
    copyVector2sArray(vectors) {
        const array = this.array;
        let offset = 0;
        for(let i43 = 0, l = vectors.length; i43 < l; i43++){
            let vector = vectors[i43];
            if (vector === undefined) {
                console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", i43);
                vector = new $084574008ccedf86$export$c977b3e384af9ae1();
            }
            array[offset++] = vector.x;
            array[offset++] = vector.y;
        }
        return this;
    }
    copyVector3sArray(vectors) {
        const array = this.array;
        let offset = 0;
        for(let i44 = 0, l = vectors.length; i44 < l; i44++){
            let vector = vectors[i44];
            if (vector === undefined) {
                console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", i44);
                vector = new $084574008ccedf86$export$64b5c384219d3699();
            }
            array[offset++] = vector.x;
            array[offset++] = vector.y;
            array[offset++] = vector.z;
        }
        return this;
    }
    copyVector4sArray(vectors) {
        const array = this.array;
        let offset = 0;
        for(let i45 = 0, l = vectors.length; i45 < l; i45++){
            let vector = vectors[i45];
            if (vector === undefined) {
                console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", i45);
                vector = new $084574008ccedf86$export$fa7daccca11cdbe3();
            }
            array[offset++] = vector.x;
            array[offset++] = vector.y;
            array[offset++] = vector.z;
            array[offset++] = vector.w;
        }
        return this;
    }
    applyMatrix3(m) {
        if (this.itemSize === 2) for(let i47 = 0, l = this.count; i47 < l; i47++){
            $084574008ccedf86$var$_vector2$1.fromBufferAttribute(this, i47);
            $084574008ccedf86$var$_vector2$1.applyMatrix3(m);
            this.setXY(i47, $084574008ccedf86$var$_vector2$1.x, $084574008ccedf86$var$_vector2$1.y);
        }
        else if (this.itemSize === 3) for(let i46 = 0, l1 = this.count; i46 < l1; i46++){
            $084574008ccedf86$var$_vector$9.fromBufferAttribute(this, i46);
            $084574008ccedf86$var$_vector$9.applyMatrix3(m);
            this.setXYZ(i46, $084574008ccedf86$var$_vector$9.x, $084574008ccedf86$var$_vector$9.y, $084574008ccedf86$var$_vector$9.z);
        }
        return this;
    }
    applyMatrix4(m) {
        for(let i48 = 0, l = this.count; i48 < l; i48++){
            $084574008ccedf86$var$_vector$9.fromBufferAttribute(this, i48);
            $084574008ccedf86$var$_vector$9.applyMatrix4(m);
            this.setXYZ(i48, $084574008ccedf86$var$_vector$9.x, $084574008ccedf86$var$_vector$9.y, $084574008ccedf86$var$_vector$9.z);
        }
        return this;
    }
    applyNormalMatrix(m) {
        for(let i49 = 0, l = this.count; i49 < l; i49++){
            $084574008ccedf86$var$_vector$9.fromBufferAttribute(this, i49);
            $084574008ccedf86$var$_vector$9.applyNormalMatrix(m);
            this.setXYZ(i49, $084574008ccedf86$var$_vector$9.x, $084574008ccedf86$var$_vector$9.y, $084574008ccedf86$var$_vector$9.z);
        }
        return this;
    }
    transformDirection(m) {
        for(let i50 = 0, l = this.count; i50 < l; i50++){
            $084574008ccedf86$var$_vector$9.fromBufferAttribute(this, i50);
            $084574008ccedf86$var$_vector$9.transformDirection(m);
            this.setXYZ(i50, $084574008ccedf86$var$_vector$9.x, $084574008ccedf86$var$_vector$9.y, $084574008ccedf86$var$_vector$9.z);
        }
        return this;
    }
    set(value, offset = 0) {
        this.array.set(value, offset);
        return this;
    }
    getX(index) {
        return this.array[index * this.itemSize];
    }
    setX(index, x) {
        this.array[index * this.itemSize] = x;
        return this;
    }
    getY(index) {
        return this.array[index * this.itemSize + 1];
    }
    setY(index, y) {
        this.array[index * this.itemSize + 1] = y;
        return this;
    }
    getZ(index) {
        return this.array[index * this.itemSize + 2];
    }
    setZ(index, z) {
        this.array[index * this.itemSize + 2] = z;
        return this;
    }
    getW(index) {
        return this.array[index * this.itemSize + 3];
    }
    setW(index, w) {
        this.array[index * this.itemSize + 3] = w;
        return this;
    }
    setXY(index, x, y) {
        index *= this.itemSize;
        this.array[index + 0] = x;
        this.array[index + 1] = y;
        return this;
    }
    setXYZ(index, x, y, z) {
        index *= this.itemSize;
        this.array[index + 0] = x;
        this.array[index + 1] = y;
        this.array[index + 2] = z;
        return this;
    }
    setXYZW(index, x, y, z, w) {
        index *= this.itemSize;
        this.array[index + 0] = x;
        this.array[index + 1] = y;
        this.array[index + 2] = z;
        this.array[index + 3] = w;
        return this;
    }
    onUpload(callback) {
        this.onUploadCallback = callback;
        return this;
    }
    clone() {
        return new this.constructor(this.array, this.itemSize).copy(this);
    }
    toJSON() {
        const data = {
            itemSize: this.itemSize,
            type: this.array.constructor.name,
            array: Array.prototype.slice.call(this.array),
            normalized: this.normalized
        };
        if (this.name !== "") data.name = this.name;
        if (this.usage !== $084574008ccedf86$export$763e8360f4d7f77d) data.usage = this.usage;
        if (this.updateRange.offset !== 0 || this.updateRange.count !== -1) data.updateRange = this.updateRange;
        return data;
    }
}
//
class $084574008ccedf86$export$f9ff2d6a20248cbf extends $084574008ccedf86$export$8dea267bd6bde117 {
    constructor(array, itemSize, normalized){
        super(new Int8Array(array), itemSize, normalized);
    }
}
class $084574008ccedf86$export$cacc90cf35d11cdd extends $084574008ccedf86$export$8dea267bd6bde117 {
    constructor(array, itemSize, normalized){
        super(new Uint8Array(array), itemSize, normalized);
    }
}
class $084574008ccedf86$export$baaa85a1a812c157 extends $084574008ccedf86$export$8dea267bd6bde117 {
    constructor(array, itemSize, normalized){
        super(new Uint8ClampedArray(array), itemSize, normalized);
    }
}
class $084574008ccedf86$export$2b755a102ccdcefe extends $084574008ccedf86$export$8dea267bd6bde117 {
    constructor(array, itemSize, normalized){
        super(new Int16Array(array), itemSize, normalized);
    }
}
class $084574008ccedf86$export$640a853f68025f2e extends $084574008ccedf86$export$8dea267bd6bde117 {
    constructor(array, itemSize, normalized){
        super(new Uint16Array(array), itemSize, normalized);
    }
}
class $084574008ccedf86$export$46b369aed2968a0a extends $084574008ccedf86$export$8dea267bd6bde117 {
    constructor(array, itemSize, normalized){
        super(new Int32Array(array), itemSize, normalized);
    }
}
class $084574008ccedf86$export$7eb8c9fa25cd5bd6 extends $084574008ccedf86$export$8dea267bd6bde117 {
    constructor(array, itemSize, normalized){
        super(new Uint32Array(array), itemSize, normalized);
    }
}
class $084574008ccedf86$export$dbd3698c64958d69 extends $084574008ccedf86$export$8dea267bd6bde117 {
    constructor(array, itemSize, normalized){
        super(new Uint16Array(array), itemSize, normalized);
        this.isFloat16BufferAttribute = true;
    }
}
class $084574008ccedf86$export$cbe7a62641830ebd extends $084574008ccedf86$export$8dea267bd6bde117 {
    constructor(array, itemSize, normalized){
        super(new Float32Array(array), itemSize, normalized);
    }
}
class $084574008ccedf86$export$9e0ade74842adbb8 extends $084574008ccedf86$export$8dea267bd6bde117 {
    constructor(array, itemSize, normalized){
        super(new Float64Array(array), itemSize, normalized);
    }
}
let $084574008ccedf86$var$_id$1 = 0;
const $084574008ccedf86$var$_m1 = /*@__PURE__*/ new $084574008ccedf86$export$2ae72fc923e5eb5();
const $084574008ccedf86$var$_obj = /*@__PURE__*/ new $084574008ccedf86$export$e4dd07dff30cc924();
const $084574008ccedf86$var$_offset = /*@__PURE__*/ new $084574008ccedf86$export$64b5c384219d3699();
const $084574008ccedf86$var$_box$1 = /*@__PURE__*/ new $084574008ccedf86$export$6f7d5a9418ab2aa3();
const $084574008ccedf86$var$_boxMorphTargets = /*@__PURE__*/ new $084574008ccedf86$export$6f7d5a9418ab2aa3();
const $084574008ccedf86$var$_vector$8 = /*@__PURE__*/ new $084574008ccedf86$export$64b5c384219d3699();
class $084574008ccedf86$export$b7be63a67df8959 extends $084574008ccedf86$export$ec8b666c5fe2c75a {
    constructor(){
        super();
        this.isBufferGeometry = true;
        Object.defineProperty(this, "id", {
            value: $084574008ccedf86$var$_id$1++
        });
        this.uuid = $084574008ccedf86$var$generateUUID();
        this.name = "";
        this.type = "BufferGeometry";
        this.index = null;
        this.attributes = {};
        this.morphAttributes = {};
        this.morphTargetsRelative = false;
        this.groups = [];
        this.boundingBox = null;
        this.boundingSphere = null;
        this.drawRange = {
            start: 0,
            count: Infinity
        };
        this.userData = {};
    }
    getIndex() {
        return this.index;
    }
    setIndex(index) {
        if (Array.isArray(index)) this.index = new ($084574008ccedf86$var$arrayNeedsUint32(index) ? $084574008ccedf86$export$7eb8c9fa25cd5bd6 : $084574008ccedf86$export$640a853f68025f2e)(index, 1);
        else this.index = index;
        return this;
    }
    getAttribute(name) {
        return this.attributes[name];
    }
    setAttribute(name, attribute) {
        this.attributes[name] = attribute;
        return this;
    }
    deleteAttribute(name) {
        delete this.attributes[name];
        return this;
    }
    hasAttribute(name) {
        return this.attributes[name] !== undefined;
    }
    addGroup(start, count, materialIndex = 0) {
        this.groups.push({
            start: start,
            count: count,
            materialIndex: materialIndex
        });
    }
    clearGroups() {
        this.groups = [];
    }
    setDrawRange(start, count) {
        this.drawRange.start = start;
        this.drawRange.count = count;
    }
    applyMatrix4(matrix) {
        const position = this.attributes.position;
        if (position !== undefined) {
            position.applyMatrix4(matrix);
            position.needsUpdate = true;
        }
        const normal = this.attributes.normal;
        if (normal !== undefined) {
            const normalMatrix = new $084574008ccedf86$export$8ff26dafa08918().getNormalMatrix(matrix);
            normal.applyNormalMatrix(normalMatrix);
            normal.needsUpdate = true;
        }
        const tangent = this.attributes.tangent;
        if (tangent !== undefined) {
            tangent.transformDirection(matrix);
            tangent.needsUpdate = true;
        }
        if (this.boundingBox !== null) this.computeBoundingBox();
        if (this.boundingSphere !== null) this.computeBoundingSphere();
        return this;
    }
    applyQuaternion(q) {
        $084574008ccedf86$var$_m1.makeRotationFromQuaternion(q);
        this.applyMatrix4($084574008ccedf86$var$_m1);
        return this;
    }
    rotateX(angle) {
        // rotate geometry around world x-axis
        $084574008ccedf86$var$_m1.makeRotationX(angle);
        this.applyMatrix4($084574008ccedf86$var$_m1);
        return this;
    }
    rotateY(angle) {
        // rotate geometry around world y-axis
        $084574008ccedf86$var$_m1.makeRotationY(angle);
        this.applyMatrix4($084574008ccedf86$var$_m1);
        return this;
    }
    rotateZ(angle) {
        // rotate geometry around world z-axis
        $084574008ccedf86$var$_m1.makeRotationZ(angle);
        this.applyMatrix4($084574008ccedf86$var$_m1);
        return this;
    }
    translate(x, y, z) {
        // translate geometry
        $084574008ccedf86$var$_m1.makeTranslation(x, y, z);
        this.applyMatrix4($084574008ccedf86$var$_m1);
        return this;
    }
    scale(x, y, z) {
        // scale geometry
        $084574008ccedf86$var$_m1.makeScale(x, y, z);
        this.applyMatrix4($084574008ccedf86$var$_m1);
        return this;
    }
    lookAt(vector) {
        $084574008ccedf86$var$_obj.lookAt(vector);
        $084574008ccedf86$var$_obj.updateMatrix();
        this.applyMatrix4($084574008ccedf86$var$_obj.matrix);
        return this;
    }
    center() {
        this.computeBoundingBox();
        this.boundingBox.getCenter($084574008ccedf86$var$_offset).negate();
        this.translate($084574008ccedf86$var$_offset.x, $084574008ccedf86$var$_offset.y, $084574008ccedf86$var$_offset.z);
        return this;
    }
    setFromPoints(points) {
        const position = [];
        for(let i51 = 0, l = points.length; i51 < l; i51++){
            const point = points[i51];
            position.push(point.x, point.y, point.z || 0);
        }
        this.setAttribute("position", new $084574008ccedf86$export$cbe7a62641830ebd(position, 3));
        return this;
    }
    computeBoundingBox() {
        if (this.boundingBox === null) this.boundingBox = new $084574008ccedf86$export$6f7d5a9418ab2aa3();
        const position = this.attributes.position;
        const morphAttributesPosition = this.morphAttributes.position;
        if (position && position.isGLBufferAttribute) {
            console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this);
            this.boundingBox.set(new $084574008ccedf86$export$64b5c384219d3699(-Infinity, -Infinity, -Infinity), new $084574008ccedf86$export$64b5c384219d3699(Infinity, Infinity, Infinity));
            return;
        }
        if (position !== undefined) {
            this.boundingBox.setFromBufferAttribute(position);
            // process morph attributes if present
            if (morphAttributesPosition) for(let i52 = 0, il = morphAttributesPosition.length; i52 < il; i52++){
                const morphAttribute = morphAttributesPosition[i52];
                $084574008ccedf86$var$_box$1.setFromBufferAttribute(morphAttribute);
                if (this.morphTargetsRelative) {
                    $084574008ccedf86$var$_vector$8.addVectors(this.boundingBox.min, $084574008ccedf86$var$_box$1.min);
                    this.boundingBox.expandByPoint($084574008ccedf86$var$_vector$8);
                    $084574008ccedf86$var$_vector$8.addVectors(this.boundingBox.max, $084574008ccedf86$var$_box$1.max);
                    this.boundingBox.expandByPoint($084574008ccedf86$var$_vector$8);
                } else {
                    this.boundingBox.expandByPoint($084574008ccedf86$var$_box$1.min);
                    this.boundingBox.expandByPoint($084574008ccedf86$var$_box$1.max);
                }
            }
        } else this.boundingBox.makeEmpty();
        if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
    }
    computeBoundingSphere() {
        if (this.boundingSphere === null) this.boundingSphere = new $084574008ccedf86$export$805e8b72413ccaba();
        const position = this.attributes.position;
        const morphAttributesPosition = this.morphAttributes.position;
        if (position && position.isGLBufferAttribute) {
            console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this);
            this.boundingSphere.set(new $084574008ccedf86$export$64b5c384219d3699(), Infinity);
            return;
        }
        if (position) {
            // first, find the center of the bounding sphere
            const center = this.boundingSphere.center;
            $084574008ccedf86$var$_box$1.setFromBufferAttribute(position);
            // process morph attributes if present
            if (morphAttributesPosition) for(let i55 = 0, il = morphAttributesPosition.length; i55 < il; i55++){
                const morphAttribute = morphAttributesPosition[i55];
                $084574008ccedf86$var$_boxMorphTargets.setFromBufferAttribute(morphAttribute);
                if (this.morphTargetsRelative) {
                    $084574008ccedf86$var$_vector$8.addVectors($084574008ccedf86$var$_box$1.min, $084574008ccedf86$var$_boxMorphTargets.min);
                    $084574008ccedf86$var$_box$1.expandByPoint($084574008ccedf86$var$_vector$8);
                    $084574008ccedf86$var$_vector$8.addVectors($084574008ccedf86$var$_box$1.max, $084574008ccedf86$var$_boxMorphTargets.max);
                    $084574008ccedf86$var$_box$1.expandByPoint($084574008ccedf86$var$_vector$8);
                } else {
                    $084574008ccedf86$var$_box$1.expandByPoint($084574008ccedf86$var$_boxMorphTargets.min);
                    $084574008ccedf86$var$_box$1.expandByPoint($084574008ccedf86$var$_boxMorphTargets.max);
                }
            }
            $084574008ccedf86$var$_box$1.getCenter(center);
            // second, try to find a boundingSphere with a radius smaller than the
            // boundingSphere of the boundingBox: sqrt(3) smaller in the best case
            let maxRadiusSq = 0;
            for(let i53 = 0, il1 = position.count; i53 < il1; i53++){
                $084574008ccedf86$var$_vector$8.fromBufferAttribute(position, i53);
                maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared($084574008ccedf86$var$_vector$8));
            }
            // process morph attributes if present
            if (morphAttributesPosition) for(let i54 = 0, il2 = morphAttributesPosition.length; i54 < il2; i54++){
                const morphAttribute = morphAttributesPosition[i54];
                const morphTargetsRelative = this.morphTargetsRelative;
                for(let j = 0, jl = morphAttribute.count; j < jl; j++){
                    $084574008ccedf86$var$_vector$8.fromBufferAttribute(morphAttribute, j);
                    if (morphTargetsRelative) {
                        $084574008ccedf86$var$_offset.fromBufferAttribute(position, j);
                        $084574008ccedf86$var$_vector$8.add($084574008ccedf86$var$_offset);
                    }
                    maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared($084574008ccedf86$var$_vector$8));
                }
            }
            this.boundingSphere.radius = Math.sqrt(maxRadiusSq);
            if (isNaN(this.boundingSphere.radius)) console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
        }
    }
    computeTangents() {
        const index = this.index;
        const attributes = this.attributes;
        // based on http://www.terathon.com/code/tangent.html
        // (per vertex tangents)
        if (index === null || attributes.position === undefined || attributes.normal === undefined || attributes.uv === undefined) {
            console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
            return;
        }
        const indices = index.array;
        const positions = attributes.position.array;
        const normals = attributes.normal.array;
        const uvs = attributes.uv.array;
        const nVertices = positions.length / 3;
        if (this.hasAttribute("tangent") === false) this.setAttribute("tangent", new $084574008ccedf86$export$8dea267bd6bde117(new Float32Array(4 * nVertices), 4));
        const tangents = this.getAttribute("tangent").array;
        const tan1 = [], tan2 = [];
        for(let i58 = 0; i58 < nVertices; i58++){
            tan1[i58] = new $084574008ccedf86$export$64b5c384219d3699();
            tan2[i58] = new $084574008ccedf86$export$64b5c384219d3699();
        }
        const vA = new $084574008ccedf86$export$64b5c384219d3699(), vB = new $084574008ccedf86$export$64b5c384219d3699(), vC = new $084574008ccedf86$export$64b5c384219d3699(), uvA = new $084574008ccedf86$export$c977b3e384af9ae1(), uvB = new $084574008ccedf86$export$c977b3e384af9ae1(), uvC = new $084574008ccedf86$export$c977b3e384af9ae1(), sdir = new $084574008ccedf86$export$64b5c384219d3699(), tdir = new $084574008ccedf86$export$64b5c384219d3699();
        function handleTriangle(a, b, c) {
            vA.fromArray(positions, a * 3);
            vB.fromArray(positions, b * 3);
            vC.fromArray(positions, c * 3);
            uvA.fromArray(uvs, a * 2);
            uvB.fromArray(uvs, b * 2);
            uvC.fromArray(uvs, c * 2);
            vB.sub(vA);
            vC.sub(vA);
            uvB.sub(uvA);
            uvC.sub(uvA);
            const r = 1.0 / (uvB.x * uvC.y - uvC.x * uvB.y);
            // silently ignore degenerate uv triangles having coincident or colinear vertices
            if (!isFinite(r)) return;
            sdir.copy(vB).multiplyScalar(uvC.y).addScaledVector(vC, -uvB.y).multiplyScalar(r);
            tdir.copy(vC).multiplyScalar(uvB.x).addScaledVector(vB, -uvC.x).multiplyScalar(r);
            tan1[a].add(sdir);
            tan1[b].add(sdir);
            tan1[c].add(sdir);
            tan2[a].add(tdir);
            tan2[b].add(tdir);
            tan2[c].add(tdir);
        }
        let groups = this.groups;
        if (groups.length === 0) groups = [
            {
                start: 0,
                count: indices.length
            }
        ];
        for(let i56 = 0, il = groups.length; i56 < il; ++i56){
            const group = groups[i56];
            const start = group.start;
            const count = group.count;
            for(let j = start, jl = start + count; j < jl; j += 3)handleTriangle(indices[j + 0], indices[j + 1], indices[j + 2]);
        }
        const tmp3 = new $084574008ccedf86$export$64b5c384219d3699(), tmp2 = new $084574008ccedf86$export$64b5c384219d3699();
        const n = new $084574008ccedf86$export$64b5c384219d3699(), n2 = new $084574008ccedf86$export$64b5c384219d3699();
        function handleVertex(v) {
            n.fromArray(normals, v * 3);
            n2.copy(n);
            const t = tan1[v];
            // Gram-Schmidt orthogonalize
            tmp3.copy(t);
            tmp3.sub(n.multiplyScalar(n.dot(t))).normalize();
            // Calculate handedness
            tmp2.crossVectors(n2, t);
            const test = tmp2.dot(tan2[v]);
            const w = test < 0.0 ? -1 : 1.0;
            tangents[v * 4] = tmp3.x;
            tangents[v * 4 + 1] = tmp3.y;
            tangents[v * 4 + 2] = tmp3.z;
            tangents[v * 4 + 3] = w;
        }
        for(let i57 = 0, il3 = groups.length; i57 < il3; ++i57){
            const group = groups[i57];
            const start = group.start;
            const count = group.count;
            for(let j = start, jl = start + count; j < jl; j += 3){
                handleVertex(indices[j + 0]);
                handleVertex(indices[j + 1]);
                handleVertex(indices[j + 2]);
            }
        }
    }
    computeVertexNormals() {
        const index = this.index;
        const positionAttribute = this.getAttribute("position");
        if (positionAttribute !== undefined) {
            let normalAttribute = this.getAttribute("normal");
            if (normalAttribute === undefined) {
                normalAttribute = new $084574008ccedf86$export$8dea267bd6bde117(new Float32Array(positionAttribute.count * 3), 3);
                this.setAttribute("normal", normalAttribute);
            } else // reset existing normals to zero
            for(let i61 = 0, il = normalAttribute.count; i61 < il; i61++)normalAttribute.setXYZ(i61, 0, 0, 0);
            const pA = new $084574008ccedf86$export$64b5c384219d3699(), pB = new $084574008ccedf86$export$64b5c384219d3699(), pC = new $084574008ccedf86$export$64b5c384219d3699();
            const nA = new $084574008ccedf86$export$64b5c384219d3699(), nB = new $084574008ccedf86$export$64b5c384219d3699(), nC = new $084574008ccedf86$export$64b5c384219d3699();
            const cb = new $084574008ccedf86$export$64b5c384219d3699(), ab = new $084574008ccedf86$export$64b5c384219d3699();
            // indexed elements
            if (index) for(let i59 = 0, il4 = index.count; i59 < il4; i59 += 3){
                const vA = index.getX(i59 + 0);
                const vB = index.getX(i59 + 1);
                const vC = index.getX(i59 + 2);
                pA.fromBufferAttribute(positionAttribute, vA);
                pB.fromBufferAttribute(positionAttribute, vB);
                pC.fromBufferAttribute(positionAttribute, vC);
                cb.subVectors(pC, pB);
                ab.subVectors(pA, pB);
                cb.cross(ab);
                nA.fromBufferAttribute(normalAttribute, vA);
                nB.fromBufferAttribute(normalAttribute, vB);
                nC.fromBufferAttribute(normalAttribute, vC);
                nA.add(cb);
                nB.add(cb);
                nC.add(cb);
                normalAttribute.setXYZ(vA, nA.x, nA.y, nA.z);
                normalAttribute.setXYZ(vB, nB.x, nB.y, nB.z);
                normalAttribute.setXYZ(vC, nC.x, nC.y, nC.z);
            }
            else // non-indexed elements (unconnected triangle soup)
            for(let i60 = 0, il5 = positionAttribute.count; i60 < il5; i60 += 3){
                pA.fromBufferAttribute(positionAttribute, i60 + 0);
                pB.fromBufferAttribute(positionAttribute, i60 + 1);
                pC.fromBufferAttribute(positionAttribute, i60 + 2);
                cb.subVectors(pC, pB);
                ab.subVectors(pA, pB);
                cb.cross(ab);
                normalAttribute.setXYZ(i60 + 0, cb.x, cb.y, cb.z);
                normalAttribute.setXYZ(i60 + 1, cb.x, cb.y, cb.z);
                normalAttribute.setXYZ(i60 + 2, cb.x, cb.y, cb.z);
            }
            this.normalizeNormals();
            normalAttribute.needsUpdate = true;
        }
    }
    merge(geometry, offset) {
        if (!(geometry && geometry.isBufferGeometry)) {
            console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", geometry);
            return;
        }
        if (offset === undefined) {
            offset = 0;
            console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.");
        }
        const attributes = this.attributes;
        for(const key in attributes){
            if (geometry.attributes[key] === undefined) continue;
            const attribute1 = attributes[key];
            const attributeArray1 = attribute1.array;
            const attribute2 = geometry.attributes[key];
            const attributeArray2 = attribute2.array;
            const attributeOffset = attribute2.itemSize * offset;
            const length = Math.min(attributeArray2.length, attributeArray1.length - attributeOffset);
            for(let i62 = 0, j = attributeOffset; i62 < length; i62++, j++)attributeArray1[j] = attributeArray2[i62];
        }
        return this;
    }
    normalizeNormals() {
        const normals = this.attributes.normal;
        for(let i63 = 0, il = normals.count; i63 < il; i63++){
            $084574008ccedf86$var$_vector$8.fromBufferAttribute(normals, i63);
            $084574008ccedf86$var$_vector$8.normalize();
            normals.setXYZ(i63, $084574008ccedf86$var$_vector$8.x, $084574008ccedf86$var$_vector$8.y, $084574008ccedf86$var$_vector$8.z);
        }
    }
    toNonIndexed() {
        function convertBufferAttribute(attribute, indices) {
            const array = attribute.array;
            const itemSize = attribute.itemSize;
            const normalized = attribute.normalized;
            const array2 = new array.constructor(indices.length * itemSize);
            let index = 0, index2 = 0;
            for(let i65 = 0, l = indices.length; i65 < l; i65++){
                if (attribute.isInterleavedBufferAttribute) index = indices[i65] * attribute.data.stride + attribute.offset;
                else index = indices[i65] * itemSize;
                for(let j = 0; j < itemSize; j++)array2[index2++] = array[index++];
            }
            return new $084574008ccedf86$export$8dea267bd6bde117(array2, itemSize, normalized);
        }
        //
        if (this.index === null) {
            console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.");
            return this;
        }
        const geometry2 = new $084574008ccedf86$export$b7be63a67df8959();
        const indices1 = this.index.array;
        const attributes = this.attributes;
        // attributes
        for(const name in attributes){
            const attribute = attributes[name];
            const newAttribute = convertBufferAttribute(attribute, indices1);
            geometry2.setAttribute(name, newAttribute);
        }
        // morph attributes
        const morphAttributes = this.morphAttributes;
        for(const name1 in morphAttributes){
            const morphArray = [];
            const morphAttribute = morphAttributes[name1]; // morphAttribute: array of Float32BufferAttributes
            for(let i66 = 0, il = morphAttribute.length; i66 < il; i66++){
                const attribute = morphAttribute[i66];
                const newAttribute = convertBufferAttribute(attribute, indices1);
                morphArray.push(newAttribute);
            }
            geometry2.morphAttributes[name1] = morphArray;
        }
        geometry2.morphTargetsRelative = this.morphTargetsRelative;
        // groups
        const groups = this.groups;
        for(let i64 = 0, l2 = groups.length; i64 < l2; i64++){
            const group = groups[i64];
            geometry2.addGroup(group.start, group.count, group.materialIndex);
        }
        return geometry2;
    }
    toJSON() {
        const data = {
            metadata: {
                version: 4.5,
                type: "BufferGeometry",
                generator: "BufferGeometry.toJSON"
            }
        };
        // standard BufferGeometry serialization
        data.uuid = this.uuid;
        data.type = this.type;
        if (this.name !== "") data.name = this.name;
        if (Object.keys(this.userData).length > 0) data.userData = this.userData;
        if (this.parameters !== undefined) {
            const parameters = this.parameters;
            for(const key in parameters)if (parameters[key] !== undefined) data[key] = parameters[key];
            return data;
        }
        // for simplicity the code assumes attributes are not shared across geometries, see #15811
        data.data = {
            attributes: {}
        };
        const index = this.index;
        if (index !== null) data.data.index = {
            type: index.array.constructor.name,
            array: Array.prototype.slice.call(index.array)
        };
        const attributes = this.attributes;
        for(const key in attributes){
            const attribute = attributes[key];
            data.data.attributes[key] = attribute.toJSON(data.data);
        }
        const morphAttributes = {};
        let hasMorphAttributes = false;
        for(const key1 in this.morphAttributes){
            const attributeArray = this.morphAttributes[key1];
            const array = [];
            for(let i67 = 0, il = attributeArray.length; i67 < il; i67++){
                const attribute = attributeArray[i67];
                array.push(attribute.toJSON(data.data));
            }
            if (array.length > 0) {
                morphAttributes[key1] = array;
                hasMorphAttributes = true;
            }
        }
        if (hasMorphAttributes) {
            data.data.morphAttributes = morphAttributes;
            data.data.morphTargetsRelative = this.morphTargetsRelative;
        }
        const groups = this.groups;
        if (groups.length > 0) data.data.groups = JSON.parse(JSON.stringify(groups));
        const boundingSphere = this.boundingSphere;
        if (boundingSphere !== null) data.data.boundingSphere = {
            center: boundingSphere.center.toArray(),
            radius: boundingSphere.radius
        };
        return data;
    }
    clone() {
        return new this.constructor().copy(this);
    }
    copy(source) {
        // reset
        this.index = null;
        this.attributes = {};
        this.morphAttributes = {};
        this.groups = [];
        this.boundingBox = null;
        this.boundingSphere = null;
        // used for storing cloned, shared data
        const data = {};
        // name
        this.name = source.name;
        // index
        const index = source.index;
        if (index !== null) this.setIndex(index.clone(data));
        // attributes
        const attributes = source.attributes;
        for(const name in attributes){
            const attribute = attributes[name];
            this.setAttribute(name, attribute.clone(data));
        }
        // morph attributes
        const morphAttributes = source.morphAttributes;
        for(const name2 in morphAttributes){
            const array = [];
            const morphAttribute = morphAttributes[name2]; // morphAttribute: array of Float32BufferAttributes
            for(let i68 = 0, l = morphAttribute.length; i68 < l; i68++)array.push(morphAttribute[i68].clone(data));
            this.morphAttributes[name2] = array;
        }
        this.morphTargetsRelative = source.morphTargetsRelative;
        // groups
        const groups = source.groups;
        for(let i69 = 0, l = groups.length; i69 < l; i69++){
            const group = groups[i69];
            this.addGroup(group.start, group.count, group.materialIndex);
        }
        // bounding box
        const boundingBox = source.boundingBox;
        if (boundingBox !== null) this.boundingBox = boundingBox.clone();
        // bounding sphere
        const boundingSphere = source.boundingSphere;
        if (boundingSphere !== null) this.boundingSphere = boundingSphere.clone();
        // draw range
        this.drawRange.start = source.drawRange.start;
        this.drawRange.count = source.drawRange.count;
        // user data
        this.userData = source.userData;
        // geometry generator parameters
        if (source.parameters !== undefined) this.parameters = Object.assign({}, source.parameters);
        return this;
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        });
    }
}
const $084574008ccedf86$var$_inverseMatrix$2 = /*@__PURE__*/ new $084574008ccedf86$export$2ae72fc923e5eb5();
const $084574008ccedf86$var$_ray$2 = /*@__PURE__*/ new $084574008ccedf86$export$a186db52eed6d40e();
const $084574008ccedf86$var$_sphere$3 = /*@__PURE__*/ new $084574008ccedf86$export$805e8b72413ccaba();
const $084574008ccedf86$var$_vA$1 = /*@__PURE__*/ new $084574008ccedf86$export$64b5c384219d3699();
const $084574008ccedf86$var$_vB$1 = /*@__PURE__*/ new $084574008ccedf86$export$64b5c384219d3699();
const $084574008ccedf86$var$_vC$1 = /*@__PURE__*/ new $084574008ccedf86$export$64b5c384219d3699();
const $084574008ccedf86$var$_tempA = /*@__PURE__*/ new $084574008ccedf86$export$64b5c384219d3699();
const $084574008ccedf86$var$_tempB = /*@__PURE__*/ new $084574008ccedf86$export$64b5c384219d3699();
const $084574008ccedf86$var$_tempC = /*@__PURE__*/ new $084574008ccedf86$export$64b5c384219d3699();
const $084574008ccedf86$var$_morphA = /*@__PURE__*/ new $084574008ccedf86$export$64b5c384219d3699();
const $084574008ccedf86$var$_morphB = /*@__PURE__*/ new $084574008ccedf86$export$64b5c384219d3699();
const $084574008ccedf86$var$_morphC = /*@__PURE__*/ new $084574008ccedf86$export$64b5c384219d3699();
const $084574008ccedf86$var$_uvA$1 = /*@__PURE__*/ new $084574008ccedf86$export$c977b3e384af9ae1();
const $084574008ccedf86$var$_uvB$1 = /*@__PURE__*/ new $084574008ccedf86$export$c977b3e384af9ae1();
const $084574008ccedf86$var$_uvC$1 = /*@__PURE__*/ new $084574008ccedf86$export$c977b3e384af9ae1();
const $084574008ccedf86$var$_intersectionPoint = /*@__PURE__*/ new $084574008ccedf86$export$64b5c384219d3699();
const $084574008ccedf86$var$_intersectionPointWorld = /*@__PURE__*/ new $084574008ccedf86$export$64b5c384219d3699();
class $084574008ccedf86$export$e176487c05830cc5 extends $084574008ccedf86$export$e4dd07dff30cc924 {
    constructor(geometry = new $084574008ccedf86$export$b7be63a67df8959(), material = new $084574008ccedf86$export$55cbcc9b622fe1f5()){
        super();
        this.isMesh = true;
        this.type = "Mesh";
        this.geometry = geometry;
        this.material = material;
        this.updateMorphTargets();
    }
    copy(source, recursive) {
        super.copy(source, recursive);
        if (source.morphTargetInfluences !== undefined) this.morphTargetInfluences = source.morphTargetInfluences.slice();
        if (source.morphTargetDictionary !== undefined) this.morphTargetDictionary = Object.assign({}, source.morphTargetDictionary);
        this.material = source.material;
        this.geometry = source.geometry;
        return this;
    }
    updateMorphTargets() {
        const geometry = this.geometry;
        const morphAttributes = geometry.morphAttributes;
        const keys = Object.keys(morphAttributes);
        if (keys.length > 0) {
            const morphAttribute = morphAttributes[keys[0]];
            if (morphAttribute !== undefined) {
                this.morphTargetInfluences = [];
                this.morphTargetDictionary = {};
                for(let m = 0, ml = morphAttribute.length; m < ml; m++){
                    const name = morphAttribute[m].name || String(m);
                    this.morphTargetInfluences.push(0);
                    this.morphTargetDictionary[name] = m;
                }
            }
        }
    }
    raycast(raycaster, intersects1) {
        const geometry = this.geometry;
        const material = this.material;
        const matrixWorld = this.matrixWorld;
        if (material === undefined) return;
        // Checking boundingSphere distance to ray
        if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
        $084574008ccedf86$var$_sphere$3.copy(geometry.boundingSphere);
        $084574008ccedf86$var$_sphere$3.applyMatrix4(matrixWorld);
        if (raycaster.ray.intersectsSphere($084574008ccedf86$var$_sphere$3) === false) return;
        //
        $084574008ccedf86$var$_inverseMatrix$2.copy(matrixWorld).invert();
        $084574008ccedf86$var$_ray$2.copy(raycaster.ray).applyMatrix4($084574008ccedf86$var$_inverseMatrix$2);
        // Check boundingBox before continuing
        if (geometry.boundingBox !== null) {
            if ($084574008ccedf86$var$_ray$2.intersectsBox(geometry.boundingBox) === false) return;
        }
        let intersection;
        const index = geometry.index;
        const position = geometry.attributes.position;
        const morphPosition = geometry.morphAttributes.position;
        const morphTargetsRelative = geometry.morphTargetsRelative;
        const uv = geometry.attributes.uv;
        const uv2 = geometry.attributes.uv2;
        const groups = geometry.groups;
        const drawRange = geometry.drawRange;
        if (index !== null) {
            // indexed buffer geometry
            if (Array.isArray(material)) for(let i70 = 0, il = groups.length; i70 < il; i70++){
                const group = groups[i70];
                const groupMaterial = material[group.materialIndex];
                const start = Math.max(group.start, drawRange.start);
                const end = Math.min(index.count, Math.min(group.start + group.count, drawRange.start + drawRange.count));
                for(let j = start, jl = end; j < jl; j += 3){
                    const a = index.getX(j);
                    const b = index.getX(j + 1);
                    const c = index.getX(j + 2);
                    intersection = $084574008ccedf86$var$checkBufferGeometryIntersection(this, groupMaterial, raycaster, $084574008ccedf86$var$_ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);
                    if (intersection) {
                        intersection.faceIndex = Math.floor(j / 3); // triangle number in indexed buffer semantics
                        intersection.face.materialIndex = group.materialIndex;
                        intersects1.push(intersection);
                    }
                }
            }
            else {
                const start = Math.max(0, drawRange.start);
                const end = Math.min(index.count, drawRange.start + drawRange.count);
                for(let i71 = start, il = end; i71 < il; i71 += 3){
                    const a = index.getX(i71);
                    const b = index.getX(i71 + 1);
                    const c = index.getX(i71 + 2);
                    intersection = $084574008ccedf86$var$checkBufferGeometryIntersection(this, material, raycaster, $084574008ccedf86$var$_ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);
                    if (intersection) {
                        intersection.faceIndex = Math.floor(i71 / 3); // triangle number in indexed buffer semantics
                        intersects1.push(intersection);
                    }
                }
            }
        } else if (position !== undefined) {
            // non-indexed buffer geometry
            if (Array.isArray(material)) for(let i72 = 0, il = groups.length; i72 < il; i72++){
                const group = groups[i72];
                const groupMaterial = material[group.materialIndex];
                const start = Math.max(group.start, drawRange.start);
                const end = Math.min(position.count, Math.min(group.start + group.count, drawRange.start + drawRange.count));
                for(let j = start, jl = end; j < jl; j += 3){
                    const a = j;
                    const b = j + 1;
                    const c = j + 2;
                    intersection = $084574008ccedf86$var$checkBufferGeometryIntersection(this, groupMaterial, raycaster, $084574008ccedf86$var$_ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);
                    if (intersection) {
                        intersection.faceIndex = Math.floor(j / 3); // triangle number in non-indexed buffer semantics
                        intersection.face.materialIndex = group.materialIndex;
                        intersects1.push(intersection);
                    }
                }
            }
            else {
                const start = Math.max(0, drawRange.start);
                const end = Math.min(position.count, drawRange.start + drawRange.count);
                for(let i73 = start, il = end; i73 < il; i73 += 3){
                    const a = i73;
                    const b = i73 + 1;
                    const c = i73 + 2;
                    intersection = $084574008ccedf86$var$checkBufferGeometryIntersection(this, material, raycaster, $084574008ccedf86$var$_ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);
                    if (intersection) {
                        intersection.faceIndex = Math.floor(i73 / 3); // triangle number in non-indexed buffer semantics
                        intersects1.push(intersection);
                    }
                }
            }
        }
    }
}
function $084574008ccedf86$var$checkIntersection(object, material, raycaster, ray, pA, pB, pC, point) {
    let intersect;
    if (material.side === $084574008ccedf86$export$d9f0486e75b5ace) intersect = ray.intersectTriangle(pC, pB, pA, true, point);
    else intersect = ray.intersectTriangle(pA, pB, pC, material.side !== $084574008ccedf86$export$3b296b6f144d5b03, point);
    if (intersect === null) return null;
    $084574008ccedf86$var$_intersectionPointWorld.copy(point);
    $084574008ccedf86$var$_intersectionPointWorld.applyMatrix4(object.matrixWorld);
    const distance = raycaster.ray.origin.distanceTo($084574008ccedf86$var$_intersectionPointWorld);
    if (distance < raycaster.near || distance > raycaster.far) return null;
    return {
        distance: distance,
        point: $084574008ccedf86$var$_intersectionPointWorld.clone(),
        object: object
    };
}
function $084574008ccedf86$var$checkBufferGeometryIntersection(object, material, raycaster, ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c) {
    $084574008ccedf86$var$_vA$1.fromBufferAttribute(position, a);
    $084574008ccedf86$var$_vB$1.fromBufferAttribute(position, b);
    $084574008ccedf86$var$_vC$1.fromBufferAttribute(position, c);
    const morphInfluences = object.morphTargetInfluences;
    if (morphPosition && morphInfluences) {
        $084574008ccedf86$var$_morphA.set(0, 0, 0);
        $084574008ccedf86$var$_morphB.set(0, 0, 0);
        $084574008ccedf86$var$_morphC.set(0, 0, 0);
        for(let i74 = 0, il = morphPosition.length; i74 < il; i74++){
            const influence = morphInfluences[i74];
            const morphAttribute = morphPosition[i74];
            if (influence === 0) continue;
            $084574008ccedf86$var$_tempA.fromBufferAttribute(morphAttribute, a);
            $084574008ccedf86$var$_tempB.fromBufferAttribute(morphAttribute, b);
            $084574008ccedf86$var$_tempC.fromBufferAttribute(morphAttribute, c);
            if (morphTargetsRelative) {
                $084574008ccedf86$var$_morphA.addScaledVector($084574008ccedf86$var$_tempA, influence);
                $084574008ccedf86$var$_morphB.addScaledVector($084574008ccedf86$var$_tempB, influence);
                $084574008ccedf86$var$_morphC.addScaledVector($084574008ccedf86$var$_tempC, influence);
            } else {
                $084574008ccedf86$var$_morphA.addScaledVector($084574008ccedf86$var$_tempA.sub($084574008ccedf86$var$_vA$1), influence);
                $084574008ccedf86$var$_morphB.addScaledVector($084574008ccedf86$var$_tempB.sub($084574008ccedf86$var$_vB$1), influence);
                $084574008ccedf86$var$_morphC.addScaledVector($084574008ccedf86$var$_tempC.sub($084574008ccedf86$var$_vC$1), influence);
            }
        }
        $084574008ccedf86$var$_vA$1.add($084574008ccedf86$var$_morphA);
        $084574008ccedf86$var$_vB$1.add($084574008ccedf86$var$_morphB);
        $084574008ccedf86$var$_vC$1.add($084574008ccedf86$var$_morphC);
    }
    if (object.isSkinnedMesh) {
        object.boneTransform(a, $084574008ccedf86$var$_vA$1);
        object.boneTransform(b, $084574008ccedf86$var$_vB$1);
        object.boneTransform(c, $084574008ccedf86$var$_vC$1);
    }
    const intersection = $084574008ccedf86$var$checkIntersection(object, material, raycaster, ray, $084574008ccedf86$var$_vA$1, $084574008ccedf86$var$_vB$1, $084574008ccedf86$var$_vC$1, $084574008ccedf86$var$_intersectionPoint);
    if (intersection) {
        if (uv) {
            $084574008ccedf86$var$_uvA$1.fromBufferAttribute(uv, a);
            $084574008ccedf86$var$_uvB$1.fromBufferAttribute(uv, b);
            $084574008ccedf86$var$_uvC$1.fromBufferAttribute(uv, c);
            intersection.uv = $084574008ccedf86$export$5a465592bfe74b48.getUV($084574008ccedf86$var$_intersectionPoint, $084574008ccedf86$var$_vA$1, $084574008ccedf86$var$_vB$1, $084574008ccedf86$var$_vC$1, $084574008ccedf86$var$_uvA$1, $084574008ccedf86$var$_uvB$1, $084574008ccedf86$var$_uvC$1, new $084574008ccedf86$export$c977b3e384af9ae1());
        }
        if (uv2) {
            $084574008ccedf86$var$_uvA$1.fromBufferAttribute(uv2, a);
            $084574008ccedf86$var$_uvB$1.fromBufferAttribute(uv2, b);
            $084574008ccedf86$var$_uvC$1.fromBufferAttribute(uv2, c);
            intersection.uv2 = $084574008ccedf86$export$5a465592bfe74b48.getUV($084574008ccedf86$var$_intersectionPoint, $084574008ccedf86$var$_vA$1, $084574008ccedf86$var$_vB$1, $084574008ccedf86$var$_vC$1, $084574008ccedf86$var$_uvA$1, $084574008ccedf86$var$_uvB$1, $084574008ccedf86$var$_uvC$1, new $084574008ccedf86$export$c977b3e384af9ae1());
        }
        const face = {
            a: a,
            b: b,
            c: c,
            normal: new $084574008ccedf86$export$64b5c384219d3699(),
            materialIndex: 0
        };
        $084574008ccedf86$export$5a465592bfe74b48.getNormal($084574008ccedf86$var$_vA$1, $084574008ccedf86$var$_vB$1, $084574008ccedf86$var$_vC$1, face.normal);
        intersection.face = face;
    }
    return intersection;
}
class $084574008ccedf86$export$ab3456a079aa7d80 extends $084574008ccedf86$export$b7be63a67df8959 {
    constructor(width1 = 1, height1 = 1, depth1 = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1){
        super();
        this.type = "BoxGeometry";
        this.parameters = {
            width: width1,
            height: height1,
            depth: depth1,
            widthSegments: widthSegments,
            heightSegments: heightSegments,
            depthSegments: depthSegments
        };
        const scope = this;
        // segments
        widthSegments = Math.floor(widthSegments);
        heightSegments = Math.floor(heightSegments);
        depthSegments = Math.floor(depthSegments);
        // buffers
        const indices = [];
        const vertices = [];
        const normals = [];
        const uvs = [];
        // helper variables
        let numberOfVertices = 0;
        let groupStart = 0;
        // build each side of the box geometry
        buildPlane("z", "y", "x", -1, -1, depth1, height1, width1, depthSegments, heightSegments, 0); // px
        buildPlane("z", "y", "x", 1, -1, depth1, height1, -width1, depthSegments, heightSegments, 1); // nx
        buildPlane("x", "z", "y", 1, 1, width1, depth1, height1, widthSegments, depthSegments, 2); // py
        buildPlane("x", "z", "y", 1, -1, width1, depth1, -height1, widthSegments, depthSegments, 3); // ny
        buildPlane("x", "y", "z", 1, -1, width1, height1, depth1, widthSegments, heightSegments, 4); // pz
        buildPlane("x", "y", "z", -1, -1, width1, height1, -depth1, widthSegments, heightSegments, 5); // nz
        // build geometry
        this.setIndex(indices);
        this.setAttribute("position", new $084574008ccedf86$export$cbe7a62641830ebd(vertices, 3));
        this.setAttribute("normal", new $084574008ccedf86$export$cbe7a62641830ebd(normals, 3));
        this.setAttribute("uv", new $084574008ccedf86$export$cbe7a62641830ebd(uvs, 2));
        function buildPlane(u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex) {
            const segmentWidth = width / gridX;
            const segmentHeight = height / gridY;
            const widthHalf = width / 2;
            const heightHalf = height / 2;
            const depthHalf = depth / 2;
            const gridX1 = gridX + 1;
            const gridY1 = gridY + 1;
            let vertexCounter = 0;
            let groupCount = 0;
            const vector = new $084574008ccedf86$export$64b5c384219d3699();
            // generate vertices, normals and uvs
            for(let iy = 0; iy < gridY1; iy++){
                const y = iy * segmentHeight - heightHalf;
                for(let ix = 0; ix < gridX1; ix++){
                    const x = ix * segmentWidth - widthHalf;
                    // set values to correct vector component
                    vector[u] = x * udir;
                    vector[v] = y * vdir;
                    vector[w] = depthHalf;
                    // now apply vector to vertex buffer
                    vertices.push(vector.x, vector.y, vector.z);
                    // set values to correct vector component
                    vector[u] = 0;
                    vector[v] = 0;
                    vector[w] = depth > 0 ? 1 : -1;
                    // now apply vector to normal buffer
                    normals.push(vector.x, vector.y, vector.z);
                    // uvs
                    uvs.push(ix / gridX);
                    uvs.push(1 - iy / gridY);
                    // counters
                    vertexCounter += 1;
                }
            }
            // indices
            // 1. you need three indices to draw a single face
            // 2. a single segment consists of two faces
            // 3. so we need to generate six (2*3) indices per segment
            for(let iy1 = 0; iy1 < gridY; iy1++)for(let ix = 0; ix < gridX; ix++){
                const a = numberOfVertices + ix + gridX1 * iy1;
                const b = numberOfVertices + ix + gridX1 * (iy1 + 1);
                const c = numberOfVertices + (ix + 1) + gridX1 * (iy1 + 1);
                const d = numberOfVertices + (ix + 1) + gridX1 * iy1;
                // faces
                indices.push(a, b, d);
                indices.push(b, c, d);
                // increase counter
                groupCount += 6;
            }
            // add a group to the geometry. this will ensure multi material support
            scope.addGroup(groupStart, groupCount, materialIndex);
            // calculate new start value for groups
            groupStart += groupCount;
            // update total number of vertices
            numberOfVertices += vertexCounter;
        }
    }
    static fromJSON(data) {
        return new $084574008ccedf86$export$ab3456a079aa7d80(data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments);
    }
}
/**
 * Uniform Utilities
 */ function $084574008ccedf86$var$cloneUniforms(src) {
    const dst = {};
    for(const u in src){
        dst[u] = {};
        for(const p in src[u]){
            const property = src[u][p];
            if (property && (property.isColor || property.isMatrix3 || property.isMatrix4 || property.isVector2 || property.isVector3 || property.isVector4 || property.isTexture || property.isQuaternion)) dst[u][p] = property.clone();
            else if (Array.isArray(property)) dst[u][p] = property.slice();
            else dst[u][p] = property;
        }
    }
    return dst;
}
function $084574008ccedf86$var$mergeUniforms(uniforms) {
    const merged = {};
    for(let u = 0; u < uniforms.length; u++){
        const tmp4 = $084574008ccedf86$var$cloneUniforms(uniforms[u]);
        for(const p in tmp4)merged[p] = tmp4[p];
    }
    return merged;
}
// Legacy
const $084574008ccedf86$export$d8ecdf8615bfea69 = {
    clone: $084574008ccedf86$var$cloneUniforms,
    merge: $084574008ccedf86$var$mergeUniforms
};
var $084574008ccedf86$var$default_vertex = "void main() {\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";
var $084574008ccedf86$var$default_fragment = "void main() {\n	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";
class $084574008ccedf86$export$83c7d75d550a8b0d extends $084574008ccedf86$export$a2d8b23205c25948 {
    constructor(parameters){
        super();
        this.isShaderMaterial = true;
        this.type = "ShaderMaterial";
        this.defines = {};
        this.uniforms = {};
        this.vertexShader = $084574008ccedf86$var$default_vertex;
        this.fragmentShader = $084574008ccedf86$var$default_fragment;
        this.linewidth = 1;
        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.fog = false; // set to use scene fog
        this.lights = false; // set to use scene lights
        this.clipping = false; // set to use user-defined clipping planes
        this.extensions = {
            derivatives: false,
            fragDepth: false,
            drawBuffers: false,
            shaderTextureLOD: false // set to use shader texture LOD
        };
        // When rendered geometry doesn't include these attributes but the material does,
        // use these default values in WebGL. This avoids errors when buffer data is missing.
        this.defaultAttributeValues = {
            "color": [
                1,
                1,
                1
            ],
            "uv": [
                0,
                0
            ],
            "uv2": [
                0,
                0
            ]
        };
        this.index0AttributeName = undefined;
        this.uniformsNeedUpdate = false;
        this.glslVersion = null;
        if (parameters !== undefined) {
            if (parameters.attributes !== undefined) console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.");
            this.setValues(parameters);
        }
    }
    copy(source) {
        super.copy(source);
        this.fragmentShader = source.fragmentShader;
        this.vertexShader = source.vertexShader;
        this.uniforms = $084574008ccedf86$var$cloneUniforms(source.uniforms);
        this.defines = Object.assign({}, source.defines);
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        this.fog = source.fog;
        this.lights = source.lights;
        this.clipping = source.clipping;
        this.extensions = Object.assign({}, source.extensions);
        this.glslVersion = source.glslVersion;
        return this;
    }
    toJSON(meta) {
        const data = super.toJSON(meta);
        data.glslVersion = this.glslVersion;
        data.uniforms = {};
        for(const name in this.uniforms){
            const uniform = this.uniforms[name];
            const value = uniform.value;
            if (value && value.isTexture) data.uniforms[name] = {
                type: "t",
                value: value.toJSON(meta).uuid
            };
            else if (value && value.isColor) data.uniforms[name] = {
                type: "c",
                value: value.getHex()
            };
            else if (value && value.isVector2) data.uniforms[name] = {
                type: "v2",
                value: value.toArray()
            };
            else if (value && value.isVector3) data.uniforms[name] = {
                type: "v3",
                value: value.toArray()
            };
            else if (value && value.isVector4) data.uniforms[name] = {
                type: "v4",
                value: value.toArray()
            };
            else if (value && value.isMatrix3) data.uniforms[name] = {
                type: "m3",
                value: value.toArray()
            };
            else if (value && value.isMatrix4) data.uniforms[name] = {
                type: "m4",
                value: value.toArray()
            };
            else data.uniforms[name] = {
                value: value
            };
        }
        if (Object.keys(this.defines).length > 0) data.defines = this.defines;
        data.vertexShader = this.vertexShader;
        data.fragmentShader = this.fragmentShader;
        const extensions = {};
        for(const key in this.extensions)if (this.extensions[key] === true) extensions[key] = true;
        if (Object.keys(extensions).length > 0) data.extensions = extensions;
        return data;
    }
}
class $084574008ccedf86$export$79f141de891a5fed extends $084574008ccedf86$export$e4dd07dff30cc924 {
    constructor(){
        super();
        this.isCamera = true;
        this.type = "Camera";
        this.matrixWorldInverse = new $084574008ccedf86$export$2ae72fc923e5eb5();
        this.projectionMatrix = new $084574008ccedf86$export$2ae72fc923e5eb5();
        this.projectionMatrixInverse = new $084574008ccedf86$export$2ae72fc923e5eb5();
    }
    copy(source, recursive) {
        super.copy(source, recursive);
        this.matrixWorldInverse.copy(source.matrixWorldInverse);
        this.projectionMatrix.copy(source.projectionMatrix);
        this.projectionMatrixInverse.copy(source.projectionMatrixInverse);
        return this;
    }
    getWorldDirection(target) {
        this.updateWorldMatrix(true, false);
        const e = this.matrixWorld.elements;
        return target.set(-e[8], -e[9], -e[10]).normalize();
    }
    updateMatrixWorld(force) {
        super.updateMatrixWorld(force);
        this.matrixWorldInverse.copy(this.matrixWorld).invert();
    }
    updateWorldMatrix(updateParents, updateChildren) {
        super.updateWorldMatrix(updateParents, updateChildren);
        this.matrixWorldInverse.copy(this.matrixWorld).invert();
    }
    clone() {
        return new this.constructor().copy(this);
    }
}
class $084574008ccedf86$export$74e4ae24825f68d7 extends $084574008ccedf86$export$79f141de891a5fed {
    constructor(fov1 = 50, aspect1 = 1, near = 0.1, far = 2000){
        super();
        this.isPerspectiveCamera = true;
        this.type = "PerspectiveCamera";
        this.fov = fov1;
        this.zoom = 1;
        this.near = near;
        this.far = far;
        this.focus = 10;
        this.aspect = aspect1;
        this.view = null;
        this.filmGauge = 35; // width of the film (default in millimeters)
        this.filmOffset = 0; // horizontal film offset (same unit as gauge)
        this.updateProjectionMatrix();
    }
    copy(source, recursive) {
        super.copy(source, recursive);
        this.fov = source.fov;
        this.zoom = source.zoom;
        this.near = source.near;
        this.far = source.far;
        this.focus = source.focus;
        this.aspect = source.aspect;
        this.view = source.view === null ? null : Object.assign({}, source.view);
        this.filmGauge = source.filmGauge;
        this.filmOffset = source.filmOffset;
        return this;
    }
    /**
	 * Sets the FOV by focal length in respect to the current .filmGauge.
	 *
	 * The default film gauge is 35, so that the focal length can be specified for
	 * a 35mm (full frame) camera.
	 *
	 * Values for focal length and film gauge must have the same unit.
	 */ setFocalLength(focalLength) {
        /** see {@link http://www.bobatkins.com/photography/technical/field_of_view.html} */ const vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;
        this.fov = $084574008ccedf86$var$RAD2DEG * 2 * Math.atan(vExtentSlope);
        this.updateProjectionMatrix();
    }
    /**
	 * Calculates the focal length from the current .fov and .filmGauge.
	 */ getFocalLength() {
        const vExtentSlope = Math.tan($084574008ccedf86$var$DEG2RAD * 0.5 * this.fov);
        return 0.5 * this.getFilmHeight() / vExtentSlope;
    }
    getEffectiveFOV() {
        return $084574008ccedf86$var$RAD2DEG * 2 * Math.atan(Math.tan($084574008ccedf86$var$DEG2RAD * 0.5 * this.fov) / this.zoom);
    }
    getFilmWidth() {
        // film not completely covered in portrait format (aspect < 1)
        return this.filmGauge * Math.min(this.aspect, 1);
    }
    getFilmHeight() {
        // film not completely covered in landscape format (aspect > 1)
        return this.filmGauge / Math.max(this.aspect, 1);
    }
    /**
	 * Sets an offset in a larger frustum. This is useful for multi-window or
	 * multi-monitor/multi-machine setups.
	 *
	 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
	 * the monitors are in grid like this
	 *
	 *   +---+---+---+
	 *   | A | B | C |
	 *   +---+---+---+
	 *   | D | E | F |
	 *   +---+---+---+
	 *
	 * then for each monitor you would call it like this
	 *
	 *   const w = 1920;
	 *   const h = 1080;
	 *   const fullWidth = w * 3;
	 *   const fullHeight = h * 2;
	 *
	 *   --A--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
	 *   --B--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
	 *   --C--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
	 *   --D--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
	 *   --E--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
	 *   --F--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
	 *
	 *   Note there is no reason monitors have to be the same size or in a grid.
	 */ setViewOffset(fullWidth, fullHeight, x, y, width, height) {
        this.aspect = fullWidth / fullHeight;
        if (this.view === null) this.view = {
            enabled: true,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
        };
        this.view.enabled = true;
        this.view.fullWidth = fullWidth;
        this.view.fullHeight = fullHeight;
        this.view.offsetX = x;
        this.view.offsetY = y;
        this.view.width = width;
        this.view.height = height;
        this.updateProjectionMatrix();
    }
    clearViewOffset() {
        if (this.view !== null) this.view.enabled = false;
        this.updateProjectionMatrix();
    }
    updateProjectionMatrix() {
        const near = this.near;
        let top = near * Math.tan($084574008ccedf86$var$DEG2RAD * 0.5 * this.fov) / this.zoom;
        let height = 2 * top;
        let width = this.aspect * height;
        let left = -0.5 * width;
        const view = this.view;
        if (this.view !== null && this.view.enabled) {
            const fullWidth = view.fullWidth, fullHeight = view.fullHeight;
            left += view.offsetX * width / fullWidth;
            top -= view.offsetY * height / fullHeight;
            width *= view.width / fullWidth;
            height *= view.height / fullHeight;
        }
        const skew = this.filmOffset;
        if (skew !== 0) left += near * skew / this.getFilmWidth();
        this.projectionMatrix.makePerspective(left, left + width, top, top - height, near, this.far);
        this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
    }
    toJSON(meta) {
        const data = super.toJSON(meta);
        data.object.fov = this.fov;
        data.object.zoom = this.zoom;
        data.object.near = this.near;
        data.object.far = this.far;
        data.object.focus = this.focus;
        data.object.aspect = this.aspect;
        if (this.view !== null) data.object.view = Object.assign({}, this.view);
        data.object.filmGauge = this.filmGauge;
        data.object.filmOffset = this.filmOffset;
        return data;
    }
}
const $084574008ccedf86$var$fov = 90, $084574008ccedf86$var$aspect = 1;
class $084574008ccedf86$export$d0cdd0bd804995de extends $084574008ccedf86$export$e4dd07dff30cc924 {
    constructor(near, far, renderTarget){
        super();
        this.type = "CubeCamera";
        if (renderTarget.isWebGLCubeRenderTarget !== true) {
            console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");
            return;
        }
        this.renderTarget = renderTarget;
        const cameraPX = new $084574008ccedf86$export$74e4ae24825f68d7($084574008ccedf86$var$fov, $084574008ccedf86$var$aspect, near, far);
        cameraPX.layers = this.layers;
        cameraPX.up.set(0, -1, 0);
        cameraPX.lookAt(new $084574008ccedf86$export$64b5c384219d3699(1, 0, 0));
        this.add(cameraPX);
        const cameraNX = new $084574008ccedf86$export$74e4ae24825f68d7($084574008ccedf86$var$fov, $084574008ccedf86$var$aspect, near, far);
        cameraNX.layers = this.layers;
        cameraNX.up.set(0, -1, 0);
        cameraNX.lookAt(new $084574008ccedf86$export$64b5c384219d3699(-1, 0, 0));
        this.add(cameraNX);
        const cameraPY = new $084574008ccedf86$export$74e4ae24825f68d7($084574008ccedf86$var$fov, $084574008ccedf86$var$aspect, near, far);
        cameraPY.layers = this.layers;
        cameraPY.up.set(0, 0, 1);
        cameraPY.lookAt(new $084574008ccedf86$export$64b5c384219d3699(0, 1, 0));
        this.add(cameraPY);
        const cameraNY = new $084574008ccedf86$export$74e4ae24825f68d7($084574008ccedf86$var$fov, $084574008ccedf86$var$aspect, near, far);
        cameraNY.layers = this.layers;
        cameraNY.up.set(0, 0, -1);
        cameraNY.lookAt(new $084574008ccedf86$export$64b5c384219d3699(0, -1, 0));
        this.add(cameraNY);
        const cameraPZ = new $084574008ccedf86$export$74e4ae24825f68d7($084574008ccedf86$var$fov, $084574008ccedf86$var$aspect, near, far);
        cameraPZ.layers = this.layers;
        cameraPZ.up.set(0, -1, 0);
        cameraPZ.lookAt(new $084574008ccedf86$export$64b5c384219d3699(0, 0, 1));
        this.add(cameraPZ);
        const cameraNZ = new $084574008ccedf86$export$74e4ae24825f68d7($084574008ccedf86$var$fov, $084574008ccedf86$var$aspect, near, far);
        cameraNZ.layers = this.layers;
        cameraNZ.up.set(0, -1, 0);
        cameraNZ.lookAt(new $084574008ccedf86$export$64b5c384219d3699(0, 0, -1));
        this.add(cameraNZ);
    }
    update(renderer, scene) {
        if (this.parent === null) this.updateMatrixWorld();
        const renderTarget = this.renderTarget;
        const [cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ] = this.children;
        const currentRenderTarget = renderer.getRenderTarget();
        const currentToneMapping = renderer.toneMapping;
        const currentXrEnabled = renderer.xr.enabled;
        renderer.toneMapping = $084574008ccedf86$export$9fcb6b4294603b2;
        renderer.xr.enabled = false;
        const generateMipmaps = renderTarget.texture.generateMipmaps;
        renderTarget.texture.generateMipmaps = false;
        renderer.setRenderTarget(renderTarget, 0);
        renderer.render(scene, cameraPX);
        renderer.setRenderTarget(renderTarget, 1);
        renderer.render(scene, cameraNX);
        renderer.setRenderTarget(renderTarget, 2);
        renderer.render(scene, cameraPY);
        renderer.setRenderTarget(renderTarget, 3);
        renderer.render(scene, cameraNY);
        renderer.setRenderTarget(renderTarget, 4);
        renderer.render(scene, cameraPZ);
        renderTarget.texture.generateMipmaps = generateMipmaps;
        renderer.setRenderTarget(renderTarget, 5);
        renderer.render(scene, cameraNZ);
        renderer.setRenderTarget(currentRenderTarget);
        renderer.toneMapping = currentToneMapping;
        renderer.xr.enabled = currentXrEnabled;
        renderTarget.texture.needsPMREMUpdate = true;
    }
}
class $084574008ccedf86$export$ee2e5a18258a4049 extends $084574008ccedf86$export$5431306cf43de24a {
    constructor(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding){
        images = images !== undefined ? images : [];
        mapping = mapping !== undefined ? mapping : $084574008ccedf86$export$8759762a6477f2c4;
        super(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
        this.isCubeTexture = true;
        this.flipY = false;
    }
    get images() {
        return this.image;
    }
    set images(value) {
        this.image = value;
    }
}
class $084574008ccedf86$export$ac386671d651941e extends $084574008ccedf86$export$3c052beb2e51e23f {
    constructor(size, options = {}){
        super(size, size, options);
        this.isWebGLCubeRenderTarget = true;
        const image = {
            width: size,
            height: size,
            depth: 1
        };
        const images = [
            image,
            image,
            image,
            image,
            image,
            image
        ];
        this.texture = new $084574008ccedf86$export$ee2e5a18258a4049(images, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);
        // By convention -- likely based on the RenderMan spec from the 1990's -- cube maps are specified by WebGL (and three.js)
        // in a coordinate system in which positive-x is to the right when looking up the positive-z axis -- in other words,
        // in a left-handed coordinate system. By continuing this convention, preexisting cube maps continued to render correctly.
        // three.js uses a right-handed coordinate system. So environment maps used in three.js appear to have px and nx swapped
        // and the flag isRenderTargetTexture controls this conversion. The flip is not required when using WebGLCubeRenderTarget.texture
        // as a cube texture (this is detected when isRenderTargetTexture is set to true for cube textures).
        this.texture.isRenderTargetTexture = true;
        this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;
        this.texture.minFilter = options.minFilter !== undefined ? options.minFilter : $084574008ccedf86$export$8a72f490b25c56c8;
    }
    fromEquirectangularTexture(renderer, texture) {
        this.texture.type = texture.type;
        this.texture.encoding = texture.encoding;
        this.texture.generateMipmaps = texture.generateMipmaps;
        this.texture.minFilter = texture.minFilter;
        this.texture.magFilter = texture.magFilter;
        const shader = {
            uniforms: {
                tEquirect: {
                    value: null
                }
            },
            vertexShader: /* glsl */ `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
            fragmentShader: /* glsl */ `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
        };
        const geometry = new $084574008ccedf86$export$ab3456a079aa7d80(5, 5, 5);
        const material = new $084574008ccedf86$export$83c7d75d550a8b0d({
            name: "CubemapFromEquirect",
            uniforms: $084574008ccedf86$var$cloneUniforms(shader.uniforms),
            vertexShader: shader.vertexShader,
            fragmentShader: shader.fragmentShader,
            side: $084574008ccedf86$export$d9f0486e75b5ace,
            blending: $084574008ccedf86$export$63b8d6b580fc65ba
        });
        material.uniforms.tEquirect.value = texture;
        const mesh = new $084574008ccedf86$export$e176487c05830cc5(geometry, material);
        const currentMinFilter = texture.minFilter;
        // Avoid blurred poles
        if (texture.minFilter === $084574008ccedf86$export$5d8599b6a933fb1b) texture.minFilter = $084574008ccedf86$export$8a72f490b25c56c8;
        const camera = new $084574008ccedf86$export$d0cdd0bd804995de(1, 10, this);
        camera.update(renderer, mesh);
        texture.minFilter = currentMinFilter;
        mesh.geometry.dispose();
        mesh.material.dispose();
        return this;
    }
    clear(renderer, color, depth, stencil) {
        const currentRenderTarget = renderer.getRenderTarget();
        for(let i75 = 0; i75 < 6; i75++){
            renderer.setRenderTarget(this, i75);
            renderer.clear(color, depth, stencil);
        }
        renderer.setRenderTarget(currentRenderTarget);
    }
}
const $084574008ccedf86$var$_vector1 = /*@__PURE__*/ new $084574008ccedf86$export$64b5c384219d3699();
const $084574008ccedf86$var$_vector2 = /*@__PURE__*/ new $084574008ccedf86$export$64b5c384219d3699();
const $084574008ccedf86$var$_normalMatrix = /*@__PURE__*/ new $084574008ccedf86$export$8ff26dafa08918();
class $084574008ccedf86$export$7ff5ac152ef991b0 {
    constructor(normal = new $084574008ccedf86$export$64b5c384219d3699(1, 0, 0), constant = 0){
        this.isPlane = true;
        // normal is assumed to be normalized
        this.normal = normal;
        this.constant = constant;
    }
    set(normal, constant) {
        this.normal.copy(normal);
        this.constant = constant;
        return this;
    }
    setComponents(x, y, z, w) {
        this.normal.set(x, y, z);
        this.constant = w;
        return this;
    }
    setFromNormalAndCoplanarPoint(normal, point) {
        this.normal.copy(normal);
        this.constant = -point.dot(this.normal);
        return this;
    }
    setFromCoplanarPoints(a, b, c) {
        const normal = $084574008ccedf86$var$_vector1.subVectors(c, b).cross($084574008ccedf86$var$_vector2.subVectors(a, b)).normalize();
        // Q: should an error be thrown if normal is zero (e.g. degenerate plane)?
        this.setFromNormalAndCoplanarPoint(normal, a);
        return this;
    }
    copy(plane) {
        this.normal.copy(plane.normal);
        this.constant = plane.constant;
        return this;
    }
    normalize() {
        // Note: will lead to a divide by zero if the plane is invalid.
        const inverseNormalLength = 1.0 / this.normal.length();
        this.normal.multiplyScalar(inverseNormalLength);
        this.constant *= inverseNormalLength;
        return this;
    }
    negate() {
        this.constant *= -1;
        this.normal.negate();
        return this;
    }
    distanceToPoint(point) {
        return this.normal.dot(point) + this.constant;
    }
    distanceToSphere(sphere) {
        return this.distanceToPoint(sphere.center) - sphere.radius;
    }
    projectPoint(point, target) {
        return target.copy(this.normal).multiplyScalar(-this.distanceToPoint(point)).add(point);
    }
    intersectLine(line, target) {
        const direction = line.delta($084574008ccedf86$var$_vector1);
        const denominator = this.normal.dot(direction);
        if (denominator === 0) {
            // line is coplanar, return origin
            if (this.distanceToPoint(line.start) === 0) return target.copy(line.start);
            // Unsure if this is the correct method to handle this case.
            return null;
        }
        const t = -(line.start.dot(this.normal) + this.constant) / denominator;
        if (t < 0 || t > 1) return null;
        return target.copy(direction).multiplyScalar(t).add(line.start);
    }
    intersectsLine(line) {
        // Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.
        const startSign = this.distanceToPoint(line.start);
        const endSign = this.distanceToPoint(line.end);
        return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;
    }
    intersectsBox(box) {
        return box.intersectsPlane(this);
    }
    intersectsSphere(sphere) {
        return sphere.intersectsPlane(this);
    }
    coplanarPoint(target) {
        return target.copy(this.normal).multiplyScalar(-this.constant);
    }
    applyMatrix4(matrix, optionalNormalMatrix) {
        const normalMatrix = optionalNormalMatrix || $084574008ccedf86$var$_normalMatrix.getNormalMatrix(matrix);
        const referencePoint = this.coplanarPoint($084574008ccedf86$var$_vector1).applyMatrix4(matrix);
        const normal = this.normal.applyMatrix3(normalMatrix).normalize();
        this.constant = -referencePoint.dot(normal);
        return this;
    }
    translate(offset) {
        this.constant -= offset.dot(this.normal);
        return this;
    }
    equals(plane) {
        return plane.normal.equals(this.normal) && plane.constant === this.constant;
    }
    clone() {
        return new this.constructor().copy(this);
    }
}
const $084574008ccedf86$var$_sphere$2 = /*@__PURE__*/ new $084574008ccedf86$export$805e8b72413ccaba();
const $084574008ccedf86$var$_vector$7 = /*@__PURE__*/ new $084574008ccedf86$export$64b5c384219d3699();
class $084574008ccedf86$export$35efe6f4c85463d2 {
    constructor(p0 = new $084574008ccedf86$export$7ff5ac152ef991b0(), p1 = new $084574008ccedf86$export$7ff5ac152ef991b0(), p2 = new $084574008ccedf86$export$7ff5ac152ef991b0(), p3 = new $084574008ccedf86$export$7ff5ac152ef991b0(), p4 = new $084574008ccedf86$export$7ff5ac152ef991b0(), p5 = new $084574008ccedf86$export$7ff5ac152ef991b0()){
        this.planes = [
            p0,
            p1,
            p2,
            p3,
            p4,
            p5
        ];
    }
    set(p0, p1, p2, p3, p4, p5) {
        const planes = this.planes;
        planes[0].copy(p0);
        planes[1].copy(p1);
        planes[2].copy(p2);
        planes[3].copy(p3);
        planes[4].copy(p4);
        planes[5].copy(p5);
        return this;
    }
    copy(frustum) {
        const planes = this.planes;
        for(let i76 = 0; i76 < 6; i76++)planes[i76].copy(frustum.planes[i76]);
        return this;
    }
    setFromProjectionMatrix(m) {
        const planes = this.planes;
        const me = m.elements;
        const me0 = me[0], me1 = me[1], me2 = me[2], me3 = me[3];
        const me4 = me[4], me5 = me[5], me6 = me[6], me7 = me[7];
        const me8 = me[8], me9 = me[9], me10 = me[10], me11 = me[11];
        const me12 = me[12], me13 = me[13], me14 = me[14], me15 = me[15];
        planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();
        planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();
        planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();
        planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();
        planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();
        planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();
        return this;
    }
    intersectsObject(object) {
        const geometry = object.geometry;
        if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
        $084574008ccedf86$var$_sphere$2.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);
        return this.intersectsSphere($084574008ccedf86$var$_sphere$2);
    }
    intersectsSprite(sprite) {
        $084574008ccedf86$var$_sphere$2.center.set(0, 0, 0);
        $084574008ccedf86$var$_sphere$2.radius = 0.7071067811865476;
        $084574008ccedf86$var$_sphere$2.applyMatrix4(sprite.matrixWorld);
        return this.intersectsSphere($084574008ccedf86$var$_sphere$2);
    }
    intersectsSphere(sphere) {
        const planes = this.planes;
        const center = sphere.center;
        const negRadius = -sphere.radius;
        for(let i77 = 0; i77 < 6; i77++){
            const distance = planes[i77].distanceToPoint(center);
            if (distance < negRadius) return false;
        }
        return true;
    }
    intersectsBox(box) {
        const planes = this.planes;
        for(let i78 = 0; i78 < 6; i78++){
            const plane = planes[i78];
            // corner at max distance
            $084574008ccedf86$var$_vector$7.x = plane.normal.x > 0 ? box.max.x : box.min.x;
            $084574008ccedf86$var$_vector$7.y = plane.normal.y > 0 ? box.max.y : box.min.y;
            $084574008ccedf86$var$_vector$7.z = plane.normal.z > 0 ? box.max.z : box.min.z;
            if (plane.distanceToPoint($084574008ccedf86$var$_vector$7) < 0) return false;
        }
        return true;
    }
    containsPoint(point) {
        const planes = this.planes;
        for(let i79 = 0; i79 < 6; i79++){
            if (planes[i79].distanceToPoint(point) < 0) return false;
        }
        return true;
    }
    clone() {
        return new this.constructor().copy(this);
    }
}
function $084574008ccedf86$var$WebGLAnimation() {
    let context = null;
    let isAnimating = false;
    let animationLoop = null;
    let requestId = null;
    function onAnimationFrame(time, frame) {
        animationLoop(time, frame);
        requestId = context.requestAnimationFrame(onAnimationFrame);
    }
    return {
        start: function() {
            if (isAnimating === true) return;
            if (animationLoop === null) return;
            requestId = context.requestAnimationFrame(onAnimationFrame);
            isAnimating = true;
        },
        stop: function() {
            context.cancelAnimationFrame(requestId);
            isAnimating = false;
        },
        setAnimationLoop: function(callback) {
            animationLoop = callback;
        },
        setContext: function(value) {
            context = value;
        }
    };
}
function $084574008ccedf86$var$WebGLAttributes(gl, capabilities) {
    const isWebGL2 = capabilities.isWebGL2;
    const buffers = new WeakMap();
    function createBuffer(attribute, bufferType) {
        const array = attribute.array;
        const usage = attribute.usage;
        const buffer = gl.createBuffer();
        gl.bindBuffer(bufferType, buffer);
        gl.bufferData(bufferType, array, usage);
        attribute.onUploadCallback();
        let type;
        if (array instanceof Float32Array) type = 5126;
        else if (array instanceof Uint16Array) {
            if (attribute.isFloat16BufferAttribute) {
                if (isWebGL2) type = 5131;
                else throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");
            } else type = 5123;
        } else if (array instanceof Int16Array) type = 5122;
        else if (array instanceof Uint32Array) type = 5125;
        else if (array instanceof Int32Array) type = 5124;
        else if (array instanceof Int8Array) type = 5120;
        else if (array instanceof Uint8Array) type = 5121;
        else if (array instanceof Uint8ClampedArray) type = 5121;
        else throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + array);
        return {
            buffer: buffer,
            type: type,
            bytesPerElement: array.BYTES_PER_ELEMENT,
            version: attribute.version
        };
    }
    function updateBuffer(buffer, attribute, bufferType) {
        const array = attribute.array;
        const updateRange = attribute.updateRange;
        gl.bindBuffer(bufferType, buffer);
        if (updateRange.count === -1) // Not using update ranges
        gl.bufferSubData(bufferType, 0, array);
        else {
            if (isWebGL2) gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array, updateRange.offset, updateRange.count);
            else gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array.subarray(updateRange.offset, updateRange.offset + updateRange.count));
            updateRange.count = -1; // reset range
        }
    }
    //
    function get(attribute) {
        if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
        return buffers.get(attribute);
    }
    function remove(attribute) {
        if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
        const data = buffers.get(attribute);
        if (data) {
            gl.deleteBuffer(data.buffer);
            buffers.delete(attribute);
        }
    }
    function update(attribute, bufferType) {
        if (attribute.isGLBufferAttribute) {
            const cached = buffers.get(attribute);
            if (!cached || cached.version < attribute.version) buffers.set(attribute, {
                buffer: attribute.buffer,
                type: attribute.type,
                bytesPerElement: attribute.elementSize,
                version: attribute.version
            });
            return;
        }
        if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
        const data = buffers.get(attribute);
        if (data === undefined) buffers.set(attribute, createBuffer(attribute, bufferType));
        else if (data.version < attribute.version) {
            updateBuffer(data.buffer, attribute, bufferType);
            data.version = attribute.version;
        }
    }
    return {
        get: get,
        remove: remove,
        update: update
    };
}
class $084574008ccedf86$export$e789a11a194ca4e0 extends $084574008ccedf86$export$b7be63a67df8959 {
    constructor(width = 1, height = 1, widthSegments = 1, heightSegments = 1){
        super();
        this.type = "PlaneGeometry";
        this.parameters = {
            width: width,
            height: height,
            widthSegments: widthSegments,
            heightSegments: heightSegments
        };
        const width_half = width / 2;
        const height_half = height / 2;
        const gridX = Math.floor(widthSegments);
        const gridY = Math.floor(heightSegments);
        const gridX1 = gridX + 1;
        const gridY1 = gridY + 1;
        const segment_width = width / gridX;
        const segment_height = height / gridY;
        //
        const indices = [];
        const vertices = [];
        const normals = [];
        const uvs = [];
        for(let iy = 0; iy < gridY1; iy++){
            const y = iy * segment_height - height_half;
            for(let ix = 0; ix < gridX1; ix++){
                const x = ix * segment_width - width_half;
                vertices.push(x, -y, 0);
                normals.push(0, 0, 1);
                uvs.push(ix / gridX);
                uvs.push(1 - iy / gridY);
            }
        }
        for(let iy2 = 0; iy2 < gridY; iy2++)for(let ix = 0; ix < gridX; ix++){
            const a = ix + gridX1 * iy2;
            const b = ix + gridX1 * (iy2 + 1);
            const c = ix + 1 + gridX1 * (iy2 + 1);
            const d = ix + 1 + gridX1 * iy2;
            indices.push(a, b, d);
            indices.push(b, c, d);
        }
        this.setIndex(indices);
        this.setAttribute("position", new $084574008ccedf86$export$cbe7a62641830ebd(vertices, 3));
        this.setAttribute("normal", new $084574008ccedf86$export$cbe7a62641830ebd(normals, 3));
        this.setAttribute("uv", new $084574008ccedf86$export$cbe7a62641830ebd(uvs, 2));
    }
    static fromJSON(data) {
        return new $084574008ccedf86$export$e789a11a194ca4e0(data.width, data.height, data.widthSegments, data.heightSegments);
    }
}
var $084574008ccedf86$var$alphamap_fragment = "#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif";
var $084574008ccedf86$var$alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif";
var $084574008ccedf86$var$alphatest_fragment = "#ifdef USE_ALPHATEST\n	if ( diffuseColor.a < alphaTest ) discard;\n#endif";
var $084574008ccedf86$var$alphatest_pars_fragment = "#ifdef USE_ALPHATEST\n	uniform float alphaTest;\n#endif";
var $084574008ccedf86$var$aomap_fragment = "#ifdef USE_AOMAP\n	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n	reflectedLight.indirectDiffuse *= ambientOcclusion;\n	#if defined( USE_ENVMAP ) && defined( STANDARD )\n		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n	#endif\n#endif";
var $084574008ccedf86$var$aomap_pars_fragment = "#ifdef USE_AOMAP\n	uniform sampler2D aoMap;\n	uniform float aoMapIntensity;\n#endif";
var $084574008ccedf86$var$begin_vertex = "vec3 transformed = vec3( position );";
var $084574008ccedf86$var$beginnormal_vertex = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n	vec3 objectTangent = vec3( tangent.xyz );\n#endif";
var $084574008ccedf86$var$bsdfs = "vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n	return RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	return 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n	float a2 = pow2( alpha );\n	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n	return RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n	float alpha = pow2( roughness );\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = F_Schlick( f0, f90, dotVH );\n	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n	float D = D_GGX( alpha, dotNH );\n	return F * ( V * D );\n}\n#ifdef USE_IRIDESCENCE\nvec3 BRDF_GGX_Iridescence( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float iridescence, const in vec3 iridescenceFresnel, const in float roughness ) {\n	float alpha = pow2( roughness );\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = mix(F_Schlick( f0, f90, dotVH ), iridescenceFresnel, iridescence);\n	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n	float D = D_GGX( alpha, dotNH );\n	return F * ( V * D );\n}\n#endif\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n	const float LUT_SIZE = 64.0;\n	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n	const float LUT_BIAS = 0.5 / LUT_SIZE;\n	float dotNV = saturate( dot( N, V ) );\n	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n	uv = uv * LUT_SCALE + LUT_BIAS;\n	return uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n	float l = length( f );\n	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n	float x = dot( v1, v2 );\n	float y = abs( x );\n	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n	float b = 3.4175940 + ( 4.1616724 + y ) * y;\n	float v = a / b;\n	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n	return cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n	vec3 lightNormal = cross( v1, v2 );\n	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n	vec3 T1, T2;\n	T1 = normalize( V - N * dot( V, N ) );\n	T2 = - cross( N, T1 );\n	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n	vec3 coords[ 4 ];\n	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n	coords[ 0 ] = normalize( coords[ 0 ] );\n	coords[ 1 ] = normalize( coords[ 1 ] );\n	coords[ 2 ] = normalize( coords[ 2 ] );\n	coords[ 3 ] = normalize( coords[ 3 ] );\n	vec3 vectorFormFactor = vec3( 0.0 );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n	return vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n	return 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = F_Schlick( specularColor, 1.0, dotVH );\n	float G = G_BlinnPhong_Implicit( );\n	float D = D_BlinnPhong( shininess, dotNH );\n	return F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n	float alpha = pow2( roughness );\n	float invAlpha = 1.0 / alpha;\n	float cos2h = dotNH * dotNH;\n	float sin2h = max( 1.0 - cos2h, 0.0078125 );\n	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float D = D_Charlie( sheenRoughness, dotNH );\n	float V = V_Neubelt( dotNV, dotNL );\n	return sheenColor * ( D * V );\n}\n#endif";
var $084574008ccedf86$var$iridescence_fragment = "#ifdef USE_IRIDESCENCE\nconst mat3 XYZ_TO_REC709 = mat3(\n    3.2404542, -0.9692660,  0.0556434,\n   -1.5371385,  1.8760108, -0.2040259,\n   -0.4985314,  0.0415560,  1.0572252\n);\nvec3 Fresnel0ToIor( vec3 fresnel0 ) {\n   vec3 sqrtF0 = sqrt( fresnel0 );\n   return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n}\nvec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n   return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n}\nfloat IorToFresnel0( float transmittedIor, float incidentIor ) {\n   return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n}\nvec3 evalSensitivity( float OPD, vec3 shift ) {\n   float phase = 2.0 * PI * OPD * 1.0e-9;\n   vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n   vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n   vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n   vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( -pow2( phase ) * var );\n   xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[0] ) * exp( -4.5282e+09 * pow2( phase ) );\n   xyz /= 1.0685e-7;\n   vec3 srgb = XYZ_TO_REC709 * xyz;\n   return srgb;\n}\nvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n   vec3 I;\n   float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n   float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n   float cosTheta2Sq = 1.0 - sinTheta2Sq;\n   if ( cosTheta2Sq < 0.0 ) {\n       return vec3( 1.0 );\n   }\n   float cosTheta2 = sqrt( cosTheta2Sq );\n   float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n   float R12 = F_Schlick( R0, 1.0, cosTheta1 );\n   float R21 = R12;\n   float T121 = 1.0 - R12;\n   float phi12 = 0.0;\n   if ( iridescenceIOR < outsideIOR ) phi12 = PI;\n   float phi21 = PI - phi12;\n   vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );   vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n   vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n   vec3 phi23 = vec3( 0.0 );\n   if ( baseIOR[0] < iridescenceIOR ) phi23[0] = PI;\n   if ( baseIOR[1] < iridescenceIOR ) phi23[1] = PI;\n   if ( baseIOR[2] < iridescenceIOR ) phi23[2] = PI;\n   float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n   vec3 phi = vec3( phi21 ) + phi23;\n   vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n   vec3 r123 = sqrt( R123 );\n   vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n   vec3 C0 = R12 + Rs;\n   I = C0;\n   vec3 Cm = Rs - T121;\n   for ( int m = 1; m <= 2; ++m ) {\n       Cm *= r123;\n       vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n       I += Cm * Sm;\n   }\n   return max( I, vec3( 0.0 ) );\n}\n#endif";
var $084574008ccedf86$var$bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n	vec2 dHdxy_fwd() {\n		vec2 dSTdx = dFdx( vUv );\n		vec2 dSTdy = dFdy( vUv );\n		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n		return vec2( dBx, dBy );\n	}\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n		vec3 vN = surf_norm;\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n		float fDet = dot( vSigmaX, R1 ) * faceDirection;\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n	}\n#endif";
var $084574008ccedf86$var$clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n	vec4 plane;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n		plane = clippingPlanes[ i ];\n		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n	}\n	#pragma unroll_loop_end\n	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n		bool clipped = true;\n		#pragma unroll_loop_start\n		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n			plane = clippingPlanes[ i ];\n			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n		}\n		#pragma unroll_loop_end\n		if ( clipped ) discard;\n	#endif\n#endif";
var $084574008ccedf86$var$clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";
var $084574008ccedf86$var$clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n#endif";
var $084574008ccedf86$var$clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0\n	vClipPosition = - mvPosition.xyz;\n#endif";
var $084574008ccedf86$var$color_fragment = "#if defined( USE_COLOR_ALPHA )\n	diffuseColor *= vColor;\n#elif defined( USE_COLOR )\n	diffuseColor.rgb *= vColor;\n#endif";
var $084574008ccedf86$var$color_pars_fragment = "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR )\n	varying vec3 vColor;\n#endif";
var $084574008ccedf86$var$color_pars_vertex = "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	varying vec3 vColor;\n#endif";
var $084574008ccedf86$var$color_vertex = "#if defined( USE_COLOR_ALPHA )\n	vColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	vColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n	vColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n	vColor.xyz *= instanceColor.xyz;\n#endif";
var $084574008ccedf86$var$common = "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n	const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n	return fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n	float precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n	float precisionSafeLength( vec3 v ) {\n		float maxComponent = max3( abs( v ) );\n		return length( v / maxComponent ) * maxComponent;\n	}\n#endif\nstruct IncidentLight {\n	vec3 color;\n	vec3 direction;\n	bool visible;\n};\nstruct ReflectedLight {\n	vec3 directDiffuse;\n	vec3 directSpecular;\n	vec3 indirectDiffuse;\n	vec3 indirectSpecular;\n};\nstruct GeometricContext {\n	vec3 position;\n	vec3 normal;\n	vec3 viewDir;\n#ifdef USE_CLEARCOAT\n	vec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n	mat3 tmp;\n	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n	return tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n	return dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n	return m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n	return vec2( u, v );\n}";
var $084574008ccedf86$var$cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n	#define cubeUV_minMipLevel 4.0\n	#define cubeUV_minTileSize 16.0\n	float getFace( vec3 direction ) {\n		vec3 absDirection = abs( direction );\n		float face = - 1.0;\n		if ( absDirection.x > absDirection.z ) {\n			if ( absDirection.x > absDirection.y )\n				face = direction.x > 0.0 ? 0.0 : 3.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		} else {\n			if ( absDirection.z > absDirection.y )\n				face = direction.z > 0.0 ? 2.0 : 5.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		}\n		return face;\n	}\n	vec2 getUV( vec3 direction, float face ) {\n		vec2 uv;\n		if ( face == 0.0 ) {\n			uv = vec2( direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 1.0 ) {\n			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n		} else if ( face == 2.0 ) {\n			uv = vec2( - direction.x, direction.y ) / abs( direction.z );\n		} else if ( face == 3.0 ) {\n			uv = vec2( - direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 4.0 ) {\n			uv = vec2( - direction.x, direction.z ) / abs( direction.y );\n		} else {\n			uv = vec2( direction.x, direction.y ) / abs( direction.z );\n		}\n		return 0.5 * ( uv + 1.0 );\n	}\n	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n		float face = getFace( direction );\n		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n		mipInt = max( mipInt, cubeUV_minMipLevel );\n		float faceSize = exp2( mipInt );\n		vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n		if ( face > 2.0 ) {\n			uv.y += faceSize;\n			face -= 3.0;\n		}\n		uv.x += face * faceSize;\n		uv.x += filterInt * 3.0 * cubeUV_minTileSize;\n		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n		uv.x *= CUBEUV_TEXEL_WIDTH;\n		uv.y *= CUBEUV_TEXEL_HEIGHT;\n		#ifdef texture2DGradEXT\n			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n		#else\n			return texture2D( envMap, uv ).rgb;\n		#endif\n	}\n	#define r0 1.0\n	#define v0 0.339\n	#define m0 - 2.0\n	#define r1 0.8\n	#define v1 0.276\n	#define m1 - 1.0\n	#define r4 0.4\n	#define v4 0.046\n	#define m4 2.0\n	#define r5 0.305\n	#define v5 0.016\n	#define m5 3.0\n	#define r6 0.21\n	#define v6 0.0038\n	#define m6 4.0\n	float roughnessToMip( float roughness ) {\n		float mip = 0.0;\n		if ( roughness >= r1 ) {\n			mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n		} else if ( roughness >= r4 ) {\n			mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n		} else if ( roughness >= r5 ) {\n			mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n		} else if ( roughness >= r6 ) {\n			mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n		} else {\n			mip = - 2.0 * log2( 1.16 * roughness );		}\n		return mip;\n	}\n	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n		float mip = clamp( roughnessToMip( roughness ), m0, CUBEUV_MAX_MIP );\n		float mipF = fract( mip );\n		float mipInt = floor( mip );\n		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n		if ( mipF == 0.0 ) {\n			return vec4( color0, 1.0 );\n		} else {\n			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n			return vec4( mix( color0, color1, mipF ), 1.0 );\n		}\n	}\n#endif";
var $084574008ccedf86$var$defaultnormal_vertex = "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n	mat3 m = mat3( instanceMatrix );\n	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n	transformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n	transformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#ifdef FLIP_SIDED\n		transformedTangent = - transformedTangent;\n	#endif\n#endif";
var $084574008ccedf86$var$displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n	uniform sampler2D displacementMap;\n	uniform float displacementScale;\n	uniform float displacementBias;\n#endif";
var $084574008ccedf86$var$displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif";
var $084574008ccedf86$var$emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n	vec4 emissiveColor = texture2D( emissiveMap, vUv );\n	totalEmissiveRadiance *= emissiveColor.rgb;\n#endif";
var $084574008ccedf86$var$emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n	uniform sampler2D emissiveMap;\n#endif";
var $084574008ccedf86$var$encodings_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );";
var $084574008ccedf86$var$encodings_pars_fragment = "vec4 LinearToLinear( in vec4 value ) {\n	return value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}";
var $084574008ccedf86$var$envmap_fragment = "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vec3 cameraToFrag;\n		if ( isOrthographic ) {\n			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToFrag = normalize( vWorldPosition - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( cameraToFrag, worldNormal );\n		#else\n			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n		#endif\n	#else\n		vec3 reflectVec = vReflect;\n	#endif\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n	#elif defined( ENVMAP_TYPE_CUBE_UV )\n		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n	#else\n		vec4 envColor = vec4( 0.0 );\n	#endif\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_MIX )\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_ADD )\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n	#endif\n#endif";
var $084574008ccedf86$var$envmap_common_pars_fragment = "#ifdef USE_ENVMAP\n	uniform float envMapIntensity;\n	uniform float flipEnvMap;\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	\n#endif";
var $084574008ccedf86$var$envmap_pars_fragment = "#ifdef USE_ENVMAP\n	uniform float reflectivity;\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		varying vec3 vWorldPosition;\n		uniform float refractionRatio;\n	#else\n		varying vec3 vReflect;\n	#endif\n#endif";
var $084574008ccedf86$var$envmap_pars_vertex = "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		\n		varying vec3 vWorldPosition;\n	#else\n		varying vec3 vReflect;\n		uniform float refractionRatio;\n	#endif\n#endif";
var $084574008ccedf86$var$envmap_vertex = "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vWorldPosition = worldPosition.xyz;\n	#else\n		vec3 cameraToVertex;\n		if ( isOrthographic ) {\n			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vReflect = reflect( cameraToVertex, worldNormal );\n		#else\n			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n		#endif\n	#endif\n#endif";
var $084574008ccedf86$var$fog_vertex = "#ifdef USE_FOG\n	vFogDepth = - mvPosition.z;\n#endif";
var $084574008ccedf86$var$fog_pars_vertex = "#ifdef USE_FOG\n	varying float vFogDepth;\n#endif";
var $084574008ccedf86$var$fog_fragment = "#ifdef USE_FOG\n	#ifdef FOG_EXP2\n		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n	#else\n		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n	#endif\n	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif";
var $084574008ccedf86$var$fog_pars_fragment = "#ifdef USE_FOG\n	uniform vec3 fogColor;\n	varying float vFogDepth;\n	#ifdef FOG_EXP2\n		uniform float fogDensity;\n	#else\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n#endif";
var $084574008ccedf86$var$gradientmap_pars_fragment = "#ifdef USE_GRADIENTMAP\n	uniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n	float dotNL = dot( normal, lightDirection );\n	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n	#ifdef USE_GRADIENTMAP\n		return vec3( texture2D( gradientMap, coord ).r );\n	#else\n		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n	#endif\n}";
var $084574008ccedf86$var$lightmap_fragment = "#ifdef USE_LIGHTMAP\n	vec4 lightMapTexel = texture2D( lightMap, vUv2 );\n	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n	reflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif";
var $084574008ccedf86$var$lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n	uniform sampler2D lightMap;\n	uniform float lightMapIntensity;\n#endif";
var $084574008ccedf86$var$lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n	vLightBack = vec3( 0.0 );\n	vIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );\n#ifdef DOUBLE_SIDED\n	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );\n#endif\n#if NUM_POINT_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		getPointLightInfo( pointLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		getSpotLightInfo( spotLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		getDirectionalLightInfo( directionalLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n		#ifdef DOUBLE_SIDED\n			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif";
var $084574008ccedf86$var$lights_pars_begin = "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n	float x = normal.x, y = normal.y, z = normal.z;\n	vec3 result = shCoefficients[ 0 ] * 0.886227;\n	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n	return result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n	return irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n	vec3 irradiance = ambientLightColor;\n	return irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n	#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n		if ( cutoffDistance > 0.0 ) {\n			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n		}\n		return distanceFalloff;\n	#else\n		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n		}\n		return 1.0;\n	#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n	return smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n	struct DirectionalLight {\n		vec3 direction;\n		vec3 color;\n	};\n	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n		light.color = directionalLight.color;\n		light.direction = directionalLight.direction;\n		light.visible = true;\n	}\n#endif\n#if NUM_POINT_LIGHTS > 0\n	struct PointLight {\n		vec3 position;\n		vec3 color;\n		float distance;\n		float decay;\n	};\n	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n		vec3 lVector = pointLight.position - geometry.position;\n		light.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		light.color = pointLight.color;\n		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n		light.visible = ( light.color != vec3( 0.0 ) );\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	struct SpotLight {\n		vec3 position;\n		vec3 direction;\n		vec3 color;\n		float distance;\n		float decay;\n		float coneCos;\n		float penumbraCos;\n	};\n	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n		vec3 lVector = spotLight.position - geometry.position;\n		light.direction = normalize( lVector );\n		float angleCos = dot( light.direction, spotLight.direction );\n		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n		if ( spotAttenuation > 0.0 ) {\n			float lightDistance = length( lVector );\n			light.color = spotLight.color * spotAttenuation;\n			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n			light.visible = ( light.color != vec3( 0.0 ) );\n		} else {\n			light.color = vec3( 0.0 );\n			light.visible = false;\n		}\n	}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n	struct RectAreaLight {\n		vec3 color;\n		vec3 position;\n		vec3 halfWidth;\n		vec3 halfHeight;\n	};\n	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;\n	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	struct HemisphereLight {\n		vec3 direction;\n		vec3 skyColor;\n		vec3 groundColor;\n	};\n	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n		float dotNL = dot( normal, hemiLight.direction );\n		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n		return irradiance;\n	}\n#endif";
var $084574008ccedf86$var$envmap_physical_pars_fragment = "#if defined( USE_ENVMAP )\n	vec3 getIBLIrradiance( const in vec3 normal ) {\n		#if defined( ENVMAP_TYPE_CUBE_UV )\n			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n			return PI * envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n		#if defined( ENVMAP_TYPE_CUBE_UV )\n			vec3 reflectVec = reflect( - viewDir, normal );\n			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n			return envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n#endif";
var $084574008ccedf86$var$lights_toon_fragment = "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;";
var $084574008ccedf86$var$lights_toon_pars_fragment = "varying vec3 vViewPosition;\nstruct ToonMaterial {\n	vec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_Toon\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )	(0)";
var $084574008ccedf86$var$lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";
var $084574008ccedf86$var$lights_phong_pars_fragment = "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n	vec3 diffuseColor;\n	vec3 specularColor;\n	float specularShininess;\n	float specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_BlinnPhong\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )	(0)";
var $084574008ccedf86$var$lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n	#ifdef SPECULAR\n		float specularIntensityFactor = specularIntensity;\n		vec3 specularColorFactor = specularColor;\n		#ifdef USE_SPECULARINTENSITYMAP\n			specularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n		#endif\n		#ifdef USE_SPECULARCOLORMAP\n			specularColorFactor *= texture2D( specularColorMap, vUv ).rgb;\n		#endif\n		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n	#else\n		float specularIntensityFactor = 1.0;\n		vec3 specularColorFactor = vec3( 1.0 );\n		material.specularF90 = 1.0;\n	#endif\n	material.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n	material.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n	material.clearcoat = clearcoat;\n	material.clearcoatRoughness = clearcoatRoughness;\n	material.clearcoatF0 = vec3( 0.04 );\n	material.clearcoatF90 = 1.0;\n	#ifdef USE_CLEARCOATMAP\n		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n	#endif\n	#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n	#endif\n	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n	material.clearcoatRoughness += geometryRoughness;\n	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_IRIDESCENCE\n	material.iridescence = iridescence;\n	material.iridescenceIOR = iridescenceIOR;\n	#ifdef USE_IRIDESCENCEMAP\n		material.iridescence *= texture2D( iridescenceMap, vUv ).r;\n	#endif\n	#ifdef USE_IRIDESCENCE_THICKNESSMAP\n		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vUv ).g + iridescenceThicknessMinimum;\n	#else\n		material.iridescenceThickness = iridescenceThicknessMaximum;\n	#endif\n#endif\n#ifdef USE_SHEEN\n	material.sheenColor = sheenColor;\n	#ifdef USE_SHEENCOLORMAP\n		material.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;\n	#endif\n	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n	#ifdef USE_SHEENROUGHNESSMAP\n		material.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;\n	#endif\n#endif";
var $084574008ccedf86$var$lights_physical_pars_fragment = "struct PhysicalMaterial {\n	vec3 diffuseColor;\n	float roughness;\n	vec3 specularColor;\n	float specularF90;\n	#ifdef USE_CLEARCOAT\n		float clearcoat;\n		float clearcoatRoughness;\n		vec3 clearcoatF0;\n		float clearcoatF90;\n	#endif\n	#ifdef USE_IRIDESCENCE\n		float iridescence;\n		float iridescenceIOR;\n		float iridescenceThickness;\n		vec3 iridescenceFresnel;\n		vec3 iridescenceF0;\n	#endif\n	#ifdef USE_SHEEN\n		vec3 sheenColor;\n		float sheenRoughness;\n	#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec3 sheenSpecular = vec3( 0.0 );\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float r2 = roughness * roughness;\n	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n	return saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n	vec4 r = roughness * c0 + c1;\n	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n	return fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n	vec2 fab = DFGApprox( normal, viewDir, roughness );\n	return specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n	vec2 fab = DFGApprox( normal, viewDir, roughness );\n	#ifdef USE_IRIDESCENCE\n		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n	#else\n		vec3 Fr = specularColor;\n	#endif\n	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n	float Ess = fab.x + fab.y;\n	float Ems = 1.0 - Ess;\n	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n	singleScatter += FssEss;\n	multiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n		vec3 normal = geometry.normal;\n		vec3 viewDir = geometry.viewDir;\n		vec3 position = geometry.position;\n		vec3 lightPos = rectAreaLight.position;\n		vec3 halfWidth = rectAreaLight.halfWidth;\n		vec3 halfHeight = rectAreaLight.halfHeight;\n		vec3 lightColor = rectAreaLight.color;\n		float roughness = material.roughness;\n		vec3 rectCoords[ 4 ];\n		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n		vec2 uv = LTC_Uv( normal, viewDir, roughness );\n		vec4 t1 = texture2D( ltc_1, uv );\n		vec4 t2 = texture2D( ltc_2, uv );\n		mat3 mInv = mat3(\n			vec3( t1.x, 0, t1.y ),\n			vec3(    0, 1,    0 ),\n			vec3( t1.z, 0, t1.w )\n		);\n		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n	}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifdef USE_CLEARCOAT\n		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n		vec3 ccIrradiance = dotNLcc * directLight.color;\n		clearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n	#endif\n	#ifdef USE_SHEEN\n		sheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n	#endif\n	#ifdef USE_IRIDESCENCE\n		reflectedLight.directSpecular += irradiance * BRDF_GGX_Iridescence( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness );\n	#else\n		reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n	#endif\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n	#ifdef USE_CLEARCOAT\n		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n	#endif\n	#ifdef USE_SHEEN\n		sheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );\n	#endif\n	vec3 singleScattering = vec3( 0.0 );\n	vec3 multiScattering = vec3( 0.0 );\n	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n	#ifdef USE_IRIDESCENCE\n		computeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n	#else\n		computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n	#endif\n	vec3 totalScattering = singleScattering + multiScattering;\n	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n	reflectedLight.indirectSpecular += radiance * singleScattering;\n	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct				RE_Direct_Physical\n#define RE_Direct_RectArea		RE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular		RE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";
var $084574008ccedf86$var$lights_fragment_begin = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n	geometry.clearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\nfloat dotNVi = saturate( dot( normal, geometry.viewDir ) );\nif ( material.iridescenceThickness == 0.0 ) {\n	material.iridescence = 0.0;\n} else {\n	material.iridescence = saturate( material.iridescence );\n}\nif ( material.iridescence > 0.0 ) {\n	material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n	material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n	PointLight pointLight;\n	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		pointLight = pointLights[ i ];\n		getPointLightInfo( pointLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n		pointLightShadow = pointLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n	SpotLight spotLight;\n	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		spotLight = spotLights[ i ];\n		getSpotLightInfo( spotLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n		spotLightShadow = spotLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n	DirectionalLight directionalLight;\n	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		getDirectionalLightInfo( directionalLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n		directionalLightShadow = directionalLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n	RectAreaLight rectAreaLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n		rectAreaLight = rectAreaLights[ i ];\n		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n	vec3 iblIrradiance = vec3( 0.0 );\n	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n	#if ( NUM_HEMI_LIGHTS > 0 )\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n		}\n		#pragma unroll_loop_end\n	#endif\n#endif\n#if defined( RE_IndirectSpecular )\n	vec3 radiance = vec3( 0.0 );\n	vec3 clearcoatRadiance = vec3( 0.0 );\n#endif";
var $084574008ccedf86$var$lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel = texture2D( lightMap, vUv2 );\n		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n		irradiance += lightMapIrradiance;\n	#endif\n	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n		iblIrradiance += getIBLIrradiance( geometry.normal );\n	#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n	radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n	#ifdef USE_CLEARCOAT\n		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n	#endif\n#endif";
var $084574008ccedf86$var$lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif";
var $084574008ccedf86$var$logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";
var $084574008ccedf86$var$logdepthbuf_pars_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	uniform float logDepthBufFC;\n	varying float vFragDepth;\n	varying float vIsPerspective;\n#endif";
var $084574008ccedf86$var$logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		varying float vFragDepth;\n		varying float vIsPerspective;\n	#else\n		uniform float logDepthBufFC;\n	#endif\n#endif";
var $084574008ccedf86$var$logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		vFragDepth = 1.0 + gl_Position.w;\n		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n	#else\n		if ( isPerspectiveMatrix( projectionMatrix ) ) {\n			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n			gl_Position.z *= gl_Position.w;\n		}\n	#endif\n#endif";
var $084574008ccedf86$var$map_fragment = "#ifdef USE_MAP\n	vec4 sampledDiffuseColor = texture2D( map, vUv );\n	#ifdef DECODE_VIDEO_TEXTURE\n		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n	#endif\n	diffuseColor *= sampledDiffuseColor;\n#endif";
var $084574008ccedf86$var$map_pars_fragment = "#ifdef USE_MAP\n	uniform sampler2D map;\n#endif";
var $084574008ccedf86$var$map_particle_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n	diffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif";
var $084574008ccedf86$var$map_particle_pars_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	uniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n	uniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif";
var $084574008ccedf86$var$metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n	vec4 texelMetalness = texture2D( metalnessMap, vUv );\n	metalnessFactor *= texelMetalness.b;\n#endif";
var $084574008ccedf86$var$metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n	uniform sampler2D metalnessMap;\n#endif";
var $084574008ccedf86$var$morphcolor_vertex = "#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n	vColor *= morphTargetBaseInfluence;\n	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n		#if defined( USE_COLOR_ALPHA )\n			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n		#elif defined( USE_COLOR )\n			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n		#endif\n	}\n#endif";
var $084574008ccedf86$var$morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n	objectNormal *= morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n		}\n	#else\n		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n	#endif\n#endif";
var $084574008ccedf86$var$morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n	uniform float morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n		uniform sampler2DArray morphTargetsTexture;\n		uniform ivec2 morphTargetsTextureSize;\n		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n			int y = texelIndex / morphTargetsTextureSize.x;\n			int x = texelIndex - y * morphTargetsTextureSize.x;\n			ivec3 morphUV = ivec3( x, y, morphTargetIndex );\n			return texelFetch( morphTargetsTexture, morphUV, 0 );\n		}\n	#else\n		#ifndef USE_MORPHNORMALS\n			uniform float morphTargetInfluences[ 8 ];\n		#else\n			uniform float morphTargetInfluences[ 4 ];\n		#endif\n	#endif\n#endif";
var $084574008ccedf86$var$morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n	transformed *= morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n		}\n	#else\n		transformed += morphTarget0 * morphTargetInfluences[ 0 ];\n		transformed += morphTarget1 * morphTargetInfluences[ 1 ];\n		transformed += morphTarget2 * morphTargetInfluences[ 2 ];\n		transformed += morphTarget3 * morphTargetInfluences[ 3 ];\n		#ifndef USE_MORPHNORMALS\n			transformed += morphTarget4 * morphTargetInfluences[ 4 ];\n			transformed += morphTarget5 * morphTargetInfluences[ 5 ];\n			transformed += morphTarget6 * morphTargetInfluences[ 6 ];\n			transformed += morphTarget7 * morphTargetInfluences[ 7 ];\n		#endif\n	#endif\n#endif";
var $084574008ccedf86$var$normal_fragment_begin = "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n#else\n	vec3 normal = normalize( vNormal );\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	#ifdef USE_TANGENT\n		vec3 tangent = normalize( vTangent );\n		vec3 bitangent = normalize( vBitangent );\n		#ifdef DOUBLE_SIDED\n			tangent = tangent * faceDirection;\n			bitangent = bitangent * faceDirection;\n		#endif\n		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n			mat3 vTBN = mat3( tangent, bitangent, normal );\n		#endif\n	#endif\n#endif\nvec3 geometryNormal = normal;";
var $084574008ccedf86$var$normal_fragment_maps = "#ifdef OBJECTSPACE_NORMALMAP\n	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n	#ifdef FLIP_SIDED\n		normal = - normal;\n	#endif\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	normal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n	mapN.xy *= normalScale;\n	#ifdef USE_TANGENT\n		normal = normalize( vTBN * mapN );\n	#else\n		normal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n	#endif\n#elif defined( USE_BUMPMAP )\n	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif";
var $084574008ccedf86$var$normal_pars_fragment = "#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif";
var $084574008ccedf86$var$normal_pars_vertex = "#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif";
var $084574008ccedf86$var$normal_vertex = "#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n	#ifdef USE_TANGENT\n		vTangent = normalize( transformedTangent );\n		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n	#endif\n#endif";
var $084574008ccedf86$var$normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n	uniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n		vec2 st0 = dFdx( vUv.st );\n		vec2 st1 = dFdy( vUv.st );\n		vec3 N = surf_norm;\n		vec3 q1perp = cross( q1, N );\n		vec3 q0perp = cross( N, q0 );\n		vec3 T = q1perp * st0.x + q0perp * st1.x;\n		vec3 B = q1perp * st0.y + q0perp * st1.y;\n		float det = max( dot( T, T ), dot( B, B ) );\n		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n	}\n#endif";
var $084574008ccedf86$var$clearcoat_normal_fragment_begin = "#ifdef USE_CLEARCOAT\n	vec3 clearcoatNormal = geometryNormal;\n#endif";
var $084574008ccedf86$var$clearcoat_normal_fragment_maps = "#ifdef USE_CLEARCOAT_NORMALMAP\n	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n	clearcoatMapN.xy *= clearcoatNormalScale;\n	#ifdef USE_TANGENT\n		clearcoatNormal = normalize( vTBN * clearcoatMapN );\n	#else\n		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n	#endif\n#endif";
var $084574008ccedf86$var$clearcoat_pars_fragment = "#ifdef USE_CLEARCOATMAP\n	uniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	uniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	uniform sampler2D clearcoatNormalMap;\n	uniform vec2 clearcoatNormalScale;\n#endif";
var $084574008ccedf86$var$iridescence_pars_fragment = "#ifdef USE_IRIDESCENCEMAP\n	uniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n	uniform sampler2D iridescenceThicknessMap;\n#endif";
var $084574008ccedf86$var$output_fragment = "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );";
var $084574008ccedf86$var$packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n	return normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n	return 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n	vec4 r = vec4( fract( v * PackFactors ), v );\n	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n	return dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n	return linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n	return ( near * far ) / ( ( far - near ) * invClipZ - far );\n}";
var $084574008ccedf86$var$premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n	gl_FragColor.rgb *= gl_FragColor.a;\n#endif";
var $084574008ccedf86$var$project_vertex = "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n	mvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;";
var $084574008ccedf86$var$dithering_fragment = "#ifdef DITHERING\n	gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif";
var $084574008ccedf86$var$dithering_pars_fragment = "#ifdef DITHERING\n	vec3 dithering( vec3 color ) {\n		float grid_position = rand( gl_FragCoord.xy );\n		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n		return color + dither_shift_RGB;\n	}\n#endif";
var $084574008ccedf86$var$roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n	vec4 texelRoughness = texture2D( roughnessMap, vUv );\n	roughnessFactor *= texelRoughness.g;\n#endif";
var $084574008ccedf86$var$roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n	uniform sampler2D roughnessMap;\n#endif";
var $084574008ccedf86$var$shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n	}\n	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n		return unpackRGBATo2Half( texture2D( shadow, uv ) );\n	}\n	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n		float occlusion = 1.0;\n		vec2 distribution = texture2DDistribution( shadow, uv );\n		float hard_shadow = step( compare , distribution.x );\n		if (hard_shadow != 1.0 ) {\n			float distance = compare - distribution.x ;\n			float variance = max( 0.00000, distribution.y * distribution.y );\n			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n		}\n		return occlusion;\n	}\n	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n		float shadow = 1.0;\n		shadowCoord.xyz /= shadowCoord.w;\n		shadowCoord.z += shadowBias;\n		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n		bool inFrustum = all( inFrustumVec );\n		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n		bool frustumTest = all( frustumTestVec );\n		if ( frustumTest ) {\n		#if defined( SHADOWMAP_TYPE_PCF )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			float dx2 = dx0 / 2.0;\n			float dy2 = dy0 / 2.0;\n			float dx3 = dx1 / 2.0;\n			float dy3 = dy1 / 2.0;\n			shadow = (\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 17.0 );\n		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx = texelSize.x;\n			float dy = texelSize.y;\n			vec2 uv = shadowCoord.xy;\n			vec2 f = fract( uv * shadowMapSize + 0.5 );\n			uv -= f * texelSize;\n			shadow = (\n				texture2DCompare( shadowMap, uv, shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n						  f.x ),\n					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n						  f.x ),\n					 f.y )\n			) * ( 1.0 / 9.0 );\n		#elif defined( SHADOWMAP_TYPE_VSM )\n			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#else\n			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#endif\n		}\n		return shadow;\n	}\n	vec2 cubeToUV( vec3 v, float texelSizeY ) {\n		vec3 absV = abs( v );\n		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n		absV *= scaleToCube;\n		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n		vec2 planar = v.xy;\n		float almostATexel = 1.5 * texelSizeY;\n		float almostOne = 1.0 - almostATexel;\n		if ( absV.z >= almostOne ) {\n			if ( v.z > 0.0 )\n				planar.x = 4.0 - v.x;\n		} else if ( absV.x >= almostOne ) {\n			float signX = sign( v.x );\n			planar.x = v.z * signX + 2.0 * signX;\n		} else if ( absV.y >= almostOne ) {\n			float signY = sign( v.y );\n			planar.x = v.x + 2.0 * signY + 2.0;\n			planar.y = v.z * signY - 2.0;\n		}\n		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n	}\n	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n		vec3 lightToPosition = shadowCoord.xyz;\n		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;\n		vec3 bd3D = normalize( lightToPosition );\n		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n			return (\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n			) * ( 1.0 / 9.0 );\n		#else\n			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n		#endif\n	}\n#endif";
var $084574008ccedf86$var$shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n#endif";
var $084574008ccedf86$var$shadowmap_vertex = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		vec4 shadowWorldPosition;\n	#endif\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n#endif";
var $084574008ccedf86$var$shadowmask_pars_fragment = "float getShadowMask() {\n	float shadow = 1.0;\n	#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		directionalLight = directionalLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		spotLight = spotLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		pointLight = pointLightShadows[ i ];\n		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#endif\n	return shadow;\n}";
var $084574008ccedf86$var$skinbase_vertex = "#ifdef USE_SKINNING\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";
var $084574008ccedf86$var$skinning_pars_vertex = "#ifdef USE_SKINNING\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n	uniform highp sampler2D boneTexture;\n	uniform int boneTextureSize;\n	mat4 getBoneMatrix( const in float i ) {\n		float j = i * 4.0;\n		float x = mod( j, float( boneTextureSize ) );\n		float y = floor( j / float( boneTextureSize ) );\n		float dx = 1.0 / float( boneTextureSize );\n		float dy = 1.0 / float( boneTextureSize );\n		y = dy * ( y + 0.5 );\n		vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n		vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n		vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n		vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n		mat4 bone = mat4( v1, v2, v3, v4 );\n		return bone;\n	}\n#endif";
var $084574008ccedf86$var$skinning_vertex = "#ifdef USE_SKINNING\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	transformed = ( bindMatrixInverse * skinned ).xyz;\n#endif";
var $084574008ccedf86$var$skinnormal_vertex = "#ifdef USE_SKINNING\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n	#ifdef USE_TANGENT\n		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#endif\n#endif";
var $084574008ccedf86$var$specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n	vec4 texelSpecular = texture2D( specularMap, vUv );\n	specularStrength = texelSpecular.r;\n#else\n	specularStrength = 1.0;\n#endif";
var $084574008ccedf86$var$specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n	uniform sampler2D specularMap;\n#endif";
var $084574008ccedf86$var$tonemapping_fragment = "#if defined( TONE_MAPPING )\n	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif";
var $084574008ccedf86$var$tonemapping_pars_fragment = "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n	return toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	return saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	color = max( vec3( 0.0 ), color - 0.004 );\n	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n	return a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n	const mat3 ACESInputMat = mat3(\n		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),\n		vec3( 0.04823, 0.01566, 0.83777 )\n	);\n	const mat3 ACESOutputMat = mat3(\n		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),\n		vec3( -0.07367, -0.00605,  1.07602 )\n	);\n	color *= toneMappingExposure / 0.6;\n	color = ACESInputMat * color;\n	color = RRTAndODTFit( color );\n	color = ACESOutputMat * color;\n	return saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }";
var $084574008ccedf86$var$transmission_fragment = "#ifdef USE_TRANSMISSION\n	float transmissionAlpha = 1.0;\n	float transmissionFactor = transmission;\n	float thicknessFactor = thickness;\n	#ifdef USE_TRANSMISSIONMAP\n		transmissionFactor *= texture2D( transmissionMap, vUv ).r;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		thicknessFactor *= texture2D( thicknessMap, vUv ).g;\n	#endif\n	vec3 pos = vWorldPosition;\n	vec3 v = normalize( cameraPosition - pos );\n	vec3 n = inverseTransformDirection( normal, viewMatrix );\n	vec4 transmission = getIBLVolumeRefraction(\n		n, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,\n		pos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n		attenuationColor, attenuationDistance );\n	totalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );\n	transmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );\n#endif";
var $084574008ccedf86$var$transmission_pars_fragment = "#ifdef USE_TRANSMISSION\n	uniform float transmission;\n	uniform float thickness;\n	uniform float attenuationDistance;\n	uniform vec3 attenuationColor;\n	#ifdef USE_TRANSMISSIONMAP\n		uniform sampler2D transmissionMap;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		uniform sampler2D thicknessMap;\n	#endif\n	uniform vec2 transmissionSamplerSize;\n	uniform sampler2D transmissionSamplerMap;\n	uniform mat4 modelMatrix;\n	uniform mat4 projectionMatrix;\n	varying vec3 vWorldPosition;\n	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n		vec3 modelScale;\n		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n		return normalize( refractionVector ) * thickness * modelScale;\n	}\n	float applyIorToRoughness( const in float roughness, const in float ior ) {\n		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n	}\n	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n		float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n		#ifdef texture2DLodEXT\n			return texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n		#else\n			return texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n		#endif\n	}\n	vec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n		if ( attenuationDistance == 0.0 ) {\n			return radiance;\n		} else {\n			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance * radiance;\n		}\n	}\n	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n		const in vec3 attenuationColor, const in float attenuationDistance ) {\n		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n		vec3 refractedRayExit = position + transmissionRay;\n		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n		vec2 refractionCoords = ndcPos.xy / ndcPos.w;\n		refractionCoords += 1.0;\n		refractionCoords /= 2.0;\n		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n		vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n		return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n	}\n#endif";
var $084574008ccedf86$var$uv_pars_fragment = "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n	varying vec2 vUv;\n#endif";
var $084574008ccedf86$var$uv_pars_vertex = "#ifdef USE_UV\n	#ifdef UVS_VERTEX_ONLY\n		vec2 vUv;\n	#else\n		varying vec2 vUv;\n	#endif\n	uniform mat3 uvTransform;\n#endif";
var $084574008ccedf86$var$uv_vertex = "#ifdef USE_UV\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif";
var $084574008ccedf86$var$uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	varying vec2 vUv2;\n#endif";
var $084574008ccedf86$var$uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	attribute vec2 uv2;\n	varying vec2 vUv2;\n	uniform mat3 uv2Transform;\n#endif";
var $084574008ccedf86$var$uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif";
var $084574008ccedf86$var$worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n	vec4 worldPosition = vec4( transformed, 1.0 );\n	#ifdef USE_INSTANCING\n		worldPosition = instanceMatrix * worldPosition;\n	#endif\n	worldPosition = modelMatrix * worldPosition;\n#endif";
const $084574008ccedf86$var$vertex$g = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n	gl_Position = vec4( position.xy, 1.0, 1.0 );\n}";
const $084574008ccedf86$var$fragment$g = "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n	gl_FragColor = texture2D( t2D, vUv );\n	#ifdef DECODE_VIDEO_TEXTURE\n		gl_FragColor = vec4( mix( pow( gl_FragColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), gl_FragColor.rgb * 0.0773993808, vec3( lessThanEqual( gl_FragColor.rgb, vec3( 0.04045 ) ) ) ), gl_FragColor.w );\n	#endif\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}";
const $084574008ccedf86$var$vertex$f = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	gl_Position.z = gl_Position.w;\n}";
const $084574008ccedf86$var$fragment$f = "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n	vec3 vReflect = vWorldDirection;\n	#include <envmap_fragment>\n	gl_FragColor = envColor;\n	gl_FragColor.a *= opacity;\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}";
const $084574008ccedf86$var$vertex$e = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vHighPrecisionZW = gl_Position.zw;\n}";
const $084574008ccedf86$var$fragment$e = "#if DEPTH_PACKING == 3200\n	uniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#if DEPTH_PACKING == 3200\n		diffuseColor.a = opacity;\n	#endif\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <logdepthbuf_fragment>\n	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n	#if DEPTH_PACKING == 3200\n		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n	#elif DEPTH_PACKING == 3201\n		gl_FragColor = packDepthToRGBA( fragCoordZ );\n	#endif\n}";
const $084574008ccedf86$var$vertex$d = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	vWorldPosition = worldPosition.xyz;\n}";
const $084574008ccedf86$var$fragment$d = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	float dist = length( vWorldPosition - referencePosition );\n	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n	dist = saturate( dist );\n	gl_FragColor = packDepthToRGBA( dist );\n}";
const $084574008ccedf86$var$vertex$c = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n}";
const $084574008ccedf86$var$fragment$c = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vec3 direction = normalize( vWorldDirection );\n	vec2 sampleUV = equirectUv( direction );\n	gl_FragColor = texture2D( tEquirect, sampleUV );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}";
const $084574008ccedf86$var$vertex$b = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	vLineDistance = scale * lineDistance;\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}";
const $084574008ccedf86$var$fragment$b = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	if ( mod( vLineDistance, totalSize ) > dashSize ) {\n		discard;\n	}\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <color_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}";
const $084574008ccedf86$var$vertex$a = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinbase_vertex>\n		#include <skinnormal_vertex>\n		#include <defaultnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <fog_vertex>\n}";
const $084574008ccedf86$var$fragment$a = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel = texture2D( lightMap, vUv2 );\n		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n	#else\n		reflectedLight.indirectDiffuse += vec3( 1.0 );\n	#endif\n	#include <aomap_fragment>\n	reflectedLight.indirectDiffuse *= diffuseColor.rgb;\n	vec3 outgoingLight = reflectedLight.indirectDiffuse;\n	#include <envmap_fragment>\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
const $084574008ccedf86$var$vertex$9 = "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n	varying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <lights_lambert_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
const $084574008ccedf86$var$fragment$9 = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n	varying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <emissivemap_fragment>\n	#ifdef DOUBLE_SIDED\n		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n	#else\n		reflectedLight.indirectDiffuse += vIndirectFront;\n	#endif\n	#include <lightmap_fragment>\n	reflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );\n	#ifdef DOUBLE_SIDED\n		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n	#else\n		reflectedLight.directDiffuse = vLightFront;\n	#endif\n	reflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
const $084574008ccedf86$var$vertex$8 = "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n	vViewPosition = - mvPosition.xyz;\n}";
const $084574008ccedf86$var$fragment$8 = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	vec3 viewDir = normalize( vViewPosition );\n	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n	vec3 y = cross( viewDir, x );\n	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n	#ifdef USE_MATCAP\n		vec4 matcapColor = texture2D( matcap, uv );\n	#else\n		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n	#endif\n	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
const $084574008ccedf86$var$vertex$7 = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	varying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	vViewPosition = - mvPosition.xyz;\n#endif\n}";
const $084574008ccedf86$var$fragment$7 = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	varying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n	#ifdef OPAQUE\n		gl_FragColor.a = 1.0;\n	#endif\n}";
const $084574008ccedf86$var$vertex$6 = "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
const $084574008ccedf86$var$fragment$6 = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_phong_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
const $084574008ccedf86$var$vertex$5 = "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n	varying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n	vWorldPosition = worldPosition.xyz;\n#endif\n}";
const $084574008ccedf86$var$fragment$5 = "#define STANDARD\n#ifdef PHYSICAL\n	#define IOR\n	#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n	uniform float ior;\n#endif\n#ifdef SPECULAR\n	uniform float specularIntensity;\n	uniform vec3 specularColor;\n	#ifdef USE_SPECULARINTENSITYMAP\n		uniform sampler2D specularIntensityMap;\n	#endif\n	#ifdef USE_SPECULARCOLORMAP\n		uniform sampler2D specularColorMap;\n	#endif\n#endif\n#ifdef USE_CLEARCOAT\n	uniform float clearcoat;\n	uniform float clearcoatRoughness;\n#endif\n#ifdef USE_IRIDESCENCE\n	uniform float iridescence;\n	uniform float iridescenceIOR;\n	uniform float iridescenceThicknessMinimum;\n	uniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n	uniform vec3 sheenColor;\n	uniform float sheenRoughness;\n	#ifdef USE_SHEENCOLORMAP\n		uniform sampler2D sheenColorMap;\n	#endif\n	#ifdef USE_SHEENROUGHNESSMAP\n		uniform sampler2D sheenRoughnessMap;\n	#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <roughnessmap_fragment>\n	#include <metalnessmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <clearcoat_normal_fragment_begin>\n	#include <clearcoat_normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_physical_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n	#include <transmission_fragment>\n	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n	#ifdef USE_SHEEN\n		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;\n	#endif\n	#ifdef USE_CLEARCOAT\n		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n	#endif\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
const $084574008ccedf86$var$vertex$4 = "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
const $084574008ccedf86$var$fragment$4 = "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_toon_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
const $084574008ccedf86$var$vertex$3 = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	gl_PointSize = size;\n	#ifdef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n	#endif\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <fog_vertex>\n}";
const $084574008ccedf86$var$fragment$3 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_particle_fragment>\n	#include <color_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}";
const $084574008ccedf86$var$vertex$2 = "#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
const $084574008ccedf86$var$fragment$2 = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}";
const $084574008ccedf86$var$vertex$1 = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n	vec2 scale;\n	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n	#ifndef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) scale *= - mvPosition.z;\n	#endif\n	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n	vec2 rotatedPosition;\n	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n	mvPosition.xy += rotatedPosition;\n	gl_Position = projectionMatrix * mvPosition;\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}";
const $084574008ccedf86$var$fragment$1 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}";
const $084574008ccedf86$export$955f9f2e84c43c8b = {
    alphamap_fragment: $084574008ccedf86$var$alphamap_fragment,
    alphamap_pars_fragment: $084574008ccedf86$var$alphamap_pars_fragment,
    alphatest_fragment: $084574008ccedf86$var$alphatest_fragment,
    alphatest_pars_fragment: $084574008ccedf86$var$alphatest_pars_fragment,
    aomap_fragment: $084574008ccedf86$var$aomap_fragment,
    aomap_pars_fragment: $084574008ccedf86$var$aomap_pars_fragment,
    begin_vertex: $084574008ccedf86$var$begin_vertex,
    beginnormal_vertex: $084574008ccedf86$var$beginnormal_vertex,
    bsdfs: $084574008ccedf86$var$bsdfs,
    iridescence_fragment: $084574008ccedf86$var$iridescence_fragment,
    bumpmap_pars_fragment: $084574008ccedf86$var$bumpmap_pars_fragment,
    clipping_planes_fragment: $084574008ccedf86$var$clipping_planes_fragment,
    clipping_planes_pars_fragment: $084574008ccedf86$var$clipping_planes_pars_fragment,
    clipping_planes_pars_vertex: $084574008ccedf86$var$clipping_planes_pars_vertex,
    clipping_planes_vertex: $084574008ccedf86$var$clipping_planes_vertex,
    color_fragment: $084574008ccedf86$var$color_fragment,
    color_pars_fragment: $084574008ccedf86$var$color_pars_fragment,
    color_pars_vertex: $084574008ccedf86$var$color_pars_vertex,
    color_vertex: $084574008ccedf86$var$color_vertex,
    common: $084574008ccedf86$var$common,
    cube_uv_reflection_fragment: $084574008ccedf86$var$cube_uv_reflection_fragment,
    defaultnormal_vertex: $084574008ccedf86$var$defaultnormal_vertex,
    displacementmap_pars_vertex: $084574008ccedf86$var$displacementmap_pars_vertex,
    displacementmap_vertex: $084574008ccedf86$var$displacementmap_vertex,
    emissivemap_fragment: $084574008ccedf86$var$emissivemap_fragment,
    emissivemap_pars_fragment: $084574008ccedf86$var$emissivemap_pars_fragment,
    encodings_fragment: $084574008ccedf86$var$encodings_fragment,
    encodings_pars_fragment: $084574008ccedf86$var$encodings_pars_fragment,
    envmap_fragment: $084574008ccedf86$var$envmap_fragment,
    envmap_common_pars_fragment: $084574008ccedf86$var$envmap_common_pars_fragment,
    envmap_pars_fragment: $084574008ccedf86$var$envmap_pars_fragment,
    envmap_pars_vertex: $084574008ccedf86$var$envmap_pars_vertex,
    envmap_physical_pars_fragment: $084574008ccedf86$var$envmap_physical_pars_fragment,
    envmap_vertex: $084574008ccedf86$var$envmap_vertex,
    fog_vertex: $084574008ccedf86$var$fog_vertex,
    fog_pars_vertex: $084574008ccedf86$var$fog_pars_vertex,
    fog_fragment: $084574008ccedf86$var$fog_fragment,
    fog_pars_fragment: $084574008ccedf86$var$fog_pars_fragment,
    gradientmap_pars_fragment: $084574008ccedf86$var$gradientmap_pars_fragment,
    lightmap_fragment: $084574008ccedf86$var$lightmap_fragment,
    lightmap_pars_fragment: $084574008ccedf86$var$lightmap_pars_fragment,
    lights_lambert_vertex: $084574008ccedf86$var$lights_lambert_vertex,
    lights_pars_begin: $084574008ccedf86$var$lights_pars_begin,
    lights_toon_fragment: $084574008ccedf86$var$lights_toon_fragment,
    lights_toon_pars_fragment: $084574008ccedf86$var$lights_toon_pars_fragment,
    lights_phong_fragment: $084574008ccedf86$var$lights_phong_fragment,
    lights_phong_pars_fragment: $084574008ccedf86$var$lights_phong_pars_fragment,
    lights_physical_fragment: $084574008ccedf86$var$lights_physical_fragment,
    lights_physical_pars_fragment: $084574008ccedf86$var$lights_physical_pars_fragment,
    lights_fragment_begin: $084574008ccedf86$var$lights_fragment_begin,
    lights_fragment_maps: $084574008ccedf86$var$lights_fragment_maps,
    lights_fragment_end: $084574008ccedf86$var$lights_fragment_end,
    logdepthbuf_fragment: $084574008ccedf86$var$logdepthbuf_fragment,
    logdepthbuf_pars_fragment: $084574008ccedf86$var$logdepthbuf_pars_fragment,
    logdepthbuf_pars_vertex: $084574008ccedf86$var$logdepthbuf_pars_vertex,
    logdepthbuf_vertex: $084574008ccedf86$var$logdepthbuf_vertex,
    map_fragment: $084574008ccedf86$var$map_fragment,
    map_pars_fragment: $084574008ccedf86$var$map_pars_fragment,
    map_particle_fragment: $084574008ccedf86$var$map_particle_fragment,
    map_particle_pars_fragment: $084574008ccedf86$var$map_particle_pars_fragment,
    metalnessmap_fragment: $084574008ccedf86$var$metalnessmap_fragment,
    metalnessmap_pars_fragment: $084574008ccedf86$var$metalnessmap_pars_fragment,
    morphcolor_vertex: $084574008ccedf86$var$morphcolor_vertex,
    morphnormal_vertex: $084574008ccedf86$var$morphnormal_vertex,
    morphtarget_pars_vertex: $084574008ccedf86$var$morphtarget_pars_vertex,
    morphtarget_vertex: $084574008ccedf86$var$morphtarget_vertex,
    normal_fragment_begin: $084574008ccedf86$var$normal_fragment_begin,
    normal_fragment_maps: $084574008ccedf86$var$normal_fragment_maps,
    normal_pars_fragment: $084574008ccedf86$var$normal_pars_fragment,
    normal_pars_vertex: $084574008ccedf86$var$normal_pars_vertex,
    normal_vertex: $084574008ccedf86$var$normal_vertex,
    normalmap_pars_fragment: $084574008ccedf86$var$normalmap_pars_fragment,
    clearcoat_normal_fragment_begin: $084574008ccedf86$var$clearcoat_normal_fragment_begin,
    clearcoat_normal_fragment_maps: $084574008ccedf86$var$clearcoat_normal_fragment_maps,
    clearcoat_pars_fragment: $084574008ccedf86$var$clearcoat_pars_fragment,
    iridescence_pars_fragment: $084574008ccedf86$var$iridescence_pars_fragment,
    output_fragment: $084574008ccedf86$var$output_fragment,
    packing: $084574008ccedf86$var$packing,
    premultiplied_alpha_fragment: $084574008ccedf86$var$premultiplied_alpha_fragment,
    project_vertex: $084574008ccedf86$var$project_vertex,
    dithering_fragment: $084574008ccedf86$var$dithering_fragment,
    dithering_pars_fragment: $084574008ccedf86$var$dithering_pars_fragment,
    roughnessmap_fragment: $084574008ccedf86$var$roughnessmap_fragment,
    roughnessmap_pars_fragment: $084574008ccedf86$var$roughnessmap_pars_fragment,
    shadowmap_pars_fragment: $084574008ccedf86$var$shadowmap_pars_fragment,
    shadowmap_pars_vertex: $084574008ccedf86$var$shadowmap_pars_vertex,
    shadowmap_vertex: $084574008ccedf86$var$shadowmap_vertex,
    shadowmask_pars_fragment: $084574008ccedf86$var$shadowmask_pars_fragment,
    skinbase_vertex: $084574008ccedf86$var$skinbase_vertex,
    skinning_pars_vertex: $084574008ccedf86$var$skinning_pars_vertex,
    skinning_vertex: $084574008ccedf86$var$skinning_vertex,
    skinnormal_vertex: $084574008ccedf86$var$skinnormal_vertex,
    specularmap_fragment: $084574008ccedf86$var$specularmap_fragment,
    specularmap_pars_fragment: $084574008ccedf86$var$specularmap_pars_fragment,
    tonemapping_fragment: $084574008ccedf86$var$tonemapping_fragment,
    tonemapping_pars_fragment: $084574008ccedf86$var$tonemapping_pars_fragment,
    transmission_fragment: $084574008ccedf86$var$transmission_fragment,
    transmission_pars_fragment: $084574008ccedf86$var$transmission_pars_fragment,
    uv_pars_fragment: $084574008ccedf86$var$uv_pars_fragment,
    uv_pars_vertex: $084574008ccedf86$var$uv_pars_vertex,
    uv_vertex: $084574008ccedf86$var$uv_vertex,
    uv2_pars_fragment: $084574008ccedf86$var$uv2_pars_fragment,
    uv2_pars_vertex: $084574008ccedf86$var$uv2_pars_vertex,
    uv2_vertex: $084574008ccedf86$var$uv2_vertex,
    worldpos_vertex: $084574008ccedf86$var$worldpos_vertex,
    background_vert: $084574008ccedf86$var$vertex$g,
    background_frag: $084574008ccedf86$var$fragment$g,
    cube_vert: $084574008ccedf86$var$vertex$f,
    cube_frag: $084574008ccedf86$var$fragment$f,
    depth_vert: $084574008ccedf86$var$vertex$e,
    depth_frag: $084574008ccedf86$var$fragment$e,
    distanceRGBA_vert: $084574008ccedf86$var$vertex$d,
    distanceRGBA_frag: $084574008ccedf86$var$fragment$d,
    equirect_vert: $084574008ccedf86$var$vertex$c,
    equirect_frag: $084574008ccedf86$var$fragment$c,
    linedashed_vert: $084574008ccedf86$var$vertex$b,
    linedashed_frag: $084574008ccedf86$var$fragment$b,
    meshbasic_vert: $084574008ccedf86$var$vertex$a,
    meshbasic_frag: $084574008ccedf86$var$fragment$a,
    meshlambert_vert: $084574008ccedf86$var$vertex$9,
    meshlambert_frag: $084574008ccedf86$var$fragment$9,
    meshmatcap_vert: $084574008ccedf86$var$vertex$8,
    meshmatcap_frag: $084574008ccedf86$var$fragment$8,
    meshnormal_vert: $084574008ccedf86$var$vertex$7,
    meshnormal_frag: $084574008ccedf86$var$fragment$7,
    meshphong_vert: $084574008ccedf86$var$vertex$6,
    meshphong_frag: $084574008ccedf86$var$fragment$6,
    meshphysical_vert: $084574008ccedf86$var$vertex$5,
    meshphysical_frag: $084574008ccedf86$var$fragment$5,
    meshtoon_vert: $084574008ccedf86$var$vertex$4,
    meshtoon_frag: $084574008ccedf86$var$fragment$4,
    points_vert: $084574008ccedf86$var$vertex$3,
    points_frag: $084574008ccedf86$var$fragment$3,
    shadow_vert: $084574008ccedf86$var$vertex$2,
    shadow_frag: $084574008ccedf86$var$fragment$2,
    sprite_vert: $084574008ccedf86$var$vertex$1,
    sprite_frag: $084574008ccedf86$var$fragment$1
};
/**
 * Uniforms library for shared webgl shaders
 */ const $084574008ccedf86$export$6643083551874bf5 = {
    common: {
        diffuse: {
            value: new $084574008ccedf86$export$892596cec99bc70e(0xffffff)
        },
        opacity: {
            value: 1.0
        },
        map: {
            value: null
        },
        uvTransform: {
            value: new $084574008ccedf86$export$8ff26dafa08918()
        },
        uv2Transform: {
            value: new $084574008ccedf86$export$8ff26dafa08918()
        },
        alphaMap: {
            value: null
        },
        alphaTest: {
            value: 0
        }
    },
    specularmap: {
        specularMap: {
            value: null
        }
    },
    envmap: {
        envMap: {
            value: null
        },
        flipEnvMap: {
            value: -1
        },
        reflectivity: {
            value: 1.0
        },
        ior: {
            value: 1.5
        },
        refractionRatio: {
            value: 0.98
        } // basic, lambert, phong
    },
    aomap: {
        aoMap: {
            value: null
        },
        aoMapIntensity: {
            value: 1
        }
    },
    lightmap: {
        lightMap: {
            value: null
        },
        lightMapIntensity: {
            value: 1
        }
    },
    emissivemap: {
        emissiveMap: {
            value: null
        }
    },
    bumpmap: {
        bumpMap: {
            value: null
        },
        bumpScale: {
            value: 1
        }
    },
    normalmap: {
        normalMap: {
            value: null
        },
        normalScale: {
            value: new $084574008ccedf86$export$c977b3e384af9ae1(1, 1)
        }
    },
    displacementmap: {
        displacementMap: {
            value: null
        },
        displacementScale: {
            value: 1
        },
        displacementBias: {
            value: 0
        }
    },
    roughnessmap: {
        roughnessMap: {
            value: null
        }
    },
    metalnessmap: {
        metalnessMap: {
            value: null
        }
    },
    gradientmap: {
        gradientMap: {
            value: null
        }
    },
    fog: {
        fogDensity: {
            value: 0.00025
        },
        fogNear: {
            value: 1
        },
        fogFar: {
            value: 2000
        },
        fogColor: {
            value: new $084574008ccedf86$export$892596cec99bc70e(0xffffff)
        }
    },
    lights: {
        ambientLightColor: {
            value: []
        },
        lightProbe: {
            value: []
        },
        directionalLights: {
            value: [],
            properties: {
                direction: {},
                color: {}
            }
        },
        directionalLightShadows: {
            value: [],
            properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {}
            }
        },
        directionalShadowMap: {
            value: []
        },
        directionalShadowMatrix: {
            value: []
        },
        spotLights: {
            value: [],
            properties: {
                color: {},
                position: {},
                direction: {},
                distance: {},
                coneCos: {},
                penumbraCos: {},
                decay: {}
            }
        },
        spotLightShadows: {
            value: [],
            properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {}
            }
        },
        spotShadowMap: {
            value: []
        },
        spotShadowMatrix: {
            value: []
        },
        pointLights: {
            value: [],
            properties: {
                color: {},
                position: {},
                decay: {},
                distance: {}
            }
        },
        pointLightShadows: {
            value: [],
            properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {},
                shadowCameraNear: {},
                shadowCameraFar: {}
            }
        },
        pointShadowMap: {
            value: []
        },
        pointShadowMatrix: {
            value: []
        },
        hemisphereLights: {
            value: [],
            properties: {
                direction: {},
                skyColor: {},
                groundColor: {}
            }
        },
        // TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
        rectAreaLights: {
            value: [],
            properties: {
                color: {},
                position: {},
                width: {},
                height: {}
            }
        },
        ltc_1: {
            value: null
        },
        ltc_2: {
            value: null
        }
    },
    points: {
        diffuse: {
            value: new $084574008ccedf86$export$892596cec99bc70e(0xffffff)
        },
        opacity: {
            value: 1.0
        },
        size: {
            value: 1.0
        },
        scale: {
            value: 1.0
        },
        map: {
            value: null
        },
        alphaMap: {
            value: null
        },
        alphaTest: {
            value: 0
        },
        uvTransform: {
            value: new $084574008ccedf86$export$8ff26dafa08918()
        }
    },
    sprite: {
        diffuse: {
            value: new $084574008ccedf86$export$892596cec99bc70e(0xffffff)
        },
        opacity: {
            value: 1.0
        },
        center: {
            value: new $084574008ccedf86$export$c977b3e384af9ae1(0.5, 0.5)
        },
        rotation: {
            value: 0.0
        },
        map: {
            value: null
        },
        alphaMap: {
            value: null
        },
        alphaTest: {
            value: 0
        },
        uvTransform: {
            value: new $084574008ccedf86$export$8ff26dafa08918()
        }
    }
};
const $084574008ccedf86$export$bee4a7d47f8f5014 = {
    basic: {
        uniforms: $084574008ccedf86$var$mergeUniforms([
            $084574008ccedf86$export$6643083551874bf5.common,
            $084574008ccedf86$export$6643083551874bf5.specularmap,
            $084574008ccedf86$export$6643083551874bf5.envmap,
            $084574008ccedf86$export$6643083551874bf5.aomap,
            $084574008ccedf86$export$6643083551874bf5.lightmap,
            $084574008ccedf86$export$6643083551874bf5.fog
        ]),
        vertexShader: $084574008ccedf86$export$955f9f2e84c43c8b.meshbasic_vert,
        fragmentShader: $084574008ccedf86$export$955f9f2e84c43c8b.meshbasic_frag
    },
    lambert: {
        uniforms: $084574008ccedf86$var$mergeUniforms([
            $084574008ccedf86$export$6643083551874bf5.common,
            $084574008ccedf86$export$6643083551874bf5.specularmap,
            $084574008ccedf86$export$6643083551874bf5.envmap,
            $084574008ccedf86$export$6643083551874bf5.aomap,
            $084574008ccedf86$export$6643083551874bf5.lightmap,
            $084574008ccedf86$export$6643083551874bf5.emissivemap,
            $084574008ccedf86$export$6643083551874bf5.fog,
            $084574008ccedf86$export$6643083551874bf5.lights,
            {
                emissive: {
                    value: new $084574008ccedf86$export$892596cec99bc70e(0x000000)
                }
            }
        ]),
        vertexShader: $084574008ccedf86$export$955f9f2e84c43c8b.meshlambert_vert,
        fragmentShader: $084574008ccedf86$export$955f9f2e84c43c8b.meshlambert_frag
    },
    phong: {
        uniforms: $084574008ccedf86$var$mergeUniforms([
            $084574008ccedf86$export$6643083551874bf5.common,
            $084574008ccedf86$export$6643083551874bf5.specularmap,
            $084574008ccedf86$export$6643083551874bf5.envmap,
            $084574008ccedf86$export$6643083551874bf5.aomap,
            $084574008ccedf86$export$6643083551874bf5.lightmap,
            $084574008ccedf86$export$6643083551874bf5.emissivemap,
            $084574008ccedf86$export$6643083551874bf5.bumpmap,
            $084574008ccedf86$export$6643083551874bf5.normalmap,
            $084574008ccedf86$export$6643083551874bf5.displacementmap,
            $084574008ccedf86$export$6643083551874bf5.fog,
            $084574008ccedf86$export$6643083551874bf5.lights,
            {
                emissive: {
                    value: new $084574008ccedf86$export$892596cec99bc70e(0x000000)
                },
                specular: {
                    value: new $084574008ccedf86$export$892596cec99bc70e(0x111111)
                },
                shininess: {
                    value: 30
                }
            }
        ]),
        vertexShader: $084574008ccedf86$export$955f9f2e84c43c8b.meshphong_vert,
        fragmentShader: $084574008ccedf86$export$955f9f2e84c43c8b.meshphong_frag
    },
    standard: {
        uniforms: $084574008ccedf86$var$mergeUniforms([
            $084574008ccedf86$export$6643083551874bf5.common,
            $084574008ccedf86$export$6643083551874bf5.envmap,
            $084574008ccedf86$export$6643083551874bf5.aomap,
            $084574008ccedf86$export$6643083551874bf5.lightmap,
            $084574008ccedf86$export$6643083551874bf5.emissivemap,
            $084574008ccedf86$export$6643083551874bf5.bumpmap,
            $084574008ccedf86$export$6643083551874bf5.normalmap,
            $084574008ccedf86$export$6643083551874bf5.displacementmap,
            $084574008ccedf86$export$6643083551874bf5.roughnessmap,
            $084574008ccedf86$export$6643083551874bf5.metalnessmap,
            $084574008ccedf86$export$6643083551874bf5.fog,
            $084574008ccedf86$export$6643083551874bf5.lights,
            {
                emissive: {
                    value: new $084574008ccedf86$export$892596cec99bc70e(0x000000)
                },
                roughness: {
                    value: 1.0
                },
                metalness: {
                    value: 0.0
                },
                envMapIntensity: {
                    value: 1
                } // temporary
            }
        ]),
        vertexShader: $084574008ccedf86$export$955f9f2e84c43c8b.meshphysical_vert,
        fragmentShader: $084574008ccedf86$export$955f9f2e84c43c8b.meshphysical_frag
    },
    toon: {
        uniforms: $084574008ccedf86$var$mergeUniforms([
            $084574008ccedf86$export$6643083551874bf5.common,
            $084574008ccedf86$export$6643083551874bf5.aomap,
            $084574008ccedf86$export$6643083551874bf5.lightmap,
            $084574008ccedf86$export$6643083551874bf5.emissivemap,
            $084574008ccedf86$export$6643083551874bf5.bumpmap,
            $084574008ccedf86$export$6643083551874bf5.normalmap,
            $084574008ccedf86$export$6643083551874bf5.displacementmap,
            $084574008ccedf86$export$6643083551874bf5.gradientmap,
            $084574008ccedf86$export$6643083551874bf5.fog,
            $084574008ccedf86$export$6643083551874bf5.lights,
            {
                emissive: {
                    value: new $084574008ccedf86$export$892596cec99bc70e(0x000000)
                }
            }
        ]),
        vertexShader: $084574008ccedf86$export$955f9f2e84c43c8b.meshtoon_vert,
        fragmentShader: $084574008ccedf86$export$955f9f2e84c43c8b.meshtoon_frag
    },
    matcap: {
        uniforms: $084574008ccedf86$var$mergeUniforms([
            $084574008ccedf86$export$6643083551874bf5.common,
            $084574008ccedf86$export$6643083551874bf5.bumpmap,
            $084574008ccedf86$export$6643083551874bf5.normalmap,
            $084574008ccedf86$export$6643083551874bf5.displacementmap,
            $084574008ccedf86$export$6643083551874bf5.fog,
            {
                matcap: {
                    value: null
                }
            }
        ]),
        vertexShader: $084574008ccedf86$export$955f9f2e84c43c8b.meshmatcap_vert,
        fragmentShader: $084574008ccedf86$export$955f9f2e84c43c8b.meshmatcap_frag
    },
    points: {
        uniforms: $084574008ccedf86$var$mergeUniforms([
            $084574008ccedf86$export$6643083551874bf5.points,
            $084574008ccedf86$export$6643083551874bf5.fog
        ]),
        vertexShader: $084574008ccedf86$export$955f9f2e84c43c8b.points_vert,
        fragmentShader: $084574008ccedf86$export$955f9f2e84c43c8b.points_frag
    },
    dashed: {
        uniforms: $084574008ccedf86$var$mergeUniforms([
            $084574008ccedf86$export$6643083551874bf5.common,
            $084574008ccedf86$export$6643083551874bf5.fog,
            {
                scale: {
                    value: 1
                },
                dashSize: {
                    value: 1
                },
                totalSize: {
                    value: 2
                }
            }
        ]),
        vertexShader: $084574008ccedf86$export$955f9f2e84c43c8b.linedashed_vert,
        fragmentShader: $084574008ccedf86$export$955f9f2e84c43c8b.linedashed_frag
    },
    depth: {
        uniforms: $084574008ccedf86$var$mergeUniforms([
            $084574008ccedf86$export$6643083551874bf5.common,
            $084574008ccedf86$export$6643083551874bf5.displacementmap
        ]),
        vertexShader: $084574008ccedf86$export$955f9f2e84c43c8b.depth_vert,
        fragmentShader: $084574008ccedf86$export$955f9f2e84c43c8b.depth_frag
    },
    normal: {
        uniforms: $084574008ccedf86$var$mergeUniforms([
            $084574008ccedf86$export$6643083551874bf5.common,
            $084574008ccedf86$export$6643083551874bf5.bumpmap,
            $084574008ccedf86$export$6643083551874bf5.normalmap,
            $084574008ccedf86$export$6643083551874bf5.displacementmap,
            {
                opacity: {
                    value: 1.0
                }
            }
        ]),
        vertexShader: $084574008ccedf86$export$955f9f2e84c43c8b.meshnormal_vert,
        fragmentShader: $084574008ccedf86$export$955f9f2e84c43c8b.meshnormal_frag
    },
    sprite: {
        uniforms: $084574008ccedf86$var$mergeUniforms([
            $084574008ccedf86$export$6643083551874bf5.sprite,
            $084574008ccedf86$export$6643083551874bf5.fog
        ]),
        vertexShader: $084574008ccedf86$export$955f9f2e84c43c8b.sprite_vert,
        fragmentShader: $084574008ccedf86$export$955f9f2e84c43c8b.sprite_frag
    },
    background: {
        uniforms: {
            uvTransform: {
                value: new $084574008ccedf86$export$8ff26dafa08918()
            },
            t2D: {
                value: null
            }
        },
        vertexShader: $084574008ccedf86$export$955f9f2e84c43c8b.background_vert,
        fragmentShader: $084574008ccedf86$export$955f9f2e84c43c8b.background_frag
    },
    /* -------------------------------------------------------------------------
	//	Cube map shader
	 ------------------------------------------------------------------------- */ cube: {
        uniforms: $084574008ccedf86$var$mergeUniforms([
            $084574008ccedf86$export$6643083551874bf5.envmap,
            {
                opacity: {
                    value: 1.0
                }
            }
        ]),
        vertexShader: $084574008ccedf86$export$955f9f2e84c43c8b.cube_vert,
        fragmentShader: $084574008ccedf86$export$955f9f2e84c43c8b.cube_frag
    },
    equirect: {
        uniforms: {
            tEquirect: {
                value: null
            }
        },
        vertexShader: $084574008ccedf86$export$955f9f2e84c43c8b.equirect_vert,
        fragmentShader: $084574008ccedf86$export$955f9f2e84c43c8b.equirect_frag
    },
    distanceRGBA: {
        uniforms: $084574008ccedf86$var$mergeUniforms([
            $084574008ccedf86$export$6643083551874bf5.common,
            $084574008ccedf86$export$6643083551874bf5.displacementmap,
            {
                referencePosition: {
                    value: new $084574008ccedf86$export$64b5c384219d3699()
                },
                nearDistance: {
                    value: 1
                },
                farDistance: {
                    value: 1000
                }
            }
        ]),
        vertexShader: $084574008ccedf86$export$955f9f2e84c43c8b.distanceRGBA_vert,
        fragmentShader: $084574008ccedf86$export$955f9f2e84c43c8b.distanceRGBA_frag
    },
    shadow: {
        uniforms: $084574008ccedf86$var$mergeUniforms([
            $084574008ccedf86$export$6643083551874bf5.lights,
            $084574008ccedf86$export$6643083551874bf5.fog,
            {
                color: {
                    value: new $084574008ccedf86$export$892596cec99bc70e(0x00000)
                },
                opacity: {
                    value: 1.0
                }
            }, 
        ]),
        vertexShader: $084574008ccedf86$export$955f9f2e84c43c8b.shadow_vert,
        fragmentShader: $084574008ccedf86$export$955f9f2e84c43c8b.shadow_frag
    }
};
$084574008ccedf86$export$bee4a7d47f8f5014.physical = {
    uniforms: $084574008ccedf86$var$mergeUniforms([
        $084574008ccedf86$export$bee4a7d47f8f5014.standard.uniforms,
        {
            clearcoat: {
                value: 0
            },
            clearcoatMap: {
                value: null
            },
            clearcoatRoughness: {
                value: 0
            },
            clearcoatRoughnessMap: {
                value: null
            },
            clearcoatNormalScale: {
                value: new $084574008ccedf86$export$c977b3e384af9ae1(1, 1)
            },
            clearcoatNormalMap: {
                value: null
            },
            iridescence: {
                value: 0
            },
            iridescenceMap: {
                value: null
            },
            iridescenceIOR: {
                value: 1.3
            },
            iridescenceThicknessMinimum: {
                value: 100
            },
            iridescenceThicknessMaximum: {
                value: 400
            },
            iridescenceThicknessMap: {
                value: null
            },
            sheen: {
                value: 0
            },
            sheenColor: {
                value: new $084574008ccedf86$export$892596cec99bc70e(0x000000)
            },
            sheenColorMap: {
                value: null
            },
            sheenRoughness: {
                value: 1
            },
            sheenRoughnessMap: {
                value: null
            },
            transmission: {
                value: 0
            },
            transmissionMap: {
                value: null
            },
            transmissionSamplerSize: {
                value: new $084574008ccedf86$export$c977b3e384af9ae1()
            },
            transmissionSamplerMap: {
                value: null
            },
            thickness: {
                value: 0
            },
            thicknessMap: {
                value: null
            },
            attenuationDistance: {
                value: 0
            },
            attenuationColor: {
                value: new $084574008ccedf86$export$892596cec99bc70e(0x000000)
            },
            specularIntensity: {
                value: 1
            },
            specularIntensityMap: {
                value: null
            },
            specularColor: {
                value: new $084574008ccedf86$export$892596cec99bc70e(1, 1, 1)
            },
            specularColorMap: {
                value: null
            }
        }
    ]),
    vertexShader: $084574008ccedf86$export$955f9f2e84c43c8b.meshphysical_vert,
    fragmentShader: $084574008ccedf86$export$955f9f2e84c43c8b.meshphysical_frag
};
function $084574008ccedf86$var$WebGLBackground(renderer, cubemaps, state, objects, alpha1, premultipliedAlpha) {
    const clearColor = new $084574008ccedf86$export$892596cec99bc70e(0x000000);
    let clearAlpha = alpha1 === true ? 0 : 1;
    let planeMesh;
    let boxMesh;
    let currentBackground = null;
    let currentBackgroundVersion = 0;
    let currentTonemapping = null;
    function render(renderList, scene) {
        let forceClear = false;
        let background = scene.isScene === true ? scene.background : null;
        if (background && background.isTexture) background = cubemaps.get(background);
        // Ignore background in AR
        // TODO: Reconsider this.
        const xr = renderer.xr;
        const session = xr.getSession && xr.getSession();
        if (session && session.environmentBlendMode === "additive") background = null;
        if (background === null) setClear(clearColor, clearAlpha);
        else if (background && background.isColor) {
            setClear(background, 1);
            forceClear = true;
        }
        if (renderer.autoClear || forceClear) renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
        if (background && (background.isCubeTexture || background.mapping === $084574008ccedf86$export$dbf3e70ff37af79)) {
            if (boxMesh === undefined) {
                boxMesh = new $084574008ccedf86$export$e176487c05830cc5(new $084574008ccedf86$export$ab3456a079aa7d80(1, 1, 1), new $084574008ccedf86$export$83c7d75d550a8b0d({
                    name: "BackgroundCubeMaterial",
                    uniforms: $084574008ccedf86$var$cloneUniforms($084574008ccedf86$export$bee4a7d47f8f5014.cube.uniforms),
                    vertexShader: $084574008ccedf86$export$bee4a7d47f8f5014.cube.vertexShader,
                    fragmentShader: $084574008ccedf86$export$bee4a7d47f8f5014.cube.fragmentShader,
                    side: $084574008ccedf86$export$d9f0486e75b5ace,
                    depthTest: false,
                    depthWrite: false,
                    fog: false
                }));
                boxMesh.geometry.deleteAttribute("normal");
                boxMesh.geometry.deleteAttribute("uv");
                boxMesh.onBeforeRender = function(renderer, scene, camera) {
                    this.matrixWorld.copyPosition(camera.matrixWorld);
                };
                // enable code injection for non-built-in material
                Object.defineProperty(boxMesh.material, "envMap", {
                    get: function() {
                        return this.uniforms.envMap.value;
                    }
                });
                objects.update(boxMesh);
            }
            boxMesh.material.uniforms.envMap.value = background;
            boxMesh.material.uniforms.flipEnvMap.value = background.isCubeTexture && background.isRenderTargetTexture === false ? -1 : 1;
            if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
                boxMesh.material.needsUpdate = true;
                currentBackground = background;
                currentBackgroundVersion = background.version;
                currentTonemapping = renderer.toneMapping;
            }
            boxMesh.layers.enableAll();
            // push to the pre-sorted opaque render list
            renderList.unshift(boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null);
        } else if (background && background.isTexture) {
            if (planeMesh === undefined) {
                planeMesh = new $084574008ccedf86$export$e176487c05830cc5(new $084574008ccedf86$export$e789a11a194ca4e0(2, 2), new $084574008ccedf86$export$83c7d75d550a8b0d({
                    name: "BackgroundMaterial",
                    uniforms: $084574008ccedf86$var$cloneUniforms($084574008ccedf86$export$bee4a7d47f8f5014.background.uniforms),
                    vertexShader: $084574008ccedf86$export$bee4a7d47f8f5014.background.vertexShader,
                    fragmentShader: $084574008ccedf86$export$bee4a7d47f8f5014.background.fragmentShader,
                    side: $084574008ccedf86$export$2ede184fc2998901,
                    depthTest: false,
                    depthWrite: false,
                    fog: false
                }));
                planeMesh.geometry.deleteAttribute("normal");
                // enable code injection for non-built-in material
                Object.defineProperty(planeMesh.material, "map", {
                    get: function() {
                        return this.uniforms.t2D.value;
                    }
                });
                objects.update(planeMesh);
            }
            planeMesh.material.uniforms.t2D.value = background;
            if (background.matrixAutoUpdate === true) background.updateMatrix();
            planeMesh.material.uniforms.uvTransform.value.copy(background.matrix);
            if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
                planeMesh.material.needsUpdate = true;
                currentBackground = background;
                currentBackgroundVersion = background.version;
                currentTonemapping = renderer.toneMapping;
            }
            planeMesh.layers.enableAll();
            // push to the pre-sorted opaque render list
            renderList.unshift(planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null);
        }
    }
    function setClear(color, alpha) {
        state.buffers.color.setClear(color.r, color.g, color.b, alpha, premultipliedAlpha);
    }
    return {
        getClearColor: function() {
            return clearColor;
        },
        setClearColor: function(color, alpha = 1) {
            clearColor.set(color);
            clearAlpha = alpha;
            setClear(clearColor, clearAlpha);
        },
        getClearAlpha: function() {
            return clearAlpha;
        },
        setClearAlpha: function(alpha) {
            clearAlpha = alpha;
            setClear(clearColor, clearAlpha);
        },
        render: render
    };
}
function $084574008ccedf86$var$WebGLBindingStates(gl, extensions, attributes1, capabilities) {
    const maxVertexAttributes = gl.getParameter(34921);
    const extension1 = capabilities.isWebGL2 ? null : extensions.get("OES_vertex_array_object");
    const vaoAvailable = capabilities.isWebGL2 || extension1 !== null;
    const bindingStates = {};
    const defaultState = createBindingState(null);
    let currentState = defaultState;
    let forceUpdate = false;
    function setup(object, material, program, geometry, index) {
        let updateBuffers = false;
        if (vaoAvailable) {
            const state = getBindingState(geometry, program, material);
            if (currentState !== state) {
                currentState = state;
                bindVertexArrayObject(currentState.object);
            }
            updateBuffers = needsUpdate(object, geometry, program, index);
            if (updateBuffers) saveCache(object, geometry, program, index);
        } else {
            const wireframe = material.wireframe === true;
            if (currentState.geometry !== geometry.id || currentState.program !== program.id || currentState.wireframe !== wireframe) {
                currentState.geometry = geometry.id;
                currentState.program = program.id;
                currentState.wireframe = wireframe;
                updateBuffers = true;
            }
        }
        if (index !== null) attributes1.update(index, 34963);
        if (updateBuffers || forceUpdate) {
            forceUpdate = false;
            setupVertexAttributes(object, material, program, geometry);
            if (index !== null) gl.bindBuffer(34963, attributes1.get(index).buffer);
        }
    }
    function createVertexArrayObject() {
        if (capabilities.isWebGL2) return gl.createVertexArray();
        return extension1.createVertexArrayOES();
    }
    function bindVertexArrayObject(vao) {
        if (capabilities.isWebGL2) return gl.bindVertexArray(vao);
        return extension1.bindVertexArrayOES(vao);
    }
    function deleteVertexArrayObject(vao) {
        if (capabilities.isWebGL2) return gl.deleteVertexArray(vao);
        return extension1.deleteVertexArrayOES(vao);
    }
    function getBindingState(geometry, program, material) {
        const wireframe = material.wireframe === true;
        let programMap = bindingStates[geometry.id];
        if (programMap === undefined) {
            programMap = {};
            bindingStates[geometry.id] = programMap;
        }
        let stateMap = programMap[program.id];
        if (stateMap === undefined) {
            stateMap = {};
            programMap[program.id] = stateMap;
        }
        let state = stateMap[wireframe];
        if (state === undefined) {
            state = createBindingState(createVertexArrayObject());
            stateMap[wireframe] = state;
        }
        return state;
    }
    function createBindingState(vao) {
        const newAttributes = [];
        const enabledAttributes = [];
        const attributeDivisors = [];
        for(let i80 = 0; i80 < maxVertexAttributes; i80++){
            newAttributes[i80] = 0;
            enabledAttributes[i80] = 0;
            attributeDivisors[i80] = 0;
        }
        return {
            // for backward compatibility on non-VAO support browser
            geometry: null,
            program: null,
            wireframe: false,
            newAttributes: newAttributes,
            enabledAttributes: enabledAttributes,
            attributeDivisors: attributeDivisors,
            object: vao,
            attributes: {},
            index: null
        };
    }
    function needsUpdate(object, geometry, program, index) {
        const cachedAttributes = currentState.attributes;
        const geometryAttributes = geometry.attributes;
        let attributesNum = 0;
        const programAttributes = program.getAttributes();
        for(const name in programAttributes){
            const programAttribute = programAttributes[name];
            if (programAttribute.location >= 0) {
                const cachedAttribute = cachedAttributes[name];
                let geometryAttribute = geometryAttributes[name];
                if (geometryAttribute === undefined) {
                    if (name === "instanceMatrix" && object.instanceMatrix) geometryAttribute = object.instanceMatrix;
                    if (name === "instanceColor" && object.instanceColor) geometryAttribute = object.instanceColor;
                }
                if (cachedAttribute === undefined) return true;
                if (cachedAttribute.attribute !== geometryAttribute) return true;
                if (geometryAttribute && cachedAttribute.data !== geometryAttribute.data) return true;
                attributesNum++;
            }
        }
        if (currentState.attributesNum !== attributesNum) return true;
        if (currentState.index !== index) return true;
        return false;
    }
    function saveCache(object, geometry, program, index) {
        const cache = {};
        const attributes = geometry.attributes;
        let attributesNum = 0;
        const programAttributes = program.getAttributes();
        for(const name in programAttributes){
            const programAttribute = programAttributes[name];
            if (programAttribute.location >= 0) {
                let attribute = attributes[name];
                if (attribute === undefined) {
                    if (name === "instanceMatrix" && object.instanceMatrix) attribute = object.instanceMatrix;
                    if (name === "instanceColor" && object.instanceColor) attribute = object.instanceColor;
                }
                const data = {};
                data.attribute = attribute;
                if (attribute && attribute.data) data.data = attribute.data;
                cache[name] = data;
                attributesNum++;
            }
        }
        currentState.attributes = cache;
        currentState.attributesNum = attributesNum;
        currentState.index = index;
    }
    function initAttributes() {
        const newAttributes = currentState.newAttributes;
        for(let i81 = 0, il = newAttributes.length; i81 < il; i81++)newAttributes[i81] = 0;
    }
    function enableAttribute(attribute) {
        enableAttributeAndDivisor(attribute, 0);
    }
    function enableAttributeAndDivisor(attribute, meshPerAttribute) {
        const newAttributes = currentState.newAttributes;
        const enabledAttributes = currentState.enabledAttributes;
        const attributeDivisors = currentState.attributeDivisors;
        newAttributes[attribute] = 1;
        if (enabledAttributes[attribute] === 0) {
            gl.enableVertexAttribArray(attribute);
            enabledAttributes[attribute] = 1;
        }
        if (attributeDivisors[attribute] !== meshPerAttribute) {
            const extension = capabilities.isWebGL2 ? gl : extensions.get("ANGLE_instanced_arrays");
            extension[capabilities.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](attribute, meshPerAttribute);
            attributeDivisors[attribute] = meshPerAttribute;
        }
    }
    function disableUnusedAttributes() {
        const newAttributes = currentState.newAttributes;
        const enabledAttributes = currentState.enabledAttributes;
        for(let i82 = 0, il = enabledAttributes.length; i82 < il; i82++)if (enabledAttributes[i82] !== newAttributes[i82]) {
            gl.disableVertexAttribArray(i82);
            enabledAttributes[i82] = 0;
        }
    }
    function vertexAttribPointer(index, size, type, normalized, stride, offset) {
        if (capabilities.isWebGL2 === true && (type === 5124 || type === 5125)) gl.vertexAttribIPointer(index, size, type, stride, offset);
        else gl.vertexAttribPointer(index, size, type, normalized, stride, offset);
    }
    function setupVertexAttributes(object, material, program, geometry) {
        if (capabilities.isWebGL2 === false && (object.isInstancedMesh || geometry.isInstancedBufferGeometry)) {
            if (extensions.get("ANGLE_instanced_arrays") === null) return;
        }
        initAttributes();
        const geometryAttributes = geometry.attributes;
        const programAttributes = program.getAttributes();
        const materialDefaultAttributeValues = material.defaultAttributeValues;
        for(const name in programAttributes){
            const programAttribute = programAttributes[name];
            if (programAttribute.location >= 0) {
                let geometryAttribute = geometryAttributes[name];
                if (geometryAttribute === undefined) {
                    if (name === "instanceMatrix" && object.instanceMatrix) geometryAttribute = object.instanceMatrix;
                    if (name === "instanceColor" && object.instanceColor) geometryAttribute = object.instanceColor;
                }
                if (geometryAttribute !== undefined) {
                    const normalized = geometryAttribute.normalized;
                    const size = geometryAttribute.itemSize;
                    const attribute = attributes1.get(geometryAttribute);
                    // TODO Attribute may not be available on context restore
                    if (attribute === undefined) continue;
                    const buffer = attribute.buffer;
                    const type = attribute.type;
                    const bytesPerElement = attribute.bytesPerElement;
                    if (geometryAttribute.isInterleavedBufferAttribute) {
                        const data = geometryAttribute.data;
                        const stride = data.stride;
                        const offset = geometryAttribute.offset;
                        if (data.isInstancedInterleavedBuffer) {
                            for(let i84 = 0; i84 < programAttribute.locationSize; i84++)enableAttributeAndDivisor(programAttribute.location + i84, data.meshPerAttribute);
                            if (object.isInstancedMesh !== true && geometry._maxInstanceCount === undefined) geometry._maxInstanceCount = data.meshPerAttribute * data.count;
                        } else for(let i85 = 0; i85 < programAttribute.locationSize; i85++)enableAttribute(programAttribute.location + i85);
                        gl.bindBuffer(34962, buffer);
                        for(let i83 = 0; i83 < programAttribute.locationSize; i83++)vertexAttribPointer(programAttribute.location + i83, size / programAttribute.locationSize, type, normalized, stride * bytesPerElement, (offset + size / programAttribute.locationSize * i83) * bytesPerElement);
                    } else {
                        if (geometryAttribute.isInstancedBufferAttribute) {
                            for(let i87 = 0; i87 < programAttribute.locationSize; i87++)enableAttributeAndDivisor(programAttribute.location + i87, geometryAttribute.meshPerAttribute);
                            if (object.isInstancedMesh !== true && geometry._maxInstanceCount === undefined) geometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;
                        } else for(let i88 = 0; i88 < programAttribute.locationSize; i88++)enableAttribute(programAttribute.location + i88);
                        gl.bindBuffer(34962, buffer);
                        for(let i86 = 0; i86 < programAttribute.locationSize; i86++)vertexAttribPointer(programAttribute.location + i86, size / programAttribute.locationSize, type, normalized, size * bytesPerElement, size / programAttribute.locationSize * i86 * bytesPerElement);
                    }
                } else if (materialDefaultAttributeValues !== undefined) {
                    const value = materialDefaultAttributeValues[name];
                    if (value !== undefined) switch(value.length){
                        case 2:
                            gl.vertexAttrib2fv(programAttribute.location, value);
                            break;
                        case 3:
                            gl.vertexAttrib3fv(programAttribute.location, value);
                            break;
                        case 4:
                            gl.vertexAttrib4fv(programAttribute.location, value);
                            break;
                        default:
                            gl.vertexAttrib1fv(programAttribute.location, value);
                    }
                }
            }
        }
        disableUnusedAttributes();
    }
    function dispose() {
        reset();
        for(const geometryId in bindingStates){
            const programMap = bindingStates[geometryId];
            for(const programId in programMap){
                const stateMap = programMap[programId];
                for(const wireframe in stateMap){
                    deleteVertexArrayObject(stateMap[wireframe].object);
                    delete stateMap[wireframe];
                }
                delete programMap[programId];
            }
            delete bindingStates[geometryId];
        }
    }
    function releaseStatesOfGeometry(geometry) {
        if (bindingStates[geometry.id] === undefined) return;
        const programMap = bindingStates[geometry.id];
        for(const programId in programMap){
            const stateMap = programMap[programId];
            for(const wireframe in stateMap){
                deleteVertexArrayObject(stateMap[wireframe].object);
                delete stateMap[wireframe];
            }
            delete programMap[programId];
        }
        delete bindingStates[geometry.id];
    }
    function releaseStatesOfProgram(program) {
        for(const geometryId in bindingStates){
            const programMap = bindingStates[geometryId];
            if (programMap[program.id] === undefined) continue;
            const stateMap = programMap[program.id];
            for(const wireframe in stateMap){
                deleteVertexArrayObject(stateMap[wireframe].object);
                delete stateMap[wireframe];
            }
            delete programMap[program.id];
        }
    }
    function reset() {
        resetDefaultState();
        forceUpdate = true;
        if (currentState === defaultState) return;
        currentState = defaultState;
        bindVertexArrayObject(currentState.object);
    }
    // for backward-compatibility
    function resetDefaultState() {
        defaultState.geometry = null;
        defaultState.program = null;
        defaultState.wireframe = false;
    }
    return {
        setup: setup,
        reset: reset,
        resetDefaultState: resetDefaultState,
        dispose: dispose,
        releaseStatesOfGeometry: releaseStatesOfGeometry,
        releaseStatesOfProgram: releaseStatesOfProgram,
        initAttributes: initAttributes,
        enableAttribute: enableAttribute,
        disableUnusedAttributes: disableUnusedAttributes
    };
}
function $084574008ccedf86$var$WebGLBufferRenderer(gl, extensions, info, capabilities) {
    const isWebGL2 = capabilities.isWebGL2;
    let mode;
    function setMode(value) {
        mode = value;
    }
    function render(start, count) {
        gl.drawArrays(mode, start, count);
        info.update(count, mode, 1);
    }
    function renderInstances(start, count, primcount) {
        if (primcount === 0) return;
        let extension, methodName;
        if (isWebGL2) {
            extension = gl;
            methodName = "drawArraysInstanced";
        } else {
            extension = extensions.get("ANGLE_instanced_arrays");
            methodName = "drawArraysInstancedANGLE";
            if (extension === null) {
                console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                return;
            }
        }
        extension[methodName](mode, start, count, primcount);
        info.update(count, mode, primcount);
    }
    //
    this.setMode = setMode;
    this.render = render;
    this.renderInstances = renderInstances;
}
function $084574008ccedf86$var$WebGLCapabilities(gl, extensions, parameters) {
    let maxAnisotropy;
    function getMaxAnisotropy() {
        if (maxAnisotropy !== undefined) return maxAnisotropy;
        if (extensions.has("EXT_texture_filter_anisotropic") === true) {
            const extension = extensions.get("EXT_texture_filter_anisotropic");
            maxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
        } else maxAnisotropy = 0;
        return maxAnisotropy;
    }
    function getMaxPrecision(precision) {
        if (precision === "highp") {
            if (gl.getShaderPrecisionFormat(35633, 36338).precision > 0 && gl.getShaderPrecisionFormat(35632, 36338).precision > 0) return "highp";
            precision = "mediump";
        }
        if (precision === "mediump") {
            if (gl.getShaderPrecisionFormat(35633, 36337).precision > 0 && gl.getShaderPrecisionFormat(35632, 36337).precision > 0) return "mediump";
        }
        return "lowp";
    }
    const isWebGL2 = typeof WebGL2RenderingContext !== "undefined" && gl instanceof WebGL2RenderingContext || typeof WebGL2ComputeRenderingContext !== "undefined" && gl instanceof WebGL2ComputeRenderingContext;
    let precision1 = parameters.precision !== undefined ? parameters.precision : "highp";
    const maxPrecision = getMaxPrecision(precision1);
    if (maxPrecision !== precision1) {
        console.warn("THREE.WebGLRenderer:", precision1, "not supported, using", maxPrecision, "instead.");
        precision1 = maxPrecision;
    }
    const drawBuffers = isWebGL2 || extensions.has("WEBGL_draw_buffers");
    const logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;
    const maxTextures = gl.getParameter(34930);
    const maxVertexTextures = gl.getParameter(35660);
    const maxTextureSize = gl.getParameter(3379);
    const maxCubemapSize = gl.getParameter(34076);
    const maxAttributes = gl.getParameter(34921);
    const maxVertexUniforms = gl.getParameter(36347);
    const maxVaryings = gl.getParameter(36348);
    const maxFragmentUniforms = gl.getParameter(36349);
    const vertexTextures = maxVertexTextures > 0;
    const floatFragmentTextures = isWebGL2 || extensions.has("OES_texture_float");
    const floatVertexTextures = vertexTextures && floatFragmentTextures;
    const maxSamples = isWebGL2 ? gl.getParameter(36183) : 0;
    return {
        isWebGL2: isWebGL2,
        drawBuffers: drawBuffers,
        getMaxAnisotropy: getMaxAnisotropy,
        getMaxPrecision: getMaxPrecision,
        precision: precision1,
        logarithmicDepthBuffer: logarithmicDepthBuffer,
        maxTextures: maxTextures,
        maxVertexTextures: maxVertexTextures,
        maxTextureSize: maxTextureSize,
        maxCubemapSize: maxCubemapSize,
        maxAttributes: maxAttributes,
        maxVertexUniforms: maxVertexUniforms,
        maxVaryings: maxVaryings,
        maxFragmentUniforms: maxFragmentUniforms,
        vertexTextures: vertexTextures,
        floatFragmentTextures: floatFragmentTextures,
        floatVertexTextures: floatVertexTextures,
        maxSamples: maxSamples
    };
}
function $084574008ccedf86$var$WebGLClipping(properties) {
    const scope = this;
    let globalState = null, numGlobalPlanes = 0, localClippingEnabled = false, renderingShadows = false;
    const plane = new $084574008ccedf86$export$7ff5ac152ef991b0(), viewNormalMatrix = new $084574008ccedf86$export$8ff26dafa08918(), uniform = {
        value: null,
        needsUpdate: false
    };
    this.uniform = uniform;
    this.numPlanes = 0;
    this.numIntersection = 0;
    this.init = function(planes, enableLocalClipping, camera) {
        const enabled = planes.length !== 0 || enableLocalClipping || // enable state of previous frame - the clipping code has to
        // run another frame in order to reset the state:
        numGlobalPlanes !== 0 || localClippingEnabled;
        localClippingEnabled = enableLocalClipping;
        globalState = projectPlanes(planes, camera, 0);
        numGlobalPlanes = planes.length;
        return enabled;
    };
    this.beginShadows = function() {
        renderingShadows = true;
        projectPlanes(null);
    };
    this.endShadows = function() {
        renderingShadows = false;
        resetGlobalState();
    };
    this.setState = function(material, camera, useCache) {
        const planes = material.clippingPlanes, clipIntersection = material.clipIntersection, clipShadows = material.clipShadows;
        const materialProperties = properties.get(material);
        if (!localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && !clipShadows) {
            // there's no local clipping
            if (renderingShadows) // there's no global clipping
            projectPlanes(null);
            else resetGlobalState();
        } else {
            const nGlobal = renderingShadows ? 0 : numGlobalPlanes, lGlobal = nGlobal * 4;
            let dstArray = materialProperties.clippingState || null;
            uniform.value = dstArray; // ensure unique state
            dstArray = projectPlanes(planes, camera, lGlobal, useCache);
            for(let i89 = 0; i89 !== lGlobal; ++i89)dstArray[i89] = globalState[i89];
            materialProperties.clippingState = dstArray;
            this.numIntersection = clipIntersection ? this.numPlanes : 0;
            this.numPlanes += nGlobal;
        }
    };
    function resetGlobalState() {
        if (uniform.value !== globalState) {
            uniform.value = globalState;
            uniform.needsUpdate = numGlobalPlanes > 0;
        }
        scope.numPlanes = numGlobalPlanes;
        scope.numIntersection = 0;
    }
    function projectPlanes(planes, camera, dstOffset, skipTransform) {
        const nPlanes = planes !== null ? planes.length : 0;
        let dstArray = null;
        if (nPlanes !== 0) {
            dstArray = uniform.value;
            if (skipTransform !== true || dstArray === null) {
                const flatSize = dstOffset + nPlanes * 4, viewMatrix = camera.matrixWorldInverse;
                viewNormalMatrix.getNormalMatrix(viewMatrix);
                if (dstArray === null || dstArray.length < flatSize) dstArray = new Float32Array(flatSize);
                for(let i90 = 0, i410 = dstOffset; i90 !== nPlanes; ++i90, i410 += 4){
                    plane.copy(planes[i90]).applyMatrix4(viewMatrix, viewNormalMatrix);
                    plane.normal.toArray(dstArray, i410);
                    dstArray[i410 + 3] = plane.constant;
                }
            }
            uniform.value = dstArray;
            uniform.needsUpdate = true;
        }
        scope.numPlanes = nPlanes;
        scope.numIntersection = 0;
        return dstArray;
    }
}
function $084574008ccedf86$var$WebGLCubeMaps(renderer) {
    let cubemaps = new WeakMap();
    function mapTextureMapping(texture, mapping) {
        if (mapping === $084574008ccedf86$export$d64030b316d3b087) texture.mapping = $084574008ccedf86$export$8759762a6477f2c4;
        else if (mapping === $084574008ccedf86$export$ee99d97d46898098) texture.mapping = $084574008ccedf86$export$dc59f8aed047f61d;
        return texture;
    }
    function get(texture) {
        if (texture && texture.isTexture && texture.isRenderTargetTexture === false) {
            const mapping = texture.mapping;
            if (mapping === $084574008ccedf86$export$d64030b316d3b087 || mapping === $084574008ccedf86$export$ee99d97d46898098) {
                if (cubemaps.has(texture)) {
                    const cubemap = cubemaps.get(texture).texture;
                    return mapTextureMapping(cubemap, texture.mapping);
                } else {
                    const image = texture.image;
                    if (image && image.height > 0) {
                        const renderTarget = new $084574008ccedf86$export$ac386671d651941e(image.height / 2);
                        renderTarget.fromEquirectangularTexture(renderer, texture);
                        cubemaps.set(texture, renderTarget);
                        texture.addEventListener("dispose", onTextureDispose);
                        return mapTextureMapping(renderTarget.texture, texture.mapping);
                    } else // image not yet ready. try the conversion next frame
                    return null;
                }
            }
        }
        return texture;
    }
    function onTextureDispose(event) {
        const texture = event.target;
        texture.removeEventListener("dispose", onTextureDispose);
        const cubemap = cubemaps.get(texture);
        if (cubemap !== undefined) {
            cubemaps.delete(texture);
            cubemap.dispose();
        }
    }
    function dispose() {
        cubemaps = new WeakMap();
    }
    return {
        get: get,
        dispose: dispose
    };
}
class $084574008ccedf86$export$9ebf355ee4ed261b extends $084574008ccedf86$export$79f141de891a5fed {
    constructor(left = -1, right = 1, top = 1, bottom = -1, near = 0.1, far = 2000){
        super();
        this.isOrthographicCamera = true;
        this.type = "OrthographicCamera";
        this.zoom = 1;
        this.view = null;
        this.left = left;
        this.right = right;
        this.top = top;
        this.bottom = bottom;
        this.near = near;
        this.far = far;
        this.updateProjectionMatrix();
    }
    copy(source, recursive) {
        super.copy(source, recursive);
        this.left = source.left;
        this.right = source.right;
        this.top = source.top;
        this.bottom = source.bottom;
        this.near = source.near;
        this.far = source.far;
        this.zoom = source.zoom;
        this.view = source.view === null ? null : Object.assign({}, source.view);
        return this;
    }
    setViewOffset(fullWidth, fullHeight, x, y, width, height) {
        if (this.view === null) this.view = {
            enabled: true,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
        };
        this.view.enabled = true;
        this.view.fullWidth = fullWidth;
        this.view.fullHeight = fullHeight;
        this.view.offsetX = x;
        this.view.offsetY = y;
        this.view.width = width;
        this.view.height = height;
        this.updateProjectionMatrix();
    }
    clearViewOffset() {
        if (this.view !== null) this.view.enabled = false;
        this.updateProjectionMatrix();
    }
    updateProjectionMatrix() {
        const dx = (this.right - this.left) / (2 * this.zoom);
        const dy = (this.top - this.bottom) / (2 * this.zoom);
        const cx = (this.right + this.left) / 2;
        const cy = (this.top + this.bottom) / 2;
        let left = cx - dx;
        let right = cx + dx;
        let top = cy + dy;
        let bottom = cy - dy;
        if (this.view !== null && this.view.enabled) {
            const scaleW = (this.right - this.left) / this.view.fullWidth / this.zoom;
            const scaleH = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
            left += scaleW * this.view.offsetX;
            right = left + scaleW * this.view.width;
            top -= scaleH * this.view.offsetY;
            bottom = top - scaleH * this.view.height;
        }
        this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far);
        this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
    }
    toJSON(meta) {
        const data = super.toJSON(meta);
        data.object.zoom = this.zoom;
        data.object.left = this.left;
        data.object.right = this.right;
        data.object.top = this.top;
        data.object.bottom = this.bottom;
        data.object.near = this.near;
        data.object.far = this.far;
        if (this.view !== null) data.object.view = Object.assign({}, this.view);
        return data;
    }
}
const $084574008ccedf86$var$LOD_MIN = 4;
// The standard deviations (radians) associated with the extra mips. These are
// chosen to approximate a Trowbridge-Reitz distribution function times the
// geometric shadowing function. These sigma values squared must match the
// variance #defines in cube_uv_reflection_fragment.glsl.js.
const $084574008ccedf86$var$EXTRA_LOD_SIGMA = [
    0.125,
    0.215,
    0.35,
    0.446,
    0.526,
    0.582
];
// The maximum length of the blur for loop. Smaller sigmas will use fewer
// samples and exit early, but not recompile the shader.
const $084574008ccedf86$var$MAX_SAMPLES = 20;
const $084574008ccedf86$var$_flatCamera = /*@__PURE__*/ new $084574008ccedf86$export$9ebf355ee4ed261b();
const $084574008ccedf86$var$_clearColor = /*@__PURE__*/ new $084574008ccedf86$export$892596cec99bc70e();
let $084574008ccedf86$var$_oldTarget = null;
// Golden Ratio
const $084574008ccedf86$var$PHI = (1 + Math.sqrt(5)) / 2;
const $084574008ccedf86$var$INV_PHI = 1 / $084574008ccedf86$var$PHI;
// Vertices of a dodecahedron (except the opposites, which represent the
// same axis), used as axis directions evenly spread on a sphere.
const $084574008ccedf86$var$_axisDirections = [
    /*@__PURE__*/ new $084574008ccedf86$export$64b5c384219d3699(1, 1, 1),
    /*@__PURE__*/ new $084574008ccedf86$export$64b5c384219d3699(-1, 1, 1),
    /*@__PURE__*/ new $084574008ccedf86$export$64b5c384219d3699(1, 1, -1),
    /*@__PURE__*/ new $084574008ccedf86$export$64b5c384219d3699(-1, 1, -1),
    /*@__PURE__*/ new $084574008ccedf86$export$64b5c384219d3699(0, $084574008ccedf86$var$PHI, $084574008ccedf86$var$INV_PHI),
    /*@__PURE__*/ new $084574008ccedf86$export$64b5c384219d3699(0, $084574008ccedf86$var$PHI, -$084574008ccedf86$var$INV_PHI),
    /*@__PURE__*/ new $084574008ccedf86$export$64b5c384219d3699($084574008ccedf86$var$INV_PHI, 0, $084574008ccedf86$var$PHI),
    /*@__PURE__*/ new $084574008ccedf86$export$64b5c384219d3699(-$084574008ccedf86$var$INV_PHI, 0, $084574008ccedf86$var$PHI),
    /*@__PURE__*/ new $084574008ccedf86$export$64b5c384219d3699($084574008ccedf86$var$PHI, $084574008ccedf86$var$INV_PHI, 0),
    /*@__PURE__*/ new $084574008ccedf86$export$64b5c384219d3699(-$084574008ccedf86$var$PHI, $084574008ccedf86$var$INV_PHI, 0)
];
/**
 * This class generates a Prefiltered, Mipmapped Radiance Environment Map
 * (PMREM) from a cubeMap environment texture. This allows different levels of
 * blur to be quickly accessed based on material roughness. It is packed into a
 * special CubeUV format that allows us to perform custom interpolation so that
 * we can support nonlinear formats such as RGBE. Unlike a traditional mipmap
 * chain, it only goes down to the LOD_MIN level (above), and then creates extra
 * even more filtered 'mips' at the same LOD_MIN resolution, associated with
 * higher roughness levels. In this way we maintain resolution to smoothly
 * interpolate diffuse lighting while limiting sampling computation.
 *
 * Paper: Fast, Accurate Image-Based Lighting
 * https://drive.google.com/file/d/15y8r_UpKlU9SvV4ILb0C3qCPecS8pvLz/view
*/ class $084574008ccedf86$export$6add42717753e221 {
    constructor(renderer){
        this._renderer = renderer;
        this._pingPongRenderTarget = null;
        this._lodMax = 0;
        this._cubeSize = 0;
        this._lodPlanes = [];
        this._sizeLods = [];
        this._sigmas = [];
        this._blurMaterial = null;
        this._cubemapMaterial = null;
        this._equirectMaterial = null;
        this._compileMaterial(this._blurMaterial);
    }
    /**
	 * Generates a PMREM from a supplied Scene, which can be faster than using an
	 * image if networking bandwidth is low. Optional sigma specifies a blur radius
	 * in radians to be applied to the scene before PMREM generation. Optional near
	 * and far planes ensure the scene is rendered in its entirety (the cubeCamera
	 * is placed at the origin).
	 */ fromScene(scene, sigma = 0, near = 0.1, far = 100) {
        $084574008ccedf86$var$_oldTarget = this._renderer.getRenderTarget();
        this._setSize(256);
        const cubeUVRenderTarget = this._allocateTargets();
        cubeUVRenderTarget.depthBuffer = true;
        this._sceneToCubeUV(scene, near, far, cubeUVRenderTarget);
        if (sigma > 0) this._blur(cubeUVRenderTarget, 0, 0, sigma);
        this._applyPMREM(cubeUVRenderTarget);
        this._cleanup(cubeUVRenderTarget);
        return cubeUVRenderTarget;
    }
    /**
	 * Generates a PMREM from an equirectangular texture, which can be either LDR
	 * or HDR. The ideal input image size is 1k (1024 x 512),
	 * as this matches best with the 256 x 256 cubemap output.
	 */ fromEquirectangular(equirectangular, renderTarget = null) {
        return this._fromTexture(equirectangular, renderTarget);
    }
    /**
	 * Generates a PMREM from an cubemap texture, which can be either LDR
	 * or HDR. The ideal input cube size is 256 x 256,
	 * as this matches best with the 256 x 256 cubemap output.
	 */ fromCubemap(cubemap, renderTarget = null) {
        return this._fromTexture(cubemap, renderTarget);
    }
    /**
	 * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
	 * your texture's network fetch for increased concurrency.
	 */ compileCubemapShader() {
        if (this._cubemapMaterial === null) {
            this._cubemapMaterial = $084574008ccedf86$var$_getCubemapMaterial();
            this._compileMaterial(this._cubemapMaterial);
        }
    }
    /**
	 * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
	 * your texture's network fetch for increased concurrency.
	 */ compileEquirectangularShader() {
        if (this._equirectMaterial === null) {
            this._equirectMaterial = $084574008ccedf86$var$_getEquirectMaterial();
            this._compileMaterial(this._equirectMaterial);
        }
    }
    /**
	 * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
	 * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
	 * one of them will cause any others to also become unusable.
	 */ dispose() {
        this._dispose();
        if (this._cubemapMaterial !== null) this._cubemapMaterial.dispose();
        if (this._equirectMaterial !== null) this._equirectMaterial.dispose();
    }
    // private interface
    _setSize(cubeSize) {
        this._lodMax = Math.floor(Math.log2(cubeSize));
        this._cubeSize = Math.pow(2, this._lodMax);
    }
    _dispose() {
        if (this._blurMaterial !== null) this._blurMaterial.dispose();
        if (this._pingPongRenderTarget !== null) this._pingPongRenderTarget.dispose();
        for(let i91 = 0; i91 < this._lodPlanes.length; i91++)this._lodPlanes[i91].dispose();
    }
    _cleanup(outputTarget) {
        this._renderer.setRenderTarget($084574008ccedf86$var$_oldTarget);
        outputTarget.scissorTest = false;
        $084574008ccedf86$var$_setViewport(outputTarget, 0, 0, outputTarget.width, outputTarget.height);
    }
    _fromTexture(texture, renderTarget) {
        if (texture.mapping === $084574008ccedf86$export$8759762a6477f2c4 || texture.mapping === $084574008ccedf86$export$dc59f8aed047f61d) this._setSize(texture.image.length === 0 ? 16 : texture.image[0].width || texture.image[0].image.width);
        else this._setSize(texture.image.width / 4);
        $084574008ccedf86$var$_oldTarget = this._renderer.getRenderTarget();
        const cubeUVRenderTarget = renderTarget || this._allocateTargets();
        this._textureToCubeUV(texture, cubeUVRenderTarget);
        this._applyPMREM(cubeUVRenderTarget);
        this._cleanup(cubeUVRenderTarget);
        return cubeUVRenderTarget;
    }
    _allocateTargets() {
        const width = 3 * Math.max(this._cubeSize, 112);
        const height = 4 * this._cubeSize;
        const params = {
            magFilter: $084574008ccedf86$export$8a72f490b25c56c8,
            minFilter: $084574008ccedf86$export$8a72f490b25c56c8,
            generateMipmaps: false,
            type: $084574008ccedf86$export$2697304443f382bc,
            format: $084574008ccedf86$export$3f8bb04b555a363c,
            encoding: $084574008ccedf86$export$7207336e4151a112,
            depthBuffer: false
        };
        const cubeUVRenderTarget = $084574008ccedf86$var$_createRenderTarget(width, height, params);
        if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== width) {
            if (this._pingPongRenderTarget !== null) this._dispose();
            this._pingPongRenderTarget = $084574008ccedf86$var$_createRenderTarget(width, height, params);
            const { _lodMax: _lodMax  } = this;
            ({ sizeLods: this._sizeLods , lodPlanes: this._lodPlanes , sigmas: this._sigmas  } = $084574008ccedf86$var$_createPlanes(_lodMax));
            this._blurMaterial = $084574008ccedf86$var$_getBlurShader(_lodMax, width, height);
        }
        return cubeUVRenderTarget;
    }
    _compileMaterial(material) {
        const tmpMesh = new $084574008ccedf86$export$e176487c05830cc5(this._lodPlanes[0], material);
        this._renderer.compile(tmpMesh, $084574008ccedf86$var$_flatCamera);
    }
    _sceneToCubeUV(scene, near, far, cubeUVRenderTarget) {
        const fov2 = 90;
        const aspect2 = 1;
        const cubeCamera = new $084574008ccedf86$export$74e4ae24825f68d7(fov2, aspect2, near, far);
        const upSign = [
            1,
            -1,
            1,
            1,
            1,
            1
        ];
        const forwardSign = [
            1,
            1,
            1,
            -1,
            -1,
            -1
        ];
        const renderer = this._renderer;
        const originalAutoClear = renderer.autoClear;
        const toneMapping = renderer.toneMapping;
        renderer.getClearColor($084574008ccedf86$var$_clearColor);
        renderer.toneMapping = $084574008ccedf86$export$9fcb6b4294603b2;
        renderer.autoClear = false;
        const backgroundMaterial = new $084574008ccedf86$export$55cbcc9b622fe1f5({
            name: "PMREM.Background",
            side: $084574008ccedf86$export$d9f0486e75b5ace,
            depthWrite: false,
            depthTest: false
        });
        const backgroundBox = new $084574008ccedf86$export$e176487c05830cc5(new $084574008ccedf86$export$ab3456a079aa7d80(), backgroundMaterial);
        let useSolidColor = false;
        const background = scene.background;
        if (background) {
            if (background.isColor) {
                backgroundMaterial.color.copy(background);
                scene.background = null;
                useSolidColor = true;
            }
        } else {
            backgroundMaterial.color.copy($084574008ccedf86$var$_clearColor);
            useSolidColor = true;
        }
        for(let i92 = 0; i92 < 6; i92++){
            const col = i92 % 3;
            if (col === 0) {
                cubeCamera.up.set(0, upSign[i92], 0);
                cubeCamera.lookAt(forwardSign[i92], 0, 0);
            } else if (col === 1) {
                cubeCamera.up.set(0, 0, upSign[i92]);
                cubeCamera.lookAt(0, forwardSign[i92], 0);
            } else {
                cubeCamera.up.set(0, upSign[i92], 0);
                cubeCamera.lookAt(0, 0, forwardSign[i92]);
            }
            const size = this._cubeSize;
            $084574008ccedf86$var$_setViewport(cubeUVRenderTarget, col * size, i92 > 2 ? size : 0, size, size);
            renderer.setRenderTarget(cubeUVRenderTarget);
            if (useSolidColor) renderer.render(backgroundBox, cubeCamera);
            renderer.render(scene, cubeCamera);
        }
        backgroundBox.geometry.dispose();
        backgroundBox.material.dispose();
        renderer.toneMapping = toneMapping;
        renderer.autoClear = originalAutoClear;
        scene.background = background;
    }
    _textureToCubeUV(texture, cubeUVRenderTarget) {
        const renderer = this._renderer;
        const isCubeTexture = texture.mapping === $084574008ccedf86$export$8759762a6477f2c4 || texture.mapping === $084574008ccedf86$export$dc59f8aed047f61d;
        if (isCubeTexture) {
            if (this._cubemapMaterial === null) this._cubemapMaterial = $084574008ccedf86$var$_getCubemapMaterial();
            this._cubemapMaterial.uniforms.flipEnvMap.value = texture.isRenderTargetTexture === false ? -1 : 1;
        } else if (this._equirectMaterial === null) this._equirectMaterial = $084574008ccedf86$var$_getEquirectMaterial();
        const material = isCubeTexture ? this._cubemapMaterial : this._equirectMaterial;
        const mesh = new $084574008ccedf86$export$e176487c05830cc5(this._lodPlanes[0], material);
        const uniforms = material.uniforms;
        uniforms["envMap"].value = texture;
        const size = this._cubeSize;
        $084574008ccedf86$var$_setViewport(cubeUVRenderTarget, 0, 0, 3 * size, 2 * size);
        renderer.setRenderTarget(cubeUVRenderTarget);
        renderer.render(mesh, $084574008ccedf86$var$_flatCamera);
    }
    _applyPMREM(cubeUVRenderTarget) {
        const renderer = this._renderer;
        const autoClear = renderer.autoClear;
        renderer.autoClear = false;
        for(let i93 = 1; i93 < this._lodPlanes.length; i93++){
            const sigma = Math.sqrt(this._sigmas[i93] * this._sigmas[i93] - this._sigmas[i93 - 1] * this._sigmas[i93 - 1]);
            const poleAxis = $084574008ccedf86$var$_axisDirections[(i93 - 1) % $084574008ccedf86$var$_axisDirections.length];
            this._blur(cubeUVRenderTarget, i93 - 1, i93, sigma, poleAxis);
        }
        renderer.autoClear = autoClear;
    }
    /**
	 * This is a two-pass Gaussian blur for a cubemap. Normally this is done
	 * vertically and horizontally, but this breaks down on a cube. Here we apply
	 * the blur latitudinally (around the poles), and then longitudinally (towards
	 * the poles) to approximate the orthogonally-separable blur. It is least
	 * accurate at the poles, but still does a decent job.
	 */ _blur(cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis) {
        const pingPongRenderTarget = this._pingPongRenderTarget;
        this._halfBlur(cubeUVRenderTarget, pingPongRenderTarget, lodIn, lodOut, sigma, "latitudinal", poleAxis);
        this._halfBlur(pingPongRenderTarget, cubeUVRenderTarget, lodOut, lodOut, sigma, "longitudinal", poleAxis);
    }
    _halfBlur(targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis) {
        const renderer = this._renderer;
        const blurMaterial = this._blurMaterial;
        if (direction !== "latitudinal" && direction !== "longitudinal") console.error("blur direction must be either latitudinal or longitudinal!");
        // Number of standard deviations at which to cut off the discrete approximation.
        const STANDARD_DEVIATIONS = 3;
        const blurMesh = new $084574008ccedf86$export$e176487c05830cc5(this._lodPlanes[lodOut], blurMaterial);
        const blurUniforms = blurMaterial.uniforms;
        const pixels = this._sizeLods[lodIn] - 1;
        const radiansPerPixel = isFinite(sigmaRadians) ? Math.PI / (2 * pixels) : 2 * Math.PI / (2 * $084574008ccedf86$var$MAX_SAMPLES - 1);
        const sigmaPixels = sigmaRadians / radiansPerPixel;
        const samples = isFinite(sigmaRadians) ? 1 + Math.floor(STANDARD_DEVIATIONS * sigmaPixels) : $084574008ccedf86$var$MAX_SAMPLES;
        if (samples > $084574008ccedf86$var$MAX_SAMPLES) console.warn(`sigmaRadians, ${sigmaRadians}, is too large and will clip, as it requested ${samples} samples when the maximum is set to ${$084574008ccedf86$var$MAX_SAMPLES}`);
        const weights = [];
        let sum = 0;
        for(let i95 = 0; i95 < $084574008ccedf86$var$MAX_SAMPLES; ++i95){
            const x = i95 / sigmaPixels;
            const weight = Math.exp(-x * x / 2);
            weights.push(weight);
            if (i95 === 0) sum += weight;
            else if (i95 < samples) sum += 2 * weight;
        }
        for(let i94 = 0; i94 < weights.length; i94++)weights[i94] = weights[i94] / sum;
        blurUniforms["envMap"].value = targetIn.texture;
        blurUniforms["samples"].value = samples;
        blurUniforms["weights"].value = weights;
        blurUniforms["latitudinal"].value = direction === "latitudinal";
        if (poleAxis) blurUniforms["poleAxis"].value = poleAxis;
        const { _lodMax: _lodMax  } = this;
        blurUniforms["dTheta"].value = radiansPerPixel;
        blurUniforms["mipInt"].value = _lodMax - lodIn;
        const outputSize = this._sizeLods[lodOut];
        const x = 3 * outputSize * (lodOut > _lodMax - $084574008ccedf86$var$LOD_MIN ? lodOut - _lodMax + $084574008ccedf86$var$LOD_MIN : 0);
        const y = 4 * (this._cubeSize - outputSize);
        $084574008ccedf86$var$_setViewport(targetOut, x, y, 3 * outputSize, 2 * outputSize);
        renderer.setRenderTarget(targetOut);
        renderer.render(blurMesh, $084574008ccedf86$var$_flatCamera);
    }
}
function $084574008ccedf86$var$_createPlanes(lodMax) {
    const lodPlanes = [];
    const sizeLods = [];
    const sigmas = [];
    let lod = lodMax;
    const totalLods = lodMax - $084574008ccedf86$var$LOD_MIN + 1 + $084574008ccedf86$var$EXTRA_LOD_SIGMA.length;
    for(let i96 = 0; i96 < totalLods; i96++){
        const sizeLod = Math.pow(2, lod);
        sizeLods.push(sizeLod);
        let sigma = 1.0 / sizeLod;
        if (i96 > lodMax - $084574008ccedf86$var$LOD_MIN) sigma = $084574008ccedf86$var$EXTRA_LOD_SIGMA[i96 - lodMax + $084574008ccedf86$var$LOD_MIN - 1];
        else if (i96 === 0) sigma = 0;
        sigmas.push(sigma);
        const texelSize = 1.0 / (sizeLod - 2);
        const min = -texelSize;
        const max = 1 + texelSize;
        const uv1 = [
            min,
            min,
            max,
            min,
            max,
            max,
            min,
            min,
            max,
            max,
            min,
            max
        ];
        const cubeFaces = 6;
        const vertices = 6;
        const positionSize = 3;
        const uvSize = 2;
        const faceIndexSize = 1;
        const position = new Float32Array(positionSize * vertices * cubeFaces);
        const uv = new Float32Array(uvSize * vertices * cubeFaces);
        const faceIndex = new Float32Array(faceIndexSize * vertices * cubeFaces);
        for(let face = 0; face < cubeFaces; face++){
            const x = face % 3 * 2 / 3 - 1;
            const y = face > 2 ? 0 : -1;
            const coordinates = [
                x,
                y,
                0,
                x + 2 / 3,
                y,
                0,
                x + 2 / 3,
                y + 1,
                0,
                x,
                y,
                0,
                x + 2 / 3,
                y + 1,
                0,
                x,
                y + 1,
                0
            ];
            position.set(coordinates, positionSize * vertices * face);
            uv.set(uv1, uvSize * vertices * face);
            const fill = [
                face,
                face,
                face,
                face,
                face,
                face
            ];
            faceIndex.set(fill, faceIndexSize * vertices * face);
        }
        const planes = new $084574008ccedf86$export$b7be63a67df8959();
        planes.setAttribute("position", new $084574008ccedf86$export$8dea267bd6bde117(position, positionSize));
        planes.setAttribute("uv", new $084574008ccedf86$export$8dea267bd6bde117(uv, uvSize));
        planes.setAttribute("faceIndex", new $084574008ccedf86$export$8dea267bd6bde117(faceIndex, faceIndexSize));
        lodPlanes.push(planes);
        if (lod > $084574008ccedf86$var$LOD_MIN) lod--;
    }
    return {
        lodPlanes: lodPlanes,
        sizeLods: sizeLods,
        sigmas: sigmas
    };
}
function $084574008ccedf86$var$_createRenderTarget(width, height, params) {
    const cubeUVRenderTarget = new $084574008ccedf86$export$3c052beb2e51e23f(width, height, params);
    cubeUVRenderTarget.texture.mapping = $084574008ccedf86$export$dbf3e70ff37af79;
    cubeUVRenderTarget.texture.name = "PMREM.cubeUv";
    cubeUVRenderTarget.scissorTest = true;
    return cubeUVRenderTarget;
}
function $084574008ccedf86$var$_setViewport(target, x, y, width, height) {
    target.viewport.set(x, y, width, height);
    target.scissor.set(x, y, width, height);
}
function $084574008ccedf86$var$_getBlurShader(lodMax, width, height) {
    const weights = new Float32Array($084574008ccedf86$var$MAX_SAMPLES);
    const poleAxis = new $084574008ccedf86$export$64b5c384219d3699(0, 1, 0);
    const shaderMaterial = new $084574008ccedf86$export$83c7d75d550a8b0d({
        name: "SphericalGaussianBlur",
        defines: {
            "n": $084574008ccedf86$var$MAX_SAMPLES,
            "CUBEUV_TEXEL_WIDTH": 1.0 / width,
            "CUBEUV_TEXEL_HEIGHT": 1.0 / height,
            "CUBEUV_MAX_MIP": `${lodMax}.0`
        },
        uniforms: {
            "envMap": {
                value: null
            },
            "samples": {
                value: 1
            },
            "weights": {
                value: weights
            },
            "latitudinal": {
                value: false
            },
            "dTheta": {
                value: 0
            },
            "mipInt": {
                value: 0
            },
            "poleAxis": {
                value: poleAxis
            }
        },
        vertexShader: $084574008ccedf86$var$_getCommonVertexShader(),
        fragmentShader: /* glsl */ `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
        blending: $084574008ccedf86$export$63b8d6b580fc65ba,
        depthTest: false,
        depthWrite: false
    });
    return shaderMaterial;
}
function $084574008ccedf86$var$_getEquirectMaterial() {
    return new $084574008ccedf86$export$83c7d75d550a8b0d({
        name: "EquirectangularToCubeUV",
        uniforms: {
            "envMap": {
                value: null
            }
        },
        vertexShader: $084574008ccedf86$var$_getCommonVertexShader(),
        fragmentShader: /* glsl */ `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
        blending: $084574008ccedf86$export$63b8d6b580fc65ba,
        depthTest: false,
        depthWrite: false
    });
}
function $084574008ccedf86$var$_getCubemapMaterial() {
    return new $084574008ccedf86$export$83c7d75d550a8b0d({
        name: "CubemapToCubeUV",
        uniforms: {
            "envMap": {
                value: null
            },
            "flipEnvMap": {
                value: -1
            }
        },
        vertexShader: $084574008ccedf86$var$_getCommonVertexShader(),
        fragmentShader: /* glsl */ `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
        blending: $084574008ccedf86$export$63b8d6b580fc65ba,
        depthTest: false,
        depthWrite: false
    });
}
function $084574008ccedf86$var$_getCommonVertexShader() {
    return /* glsl */ `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;
}
function $084574008ccedf86$var$WebGLCubeUVMaps(renderer) {
    let cubeUVmaps = new WeakMap();
    let pmremGenerator = null;
    function get(texture) {
        if (texture && texture.isTexture) {
            const mapping = texture.mapping;
            const isEquirectMap = mapping === $084574008ccedf86$export$d64030b316d3b087 || mapping === $084574008ccedf86$export$ee99d97d46898098;
            const isCubeMap = mapping === $084574008ccedf86$export$8759762a6477f2c4 || mapping === $084574008ccedf86$export$dc59f8aed047f61d;
            // equirect/cube map to cubeUV conversion
            if (isEquirectMap || isCubeMap) {
                if (texture.isRenderTargetTexture && texture.needsPMREMUpdate === true) {
                    texture.needsPMREMUpdate = false;
                    let renderTarget = cubeUVmaps.get(texture);
                    if (pmremGenerator === null) pmremGenerator = new $084574008ccedf86$export$6add42717753e221(renderer);
                    renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular(texture, renderTarget) : pmremGenerator.fromCubemap(texture, renderTarget);
                    cubeUVmaps.set(texture, renderTarget);
                    return renderTarget.texture;
                } else {
                    if (cubeUVmaps.has(texture)) return cubeUVmaps.get(texture).texture;
                    else {
                        const image = texture.image;
                        if (isEquirectMap && image && image.height > 0 || isCubeMap && image && isCubeTextureComplete(image)) {
                            if (pmremGenerator === null) pmremGenerator = new $084574008ccedf86$export$6add42717753e221(renderer);
                            const renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular(texture) : pmremGenerator.fromCubemap(texture);
                            cubeUVmaps.set(texture, renderTarget);
                            texture.addEventListener("dispose", onTextureDispose);
                            return renderTarget.texture;
                        } else // image not yet ready. try the conversion next frame
                        return null;
                    }
                }
            }
        }
        return texture;
    }
    function isCubeTextureComplete(image) {
        let count = 0;
        const length = 6;
        for(let i97 = 0; i97 < length; i97++)if (image[i97] !== undefined) count++;
        return count === length;
    }
    function onTextureDispose(event) {
        const texture = event.target;
        texture.removeEventListener("dispose", onTextureDispose);
        const cubemapUV = cubeUVmaps.get(texture);
        if (cubemapUV !== undefined) {
            cubeUVmaps.delete(texture);
            cubemapUV.dispose();
        }
    }
    function dispose() {
        cubeUVmaps = new WeakMap();
        if (pmremGenerator !== null) {
            pmremGenerator.dispose();
            pmremGenerator = null;
        }
    }
    return {
        get: get,
        dispose: dispose
    };
}
function $084574008ccedf86$var$WebGLExtensions(gl) {
    const extensions = {};
    function getExtension(name) {
        if (extensions[name] !== undefined) return extensions[name];
        let extension;
        switch(name){
            case "WEBGL_depth_texture":
                extension = gl.getExtension("WEBGL_depth_texture") || gl.getExtension("MOZ_WEBGL_depth_texture") || gl.getExtension("WEBKIT_WEBGL_depth_texture");
                break;
            case "EXT_texture_filter_anisotropic":
                extension = gl.getExtension("EXT_texture_filter_anisotropic") || gl.getExtension("MOZ_EXT_texture_filter_anisotropic") || gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                break;
            case "WEBGL_compressed_texture_s3tc":
                extension = gl.getExtension("WEBGL_compressed_texture_s3tc") || gl.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                break;
            case "WEBGL_compressed_texture_pvrtc":
                extension = gl.getExtension("WEBGL_compressed_texture_pvrtc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                break;
            default:
                extension = gl.getExtension(name);
        }
        extensions[name] = extension;
        return extension;
    }
    return {
        has: function(name) {
            return getExtension(name) !== null;
        },
        init: function(capabilities) {
            if (capabilities.isWebGL2) getExtension("EXT_color_buffer_float");
            else {
                getExtension("WEBGL_depth_texture");
                getExtension("OES_texture_float");
                getExtension("OES_texture_half_float");
                getExtension("OES_texture_half_float_linear");
                getExtension("OES_standard_derivatives");
                getExtension("OES_element_index_uint");
                getExtension("OES_vertex_array_object");
                getExtension("ANGLE_instanced_arrays");
            }
            getExtension("OES_texture_float_linear");
            getExtension("EXT_color_buffer_half_float");
            getExtension("WEBGL_multisampled_render_to_texture");
        },
        get: function(name) {
            const extension = getExtension(name);
            if (extension === null) console.warn("THREE.WebGLRenderer: " + name + " extension not supported.");
            return extension;
        }
    };
}
function $084574008ccedf86$var$WebGLGeometries(gl, attributes, info, bindingStates) {
    const geometries = {};
    const wireframeAttributes = new WeakMap();
    function onGeometryDispose(event) {
        const geometry = event.target;
        if (geometry.index !== null) attributes.remove(geometry.index);
        for(const name in geometry.attributes)attributes.remove(geometry.attributes[name]);
        geometry.removeEventListener("dispose", onGeometryDispose);
        delete geometries[geometry.id];
        const attribute = wireframeAttributes.get(geometry);
        if (attribute) {
            attributes.remove(attribute);
            wireframeAttributes.delete(geometry);
        }
        bindingStates.releaseStatesOfGeometry(geometry);
        if (geometry.isInstancedBufferGeometry === true) delete geometry._maxInstanceCount;
        //
        info.memory.geometries--;
    }
    function get(object, geometry) {
        if (geometries[geometry.id] === true) return geometry;
        geometry.addEventListener("dispose", onGeometryDispose);
        geometries[geometry.id] = true;
        info.memory.geometries++;
        return geometry;
    }
    function update(geometry) {
        const geometryAttributes = geometry.attributes;
        // Updating index buffer in VAO now. See WebGLBindingStates.
        for(const name in geometryAttributes)attributes.update(geometryAttributes[name], 34962);
        // morph targets
        const morphAttributes = geometry.morphAttributes;
        for(const name3 in morphAttributes){
            const array = morphAttributes[name3];
            for(let i98 = 0, l = array.length; i98 < l; i98++)attributes.update(array[i98], 34962);
        }
    }
    function updateWireframeAttribute(geometry) {
        const indices = [];
        const geometryIndex = geometry.index;
        const geometryPosition = geometry.attributes.position;
        let version = 0;
        if (geometryIndex !== null) {
            const array = geometryIndex.array;
            version = geometryIndex.version;
            for(let i99 = 0, l = array.length; i99 < l; i99 += 3){
                const a = array[i99 + 0];
                const b = array[i99 + 1];
                const c = array[i99 + 2];
                indices.push(a, b, b, c, c, a);
            }
        } else {
            const array = geometryPosition.array;
            version = geometryPosition.version;
            for(let i100 = 0, l = array.length / 3 - 1; i100 < l; i100 += 3){
                const a = i100 + 0;
                const b = i100 + 1;
                const c = i100 + 2;
                indices.push(a, b, b, c, c, a);
            }
        }
        const attribute = new ($084574008ccedf86$var$arrayNeedsUint32(indices) ? $084574008ccedf86$export$7eb8c9fa25cd5bd6 : $084574008ccedf86$export$640a853f68025f2e)(indices, 1);
        attribute.version = version;
        // Updating index buffer in VAO now. See WebGLBindingStates
        //
        const previousAttribute = wireframeAttributes.get(geometry);
        if (previousAttribute) attributes.remove(previousAttribute);
        //
        wireframeAttributes.set(geometry, attribute);
    }
    function getWireframeAttribute(geometry) {
        const currentAttribute = wireframeAttributes.get(geometry);
        if (currentAttribute) {
            const geometryIndex = geometry.index;
            if (geometryIndex !== null) // if the attribute is obsolete, create a new one
            {
                if (currentAttribute.version < geometryIndex.version) updateWireframeAttribute(geometry);
            }
        } else updateWireframeAttribute(geometry);
        return wireframeAttributes.get(geometry);
    }
    return {
        get: get,
        update: update,
        getWireframeAttribute: getWireframeAttribute
    };
}
function $084574008ccedf86$var$WebGLIndexedBufferRenderer(gl, extensions, info, capabilities) {
    const isWebGL2 = capabilities.isWebGL2;
    let mode;
    function setMode(value) {
        mode = value;
    }
    let type, bytesPerElement;
    function setIndex(value) {
        type = value.type;
        bytesPerElement = value.bytesPerElement;
    }
    function render(start, count) {
        gl.drawElements(mode, count, type, start * bytesPerElement);
        info.update(count, mode, 1);
    }
    function renderInstances(start, count, primcount) {
        if (primcount === 0) return;
        let extension, methodName;
        if (isWebGL2) {
            extension = gl;
            methodName = "drawElementsInstanced";
        } else {
            extension = extensions.get("ANGLE_instanced_arrays");
            methodName = "drawElementsInstancedANGLE";
            if (extension === null) {
                console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                return;
            }
        }
        extension[methodName](mode, count, type, start * bytesPerElement, primcount);
        info.update(count, mode, primcount);
    }
    //
    this.setMode = setMode;
    this.setIndex = setIndex;
    this.render = render;
    this.renderInstances = renderInstances;
}
function $084574008ccedf86$var$WebGLInfo(gl) {
    const memory = {
        geometries: 0,
        textures: 0
    };
    const render = {
        frame: 0,
        calls: 0,
        triangles: 0,
        points: 0,
        lines: 0
    };
    function update(count, mode, instanceCount) {
        render.calls++;
        switch(mode){
            case 4:
                render.triangles += instanceCount * (count / 3);
                break;
            case 1:
                render.lines += instanceCount * (count / 2);
                break;
            case 3:
                render.lines += instanceCount * (count - 1);
                break;
            case 2:
                render.lines += instanceCount * count;
                break;
            case 0:
                render.points += instanceCount * count;
                break;
            default:
                console.error("THREE.WebGLInfo: Unknown draw mode:", mode);
                break;
        }
    }
    function reset() {
        render.frame++;
        render.calls = 0;
        render.triangles = 0;
        render.points = 0;
        render.lines = 0;
    }
    return {
        memory: memory,
        render: render,
        programs: null,
        autoReset: true,
        reset: reset,
        update: update
    };
}
function $084574008ccedf86$var$numericalSort(a, b) {
    return a[0] - b[0];
}
function $084574008ccedf86$var$absNumericalSort(a, b) {
    return Math.abs(b[1]) - Math.abs(a[1]);
}
function $084574008ccedf86$var$denormalize(morph, attribute) {
    let denominator = 1;
    const array = attribute.isInterleavedBufferAttribute ? attribute.data.array : attribute.array;
    if (array instanceof Int8Array) denominator = 127;
    else if (array instanceof Int16Array) denominator = 32767;
    else if (array instanceof Int32Array) denominator = 2147483647;
    else console.error("THREE.WebGLMorphtargets: Unsupported morph attribute data type: ", array);
    morph.divideScalar(denominator);
}
function $084574008ccedf86$var$WebGLMorphtargets(gl, capabilities, textures) {
    const influencesList = {};
    const morphInfluences = new Float32Array(8);
    const morphTextures = new WeakMap();
    const morph = new $084574008ccedf86$export$fa7daccca11cdbe3();
    const workInfluences = [];
    for(let i101 = 0; i101 < 8; i101++)workInfluences[i101] = [
        i101,
        0
    ];
    function update(object, geometry, material, program) {
        const objectInfluences = object.morphTargetInfluences;
        if (capabilities.isWebGL2 === true) {
            // instead of using attributes, the WebGL 2 code path encodes morph targets
            // into an array of data textures. Each layer represents a single morph target.
            const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
            const morphTargetsCount = morphAttribute !== undefined ? morphAttribute.length : 0;
            let entry = morphTextures.get(geometry);
            if (entry === undefined || entry.count !== morphTargetsCount) {
                if (entry !== undefined) entry.texture.dispose();
                const hasMorphPosition = geometry.morphAttributes.position !== undefined;
                const hasMorphNormals = geometry.morphAttributes.normal !== undefined;
                const hasMorphColors = geometry.morphAttributes.color !== undefined;
                const morphTargets = geometry.morphAttributes.position || [];
                const morphNormals = geometry.morphAttributes.normal || [];
                const morphColors = geometry.morphAttributes.color || [];
                let vertexDataCount = 0;
                if (hasMorphPosition === true) vertexDataCount = 1;
                if (hasMorphNormals === true) vertexDataCount = 2;
                if (hasMorphColors === true) vertexDataCount = 3;
                let width = geometry.attributes.position.count * vertexDataCount;
                let height = 1;
                if (width > capabilities.maxTextureSize) {
                    height = Math.ceil(width / capabilities.maxTextureSize);
                    width = capabilities.maxTextureSize;
                }
                const buffer = new Float32Array(width * height * 4 * morphTargetsCount);
                const texture = new $084574008ccedf86$export$dfac6c8e811406a3(buffer, width, height, morphTargetsCount);
                texture.type = $084574008ccedf86$export$f6d331659b644596;
                texture.needsUpdate = true;
                // fill buffer
                const vertexDataStride = vertexDataCount * 4;
                for(let i102 = 0; i102 < morphTargetsCount; i102++){
                    const morphTarget = morphTargets[i102];
                    const morphNormal = morphNormals[i102];
                    const morphColor = morphColors[i102];
                    const offset = width * height * 4 * i102;
                    for(let j = 0; j < morphTarget.count; j++){
                        const stride = j * vertexDataStride;
                        if (hasMorphPosition === true) {
                            morph.fromBufferAttribute(morphTarget, j);
                            if (morphTarget.normalized === true) $084574008ccedf86$var$denormalize(morph, morphTarget);
                            buffer[offset + stride + 0] = morph.x;
                            buffer[offset + stride + 1] = morph.y;
                            buffer[offset + stride + 2] = morph.z;
                            buffer[offset + stride + 3] = 0;
                        }
                        if (hasMorphNormals === true) {
                            morph.fromBufferAttribute(morphNormal, j);
                            if (morphNormal.normalized === true) $084574008ccedf86$var$denormalize(morph, morphNormal);
                            buffer[offset + stride + 4] = morph.x;
                            buffer[offset + stride + 5] = morph.y;
                            buffer[offset + stride + 6] = morph.z;
                            buffer[offset + stride + 7] = 0;
                        }
                        if (hasMorphColors === true) {
                            morph.fromBufferAttribute(morphColor, j);
                            if (morphColor.normalized === true) $084574008ccedf86$var$denormalize(morph, morphColor);
                            buffer[offset + stride + 8] = morph.x;
                            buffer[offset + stride + 9] = morph.y;
                            buffer[offset + stride + 10] = morph.z;
                            buffer[offset + stride + 11] = morphColor.itemSize === 4 ? morph.w : 1;
                        }
                    }
                }
                entry = {
                    count: morphTargetsCount,
                    texture: texture,
                    size: new $084574008ccedf86$export$c977b3e384af9ae1(width, height)
                };
                morphTextures.set(geometry, entry);
                function disposeTexture() {
                    texture.dispose();
                    morphTextures.delete(geometry);
                    geometry.removeEventListener("dispose", disposeTexture);
                }
                geometry.addEventListener("dispose", disposeTexture);
            }
            //
            let morphInfluencesSum = 0;
            for(let i103 = 0; i103 < objectInfluences.length; i103++)morphInfluencesSum += objectInfluences[i103];
            const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
            program.getUniforms().setValue(gl, "morphTargetBaseInfluence", morphBaseInfluence);
            program.getUniforms().setValue(gl, "morphTargetInfluences", objectInfluences);
            program.getUniforms().setValue(gl, "morphTargetsTexture", entry.texture, textures);
            program.getUniforms().setValue(gl, "morphTargetsTextureSize", entry.size);
        } else {
            // When object doesn't have morph target influences defined, we treat it as a 0-length array
            // This is important to make sure we set up morphTargetBaseInfluence / morphTargetInfluences
            const length = objectInfluences === undefined ? 0 : objectInfluences.length;
            let influences = influencesList[geometry.id];
            if (influences === undefined || influences.length !== length) {
                // initialise list
                influences = [];
                for(let i106 = 0; i106 < length; i106++)influences[i106] = [
                    i106,
                    0
                ];
                influencesList[geometry.id] = influences;
            }
            // Collect influences
            for(let i107 = 0; i107 < length; i107++){
                const influence = influences[i107];
                influence[0] = i107;
                influence[1] = objectInfluences[i107];
            }
            influences.sort($084574008ccedf86$var$absNumericalSort);
            for(let i104 = 0; i104 < 8; i104++)if (i104 < length && influences[i104][1]) {
                workInfluences[i104][0] = influences[i104][0];
                workInfluences[i104][1] = influences[i104][1];
            } else {
                workInfluences[i104][0] = Number.MAX_SAFE_INTEGER;
                workInfluences[i104][1] = 0;
            }
            workInfluences.sort($084574008ccedf86$var$numericalSort);
            const morphTargets = geometry.morphAttributes.position;
            const morphNormals = geometry.morphAttributes.normal;
            let morphInfluencesSum = 0;
            for(let i105 = 0; i105 < 8; i105++){
                const influence = workInfluences[i105];
                const index = influence[0];
                const value = influence[1];
                if (index !== Number.MAX_SAFE_INTEGER && value) {
                    if (morphTargets && geometry.getAttribute("morphTarget" + i105) !== morphTargets[index]) geometry.setAttribute("morphTarget" + i105, morphTargets[index]);
                    if (morphNormals && geometry.getAttribute("morphNormal" + i105) !== morphNormals[index]) geometry.setAttribute("morphNormal" + i105, morphNormals[index]);
                    morphInfluences[i105] = value;
                    morphInfluencesSum += value;
                } else {
                    if (morphTargets && geometry.hasAttribute("morphTarget" + i105) === true) geometry.deleteAttribute("morphTarget" + i105);
                    if (morphNormals && geometry.hasAttribute("morphNormal" + i105) === true) geometry.deleteAttribute("morphNormal" + i105);
                    morphInfluences[i105] = 0;
                }
            }
            // GLSL shader uses formula baseinfluence * base + sum(target * influence)
            // This allows us to switch between absolute morphs and relative morphs without changing shader code
            // When baseinfluence = 1 - sum(influence), the above is equivalent to sum((target - base) * influence)
            const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
            program.getUniforms().setValue(gl, "morphTargetBaseInfluence", morphBaseInfluence);
            program.getUniforms().setValue(gl, "morphTargetInfluences", morphInfluences);
        }
    }
    return {
        update: update
    };
}
function $084574008ccedf86$var$WebGLObjects(gl, geometries, attributes, info) {
    let updateMap = new WeakMap();
    function update(object) {
        const frame = info.render.frame;
        const geometry = object.geometry;
        const buffergeometry = geometries.get(object, geometry);
        // Update once per frame
        if (updateMap.get(buffergeometry) !== frame) {
            geometries.update(buffergeometry);
            updateMap.set(buffergeometry, frame);
        }
        if (object.isInstancedMesh) {
            if (object.hasEventListener("dispose", onInstancedMeshDispose) === false) object.addEventListener("dispose", onInstancedMeshDispose);
            attributes.update(object.instanceMatrix, 34962);
            if (object.instanceColor !== null) attributes.update(object.instanceColor, 34962);
        }
        return buffergeometry;
    }
    function dispose() {
        updateMap = new WeakMap();
    }
    function onInstancedMeshDispose(event) {
        const instancedMesh = event.target;
        instancedMesh.removeEventListener("dispose", onInstancedMeshDispose);
        attributes.remove(instancedMesh.instanceMatrix);
        if (instancedMesh.instanceColor !== null) attributes.remove(instancedMesh.instanceColor);
    }
    return {
        update: update,
        dispose: dispose
    };
}
/**
 * Uniforms of a program.
 * Those form a tree structure with a special top-level container for the root,
 * which you get by calling 'new WebGLUniforms( gl, program )'.
 *
 *
 * Properties of inner nodes including the top-level container:
 *
 * .seq - array of nested uniforms
 * .map - nested uniforms by name
 *
 *
 * Methods of all nodes except the top-level container:
 *
 * .setValue( gl, value, [textures] )
 *
 * 		uploads a uniform value(s)
 *  	the 'textures' parameter is needed for sampler uniforms
 *
 *
 * Static methods of the top-level container (textures factorizations):
 *
 * .upload( gl, seq, values, textures )
 *
 * 		sets uniforms in 'seq' to 'values[id].value'
 *
 * .seqWithValue( seq, values ) : filteredSeq
 *
 * 		filters 'seq' entries with corresponding entry in values
 *
 *
 * Methods of the top-level container (textures factorizations):
 *
 * .setValue( gl, name, value, textures )
 *
 * 		sets uniform with  name 'name' to 'value'
 *
 * .setOptional( gl, obj, prop )
 *
 * 		like .set for an optional property of the object
 *
 */ const $084574008ccedf86$var$emptyTexture = new $084574008ccedf86$export$5431306cf43de24a();
const $084574008ccedf86$var$emptyArrayTexture = new $084574008ccedf86$export$dfac6c8e811406a3();
const $084574008ccedf86$var$empty3dTexture = new $084574008ccedf86$export$d7a3086320f856db();
const $084574008ccedf86$var$emptyCubeTexture = new $084574008ccedf86$export$ee2e5a18258a4049();
// --- Utilities ---
// Array Caches (provide typed arrays for temporary by size)
const $084574008ccedf86$var$arrayCacheF32 = [];
const $084574008ccedf86$var$arrayCacheI32 = [];
// Float32Array caches used for uploading Matrix uniforms
const $084574008ccedf86$var$mat4array = new Float32Array(16);
const $084574008ccedf86$var$mat3array = new Float32Array(9);
const $084574008ccedf86$var$mat2array = new Float32Array(4);
// Flattening for arrays of vectors and matrices
function $084574008ccedf86$var$flatten(array, nBlocks, blockSize) {
    const firstElem = array[0];
    if (firstElem <= 0 || firstElem > 0) return array;
    // unoptimized: ! isNaN( firstElem )
    // see http://jacksondunstan.com/articles/983
    const n = nBlocks * blockSize;
    let r = $084574008ccedf86$var$arrayCacheF32[n];
    if (r === undefined) {
        r = new Float32Array(n);
        $084574008ccedf86$var$arrayCacheF32[n] = r;
    }
    if (nBlocks !== 0) {
        firstElem.toArray(r, 0);
        for(let i108 = 1, offset = 0; i108 !== nBlocks; ++i108){
            offset += blockSize;
            array[i108].toArray(r, offset);
        }
    }
    return r;
}
function $084574008ccedf86$var$arraysEqual(a, b) {
    if (a.length !== b.length) return false;
    for(let i109 = 0, l = a.length; i109 < l; i109++){
        if (a[i109] !== b[i109]) return false;
    }
    return true;
}
function $084574008ccedf86$var$copyArray(a, b) {
    for(let i110 = 0, l = b.length; i110 < l; i110++)a[i110] = b[i110];
}
// Texture unit allocation
function $084574008ccedf86$var$allocTexUnits(textures, n) {
    let r = $084574008ccedf86$var$arrayCacheI32[n];
    if (r === undefined) {
        r = new Int32Array(n);
        $084574008ccedf86$var$arrayCacheI32[n] = r;
    }
    for(let i111 = 0; i111 !== n; ++i111)r[i111] = textures.allocateTextureUnit();
    return r;
}
// --- Setters ---
// Note: Defining these methods externally, because they come in a bunch
// and this way their names minify.
// Single scalar
function $084574008ccedf86$var$setValueV1f(gl, v) {
    const cache = this.cache;
    if (cache[0] === v) return;
    gl.uniform1f(this.addr, v);
    cache[0] = v;
}
// Single float vector (from flat array or THREE.VectorN)
function $084574008ccedf86$var$setValueV2f(gl, v) {
    const cache = this.cache;
    if (v.x !== undefined) {
        if (cache[0] !== v.x || cache[1] !== v.y) {
            gl.uniform2f(this.addr, v.x, v.y);
            cache[0] = v.x;
            cache[1] = v.y;
        }
    } else {
        if ($084574008ccedf86$var$arraysEqual(cache, v)) return;
        gl.uniform2fv(this.addr, v);
        $084574008ccedf86$var$copyArray(cache, v);
    }
}
function $084574008ccedf86$var$setValueV3f(gl, v) {
    const cache = this.cache;
    if (v.x !== undefined) {
        if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z) {
            gl.uniform3f(this.addr, v.x, v.y, v.z);
            cache[0] = v.x;
            cache[1] = v.y;
            cache[2] = v.z;
        }
    } else if (v.r !== undefined) {
        if (cache[0] !== v.r || cache[1] !== v.g || cache[2] !== v.b) {
            gl.uniform3f(this.addr, v.r, v.g, v.b);
            cache[0] = v.r;
            cache[1] = v.g;
            cache[2] = v.b;
        }
    } else {
        if ($084574008ccedf86$var$arraysEqual(cache, v)) return;
        gl.uniform3fv(this.addr, v);
        $084574008ccedf86$var$copyArray(cache, v);
    }
}
function $084574008ccedf86$var$setValueV4f(gl, v) {
    const cache = this.cache;
    if (v.x !== undefined) {
        if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z || cache[3] !== v.w) {
            gl.uniform4f(this.addr, v.x, v.y, v.z, v.w);
            cache[0] = v.x;
            cache[1] = v.y;
            cache[2] = v.z;
            cache[3] = v.w;
        }
    } else {
        if ($084574008ccedf86$var$arraysEqual(cache, v)) return;
        gl.uniform4fv(this.addr, v);
        $084574008ccedf86$var$copyArray(cache, v);
    }
}
// Single matrix (from flat array or THREE.MatrixN)
function $084574008ccedf86$var$setValueM2(gl, v) {
    const cache = this.cache;
    const elements = v.elements;
    if (elements === undefined) {
        if ($084574008ccedf86$var$arraysEqual(cache, v)) return;
        gl.uniformMatrix2fv(this.addr, false, v);
        $084574008ccedf86$var$copyArray(cache, v);
    } else {
        if ($084574008ccedf86$var$arraysEqual(cache, elements)) return;
        $084574008ccedf86$var$mat2array.set(elements);
        gl.uniformMatrix2fv(this.addr, false, $084574008ccedf86$var$mat2array);
        $084574008ccedf86$var$copyArray(cache, elements);
    }
}
function $084574008ccedf86$var$setValueM3(gl, v) {
    const cache = this.cache;
    const elements = v.elements;
    if (elements === undefined) {
        if ($084574008ccedf86$var$arraysEqual(cache, v)) return;
        gl.uniformMatrix3fv(this.addr, false, v);
        $084574008ccedf86$var$copyArray(cache, v);
    } else {
        if ($084574008ccedf86$var$arraysEqual(cache, elements)) return;
        $084574008ccedf86$var$mat3array.set(elements);
        gl.uniformMatrix3fv(this.addr, false, $084574008ccedf86$var$mat3array);
        $084574008ccedf86$var$copyArray(cache, elements);
    }
}
function $084574008ccedf86$var$setValueM4(gl, v) {
    const cache = this.cache;
    const elements = v.elements;
    if (elements === undefined) {
        if ($084574008ccedf86$var$arraysEqual(cache, v)) return;
        gl.uniformMatrix4fv(this.addr, false, v);
        $084574008ccedf86$var$copyArray(cache, v);
    } else {
        if ($084574008ccedf86$var$arraysEqual(cache, elements)) return;
        $084574008ccedf86$var$mat4array.set(elements);
        gl.uniformMatrix4fv(this.addr, false, $084574008ccedf86$var$mat4array);
        $084574008ccedf86$var$copyArray(cache, elements);
    }
}
// Single integer / boolean
function $084574008ccedf86$var$setValueV1i(gl, v) {
    const cache = this.cache;
    if (cache[0] === v) return;
    gl.uniform1i(this.addr, v);
    cache[0] = v;
}
// Single integer / boolean vector (from flat array)
function $084574008ccedf86$var$setValueV2i(gl, v) {
    const cache = this.cache;
    if ($084574008ccedf86$var$arraysEqual(cache, v)) return;
    gl.uniform2iv(this.addr, v);
    $084574008ccedf86$var$copyArray(cache, v);
}
function $084574008ccedf86$var$setValueV3i(gl, v) {
    const cache = this.cache;
    if ($084574008ccedf86$var$arraysEqual(cache, v)) return;
    gl.uniform3iv(this.addr, v);
    $084574008ccedf86$var$copyArray(cache, v);
}
function $084574008ccedf86$var$setValueV4i(gl, v) {
    const cache = this.cache;
    if ($084574008ccedf86$var$arraysEqual(cache, v)) return;
    gl.uniform4iv(this.addr, v);
    $084574008ccedf86$var$copyArray(cache, v);
}
// Single unsigned integer
function $084574008ccedf86$var$setValueV1ui(gl, v) {
    const cache = this.cache;
    if (cache[0] === v) return;
    gl.uniform1ui(this.addr, v);
    cache[0] = v;
}
// Single unsigned integer vector (from flat array)
function $084574008ccedf86$var$setValueV2ui(gl, v) {
    const cache = this.cache;
    if ($084574008ccedf86$var$arraysEqual(cache, v)) return;
    gl.uniform2uiv(this.addr, v);
    $084574008ccedf86$var$copyArray(cache, v);
}
function $084574008ccedf86$var$setValueV3ui(gl, v) {
    const cache = this.cache;
    if ($084574008ccedf86$var$arraysEqual(cache, v)) return;
    gl.uniform3uiv(this.addr, v);
    $084574008ccedf86$var$copyArray(cache, v);
}
function $084574008ccedf86$var$setValueV4ui(gl, v) {
    const cache = this.cache;
    if ($084574008ccedf86$var$arraysEqual(cache, v)) return;
    gl.uniform4uiv(this.addr, v);
    $084574008ccedf86$var$copyArray(cache, v);
}
// Single texture (2D / Cube)
function $084574008ccedf86$var$setValueT1(gl, v, textures) {
    const cache = this.cache;
    const unit = textures.allocateTextureUnit();
    if (cache[0] !== unit) {
        gl.uniform1i(this.addr, unit);
        cache[0] = unit;
    }
    textures.setTexture2D(v || $084574008ccedf86$var$emptyTexture, unit);
}
function $084574008ccedf86$var$setValueT3D1(gl, v, textures) {
    const cache = this.cache;
    const unit = textures.allocateTextureUnit();
    if (cache[0] !== unit) {
        gl.uniform1i(this.addr, unit);
        cache[0] = unit;
    }
    textures.setTexture3D(v || $084574008ccedf86$var$empty3dTexture, unit);
}
function $084574008ccedf86$var$setValueT6(gl, v, textures) {
    const cache = this.cache;
    const unit = textures.allocateTextureUnit();
    if (cache[0] !== unit) {
        gl.uniform1i(this.addr, unit);
        cache[0] = unit;
    }
    textures.setTextureCube(v || $084574008ccedf86$var$emptyCubeTexture, unit);
}
function $084574008ccedf86$var$setValueT2DArray1(gl, v, textures) {
    const cache = this.cache;
    const unit = textures.allocateTextureUnit();
    if (cache[0] !== unit) {
        gl.uniform1i(this.addr, unit);
        cache[0] = unit;
    }
    textures.setTexture2DArray(v || $084574008ccedf86$var$emptyArrayTexture, unit);
}
// Helper to pick the right setter for the singular case
function $084574008ccedf86$var$getSingularSetter(type) {
    switch(type){
        case 0x1406:
            return $084574008ccedf86$var$setValueV1f; // FLOAT
        case 0x8b50:
            return $084574008ccedf86$var$setValueV2f; // _VEC2
        case 0x8b51:
            return $084574008ccedf86$var$setValueV3f; // _VEC3
        case 0x8b52:
            return $084574008ccedf86$var$setValueV4f; // _VEC4
        case 0x8b5a:
            return $084574008ccedf86$var$setValueM2; // _MAT2
        case 0x8b5b:
            return $084574008ccedf86$var$setValueM3; // _MAT3
        case 0x8b5c:
            return $084574008ccedf86$var$setValueM4; // _MAT4
        case 0x1404:
        case 0x8b56:
            return $084574008ccedf86$var$setValueV1i; // INT, BOOL
        case 0x8b53:
        case 0x8b57:
            return $084574008ccedf86$var$setValueV2i; // _VEC2
        case 0x8b54:
        case 0x8b58:
            return $084574008ccedf86$var$setValueV3i; // _VEC3
        case 0x8b55:
        case 0x8b59:
            return $084574008ccedf86$var$setValueV4i; // _VEC4
        case 0x1405:
            return $084574008ccedf86$var$setValueV1ui; // UINT
        case 0x8dc6:
            return $084574008ccedf86$var$setValueV2ui; // _VEC2
        case 0x8dc7:
            return $084574008ccedf86$var$setValueV3ui; // _VEC3
        case 0x8dc8:
            return $084574008ccedf86$var$setValueV4ui; // _VEC4
        case 0x8b5e:
        case 0x8d66:
        case 0x8dca:
        case 0x8dd2:
        case 0x8b62:
            return $084574008ccedf86$var$setValueT1;
        case 0x8b5f:
        case 0x8dcb:
        case 0x8dd3:
            return $084574008ccedf86$var$setValueT3D1;
        case 0x8b60:
        case 0x8dcc:
        case 0x8dd4:
        case 0x8dc5:
            return $084574008ccedf86$var$setValueT6;
        case 0x8dc1:
        case 0x8dcf:
        case 0x8dd7:
        case 0x8dc4:
            return $084574008ccedf86$var$setValueT2DArray1;
    }
}
// Array of scalars
function $084574008ccedf86$var$setValueV1fArray(gl, v) {
    gl.uniform1fv(this.addr, v);
}
// Array of vectors (from flat array or array of THREE.VectorN)
function $084574008ccedf86$var$setValueV2fArray(gl, v) {
    const data = $084574008ccedf86$var$flatten(v, this.size, 2);
    gl.uniform2fv(this.addr, data);
}
function $084574008ccedf86$var$setValueV3fArray(gl, v) {
    const data = $084574008ccedf86$var$flatten(v, this.size, 3);
    gl.uniform3fv(this.addr, data);
}
function $084574008ccedf86$var$setValueV4fArray(gl, v) {
    const data = $084574008ccedf86$var$flatten(v, this.size, 4);
    gl.uniform4fv(this.addr, data);
}
// Array of matrices (from flat array or array of THREE.MatrixN)
function $084574008ccedf86$var$setValueM2Array(gl, v) {
    const data = $084574008ccedf86$var$flatten(v, this.size, 4);
    gl.uniformMatrix2fv(this.addr, false, data);
}
function $084574008ccedf86$var$setValueM3Array(gl, v) {
    const data = $084574008ccedf86$var$flatten(v, this.size, 9);
    gl.uniformMatrix3fv(this.addr, false, data);
}
function $084574008ccedf86$var$setValueM4Array(gl, v) {
    const data = $084574008ccedf86$var$flatten(v, this.size, 16);
    gl.uniformMatrix4fv(this.addr, false, data);
}
// Array of integer / boolean
function $084574008ccedf86$var$setValueV1iArray(gl, v) {
    gl.uniform1iv(this.addr, v);
}
// Array of integer / boolean vectors (from flat array)
function $084574008ccedf86$var$setValueV2iArray(gl, v) {
    gl.uniform2iv(this.addr, v);
}
function $084574008ccedf86$var$setValueV3iArray(gl, v) {
    gl.uniform3iv(this.addr, v);
}
function $084574008ccedf86$var$setValueV4iArray(gl, v) {
    gl.uniform4iv(this.addr, v);
}
// Array of unsigned integer
function $084574008ccedf86$var$setValueV1uiArray(gl, v) {
    gl.uniform1uiv(this.addr, v);
}
// Array of unsigned integer vectors (from flat array)
function $084574008ccedf86$var$setValueV2uiArray(gl, v) {
    gl.uniform2uiv(this.addr, v);
}
function $084574008ccedf86$var$setValueV3uiArray(gl, v) {
    gl.uniform3uiv(this.addr, v);
}
function $084574008ccedf86$var$setValueV4uiArray(gl, v) {
    gl.uniform4uiv(this.addr, v);
}
// Array of textures (2D / 3D / Cube / 2DArray)
function $084574008ccedf86$var$setValueT1Array(gl, v, textures) {
    const n = v.length;
    const units = $084574008ccedf86$var$allocTexUnits(textures, n);
    gl.uniform1iv(this.addr, units);
    for(let i112 = 0; i112 !== n; ++i112)textures.setTexture2D(v[i112] || $084574008ccedf86$var$emptyTexture, units[i112]);
}
function $084574008ccedf86$var$setValueT3DArray(gl, v, textures) {
    const n = v.length;
    const units = $084574008ccedf86$var$allocTexUnits(textures, n);
    gl.uniform1iv(this.addr, units);
    for(let i113 = 0; i113 !== n; ++i113)textures.setTexture3D(v[i113] || $084574008ccedf86$var$empty3dTexture, units[i113]);
}
function $084574008ccedf86$var$setValueT6Array(gl, v, textures) {
    const n = v.length;
    const units = $084574008ccedf86$var$allocTexUnits(textures, n);
    gl.uniform1iv(this.addr, units);
    for(let i114 = 0; i114 !== n; ++i114)textures.setTextureCube(v[i114] || $084574008ccedf86$var$emptyCubeTexture, units[i114]);
}
function $084574008ccedf86$var$setValueT2DArrayArray(gl, v, textures) {
    const n = v.length;
    const units = $084574008ccedf86$var$allocTexUnits(textures, n);
    gl.uniform1iv(this.addr, units);
    for(let i115 = 0; i115 !== n; ++i115)textures.setTexture2DArray(v[i115] || $084574008ccedf86$var$emptyArrayTexture, units[i115]);
}
// Helper to pick the right setter for a pure (bottom-level) array
function $084574008ccedf86$var$getPureArraySetter(type) {
    switch(type){
        case 0x1406:
            return $084574008ccedf86$var$setValueV1fArray; // FLOAT
        case 0x8b50:
            return $084574008ccedf86$var$setValueV2fArray; // _VEC2
        case 0x8b51:
            return $084574008ccedf86$var$setValueV3fArray; // _VEC3
        case 0x8b52:
            return $084574008ccedf86$var$setValueV4fArray; // _VEC4
        case 0x8b5a:
            return $084574008ccedf86$var$setValueM2Array; // _MAT2
        case 0x8b5b:
            return $084574008ccedf86$var$setValueM3Array; // _MAT3
        case 0x8b5c:
            return $084574008ccedf86$var$setValueM4Array; // _MAT4
        case 0x1404:
        case 0x8b56:
            return $084574008ccedf86$var$setValueV1iArray; // INT, BOOL
        case 0x8b53:
        case 0x8b57:
            return $084574008ccedf86$var$setValueV2iArray; // _VEC2
        case 0x8b54:
        case 0x8b58:
            return $084574008ccedf86$var$setValueV3iArray; // _VEC3
        case 0x8b55:
        case 0x8b59:
            return $084574008ccedf86$var$setValueV4iArray; // _VEC4
        case 0x1405:
            return $084574008ccedf86$var$setValueV1uiArray; // UINT
        case 0x8dc6:
            return $084574008ccedf86$var$setValueV2uiArray; // _VEC2
        case 0x8dc7:
            return $084574008ccedf86$var$setValueV3uiArray; // _VEC3
        case 0x8dc8:
            return $084574008ccedf86$var$setValueV4uiArray; // _VEC4
        case 0x8b5e:
        case 0x8d66:
        case 0x8dca:
        case 0x8dd2:
        case 0x8b62:
            return $084574008ccedf86$var$setValueT1Array;
        case 0x8b5f:
        case 0x8dcb:
        case 0x8dd3:
            return $084574008ccedf86$var$setValueT3DArray;
        case 0x8b60:
        case 0x8dcc:
        case 0x8dd4:
        case 0x8dc5:
            return $084574008ccedf86$var$setValueT6Array;
        case 0x8dc1:
        case 0x8dcf:
        case 0x8dd7:
        case 0x8dc4:
            return $084574008ccedf86$var$setValueT2DArrayArray;
    }
}
// --- Uniform Classes ---
class $084574008ccedf86$var$SingleUniform {
    constructor(id, activeInfo, addr){
        this.id = id;
        this.addr = addr;
        this.cache = [];
        this.setValue = $084574008ccedf86$var$getSingularSetter(activeInfo.type);
    // this.path = activeInfo.name; // DEBUG
    }
}
class $084574008ccedf86$var$PureArrayUniform {
    constructor(id, activeInfo, addr){
        this.id = id;
        this.addr = addr;
        this.cache = [];
        this.size = activeInfo.size;
        this.setValue = $084574008ccedf86$var$getPureArraySetter(activeInfo.type);
    // this.path = activeInfo.name; // DEBUG
    }
}
class $084574008ccedf86$var$StructuredUniform {
    constructor(id){
        this.id = id;
        this.seq = [];
        this.map = {};
    }
    setValue(gl, value, textures) {
        const seq = this.seq;
        for(let i116 = 0, n = seq.length; i116 !== n; ++i116){
            const u = seq[i116];
            u.setValue(gl, value[u.id], textures);
        }
    }
}
// --- Top-level ---
// Parser - builds up the property tree from the path strings
const $084574008ccedf86$var$RePathPart = /(\w+)(\])?(\[|\.)?/g;
// extracts
// 	- the identifier (member name or array index)
//  - followed by an optional right bracket (found when array index)
//  - followed by an optional left bracket or dot (type of subscript)
//
// Note: These portions can be read in a non-overlapping fashion and
// allow straightforward parsing of the hierarchy that WebGL encodes
// in the uniform names.
function $084574008ccedf86$var$addUniform(container, uniformObject) {
    container.seq.push(uniformObject);
    container.map[uniformObject.id] = uniformObject;
}
function $084574008ccedf86$var$parseUniform(activeInfo, addr, container) {
    const path = activeInfo.name, pathLength = path.length;
    // reset RegExp object, because of the early exit of a previous run
    $084574008ccedf86$var$RePathPart.lastIndex = 0;
    while(true){
        const match = $084574008ccedf86$var$RePathPart.exec(path), matchEnd = $084574008ccedf86$var$RePathPart.lastIndex;
        let id = match[1];
        const idIsIndex = match[2] === "]", subscript = match[3];
        if (idIsIndex) id = id | 0; // convert to integer
        if (subscript === undefined || subscript === "[" && matchEnd + 2 === pathLength) {
            // bare name or "pure" bottom-level array "[0]" suffix
            $084574008ccedf86$var$addUniform(container, subscript === undefined ? new $084574008ccedf86$var$SingleUniform(id, activeInfo, addr) : new $084574008ccedf86$var$PureArrayUniform(id, activeInfo, addr));
            break;
        } else {
            // step into inner node / create it in case it doesn't exist
            const map = container.map;
            let next = map[id];
            if (next === undefined) {
                next = new $084574008ccedf86$var$StructuredUniform(id);
                $084574008ccedf86$var$addUniform(container, next);
            }
            container = next;
        }
    }
}
// Root Container
class $084574008ccedf86$var$WebGLUniforms {
    constructor(gl, program){
        this.seq = [];
        this.map = {};
        const n = gl.getProgramParameter(program, 35718);
        for(let i117 = 0; i117 < n; ++i117){
            const info = gl.getActiveUniform(program, i117), addr = gl.getUniformLocation(program, info.name);
            $084574008ccedf86$var$parseUniform(info, addr, this);
        }
    }
    setValue(gl, name, value, textures) {
        const u = this.map[name];
        if (u !== undefined) u.setValue(gl, value, textures);
    }
    setOptional(gl, object, name) {
        const v = object[name];
        if (v !== undefined) this.setValue(gl, name, v);
    }
    static upload(gl, seq, values, textures) {
        for(let i118 = 0, n = seq.length; i118 !== n; ++i118){
            const u = seq[i118], v = values[u.id];
            if (v.needsUpdate !== false) // note: always updating when .needsUpdate is undefined
            u.setValue(gl, v.value, textures);
        }
    }
    static seqWithValue(seq, values) {
        const r = [];
        for(let i119 = 0, n = seq.length; i119 !== n; ++i119){
            const u = seq[i119];
            if (u.id in values) r.push(u);
        }
        return r;
    }
}
function $084574008ccedf86$var$WebGLShader(gl, type, string) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, string);
    gl.compileShader(shader);
    return shader;
}
let $084574008ccedf86$var$programIdCount = 0;
function $084574008ccedf86$var$handleSource(string, errorLine) {
    const lines = string.split("\n");
    const lines2 = [];
    const from = Math.max(errorLine - 6, 0);
    const to = Math.min(errorLine + 6, lines.length);
    for(let i120 = from; i120 < to; i120++){
        const line = i120 + 1;
        lines2.push(`${line === errorLine ? ">" : " "} ${line}: ${lines[i120]}`);
    }
    return lines2.join("\n");
}
function $084574008ccedf86$var$getEncodingComponents(encoding) {
    switch(encoding){
        case $084574008ccedf86$export$7207336e4151a112:
            return [
                "Linear",
                "( value )"
            ];
        case $084574008ccedf86$export$f32388edbb32674:
            return [
                "sRGB",
                "( value )"
            ];
        default:
            console.warn("THREE.WebGLProgram: Unsupported encoding:", encoding);
            return [
                "Linear",
                "( value )"
            ];
    }
}
function $084574008ccedf86$var$getShaderErrors(gl, shader, type) {
    const status = gl.getShaderParameter(shader, 35713);
    const errors = gl.getShaderInfoLog(shader).trim();
    if (status && errors === "") return "";
    const errorMatches = /ERROR: 0:(\d+)/.exec(errors);
    if (errorMatches) {
        // --enable-privileged-webgl-extension
        // console.log( '**' + type + '**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );
        const errorLine = parseInt(errorMatches[1]);
        return type.toUpperCase() + "\n\n" + errors + "\n\n" + $084574008ccedf86$var$handleSource(gl.getShaderSource(shader), errorLine);
    } else return errors;
}
function $084574008ccedf86$var$getTexelEncodingFunction(functionName, encoding) {
    const components = $084574008ccedf86$var$getEncodingComponents(encoding);
    return "vec4 " + functionName + "( vec4 value ) { return LinearTo" + components[0] + components[1] + "; }";
}
function $084574008ccedf86$var$getToneMappingFunction(functionName, toneMapping) {
    let toneMappingName;
    switch(toneMapping){
        case $084574008ccedf86$export$98f52c2a46c598ca:
            toneMappingName = "Linear";
            break;
        case $084574008ccedf86$export$74b25e54b3bcd548:
            toneMappingName = "Reinhard";
            break;
        case $084574008ccedf86$export$932b3dd283d4a366:
            toneMappingName = "OptimizedCineon";
            break;
        case $084574008ccedf86$export$a0d98fe6d7e4af64:
            toneMappingName = "ACESFilmic";
            break;
        case $084574008ccedf86$export$2c7b09c1e9abfb5e:
            toneMappingName = "Custom";
            break;
        default:
            console.warn("THREE.WebGLProgram: Unsupported toneMapping:", toneMapping);
            toneMappingName = "Linear";
    }
    return "vec3 " + functionName + "( vec3 color ) { return " + toneMappingName + "ToneMapping( color ); }";
}
function $084574008ccedf86$var$generateExtensions(parameters) {
    const chunks = [
        parameters.extensionDerivatives || !!parameters.envMapCubeUVHeight || parameters.bumpMap || parameters.tangentSpaceNormalMap || parameters.clearcoatNormalMap || parameters.flatShading || parameters.shaderID === "physical" ? "#extension GL_OES_standard_derivatives : enable" : "",
        (parameters.extensionFragDepth || parameters.logarithmicDepthBuffer) && parameters.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "",
        parameters.extensionDrawBuffers && parameters.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "",
        (parameters.extensionShaderTextureLOD || parameters.envMap || parameters.transmission) && parameters.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""
    ];
    return chunks.filter($084574008ccedf86$var$filterEmptyLine).join("\n");
}
function $084574008ccedf86$var$generateDefines(defines) {
    const chunks = [];
    for(const name in defines){
        const value = defines[name];
        if (value === false) continue;
        chunks.push("#define " + name + " " + value);
    }
    return chunks.join("\n");
}
function $084574008ccedf86$var$fetchAttributeLocations(gl, program) {
    const attributes = {};
    const n = gl.getProgramParameter(program, 35721);
    for(let i121 = 0; i121 < n; i121++){
        const info = gl.getActiveAttrib(program, i121);
        const name = info.name;
        let locationSize = 1;
        if (info.type === 35674) locationSize = 2;
        if (info.type === 35675) locationSize = 3;
        if (info.type === 35676) locationSize = 4;
        // console.log( 'THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:', name, i );
        attributes[name] = {
            type: info.type,
            location: gl.getAttribLocation(program, name),
            locationSize: locationSize
        };
    }
    return attributes;
}
function $084574008ccedf86$var$filterEmptyLine(string) {
    return string !== "";
}
function $084574008ccedf86$var$replaceLightNums(string, parameters) {
    return string.replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights).replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights).replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows);
}
function $084574008ccedf86$var$replaceClippingPlaneNums(string, parameters) {
    return string.replace(/NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, parameters.numClippingPlanes - parameters.numClipIntersection);
}
// Resolve Includes
const $084574008ccedf86$var$includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;
function $084574008ccedf86$var$resolveIncludes(string) {
    return string.replace($084574008ccedf86$var$includePattern, $084574008ccedf86$var$includeReplacer);
}
function $084574008ccedf86$var$includeReplacer(match, include) {
    const string = $084574008ccedf86$export$955f9f2e84c43c8b[include];
    if (string === undefined) throw new Error("Can not resolve #include <" + include + ">");
    return $084574008ccedf86$var$resolveIncludes(string);
}
// Unroll Loops
const $084574008ccedf86$var$deprecatedUnrollLoopPattern = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
const $084574008ccedf86$var$unrollLoopPattern = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function $084574008ccedf86$var$unrollLoops(string) {
    return string.replace($084574008ccedf86$var$unrollLoopPattern, $084574008ccedf86$var$loopReplacer).replace($084574008ccedf86$var$deprecatedUnrollLoopPattern, $084574008ccedf86$var$deprecatedLoopReplacer);
}
function $084574008ccedf86$var$deprecatedLoopReplacer(match, start, end, snippet) {
    console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead.");
    return $084574008ccedf86$var$loopReplacer(match, start, end, snippet);
}
function $084574008ccedf86$var$loopReplacer(match, start, end, snippet) {
    let string = "";
    for(let i122 = parseInt(start); i122 < parseInt(end); i122++)string += snippet.replace(/\[\s*i\s*\]/g, "[ " + i122 + " ]").replace(/UNROLLED_LOOP_INDEX/g, i122);
    return string;
}
//
function $084574008ccedf86$var$generatePrecision(parameters) {
    let precisionstring = "precision " + parameters.precision + " float;\nprecision " + parameters.precision + " int;";
    if (parameters.precision === "highp") precisionstring += "\n#define HIGH_PRECISION";
    else if (parameters.precision === "mediump") precisionstring += "\n#define MEDIUM_PRECISION";
    else if (parameters.precision === "lowp") precisionstring += "\n#define LOW_PRECISION";
    return precisionstring;
}
function $084574008ccedf86$var$generateShadowMapTypeDefine(parameters) {
    let shadowMapTypeDefine = "SHADOWMAP_TYPE_BASIC";
    if (parameters.shadowMapType === $084574008ccedf86$export$5813f879eee7cd88) shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF";
    else if (parameters.shadowMapType === $084574008ccedf86$export$a47c4b43a1be34f0) shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF_SOFT";
    else if (parameters.shadowMapType === $084574008ccedf86$export$896ae1ade6c829c4) shadowMapTypeDefine = "SHADOWMAP_TYPE_VSM";
    return shadowMapTypeDefine;
}
function $084574008ccedf86$var$generateEnvMapTypeDefine(parameters) {
    let envMapTypeDefine = "ENVMAP_TYPE_CUBE";
    if (parameters.envMap) switch(parameters.envMapMode){
        case $084574008ccedf86$export$8759762a6477f2c4:
        case $084574008ccedf86$export$dc59f8aed047f61d:
            envMapTypeDefine = "ENVMAP_TYPE_CUBE";
            break;
        case $084574008ccedf86$export$dbf3e70ff37af79:
            envMapTypeDefine = "ENVMAP_TYPE_CUBE_UV";
            break;
    }
    return envMapTypeDefine;
}
function $084574008ccedf86$var$generateEnvMapModeDefine(parameters) {
    let envMapModeDefine = "ENVMAP_MODE_REFLECTION";
    if (parameters.envMap) switch(parameters.envMapMode){
        case $084574008ccedf86$export$dc59f8aed047f61d:
            envMapModeDefine = "ENVMAP_MODE_REFRACTION";
            break;
    }
    return envMapModeDefine;
}
function $084574008ccedf86$var$generateEnvMapBlendingDefine(parameters) {
    let envMapBlendingDefine = "ENVMAP_BLENDING_NONE";
    if (parameters.envMap) switch(parameters.combine){
        case $084574008ccedf86$export$e50ac29801f1774d:
            envMapBlendingDefine = "ENVMAP_BLENDING_MULTIPLY";
            break;
        case $084574008ccedf86$export$9f9d94f963c85479:
            envMapBlendingDefine = "ENVMAP_BLENDING_MIX";
            break;
        case $084574008ccedf86$export$e641dc52bc3494aa:
            envMapBlendingDefine = "ENVMAP_BLENDING_ADD";
            break;
    }
    return envMapBlendingDefine;
}
function $084574008ccedf86$var$generateCubeUVSize(parameters) {
    const imageHeight = parameters.envMapCubeUVHeight;
    if (imageHeight === null) return null;
    const maxMip = Math.log2(imageHeight) - 2;
    const texelHeight = 1.0 / imageHeight;
    const texelWidth = 1.0 / (3 * Math.max(Math.pow(2, maxMip), 112));
    return {
        texelWidth: texelWidth,
        texelHeight: texelHeight,
        maxMip: maxMip
    };
}
function $084574008ccedf86$var$WebGLProgram(renderer, cacheKey, parameters, bindingStates) {
    // TODO Send this event to Three.js DevTools
    // console.log( 'WebGLProgram', cacheKey );
    const gl = renderer.getContext();
    const defines = parameters.defines;
    let vertexShader = parameters.vertexShader;
    let fragmentShader = parameters.fragmentShader;
    const shadowMapTypeDefine = $084574008ccedf86$var$generateShadowMapTypeDefine(parameters);
    const envMapTypeDefine = $084574008ccedf86$var$generateEnvMapTypeDefine(parameters);
    const envMapModeDefine = $084574008ccedf86$var$generateEnvMapModeDefine(parameters);
    const envMapBlendingDefine = $084574008ccedf86$var$generateEnvMapBlendingDefine(parameters);
    const envMapCubeUVSize = $084574008ccedf86$var$generateCubeUVSize(parameters);
    const customExtensions = parameters.isWebGL2 ? "" : $084574008ccedf86$var$generateExtensions(parameters);
    const customDefines = $084574008ccedf86$var$generateDefines(defines);
    const program = gl.createProgram();
    let prefixVertex, prefixFragment;
    let versionString = parameters.glslVersion ? "#version " + parameters.glslVersion + "\n" : "";
    if (parameters.isRawShaderMaterial) {
        prefixVertex = [
            customDefines
        ].filter($084574008ccedf86$var$filterEmptyLine).join("\n");
        if (prefixVertex.length > 0) prefixVertex += "\n";
        prefixFragment = [
            customExtensions,
            customDefines
        ].filter($084574008ccedf86$var$filterEmptyLine).join("\n");
        if (prefixFragment.length > 0) prefixFragment += "\n";
    } else {
        prefixVertex = [
            $084574008ccedf86$var$generatePrecision(parameters),
            "#define SHADER_NAME " + parameters.shaderName,
            customDefines,
            parameters.instancing ? "#define USE_INSTANCING" : "",
            parameters.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
            parameters.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",
            parameters.useFog && parameters.fog ? "#define USE_FOG" : "",
            parameters.useFog && parameters.fogExp2 ? "#define FOG_EXP2" : "",
            parameters.map ? "#define USE_MAP" : "",
            parameters.envMap ? "#define USE_ENVMAP" : "",
            parameters.envMap ? "#define " + envMapModeDefine : "",
            parameters.lightMap ? "#define USE_LIGHTMAP" : "",
            parameters.aoMap ? "#define USE_AOMAP" : "",
            parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
            parameters.bumpMap ? "#define USE_BUMPMAP" : "",
            parameters.normalMap ? "#define USE_NORMALMAP" : "",
            parameters.normalMap && parameters.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "",
            parameters.normalMap && parameters.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "",
            parameters.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
            parameters.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
            parameters.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
            parameters.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
            parameters.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
            parameters.displacementMap && parameters.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "",
            parameters.specularMap ? "#define USE_SPECULARMAP" : "",
            parameters.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "",
            parameters.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "",
            parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
            parameters.metalnessMap ? "#define USE_METALNESSMAP" : "",
            parameters.alphaMap ? "#define USE_ALPHAMAP" : "",
            parameters.transmission ? "#define USE_TRANSMISSION" : "",
            parameters.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
            parameters.thicknessMap ? "#define USE_THICKNESSMAP" : "",
            parameters.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "",
            parameters.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "",
            parameters.vertexTangents ? "#define USE_TANGENT" : "",
            parameters.vertexColors ? "#define USE_COLOR" : "",
            parameters.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
            parameters.vertexUvs ? "#define USE_UV" : "",
            parameters.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
            parameters.flatShading ? "#define FLAT_SHADED" : "",
            parameters.skinning ? "#define USE_SKINNING" : "",
            parameters.morphTargets ? "#define USE_MORPHTARGETS" : "",
            parameters.morphNormals && parameters.flatShading === false ? "#define USE_MORPHNORMALS" : "",
            parameters.morphColors && parameters.isWebGL2 ? "#define USE_MORPHCOLORS" : "",
            parameters.morphTargetsCount > 0 && parameters.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "",
            parameters.morphTargetsCount > 0 && parameters.isWebGL2 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + parameters.morphTextureStride : "",
            parameters.morphTargetsCount > 0 && parameters.isWebGL2 ? "#define MORPHTARGETS_COUNT " + parameters.morphTargetsCount : "",
            parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
            parameters.flipSided ? "#define FLIP_SIDED" : "",
            parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
            parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
            parameters.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
            parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
            parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
            "uniform mat4 modelMatrix;",
            "uniform mat4 modelViewMatrix;",
            "uniform mat4 projectionMatrix;",
            "uniform mat4 viewMatrix;",
            "uniform mat3 normalMatrix;",
            "uniform vec3 cameraPosition;",
            "uniform bool isOrthographic;",
            "#ifdef USE_INSTANCING",
            "	attribute mat4 instanceMatrix;",
            "#endif",
            "#ifdef USE_INSTANCING_COLOR",
            "	attribute vec3 instanceColor;",
            "#endif",
            "attribute vec3 position;",
            "attribute vec3 normal;",
            "attribute vec2 uv;",
            "#ifdef USE_TANGENT",
            "	attribute vec4 tangent;",
            "#endif",
            "#if defined( USE_COLOR_ALPHA )",
            "	attribute vec4 color;",
            "#elif defined( USE_COLOR )",
            "	attribute vec3 color;",
            "#endif",
            "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )",
            "	attribute vec3 morphTarget0;",
            "	attribute vec3 morphTarget1;",
            "	attribute vec3 morphTarget2;",
            "	attribute vec3 morphTarget3;",
            "	#ifdef USE_MORPHNORMALS",
            "		attribute vec3 morphNormal0;",
            "		attribute vec3 morphNormal1;",
            "		attribute vec3 morphNormal2;",
            "		attribute vec3 morphNormal3;",
            "	#else",
            "		attribute vec3 morphTarget4;",
            "		attribute vec3 morphTarget5;",
            "		attribute vec3 morphTarget6;",
            "		attribute vec3 morphTarget7;",
            "	#endif",
            "#endif",
            "#ifdef USE_SKINNING",
            "	attribute vec4 skinIndex;",
            "	attribute vec4 skinWeight;",
            "#endif",
            "\n"
        ].filter($084574008ccedf86$var$filterEmptyLine).join("\n");
        prefixFragment = [
            customExtensions,
            $084574008ccedf86$var$generatePrecision(parameters),
            "#define SHADER_NAME " + parameters.shaderName,
            customDefines,
            parameters.useFog && parameters.fog ? "#define USE_FOG" : "",
            parameters.useFog && parameters.fogExp2 ? "#define FOG_EXP2" : "",
            parameters.map ? "#define USE_MAP" : "",
            parameters.matcap ? "#define USE_MATCAP" : "",
            parameters.envMap ? "#define USE_ENVMAP" : "",
            parameters.envMap ? "#define " + envMapTypeDefine : "",
            parameters.envMap ? "#define " + envMapModeDefine : "",
            parameters.envMap ? "#define " + envMapBlendingDefine : "",
            envMapCubeUVSize ? "#define CUBEUV_TEXEL_WIDTH " + envMapCubeUVSize.texelWidth : "",
            envMapCubeUVSize ? "#define CUBEUV_TEXEL_HEIGHT " + envMapCubeUVSize.texelHeight : "",
            envMapCubeUVSize ? "#define CUBEUV_MAX_MIP " + envMapCubeUVSize.maxMip + ".0" : "",
            parameters.lightMap ? "#define USE_LIGHTMAP" : "",
            parameters.aoMap ? "#define USE_AOMAP" : "",
            parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
            parameters.bumpMap ? "#define USE_BUMPMAP" : "",
            parameters.normalMap ? "#define USE_NORMALMAP" : "",
            parameters.normalMap && parameters.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "",
            parameters.normalMap && parameters.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "",
            parameters.clearcoat ? "#define USE_CLEARCOAT" : "",
            parameters.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
            parameters.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
            parameters.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
            parameters.iridescence ? "#define USE_IRIDESCENCE" : "",
            parameters.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
            parameters.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
            parameters.specularMap ? "#define USE_SPECULARMAP" : "",
            parameters.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "",
            parameters.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "",
            parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
            parameters.metalnessMap ? "#define USE_METALNESSMAP" : "",
            parameters.alphaMap ? "#define USE_ALPHAMAP" : "",
            parameters.alphaTest ? "#define USE_ALPHATEST" : "",
            parameters.sheen ? "#define USE_SHEEN" : "",
            parameters.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "",
            parameters.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "",
            parameters.transmission ? "#define USE_TRANSMISSION" : "",
            parameters.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
            parameters.thicknessMap ? "#define USE_THICKNESSMAP" : "",
            parameters.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
            parameters.vertexTangents ? "#define USE_TANGENT" : "",
            parameters.vertexColors || parameters.instancingColor ? "#define USE_COLOR" : "",
            parameters.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
            parameters.vertexUvs ? "#define USE_UV" : "",
            parameters.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
            parameters.gradientMap ? "#define USE_GRADIENTMAP" : "",
            parameters.flatShading ? "#define FLAT_SHADED" : "",
            parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
            parameters.flipSided ? "#define FLIP_SIDED" : "",
            parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
            parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
            parameters.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
            parameters.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "",
            parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
            parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
            "uniform mat4 viewMatrix;",
            "uniform vec3 cameraPosition;",
            "uniform bool isOrthographic;",
            parameters.toneMapping !== $084574008ccedf86$export$9fcb6b4294603b2 ? "#define TONE_MAPPING" : "",
            parameters.toneMapping !== $084574008ccedf86$export$9fcb6b4294603b2 ? $084574008ccedf86$export$955f9f2e84c43c8b["tonemapping_pars_fragment"] : "",
            parameters.toneMapping !== $084574008ccedf86$export$9fcb6b4294603b2 ? $084574008ccedf86$var$getToneMappingFunction("toneMapping", parameters.toneMapping) : "",
            parameters.dithering ? "#define DITHERING" : "",
            parameters.opaque ? "#define OPAQUE" : "",
            $084574008ccedf86$export$955f9f2e84c43c8b["encodings_pars_fragment"],
            $084574008ccedf86$var$getTexelEncodingFunction("linearToOutputTexel", parameters.outputEncoding),
            parameters.useDepthPacking ? "#define DEPTH_PACKING " + parameters.depthPacking : "",
            "\n"
        ].filter($084574008ccedf86$var$filterEmptyLine).join("\n");
    }
    vertexShader = $084574008ccedf86$var$resolveIncludes(vertexShader);
    vertexShader = $084574008ccedf86$var$replaceLightNums(vertexShader, parameters);
    vertexShader = $084574008ccedf86$var$replaceClippingPlaneNums(vertexShader, parameters);
    fragmentShader = $084574008ccedf86$var$resolveIncludes(fragmentShader);
    fragmentShader = $084574008ccedf86$var$replaceLightNums(fragmentShader, parameters);
    fragmentShader = $084574008ccedf86$var$replaceClippingPlaneNums(fragmentShader, parameters);
    vertexShader = $084574008ccedf86$var$unrollLoops(vertexShader);
    fragmentShader = $084574008ccedf86$var$unrollLoops(fragmentShader);
    if (parameters.isWebGL2 && parameters.isRawShaderMaterial !== true) {
        // GLSL 3.0 conversion for built-in materials and ShaderMaterial
        versionString = "#version 300 es\n";
        prefixVertex = [
            "precision mediump sampler2DArray;",
            "#define attribute in",
            "#define varying out",
            "#define texture2D texture"
        ].join("\n") + "\n" + prefixVertex;
        prefixFragment = [
            "#define varying in",
            parameters.glslVersion === $084574008ccedf86$export$f63012db5506e7dd ? "" : "layout(location = 0) out highp vec4 pc_fragColor;",
            parameters.glslVersion === $084574008ccedf86$export$f63012db5506e7dd ? "" : "#define gl_FragColor pc_fragColor",
            "#define gl_FragDepthEXT gl_FragDepth",
            "#define texture2D texture",
            "#define textureCube texture",
            "#define texture2DProj textureProj",
            "#define texture2DLodEXT textureLod",
            "#define texture2DProjLodEXT textureProjLod",
            "#define textureCubeLodEXT textureLod",
            "#define texture2DGradEXT textureGrad",
            "#define texture2DProjGradEXT textureProjGrad",
            "#define textureCubeGradEXT textureGrad"
        ].join("\n") + "\n" + prefixFragment;
    }
    const vertexGlsl = versionString + prefixVertex + vertexShader;
    const fragmentGlsl = versionString + prefixFragment + fragmentShader;
    // console.log( '*VERTEX*', vertexGlsl );
    // console.log( '*FRAGMENT*', fragmentGlsl );
    const glVertexShader = $084574008ccedf86$var$WebGLShader(gl, 35633, vertexGlsl);
    const glFragmentShader = $084574008ccedf86$var$WebGLShader(gl, 35632, fragmentGlsl);
    gl.attachShader(program, glVertexShader);
    gl.attachShader(program, glFragmentShader);
    // Force a particular attribute to index 0.
    if (parameters.index0AttributeName !== undefined) gl.bindAttribLocation(program, 0, parameters.index0AttributeName);
    else if (parameters.morphTargets === true) // programs with morphTargets displace position out of attribute 0
    gl.bindAttribLocation(program, 0, "position");
    gl.linkProgram(program);
    // check for link errors
    if (renderer.debug.checkShaderErrors) {
        const programLog = gl.getProgramInfoLog(program).trim();
        const vertexLog = gl.getShaderInfoLog(glVertexShader).trim();
        const fragmentLog = gl.getShaderInfoLog(glFragmentShader).trim();
        let runnable = true;
        let haveDiagnostics = true;
        if (gl.getProgramParameter(program, 35714) === false) {
            runnable = false;
            const vertexErrors = $084574008ccedf86$var$getShaderErrors(gl, glVertexShader, "vertex");
            const fragmentErrors = $084574008ccedf86$var$getShaderErrors(gl, glFragmentShader, "fragment");
            console.error("THREE.WebGLProgram: Shader Error " + gl.getError() + " - " + "VALIDATE_STATUS " + gl.getProgramParameter(program, 35715) + "\n\n" + "Program Info Log: " + programLog + "\n" + vertexErrors + "\n" + fragmentErrors);
        } else if (programLog !== "") console.warn("THREE.WebGLProgram: Program Info Log:", programLog);
        else if (vertexLog === "" || fragmentLog === "") haveDiagnostics = false;
        if (haveDiagnostics) this.diagnostics = {
            runnable: runnable,
            programLog: programLog,
            vertexShader: {
                log: vertexLog,
                prefix: prefixVertex
            },
            fragmentShader: {
                log: fragmentLog,
                prefix: prefixFragment
            }
        };
    }
    // Clean up
    // Crashes in iOS9 and iOS10. #18402
    // gl.detachShader( program, glVertexShader );
    // gl.detachShader( program, glFragmentShader );
    gl.deleteShader(glVertexShader);
    gl.deleteShader(glFragmentShader);
    // set up caching for uniform locations
    let cachedUniforms;
    this.getUniforms = function() {
        if (cachedUniforms === undefined) cachedUniforms = new $084574008ccedf86$var$WebGLUniforms(gl, program);
        return cachedUniforms;
    };
    // set up caching for attribute locations
    let cachedAttributes;
    this.getAttributes = function() {
        if (cachedAttributes === undefined) cachedAttributes = $084574008ccedf86$var$fetchAttributeLocations(gl, program);
        return cachedAttributes;
    };
    // free resource
    this.destroy = function() {
        bindingStates.releaseStatesOfProgram(this);
        gl.deleteProgram(program);
        this.program = undefined;
    };
    //
    this.name = parameters.shaderName;
    this.id = $084574008ccedf86$var$programIdCount++;
    this.cacheKey = cacheKey;
    this.usedTimes = 1;
    this.program = program;
    this.vertexShader = glVertexShader;
    this.fragmentShader = glFragmentShader;
    return this;
}
let $084574008ccedf86$var$_id = 0;
class $084574008ccedf86$var$WebGLShaderCache {
    constructor(){
        this.shaderCache = new Map();
        this.materialCache = new Map();
    }
    update(material) {
        const vertexShader = material.vertexShader;
        const fragmentShader = material.fragmentShader;
        const vertexShaderStage = this._getShaderStage(vertexShader);
        const fragmentShaderStage = this._getShaderStage(fragmentShader);
        const materialShaders = this._getShaderCacheForMaterial(material);
        if (materialShaders.has(vertexShaderStage) === false) {
            materialShaders.add(vertexShaderStage);
            vertexShaderStage.usedTimes++;
        }
        if (materialShaders.has(fragmentShaderStage) === false) {
            materialShaders.add(fragmentShaderStage);
            fragmentShaderStage.usedTimes++;
        }
        return this;
    }
    remove(material) {
        const materialShaders = this.materialCache.get(material);
        for (const shaderStage of materialShaders){
            shaderStage.usedTimes--;
            if (shaderStage.usedTimes === 0) this.shaderCache.delete(shaderStage.code);
        }
        this.materialCache.delete(material);
        return this;
    }
    getVertexShaderID(material) {
        return this._getShaderStage(material.vertexShader).id;
    }
    getFragmentShaderID(material) {
        return this._getShaderStage(material.fragmentShader).id;
    }
    dispose() {
        this.shaderCache.clear();
        this.materialCache.clear();
    }
    _getShaderCacheForMaterial(material) {
        const cache = this.materialCache;
        if (cache.has(material) === false) cache.set(material, new Set());
        return cache.get(material);
    }
    _getShaderStage(code) {
        const cache = this.shaderCache;
        if (cache.has(code) === false) {
            const stage = new $084574008ccedf86$var$WebGLShaderStage(code);
            cache.set(code, stage);
        }
        return cache.get(code);
    }
}
class $084574008ccedf86$var$WebGLShaderStage {
    constructor(code){
        this.id = $084574008ccedf86$var$_id++;
        this.code = code;
        this.usedTimes = 0;
    }
}
function $084574008ccedf86$var$WebGLPrograms(renderer, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping) {
    const _programLayers = new $084574008ccedf86$export$89312ce47c0ca777();
    const _customShaders = new $084574008ccedf86$var$WebGLShaderCache();
    const programs = [];
    const isWebGL2 = capabilities.isWebGL2;
    const logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;
    const vertexTextures = capabilities.vertexTextures;
    let precision = capabilities.precision;
    const shaderIDs = {
        MeshDepthMaterial: "depth",
        MeshDistanceMaterial: "distanceRGBA",
        MeshNormalMaterial: "normal",
        MeshBasicMaterial: "basic",
        MeshLambertMaterial: "lambert",
        MeshPhongMaterial: "phong",
        MeshToonMaterial: "toon",
        MeshStandardMaterial: "physical",
        MeshPhysicalMaterial: "physical",
        MeshMatcapMaterial: "matcap",
        LineBasicMaterial: "basic",
        LineDashedMaterial: "dashed",
        PointsMaterial: "points",
        ShadowMaterial: "shadow",
        SpriteMaterial: "sprite"
    };
    function getParameters(material, lights, shadows, scene, object) {
        const fog = scene.fog;
        const geometry = object.geometry;
        const environment = material.isMeshStandardMaterial ? scene.environment : null;
        const envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || environment);
        const envMapCubeUVHeight = !!envMap && envMap.mapping === $084574008ccedf86$export$dbf3e70ff37af79 ? envMap.image.height : null;
        const shaderID = shaderIDs[material.type];
        // heuristics to create shader parameters according to lights in the scene
        // (not to blow over maxLights budget)
        if (material.precision !== null) {
            precision = capabilities.getMaxPrecision(material.precision);
            if (precision !== material.precision) console.warn("THREE.WebGLProgram.getParameters:", material.precision, "not supported, using", precision, "instead.");
        }
        //
        const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
        const morphTargetsCount = morphAttribute !== undefined ? morphAttribute.length : 0;
        let morphTextureStride = 0;
        if (geometry.morphAttributes.position !== undefined) morphTextureStride = 1;
        if (geometry.morphAttributes.normal !== undefined) morphTextureStride = 2;
        if (geometry.morphAttributes.color !== undefined) morphTextureStride = 3;
        //
        let vertexShader, fragmentShader;
        let customVertexShaderID, customFragmentShaderID;
        if (shaderID) {
            const shader = $084574008ccedf86$export$bee4a7d47f8f5014[shaderID];
            vertexShader = shader.vertexShader;
            fragmentShader = shader.fragmentShader;
        } else {
            vertexShader = material.vertexShader;
            fragmentShader = material.fragmentShader;
            _customShaders.update(material);
            customVertexShaderID = _customShaders.getVertexShaderID(material);
            customFragmentShaderID = _customShaders.getFragmentShaderID(material);
        }
        const currentRenderTarget = renderer.getRenderTarget();
        const useAlphaTest = material.alphaTest > 0;
        const useClearcoat = material.clearcoat > 0;
        const useIridescence = material.iridescence > 0;
        const parameters = {
            isWebGL2: isWebGL2,
            shaderID: shaderID,
            shaderName: material.type,
            vertexShader: vertexShader,
            fragmentShader: fragmentShader,
            defines: material.defines,
            customVertexShaderID: customVertexShaderID,
            customFragmentShaderID: customFragmentShaderID,
            isRawShaderMaterial: material.isRawShaderMaterial === true,
            glslVersion: material.glslVersion,
            precision: precision,
            instancing: object.isInstancedMesh === true,
            instancingColor: object.isInstancedMesh === true && object.instanceColor !== null,
            supportsVertexTextures: vertexTextures,
            outputEncoding: currentRenderTarget === null ? renderer.outputEncoding : currentRenderTarget.isXRRenderTarget === true ? currentRenderTarget.texture.encoding : $084574008ccedf86$export$7207336e4151a112,
            map: !!material.map,
            matcap: !!material.matcap,
            envMap: !!envMap,
            envMapMode: envMap && envMap.mapping,
            envMapCubeUVHeight: envMapCubeUVHeight,
            lightMap: !!material.lightMap,
            aoMap: !!material.aoMap,
            emissiveMap: !!material.emissiveMap,
            bumpMap: !!material.bumpMap,
            normalMap: !!material.normalMap,
            objectSpaceNormalMap: material.normalMapType === $084574008ccedf86$export$9990ad26f9db5b2c,
            tangentSpaceNormalMap: material.normalMapType === $084574008ccedf86$export$2852a58ebdac27b8,
            decodeVideoTexture: !!material.map && material.map.isVideoTexture === true && material.map.encoding === $084574008ccedf86$export$f32388edbb32674,
            clearcoat: useClearcoat,
            clearcoatMap: useClearcoat && !!material.clearcoatMap,
            clearcoatRoughnessMap: useClearcoat && !!material.clearcoatRoughnessMap,
            clearcoatNormalMap: useClearcoat && !!material.clearcoatNormalMap,
            iridescence: useIridescence,
            iridescenceMap: useIridescence && !!material.iridescenceMap,
            iridescenceThicknessMap: useIridescence && !!material.iridescenceThicknessMap,
            displacementMap: !!material.displacementMap,
            roughnessMap: !!material.roughnessMap,
            metalnessMap: !!material.metalnessMap,
            specularMap: !!material.specularMap,
            specularIntensityMap: !!material.specularIntensityMap,
            specularColorMap: !!material.specularColorMap,
            opaque: material.transparent === false && material.blending === $084574008ccedf86$export$5b29a26d96ee6af0,
            alphaMap: !!material.alphaMap,
            alphaTest: useAlphaTest,
            gradientMap: !!material.gradientMap,
            sheen: material.sheen > 0,
            sheenColorMap: !!material.sheenColorMap,
            sheenRoughnessMap: !!material.sheenRoughnessMap,
            transmission: material.transmission > 0,
            transmissionMap: !!material.transmissionMap,
            thicknessMap: !!material.thicknessMap,
            combine: material.combine,
            vertexTangents: !!material.normalMap && !!geometry.attributes.tangent,
            vertexColors: material.vertexColors,
            vertexAlphas: material.vertexColors === true && !!geometry.attributes.color && geometry.attributes.color.itemSize === 4,
            vertexUvs: !!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatMap || !!material.clearcoatRoughnessMap || !!material.clearcoatNormalMap || !!material.iridescenceMap || !!material.iridescenceThicknessMap || !!material.displacementMap || !!material.transmissionMap || !!material.thicknessMap || !!material.specularIntensityMap || !!material.specularColorMap || !!material.sheenColorMap || !!material.sheenRoughnessMap,
            uvsVertexOnly: !(!!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatNormalMap || !!material.iridescenceMap || !!material.iridescenceThicknessMap || material.transmission > 0 || !!material.transmissionMap || !!material.thicknessMap || !!material.specularIntensityMap || !!material.specularColorMap || material.sheen > 0 || !!material.sheenColorMap || !!material.sheenRoughnessMap) && !!material.displacementMap,
            fog: !!fog,
            useFog: material.fog === true,
            fogExp2: fog && fog.isFogExp2,
            flatShading: !!material.flatShading,
            sizeAttenuation: material.sizeAttenuation,
            logarithmicDepthBuffer: logarithmicDepthBuffer,
            skinning: object.isSkinnedMesh === true,
            morphTargets: geometry.morphAttributes.position !== undefined,
            morphNormals: geometry.morphAttributes.normal !== undefined,
            morphColors: geometry.morphAttributes.color !== undefined,
            morphTargetsCount: morphTargetsCount,
            morphTextureStride: morphTextureStride,
            numDirLights: lights.directional.length,
            numPointLights: lights.point.length,
            numSpotLights: lights.spot.length,
            numRectAreaLights: lights.rectArea.length,
            numHemiLights: lights.hemi.length,
            numDirLightShadows: lights.directionalShadowMap.length,
            numPointLightShadows: lights.pointShadowMap.length,
            numSpotLightShadows: lights.spotShadowMap.length,
            numClippingPlanes: clipping.numPlanes,
            numClipIntersection: clipping.numIntersection,
            dithering: material.dithering,
            shadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,
            shadowMapType: renderer.shadowMap.type,
            toneMapping: material.toneMapped ? renderer.toneMapping : $084574008ccedf86$export$9fcb6b4294603b2,
            physicallyCorrectLights: renderer.physicallyCorrectLights,
            premultipliedAlpha: material.premultipliedAlpha,
            doubleSided: material.side === $084574008ccedf86$export$3b296b6f144d5b03,
            flipSided: material.side === $084574008ccedf86$export$d9f0486e75b5ace,
            useDepthPacking: !!material.depthPacking,
            depthPacking: material.depthPacking || 0,
            index0AttributeName: material.index0AttributeName,
            extensionDerivatives: material.extensions && material.extensions.derivatives,
            extensionFragDepth: material.extensions && material.extensions.fragDepth,
            extensionDrawBuffers: material.extensions && material.extensions.drawBuffers,
            extensionShaderTextureLOD: material.extensions && material.extensions.shaderTextureLOD,
            rendererExtensionFragDepth: isWebGL2 || extensions.has("EXT_frag_depth"),
            rendererExtensionDrawBuffers: isWebGL2 || extensions.has("WEBGL_draw_buffers"),
            rendererExtensionShaderTextureLod: isWebGL2 || extensions.has("EXT_shader_texture_lod"),
            customProgramCacheKey: material.customProgramCacheKey()
        };
        return parameters;
    }
    function getProgramCacheKey(parameters) {
        const array = [];
        if (parameters.shaderID) array.push(parameters.shaderID);
        else {
            array.push(parameters.customVertexShaderID);
            array.push(parameters.customFragmentShaderID);
        }
        if (parameters.defines !== undefined) for(const name in parameters.defines){
            array.push(name);
            array.push(parameters.defines[name]);
        }
        if (parameters.isRawShaderMaterial === false) {
            getProgramCacheKeyParameters(array, parameters);
            getProgramCacheKeyBooleans(array, parameters);
            array.push(renderer.outputEncoding);
        }
        array.push(parameters.customProgramCacheKey);
        return array.join();
    }
    function getProgramCacheKeyParameters(array, parameters) {
        array.push(parameters.precision);
        array.push(parameters.outputEncoding);
        array.push(parameters.envMapMode);
        array.push(parameters.envMapCubeUVHeight);
        array.push(parameters.combine);
        array.push(parameters.vertexUvs);
        array.push(parameters.fogExp2);
        array.push(parameters.sizeAttenuation);
        array.push(parameters.morphTargetsCount);
        array.push(parameters.morphAttributeCount);
        array.push(parameters.numDirLights);
        array.push(parameters.numPointLights);
        array.push(parameters.numSpotLights);
        array.push(parameters.numHemiLights);
        array.push(parameters.numRectAreaLights);
        array.push(parameters.numDirLightShadows);
        array.push(parameters.numPointLightShadows);
        array.push(parameters.numSpotLightShadows);
        array.push(parameters.shadowMapType);
        array.push(parameters.toneMapping);
        array.push(parameters.numClippingPlanes);
        array.push(parameters.numClipIntersection);
        array.push(parameters.depthPacking);
    }
    function getProgramCacheKeyBooleans(array, parameters) {
        _programLayers.disableAll();
        if (parameters.isWebGL2) _programLayers.enable(0);
        if (parameters.supportsVertexTextures) _programLayers.enable(1);
        if (parameters.instancing) _programLayers.enable(2);
        if (parameters.instancingColor) _programLayers.enable(3);
        if (parameters.map) _programLayers.enable(4);
        if (parameters.matcap) _programLayers.enable(5);
        if (parameters.envMap) _programLayers.enable(6);
        if (parameters.lightMap) _programLayers.enable(7);
        if (parameters.aoMap) _programLayers.enable(8);
        if (parameters.emissiveMap) _programLayers.enable(9);
        if (parameters.bumpMap) _programLayers.enable(10);
        if (parameters.normalMap) _programLayers.enable(11);
        if (parameters.objectSpaceNormalMap) _programLayers.enable(12);
        if (parameters.tangentSpaceNormalMap) _programLayers.enable(13);
        if (parameters.clearcoat) _programLayers.enable(14);
        if (parameters.clearcoatMap) _programLayers.enable(15);
        if (parameters.clearcoatRoughnessMap) _programLayers.enable(16);
        if (parameters.clearcoatNormalMap) _programLayers.enable(17);
        if (parameters.iridescence) _programLayers.enable(18);
        if (parameters.iridescenceMap) _programLayers.enable(19);
        if (parameters.iridescenceThicknessMap) _programLayers.enable(20);
        if (parameters.displacementMap) _programLayers.enable(21);
        if (parameters.specularMap) _programLayers.enable(22);
        if (parameters.roughnessMap) _programLayers.enable(23);
        if (parameters.metalnessMap) _programLayers.enable(24);
        if (parameters.gradientMap) _programLayers.enable(25);
        if (parameters.alphaMap) _programLayers.enable(26);
        if (parameters.alphaTest) _programLayers.enable(27);
        if (parameters.vertexColors) _programLayers.enable(28);
        if (parameters.vertexAlphas) _programLayers.enable(29);
        if (parameters.vertexUvs) _programLayers.enable(30);
        if (parameters.vertexTangents) _programLayers.enable(31);
        if (parameters.uvsVertexOnly) _programLayers.enable(32);
        if (parameters.fog) _programLayers.enable(33);
        array.push(_programLayers.mask);
        _programLayers.disableAll();
        if (parameters.useFog) _programLayers.enable(0);
        if (parameters.flatShading) _programLayers.enable(1);
        if (parameters.logarithmicDepthBuffer) _programLayers.enable(2);
        if (parameters.skinning) _programLayers.enable(3);
        if (parameters.morphTargets) _programLayers.enable(4);
        if (parameters.morphNormals) _programLayers.enable(5);
        if (parameters.morphColors) _programLayers.enable(6);
        if (parameters.premultipliedAlpha) _programLayers.enable(7);
        if (parameters.shadowMapEnabled) _programLayers.enable(8);
        if (parameters.physicallyCorrectLights) _programLayers.enable(9);
        if (parameters.doubleSided) _programLayers.enable(10);
        if (parameters.flipSided) _programLayers.enable(11);
        if (parameters.useDepthPacking) _programLayers.enable(12);
        if (parameters.dithering) _programLayers.enable(13);
        if (parameters.specularIntensityMap) _programLayers.enable(14);
        if (parameters.specularColorMap) _programLayers.enable(15);
        if (parameters.transmission) _programLayers.enable(16);
        if (parameters.transmissionMap) _programLayers.enable(17);
        if (parameters.thicknessMap) _programLayers.enable(18);
        if (parameters.sheen) _programLayers.enable(19);
        if (parameters.sheenColorMap) _programLayers.enable(20);
        if (parameters.sheenRoughnessMap) _programLayers.enable(21);
        if (parameters.decodeVideoTexture) _programLayers.enable(22);
        if (parameters.opaque) _programLayers.enable(23);
        array.push(_programLayers.mask);
    }
    function getUniforms(material) {
        const shaderID = shaderIDs[material.type];
        let uniforms;
        if (shaderID) {
            const shader = $084574008ccedf86$export$bee4a7d47f8f5014[shaderID];
            uniforms = $084574008ccedf86$export$d8ecdf8615bfea69.clone(shader.uniforms);
        } else uniforms = material.uniforms;
        return uniforms;
    }
    function acquireProgram(parameters, cacheKey) {
        let program;
        // Check if code has been already compiled
        for(let p = 0, pl = programs.length; p < pl; p++){
            const preexistingProgram = programs[p];
            if (preexistingProgram.cacheKey === cacheKey) {
                program = preexistingProgram;
                ++program.usedTimes;
                break;
            }
        }
        if (program === undefined) {
            program = new $084574008ccedf86$var$WebGLProgram(renderer, cacheKey, parameters, bindingStates);
            programs.push(program);
        }
        return program;
    }
    function releaseProgram(program) {
        if (--program.usedTimes === 0) {
            // Remove from unordered set
            const i123 = programs.indexOf(program);
            programs[i123] = programs[programs.length - 1];
            programs.pop();
            // Free WebGL resources
            program.destroy();
        }
    }
    function releaseShaderCache(material) {
        _customShaders.remove(material);
    }
    function dispose() {
        _customShaders.dispose();
    }
    return {
        getParameters: getParameters,
        getProgramCacheKey: getProgramCacheKey,
        getUniforms: getUniforms,
        acquireProgram: acquireProgram,
        releaseProgram: releaseProgram,
        releaseShaderCache: releaseShaderCache,
        // Exposed for resource monitoring & error feedback via renderer.info:
        programs: programs,
        dispose: dispose
    };
}
function $084574008ccedf86$var$WebGLProperties() {
    let properties = new WeakMap();
    function get(object) {
        let map = properties.get(object);
        if (map === undefined) {
            map = {};
            properties.set(object, map);
        }
        return map;
    }
    function remove(object) {
        properties.delete(object);
    }
    function update(object, key, value) {
        properties.get(object)[key] = value;
    }
    function dispose() {
        properties = new WeakMap();
    }
    return {
        get: get,
        remove: remove,
        update: update,
        dispose: dispose
    };
}
function $084574008ccedf86$var$painterSortStable(a, b) {
    if (a.groupOrder !== b.groupOrder) return a.groupOrder - b.groupOrder;
    else if (a.renderOrder !== b.renderOrder) return a.renderOrder - b.renderOrder;
    else if (a.material.id !== b.material.id) return a.material.id - b.material.id;
    else if (a.z !== b.z) return a.z - b.z;
    else return a.id - b.id;
}
function $084574008ccedf86$var$reversePainterSortStable(a, b) {
    if (a.groupOrder !== b.groupOrder) return a.groupOrder - b.groupOrder;
    else if (a.renderOrder !== b.renderOrder) return a.renderOrder - b.renderOrder;
    else if (a.z !== b.z) return b.z - a.z;
    else return a.id - b.id;
}
function $084574008ccedf86$var$WebGLRenderList() {
    const renderItems = [];
    let renderItemsIndex = 0;
    const opaque = [];
    const transmissive = [];
    const transparent = [];
    function init() {
        renderItemsIndex = 0;
        opaque.length = 0;
        transmissive.length = 0;
        transparent.length = 0;
    }
    function getNextRenderItem(object, geometry, material, groupOrder, z, group) {
        let renderItem = renderItems[renderItemsIndex];
        if (renderItem === undefined) {
            renderItem = {
                id: object.id,
                object: object,
                geometry: geometry,
                material: material,
                groupOrder: groupOrder,
                renderOrder: object.renderOrder,
                z: z,
                group: group
            };
            renderItems[renderItemsIndex] = renderItem;
        } else {
            renderItem.id = object.id;
            renderItem.object = object;
            renderItem.geometry = geometry;
            renderItem.material = material;
            renderItem.groupOrder = groupOrder;
            renderItem.renderOrder = object.renderOrder;
            renderItem.z = z;
            renderItem.group = group;
        }
        renderItemsIndex++;
        return renderItem;
    }
    function push(object, geometry, material, groupOrder, z, group) {
        const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);
        if (material.transmission > 0.0) transmissive.push(renderItem);
        else if (material.transparent === true) transparent.push(renderItem);
        else opaque.push(renderItem);
    }
    function unshift(object, geometry, material, groupOrder, z, group) {
        const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);
        if (material.transmission > 0.0) transmissive.unshift(renderItem);
        else if (material.transparent === true) transparent.unshift(renderItem);
        else opaque.unshift(renderItem);
    }
    function sort(customOpaqueSort, customTransparentSort) {
        if (opaque.length > 1) opaque.sort(customOpaqueSort || $084574008ccedf86$var$painterSortStable);
        if (transmissive.length > 1) transmissive.sort(customTransparentSort || $084574008ccedf86$var$reversePainterSortStable);
        if (transparent.length > 1) transparent.sort(customTransparentSort || $084574008ccedf86$var$reversePainterSortStable);
    }
    function finish() {
        // Clear references from inactive renderItems in the list
        for(let i124 = renderItemsIndex, il = renderItems.length; i124 < il; i124++){
            const renderItem = renderItems[i124];
            if (renderItem.id === null) break;
            renderItem.id = null;
            renderItem.object = null;
            renderItem.geometry = null;
            renderItem.material = null;
            renderItem.group = null;
        }
    }
    return {
        opaque: opaque,
        transmissive: transmissive,
        transparent: transparent,
        init: init,
        push: push,
        unshift: unshift,
        finish: finish,
        sort: sort
    };
}
function $084574008ccedf86$var$WebGLRenderLists() {
    let lists = new WeakMap();
    function get(scene, renderCallDepth) {
        let list;
        if (lists.has(scene) === false) {
            list = new $084574008ccedf86$var$WebGLRenderList();
            lists.set(scene, [
                list
            ]);
        } else if (renderCallDepth >= lists.get(scene).length) {
            list = new $084574008ccedf86$var$WebGLRenderList();
            lists.get(scene).push(list);
        } else list = lists.get(scene)[renderCallDepth];
        return list;
    }
    function dispose() {
        lists = new WeakMap();
    }
    return {
        get: get,
        dispose: dispose
    };
}
function $084574008ccedf86$var$UniformsCache() {
    const lights = {};
    return {
        get: function(light) {
            if (lights[light.id] !== undefined) return lights[light.id];
            let uniforms;
            switch(light.type){
                case "DirectionalLight":
                    uniforms = {
                        direction: new $084574008ccedf86$export$64b5c384219d3699(),
                        color: new $084574008ccedf86$export$892596cec99bc70e()
                    };
                    break;
                case "SpotLight":
                    uniforms = {
                        position: new $084574008ccedf86$export$64b5c384219d3699(),
                        direction: new $084574008ccedf86$export$64b5c384219d3699(),
                        color: new $084574008ccedf86$export$892596cec99bc70e(),
                        distance: 0,
                        coneCos: 0,
                        penumbraCos: 0,
                        decay: 0
                    };
                    break;
                case "PointLight":
                    uniforms = {
                        position: new $084574008ccedf86$export$64b5c384219d3699(),
                        color: new $084574008ccedf86$export$892596cec99bc70e(),
                        distance: 0,
                        decay: 0
                    };
                    break;
                case "HemisphereLight":
                    uniforms = {
                        direction: new $084574008ccedf86$export$64b5c384219d3699(),
                        skyColor: new $084574008ccedf86$export$892596cec99bc70e(),
                        groundColor: new $084574008ccedf86$export$892596cec99bc70e()
                    };
                    break;
                case "RectAreaLight":
                    uniforms = {
                        color: new $084574008ccedf86$export$892596cec99bc70e(),
                        position: new $084574008ccedf86$export$64b5c384219d3699(),
                        halfWidth: new $084574008ccedf86$export$64b5c384219d3699(),
                        halfHeight: new $084574008ccedf86$export$64b5c384219d3699()
                    };
                    break;
            }
            lights[light.id] = uniforms;
            return uniforms;
        }
    };
}
function $084574008ccedf86$var$ShadowUniformsCache() {
    const lights = {};
    return {
        get: function(light) {
            if (lights[light.id] !== undefined) return lights[light.id];
            let uniforms;
            switch(light.type){
                case "DirectionalLight":
                    uniforms = {
                        shadowBias: 0,
                        shadowNormalBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new $084574008ccedf86$export$c977b3e384af9ae1()
                    };
                    break;
                case "SpotLight":
                    uniforms = {
                        shadowBias: 0,
                        shadowNormalBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new $084574008ccedf86$export$c977b3e384af9ae1()
                    };
                    break;
                case "PointLight":
                    uniforms = {
                        shadowBias: 0,
                        shadowNormalBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new $084574008ccedf86$export$c977b3e384af9ae1(),
                        shadowCameraNear: 1,
                        shadowCameraFar: 1000
                    };
                    break;
            }
            lights[light.id] = uniforms;
            return uniforms;
        }
    };
}
let $084574008ccedf86$var$nextVersion = 0;
function $084574008ccedf86$var$shadowCastingLightsFirst(lightA, lightB) {
    return (lightB.castShadow ? 1 : 0) - (lightA.castShadow ? 1 : 0);
}
function $084574008ccedf86$var$WebGLLights(extensions, capabilities) {
    const cache = new $084574008ccedf86$var$UniformsCache();
    const shadowCache = $084574008ccedf86$var$ShadowUniformsCache();
    const state = {
        version: 0,
        hash: {
            directionalLength: -1,
            pointLength: -1,
            spotLength: -1,
            rectAreaLength: -1,
            hemiLength: -1,
            numDirectionalShadows: -1,
            numPointShadows: -1,
            numSpotShadows: -1
        },
        ambient: [
            0,
            0,
            0
        ],
        probe: [],
        directional: [],
        directionalShadow: [],
        directionalShadowMap: [],
        directionalShadowMatrix: [],
        spot: [],
        spotShadow: [],
        spotShadowMap: [],
        spotShadowMatrix: [],
        rectArea: [],
        rectAreaLTC1: null,
        rectAreaLTC2: null,
        point: [],
        pointShadow: [],
        pointShadowMap: [],
        pointShadowMatrix: [],
        hemi: []
    };
    for(let i125 = 0; i125 < 9; i125++)state.probe.push(new $084574008ccedf86$export$64b5c384219d3699());
    const vector3 = new $084574008ccedf86$export$64b5c384219d3699();
    const matrix4 = new $084574008ccedf86$export$2ae72fc923e5eb5();
    const matrix42 = new $084574008ccedf86$export$2ae72fc923e5eb5();
    function setup(lights, physicallyCorrectLights) {
        let r = 0, g = 0, b = 0;
        for(let i127 = 0; i127 < 9; i127++)state.probe[i127].set(0, 0, 0);
        let directionalLength = 0;
        let pointLength = 0;
        let spotLength = 0;
        let rectAreaLength = 0;
        let hemiLength = 0;
        let numDirectionalShadows = 0;
        let numPointShadows = 0;
        let numSpotShadows = 0;
        lights.sort($084574008ccedf86$var$shadowCastingLightsFirst);
        // artist-friendly light intensity scaling factor
        const scaleFactor = physicallyCorrectLights !== true ? Math.PI : 1;
        for(let i126 = 0, l = lights.length; i126 < l; i126++){
            const light = lights[i126];
            const color = light.color;
            const intensity = light.intensity;
            const distance = light.distance;
            const shadowMap = light.shadow && light.shadow.map ? light.shadow.map.texture : null;
            if (light.isAmbientLight) {
                r += color.r * intensity * scaleFactor;
                g += color.g * intensity * scaleFactor;
                b += color.b * intensity * scaleFactor;
            } else if (light.isLightProbe) for(let j = 0; j < 9; j++)state.probe[j].addScaledVector(light.sh.coefficients[j], intensity);
            else if (light.isDirectionalLight) {
                const uniforms = cache.get(light);
                uniforms.color.copy(light.color).multiplyScalar(light.intensity * scaleFactor);
                if (light.castShadow) {
                    const shadow = light.shadow;
                    const shadowUniforms = shadowCache.get(light);
                    shadowUniforms.shadowBias = shadow.bias;
                    shadowUniforms.shadowNormalBias = shadow.normalBias;
                    shadowUniforms.shadowRadius = shadow.radius;
                    shadowUniforms.shadowMapSize = shadow.mapSize;
                    state.directionalShadow[directionalLength] = shadowUniforms;
                    state.directionalShadowMap[directionalLength] = shadowMap;
                    state.directionalShadowMatrix[directionalLength] = light.shadow.matrix;
                    numDirectionalShadows++;
                }
                state.directional[directionalLength] = uniforms;
                directionalLength++;
            } else if (light.isSpotLight) {
                const uniforms = cache.get(light);
                uniforms.position.setFromMatrixPosition(light.matrixWorld);
                uniforms.color.copy(color).multiplyScalar(intensity * scaleFactor);
                uniforms.distance = distance;
                uniforms.coneCos = Math.cos(light.angle);
                uniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra));
                uniforms.decay = light.decay;
                if (light.castShadow) {
                    const shadow = light.shadow;
                    const shadowUniforms = shadowCache.get(light);
                    shadowUniforms.shadowBias = shadow.bias;
                    shadowUniforms.shadowNormalBias = shadow.normalBias;
                    shadowUniforms.shadowRadius = shadow.radius;
                    shadowUniforms.shadowMapSize = shadow.mapSize;
                    state.spotShadow[spotLength] = shadowUniforms;
                    state.spotShadowMap[spotLength] = shadowMap;
                    state.spotShadowMatrix[spotLength] = light.shadow.matrix;
                    numSpotShadows++;
                }
                state.spot[spotLength] = uniforms;
                spotLength++;
            } else if (light.isRectAreaLight) {
                const uniforms = cache.get(light);
                // (a) intensity is the total visible light emitted
                //uniforms.color.copy( color ).multiplyScalar( intensity / ( light.width * light.height * Math.PI ) );
                // (b) intensity is the brightness of the light
                uniforms.color.copy(color).multiplyScalar(intensity);
                uniforms.halfWidth.set(light.width * 0.5, 0.0, 0.0);
                uniforms.halfHeight.set(0.0, light.height * 0.5, 0.0);
                state.rectArea[rectAreaLength] = uniforms;
                rectAreaLength++;
            } else if (light.isPointLight) {
                const uniforms = cache.get(light);
                uniforms.color.copy(light.color).multiplyScalar(light.intensity * scaleFactor);
                uniforms.distance = light.distance;
                uniforms.decay = light.decay;
                if (light.castShadow) {
                    const shadow = light.shadow;
                    const shadowUniforms = shadowCache.get(light);
                    shadowUniforms.shadowBias = shadow.bias;
                    shadowUniforms.shadowNormalBias = shadow.normalBias;
                    shadowUniforms.shadowRadius = shadow.radius;
                    shadowUniforms.shadowMapSize = shadow.mapSize;
                    shadowUniforms.shadowCameraNear = shadow.camera.near;
                    shadowUniforms.shadowCameraFar = shadow.camera.far;
                    state.pointShadow[pointLength] = shadowUniforms;
                    state.pointShadowMap[pointLength] = shadowMap;
                    state.pointShadowMatrix[pointLength] = light.shadow.matrix;
                    numPointShadows++;
                }
                state.point[pointLength] = uniforms;
                pointLength++;
            } else if (light.isHemisphereLight) {
                const uniforms = cache.get(light);
                uniforms.skyColor.copy(light.color).multiplyScalar(intensity * scaleFactor);
                uniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity * scaleFactor);
                state.hemi[hemiLength] = uniforms;
                hemiLength++;
            }
        }
        if (rectAreaLength > 0) {
            if (capabilities.isWebGL2) {
                // WebGL 2
                state.rectAreaLTC1 = $084574008ccedf86$export$6643083551874bf5.LTC_FLOAT_1;
                state.rectAreaLTC2 = $084574008ccedf86$export$6643083551874bf5.LTC_FLOAT_2;
            } else {
                // WebGL 1
                if (extensions.has("OES_texture_float_linear") === true) {
                    state.rectAreaLTC1 = $084574008ccedf86$export$6643083551874bf5.LTC_FLOAT_1;
                    state.rectAreaLTC2 = $084574008ccedf86$export$6643083551874bf5.LTC_FLOAT_2;
                } else if (extensions.has("OES_texture_half_float_linear") === true) {
                    state.rectAreaLTC1 = $084574008ccedf86$export$6643083551874bf5.LTC_HALF_1;
                    state.rectAreaLTC2 = $084574008ccedf86$export$6643083551874bf5.LTC_HALF_2;
                } else console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.");
            }
        }
        state.ambient[0] = r;
        state.ambient[1] = g;
        state.ambient[2] = b;
        const hash = state.hash;
        if (hash.directionalLength !== directionalLength || hash.pointLength !== pointLength || hash.spotLength !== spotLength || hash.rectAreaLength !== rectAreaLength || hash.hemiLength !== hemiLength || hash.numDirectionalShadows !== numDirectionalShadows || hash.numPointShadows !== numPointShadows || hash.numSpotShadows !== numSpotShadows) {
            state.directional.length = directionalLength;
            state.spot.length = spotLength;
            state.rectArea.length = rectAreaLength;
            state.point.length = pointLength;
            state.hemi.length = hemiLength;
            state.directionalShadow.length = numDirectionalShadows;
            state.directionalShadowMap.length = numDirectionalShadows;
            state.pointShadow.length = numPointShadows;
            state.pointShadowMap.length = numPointShadows;
            state.spotShadow.length = numSpotShadows;
            state.spotShadowMap.length = numSpotShadows;
            state.directionalShadowMatrix.length = numDirectionalShadows;
            state.pointShadowMatrix.length = numPointShadows;
            state.spotShadowMatrix.length = numSpotShadows;
            hash.directionalLength = directionalLength;
            hash.pointLength = pointLength;
            hash.spotLength = spotLength;
            hash.rectAreaLength = rectAreaLength;
            hash.hemiLength = hemiLength;
            hash.numDirectionalShadows = numDirectionalShadows;
            hash.numPointShadows = numPointShadows;
            hash.numSpotShadows = numSpotShadows;
            state.version = $084574008ccedf86$var$nextVersion++;
        }
    }
    function setupView(lights, camera) {
        let directionalLength = 0;
        let pointLength = 0;
        let spotLength = 0;
        let rectAreaLength = 0;
        let hemiLength = 0;
        const viewMatrix = camera.matrixWorldInverse;
        for(let i128 = 0, l = lights.length; i128 < l; i128++){
            const light = lights[i128];
            if (light.isDirectionalLight) {
                const uniforms = state.directional[directionalLength];
                uniforms.direction.setFromMatrixPosition(light.matrixWorld);
                vector3.setFromMatrixPosition(light.target.matrixWorld);
                uniforms.direction.sub(vector3);
                uniforms.direction.transformDirection(viewMatrix);
                directionalLength++;
            } else if (light.isSpotLight) {
                const uniforms = state.spot[spotLength];
                uniforms.position.setFromMatrixPosition(light.matrixWorld);
                uniforms.position.applyMatrix4(viewMatrix);
                uniforms.direction.setFromMatrixPosition(light.matrixWorld);
                vector3.setFromMatrixPosition(light.target.matrixWorld);
                uniforms.direction.sub(vector3);
                uniforms.direction.transformDirection(viewMatrix);
                spotLength++;
            } else if (light.isRectAreaLight) {
                const uniforms = state.rectArea[rectAreaLength];
                uniforms.position.setFromMatrixPosition(light.matrixWorld);
                uniforms.position.applyMatrix4(viewMatrix);
                // extract local rotation of light to derive width/height half vectors
                matrix42.identity();
                matrix4.copy(light.matrixWorld);
                matrix4.premultiply(viewMatrix);
                matrix42.extractRotation(matrix4);
                uniforms.halfWidth.set(light.width * 0.5, 0.0, 0.0);
                uniforms.halfHeight.set(0.0, light.height * 0.5, 0.0);
                uniforms.halfWidth.applyMatrix4(matrix42);
                uniforms.halfHeight.applyMatrix4(matrix42);
                rectAreaLength++;
            } else if (light.isPointLight) {
                const uniforms = state.point[pointLength];
                uniforms.position.setFromMatrixPosition(light.matrixWorld);
                uniforms.position.applyMatrix4(viewMatrix);
                pointLength++;
            } else if (light.isHemisphereLight) {
                const uniforms = state.hemi[hemiLength];
                uniforms.direction.setFromMatrixPosition(light.matrixWorld);
                uniforms.direction.transformDirection(viewMatrix);
                hemiLength++;
            }
        }
    }
    return {
        setup: setup,
        setupView: setupView,
        state: state
    };
}
function $084574008ccedf86$var$WebGLRenderState(extensions, capabilities) {
    const lights = new $084574008ccedf86$var$WebGLLights(extensions, capabilities);
    const lightsArray = [];
    const shadowsArray = [];
    function init() {
        lightsArray.length = 0;
        shadowsArray.length = 0;
    }
    function pushLight(light) {
        lightsArray.push(light);
    }
    function pushShadow(shadowLight) {
        shadowsArray.push(shadowLight);
    }
    function setupLights(physicallyCorrectLights) {
        lights.setup(lightsArray, physicallyCorrectLights);
    }
    function setupLightsView(camera) {
        lights.setupView(lightsArray, camera);
    }
    const state = {
        lightsArray: lightsArray,
        shadowsArray: shadowsArray,
        lights: lights
    };
    return {
        init: init,
        state: state,
        setupLights: setupLights,
        setupLightsView: setupLightsView,
        pushLight: pushLight,
        pushShadow: pushShadow
    };
}
function $084574008ccedf86$var$WebGLRenderStates(extensions, capabilities) {
    let renderStates = new WeakMap();
    function get(scene, renderCallDepth = 0) {
        let renderState;
        if (renderStates.has(scene) === false) {
            renderState = new $084574008ccedf86$var$WebGLRenderState(extensions, capabilities);
            renderStates.set(scene, [
                renderState
            ]);
        } else if (renderCallDepth >= renderStates.get(scene).length) {
            renderState = new $084574008ccedf86$var$WebGLRenderState(extensions, capabilities);
            renderStates.get(scene).push(renderState);
        } else renderState = renderStates.get(scene)[renderCallDepth];
        return renderState;
    }
    function dispose() {
        renderStates = new WeakMap();
    }
    return {
        get: get,
        dispose: dispose
    };
}
class $084574008ccedf86$export$2698c22ec13825db extends $084574008ccedf86$export$a2d8b23205c25948 {
    constructor(parameters){
        super();
        this.isMeshDepthMaterial = true;
        this.type = "MeshDepthMaterial";
        this.depthPacking = $084574008ccedf86$export$deeb383078690b50;
        this.map = null;
        this.alphaMap = null;
        this.displacementMap = null;
        this.displacementScale = 1;
        this.displacementBias = 0;
        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.setValues(parameters);
    }
    copy(source) {
        super.copy(source);
        this.depthPacking = source.depthPacking;
        this.map = source.map;
        this.alphaMap = source.alphaMap;
        this.displacementMap = source.displacementMap;
        this.displacementScale = source.displacementScale;
        this.displacementBias = source.displacementBias;
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        return this;
    }
}
class $084574008ccedf86$export$33e187ed002f2a19 extends $084574008ccedf86$export$a2d8b23205c25948 {
    constructor(parameters){
        super();
        this.isMeshDistanceMaterial = true;
        this.type = "MeshDistanceMaterial";
        this.referencePosition = new $084574008ccedf86$export$64b5c384219d3699();
        this.nearDistance = 1;
        this.farDistance = 1000;
        this.map = null;
        this.alphaMap = null;
        this.displacementMap = null;
        this.displacementScale = 1;
        this.displacementBias = 0;
        this.setValues(parameters);
    }
    copy(source) {
        super.copy(source);
        this.referencePosition.copy(source.referencePosition);
        this.nearDistance = source.nearDistance;
        this.farDistance = source.farDistance;
        this.map = source.map;
        this.alphaMap = source.alphaMap;
        this.displacementMap = source.displacementMap;
        this.displacementScale = source.displacementScale;
        this.displacementBias = source.displacementBias;
        return this;
    }
}
const $084574008ccedf86$var$vertex = "void main() {\n	gl_Position = vec4( position, 1.0 );\n}";
const $084574008ccedf86$var$fragment = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n	const float samples = float( VSM_SAMPLES );\n	float mean = 0.0;\n	float squared_mean = 0.0;\n	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n	for ( float i = 0.0; i < samples; i ++ ) {\n		float uvOffset = uvStart + i * uvStride;\n		#ifdef HORIZONTAL_PASS\n			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n			mean += distribution.x;\n			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n		#else\n			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n			mean += depth;\n			squared_mean += depth * depth;\n		#endif\n	}\n	mean = mean / samples;\n	squared_mean = squared_mean / samples;\n	float std_dev = sqrt( squared_mean - mean * mean );\n	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";
function $084574008ccedf86$var$WebGLShadowMap(_renderer, _objects, _capabilities) {
    let _frustum = new $084574008ccedf86$export$35efe6f4c85463d2();
    const _shadowMapSize = new $084574008ccedf86$export$c977b3e384af9ae1(), _viewportSize = new $084574008ccedf86$export$c977b3e384af9ae1(), _viewport = new $084574008ccedf86$export$fa7daccca11cdbe3(), _depthMaterial = new $084574008ccedf86$export$2698c22ec13825db({
        depthPacking: $084574008ccedf86$export$8f910f4c4f73df11
    }), _distanceMaterial = new $084574008ccedf86$export$33e187ed002f2a19(), _materialCache = {}, _maxTextureSize = _capabilities.maxTextureSize;
    const shadowSide = {
        0: $084574008ccedf86$export$d9f0486e75b5ace,
        1: $084574008ccedf86$export$2ede184fc2998901,
        2: $084574008ccedf86$export$3b296b6f144d5b03
    };
    const shadowMaterialVertical = new $084574008ccedf86$export$83c7d75d550a8b0d({
        defines: {
            VSM_SAMPLES: 8
        },
        uniforms: {
            shadow_pass: {
                value: null
            },
            resolution: {
                value: new $084574008ccedf86$export$c977b3e384af9ae1()
            },
            radius: {
                value: 4.0
            }
        },
        vertexShader: $084574008ccedf86$var$vertex,
        fragmentShader: $084574008ccedf86$var$fragment
    });
    const shadowMaterialHorizontal = shadowMaterialVertical.clone();
    shadowMaterialHorizontal.defines.HORIZONTAL_PASS = 1;
    const fullScreenTri = new $084574008ccedf86$export$b7be63a67df8959();
    fullScreenTri.setAttribute("position", new $084574008ccedf86$export$8dea267bd6bde117(new Float32Array([
        -1,
        -1,
        0.5,
        3,
        -1,
        0.5,
        -1,
        3,
        0.5
    ]), 3));
    const fullScreenMesh = new $084574008ccedf86$export$e176487c05830cc5(fullScreenTri, shadowMaterialVertical);
    const scope = this;
    this.enabled = false;
    this.autoUpdate = true;
    this.needsUpdate = false;
    this.type = $084574008ccedf86$export$5813f879eee7cd88;
    this.render = function(lights, scene, camera) {
        if (scope.enabled === false) return;
        if (scope.autoUpdate === false && scope.needsUpdate === false) return;
        if (lights.length === 0) return;
        const currentRenderTarget = _renderer.getRenderTarget();
        const activeCubeFace = _renderer.getActiveCubeFace();
        const activeMipmapLevel = _renderer.getActiveMipmapLevel();
        const _state = _renderer.state;
        // Set GL state for depth map.
        _state.setBlending($084574008ccedf86$export$63b8d6b580fc65ba);
        _state.buffers.color.setClear(1, 1, 1, 1);
        _state.buffers.depth.setTest(true);
        _state.setScissorTest(false);
        // render depth map
        for(let i129 = 0, il = lights.length; i129 < il; i129++){
            const light = lights[i129];
            const shadow = light.shadow;
            if (shadow === undefined) {
                console.warn("THREE.WebGLShadowMap:", light, "has no shadow.");
                continue;
            }
            if (shadow.autoUpdate === false && shadow.needsUpdate === false) continue;
            _shadowMapSize.copy(shadow.mapSize);
            const shadowFrameExtents = shadow.getFrameExtents();
            _shadowMapSize.multiply(shadowFrameExtents);
            _viewportSize.copy(shadow.mapSize);
            if (_shadowMapSize.x > _maxTextureSize || _shadowMapSize.y > _maxTextureSize) {
                if (_shadowMapSize.x > _maxTextureSize) {
                    _viewportSize.x = Math.floor(_maxTextureSize / shadowFrameExtents.x);
                    _shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;
                    shadow.mapSize.x = _viewportSize.x;
                }
                if (_shadowMapSize.y > _maxTextureSize) {
                    _viewportSize.y = Math.floor(_maxTextureSize / shadowFrameExtents.y);
                    _shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;
                    shadow.mapSize.y = _viewportSize.y;
                }
            }
            if (shadow.map === null && !shadow.isPointLightShadow && this.type === $084574008ccedf86$export$896ae1ade6c829c4) {
                shadow.map = new $084574008ccedf86$export$3c052beb2e51e23f(_shadowMapSize.x, _shadowMapSize.y);
                shadow.map.texture.name = light.name + ".shadowMap";
                shadow.mapPass = new $084574008ccedf86$export$3c052beb2e51e23f(_shadowMapSize.x, _shadowMapSize.y);
                shadow.camera.updateProjectionMatrix();
            }
            if (shadow.map === null) {
                const pars = {
                    minFilter: $084574008ccedf86$export$727aa5ec3fe39bf0,
                    magFilter: $084574008ccedf86$export$727aa5ec3fe39bf0,
                    format: $084574008ccedf86$export$3f8bb04b555a363c
                };
                shadow.map = new $084574008ccedf86$export$3c052beb2e51e23f(_shadowMapSize.x, _shadowMapSize.y, pars);
                shadow.map.texture.name = light.name + ".shadowMap";
                shadow.camera.updateProjectionMatrix();
            }
            _renderer.setRenderTarget(shadow.map);
            _renderer.clear();
            const viewportCount = shadow.getViewportCount();
            for(let vp = 0; vp < viewportCount; vp++){
                const viewport = shadow.getViewport(vp);
                _viewport.set(_viewportSize.x * viewport.x, _viewportSize.y * viewport.y, _viewportSize.x * viewport.z, _viewportSize.y * viewport.w);
                _state.viewport(_viewport);
                shadow.updateMatrices(light, vp);
                _frustum = shadow.getFrustum();
                renderObject(scene, camera, shadow.camera, light, this.type);
            }
            // do blur pass for VSM
            if (!shadow.isPointLightShadow && this.type === $084574008ccedf86$export$896ae1ade6c829c4) VSMPass(shadow, camera);
            shadow.needsUpdate = false;
        }
        scope.needsUpdate = false;
        _renderer.setRenderTarget(currentRenderTarget, activeCubeFace, activeMipmapLevel);
    };
    function VSMPass(shadow, camera) {
        const geometry = _objects.update(fullScreenMesh);
        if (shadowMaterialVertical.defines.VSM_SAMPLES !== shadow.blurSamples) {
            shadowMaterialVertical.defines.VSM_SAMPLES = shadow.blurSamples;
            shadowMaterialHorizontal.defines.VSM_SAMPLES = shadow.blurSamples;
            shadowMaterialVertical.needsUpdate = true;
            shadowMaterialHorizontal.needsUpdate = true;
        }
        // vertical pass
        shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;
        shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;
        shadowMaterialVertical.uniforms.radius.value = shadow.radius;
        _renderer.setRenderTarget(shadow.mapPass);
        _renderer.clear();
        _renderer.renderBufferDirect(camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null);
        // horizontal pass
        shadowMaterialHorizontal.uniforms.shadow_pass.value = shadow.mapPass.texture;
        shadowMaterialHorizontal.uniforms.resolution.value = shadow.mapSize;
        shadowMaterialHorizontal.uniforms.radius.value = shadow.radius;
        _renderer.setRenderTarget(shadow.map);
        _renderer.clear();
        _renderer.renderBufferDirect(camera, null, geometry, shadowMaterialHorizontal, fullScreenMesh, null);
    }
    function getDepthMaterial(object, material, light, shadowCameraNear, shadowCameraFar, type) {
        let result = null;
        const customMaterial = light.isPointLight === true ? object.customDistanceMaterial : object.customDepthMaterial;
        if (customMaterial !== undefined) result = customMaterial;
        else result = light.isPointLight === true ? _distanceMaterial : _depthMaterial;
        if (_renderer.localClippingEnabled && material.clipShadows === true && material.clippingPlanes.length !== 0 || material.displacementMap && material.displacementScale !== 0 || material.alphaMap && material.alphaTest > 0) {
            // in this case we need a unique material instance reflecting the
            // appropriate state
            const keyA = result.uuid, keyB = material.uuid;
            let materialsForVariant = _materialCache[keyA];
            if (materialsForVariant === undefined) {
                materialsForVariant = {};
                _materialCache[keyA] = materialsForVariant;
            }
            let cachedMaterial = materialsForVariant[keyB];
            if (cachedMaterial === undefined) {
                cachedMaterial = result.clone();
                materialsForVariant[keyB] = cachedMaterial;
            }
            result = cachedMaterial;
        }
        result.visible = material.visible;
        result.wireframe = material.wireframe;
        if (type === $084574008ccedf86$export$896ae1ade6c829c4) result.side = material.shadowSide !== null ? material.shadowSide : material.side;
        else result.side = material.shadowSide !== null ? material.shadowSide : shadowSide[material.side];
        result.alphaMap = material.alphaMap;
        result.alphaTest = material.alphaTest;
        result.clipShadows = material.clipShadows;
        result.clippingPlanes = material.clippingPlanes;
        result.clipIntersection = material.clipIntersection;
        result.displacementMap = material.displacementMap;
        result.displacementScale = material.displacementScale;
        result.displacementBias = material.displacementBias;
        result.wireframeLinewidth = material.wireframeLinewidth;
        result.linewidth = material.linewidth;
        if (light.isPointLight === true && result.isMeshDistanceMaterial === true) {
            result.referencePosition.setFromMatrixPosition(light.matrixWorld);
            result.nearDistance = shadowCameraNear;
            result.farDistance = shadowCameraFar;
        }
        return result;
    }
    function renderObject(object, camera, shadowCamera, light, type) {
        if (object.visible === false) return;
        const visible = object.layers.test(camera.layers);
        if (visible && (object.isMesh || object.isLine || object.isPoints)) {
            if ((object.castShadow || object.receiveShadow && type === $084574008ccedf86$export$896ae1ade6c829c4) && (!object.frustumCulled || _frustum.intersectsObject(object))) {
                object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);
                const geometry = _objects.update(object);
                const material = object.material;
                if (Array.isArray(material)) {
                    const groups = geometry.groups;
                    for(let k = 0, kl = groups.length; k < kl; k++){
                        const group = groups[k];
                        const groupMaterial = material[group.materialIndex];
                        if (groupMaterial && groupMaterial.visible) {
                            const depthMaterial = getDepthMaterial(object, groupMaterial, light, shadowCamera.near, shadowCamera.far, type);
                            _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, group);
                        }
                    }
                } else if (material.visible) {
                    const depthMaterial = getDepthMaterial(object, material, light, shadowCamera.near, shadowCamera.far, type);
                    _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, null);
                }
            }
        }
        const children = object.children;
        for(let i130 = 0, l = children.length; i130 < l; i130++)renderObject(children[i130], camera, shadowCamera, light, type);
    }
}
function $084574008ccedf86$var$WebGLState(gl, extensions, capabilities) {
    const isWebGL2 = capabilities.isWebGL2;
    function ColorBuffer() {
        let locked = false;
        const color = new $084574008ccedf86$export$fa7daccca11cdbe3();
        let currentColorMask = null;
        const currentColorClear = new $084574008ccedf86$export$fa7daccca11cdbe3(0, 0, 0, 0);
        return {
            setMask: function(colorMask) {
                if (currentColorMask !== colorMask && !locked) {
                    gl.colorMask(colorMask, colorMask, colorMask, colorMask);
                    currentColorMask = colorMask;
                }
            },
            setLocked: function(lock) {
                locked = lock;
            },
            setClear: function(r, g, b, a, premultipliedAlpha) {
                if (premultipliedAlpha === true) {
                    r *= a;
                    g *= a;
                    b *= a;
                }
                color.set(r, g, b, a);
                if (currentColorClear.equals(color) === false) {
                    gl.clearColor(r, g, b, a);
                    currentColorClear.copy(color);
                }
            },
            reset: function() {
                locked = false;
                currentColorMask = null;
                currentColorClear.set(-1, 0, 0, 0); // set to invalid state
            }
        };
    }
    function DepthBuffer() {
        let locked = false;
        let currentDepthMask = null;
        let currentDepthFunc = null;
        let currentDepthClear = null;
        return {
            setTest: function(depthTest) {
                if (depthTest) enable(2929);
                else disable(2929);
            },
            setMask: function(depthMask) {
                if (currentDepthMask !== depthMask && !locked) {
                    gl.depthMask(depthMask);
                    currentDepthMask = depthMask;
                }
            },
            setFunc: function(depthFunc) {
                if (currentDepthFunc !== depthFunc) {
                    if (depthFunc) switch(depthFunc){
                        case $084574008ccedf86$export$69025ce147cee220:
                            gl.depthFunc(512);
                            break;
                        case $084574008ccedf86$export$7182eb52ea3b3f04:
                            gl.depthFunc(519);
                            break;
                        case $084574008ccedf86$export$eedccec66ab7ebe:
                            gl.depthFunc(513);
                            break;
                        case $084574008ccedf86$export$296f78a0b892f81a:
                            gl.depthFunc(515);
                            break;
                        case $084574008ccedf86$export$a60d398fc7b7590e:
                            gl.depthFunc(514);
                            break;
                        case $084574008ccedf86$export$7d7234c1240a1fc4:
                            gl.depthFunc(518);
                            break;
                        case $084574008ccedf86$export$c5e2c52991f30937:
                            gl.depthFunc(516);
                            break;
                        case $084574008ccedf86$export$2f843afa843d8916:
                            gl.depthFunc(517);
                            break;
                        default:
                            gl.depthFunc(515);
                    }
                    else gl.depthFunc(515);
                    currentDepthFunc = depthFunc;
                }
            },
            setLocked: function(lock) {
                locked = lock;
            },
            setClear: function(depth) {
                if (currentDepthClear !== depth) {
                    gl.clearDepth(depth);
                    currentDepthClear = depth;
                }
            },
            reset: function() {
                locked = false;
                currentDepthMask = null;
                currentDepthFunc = null;
                currentDepthClear = null;
            }
        };
    }
    function StencilBuffer() {
        let locked = false;
        let currentStencilMask = null;
        let currentStencilFunc = null;
        let currentStencilRef = null;
        let currentStencilFuncMask = null;
        let currentStencilFail = null;
        let currentStencilZFail = null;
        let currentStencilZPass = null;
        let currentStencilClear = null;
        return {
            setTest: function(stencilTest) {
                if (!locked) {
                    if (stencilTest) enable(2960);
                    else disable(2960);
                }
            },
            setMask: function(stencilMask) {
                if (currentStencilMask !== stencilMask && !locked) {
                    gl.stencilMask(stencilMask);
                    currentStencilMask = stencilMask;
                }
            },
            setFunc: function(stencilFunc, stencilRef, stencilMask) {
                if (currentStencilFunc !== stencilFunc || currentStencilRef !== stencilRef || currentStencilFuncMask !== stencilMask) {
                    gl.stencilFunc(stencilFunc, stencilRef, stencilMask);
                    currentStencilFunc = stencilFunc;
                    currentStencilRef = stencilRef;
                    currentStencilFuncMask = stencilMask;
                }
            },
            setOp: function(stencilFail, stencilZFail, stencilZPass) {
                if (currentStencilFail !== stencilFail || currentStencilZFail !== stencilZFail || currentStencilZPass !== stencilZPass) {
                    gl.stencilOp(stencilFail, stencilZFail, stencilZPass);
                    currentStencilFail = stencilFail;
                    currentStencilZFail = stencilZFail;
                    currentStencilZPass = stencilZPass;
                }
            },
            setLocked: function(lock) {
                locked = lock;
            },
            setClear: function(stencil) {
                if (currentStencilClear !== stencil) {
                    gl.clearStencil(stencil);
                    currentStencilClear = stencil;
                }
            },
            reset: function() {
                locked = false;
                currentStencilMask = null;
                currentStencilFunc = null;
                currentStencilRef = null;
                currentStencilFuncMask = null;
                currentStencilFail = null;
                currentStencilZFail = null;
                currentStencilZPass = null;
                currentStencilClear = null;
            }
        };
    }
    //
    const colorBuffer = new ColorBuffer();
    const depthBuffer = new DepthBuffer();
    const stencilBuffer = new StencilBuffer();
    let enabledCapabilities = {};
    let currentBoundFramebuffers = {};
    let currentDrawbuffers = new WeakMap();
    let defaultDrawbuffers = [];
    let currentProgram = null;
    let currentBlendingEnabled = false;
    let currentBlending = null;
    let currentBlendEquation = null;
    let currentBlendSrc = null;
    let currentBlendDst = null;
    let currentBlendEquationAlpha = null;
    let currentBlendSrcAlpha = null;
    let currentBlendDstAlpha = null;
    let currentPremultipledAlpha = false;
    let currentFlipSided = null;
    let currentCullFace = null;
    let currentLineWidth = null;
    let currentPolygonOffsetFactor = null;
    let currentPolygonOffsetUnits = null;
    const maxTextures = gl.getParameter(35661);
    let lineWidthAvailable = false;
    let version = 0;
    const glVersion = gl.getParameter(7938);
    if (glVersion.indexOf("WebGL") !== -1) {
        version = parseFloat(/^WebGL (\d)/.exec(glVersion)[1]);
        lineWidthAvailable = version >= 1.0;
    } else if (glVersion.indexOf("OpenGL ES") !== -1) {
        version = parseFloat(/^OpenGL ES (\d)/.exec(glVersion)[1]);
        lineWidthAvailable = version >= 2.0;
    }
    let currentTextureSlot = null;
    let currentBoundTextures = {};
    const scissorParam = gl.getParameter(3088);
    const viewportParam = gl.getParameter(2978);
    const currentScissor = new $084574008ccedf86$export$fa7daccca11cdbe3().fromArray(scissorParam);
    const currentViewport = new $084574008ccedf86$export$fa7daccca11cdbe3().fromArray(viewportParam);
    function createTexture(type, target, count) {
        const data = new Uint8Array(4); // 4 is required to match default unpack alignment of 4.
        const texture = gl.createTexture();
        gl.bindTexture(type, texture);
        gl.texParameteri(type, 10241, 9728);
        gl.texParameteri(type, 10240, 9728);
        for(let i131 = 0; i131 < count; i131++)gl.texImage2D(target + i131, 0, 6408, 1, 1, 0, 6408, 5121, data);
        return texture;
    }
    const emptyTextures = {};
    emptyTextures[3553] = createTexture(3553, 3553, 1);
    emptyTextures[34067] = createTexture(34067, 34069, 6);
    // init
    colorBuffer.setClear(0, 0, 0, 1);
    depthBuffer.setClear(1);
    stencilBuffer.setClear(0);
    enable(2929);
    depthBuffer.setFunc($084574008ccedf86$export$296f78a0b892f81a);
    setFlipSided(false);
    setCullFace($084574008ccedf86$export$b9a7b4fc5cb15f9b);
    enable(2884);
    setBlending($084574008ccedf86$export$63b8d6b580fc65ba);
    //
    function enable(id) {
        if (enabledCapabilities[id] !== true) {
            gl.enable(id);
            enabledCapabilities[id] = true;
        }
    }
    function disable(id) {
        if (enabledCapabilities[id] !== false) {
            gl.disable(id);
            enabledCapabilities[id] = false;
        }
    }
    function bindFramebuffer(target, framebuffer) {
        if (currentBoundFramebuffers[target] !== framebuffer) {
            gl.bindFramebuffer(target, framebuffer);
            currentBoundFramebuffers[target] = framebuffer;
            if (isWebGL2) {
                // 36009 is equivalent to 36160
                if (target === 36009) currentBoundFramebuffers[36160] = framebuffer;
                if (target === 36160) currentBoundFramebuffers[36009] = framebuffer;
            }
            return true;
        }
        return false;
    }
    function drawBuffers1(renderTarget, framebuffer) {
        let drawBuffers = defaultDrawbuffers;
        let needsUpdate = false;
        if (renderTarget) {
            drawBuffers = currentDrawbuffers.get(framebuffer);
            if (drawBuffers === undefined) {
                drawBuffers = [];
                currentDrawbuffers.set(framebuffer, drawBuffers);
            }
            if (renderTarget.isWebGLMultipleRenderTargets) {
                const textures = renderTarget.texture;
                if (drawBuffers.length !== textures.length || drawBuffers[0] !== 36064) {
                    for(let i132 = 0, il = textures.length; i132 < il; i132++)drawBuffers[i132] = 36064 + i132;
                    drawBuffers.length = textures.length;
                    needsUpdate = true;
                }
            } else if (drawBuffers[0] !== 36064) {
                drawBuffers[0] = 36064;
                needsUpdate = true;
            }
        } else if (drawBuffers[0] !== 1029) {
            drawBuffers[0] = 1029;
            needsUpdate = true;
        }
        if (needsUpdate) {
            if (capabilities.isWebGL2) gl.drawBuffers(drawBuffers);
            else extensions.get("WEBGL_draw_buffers").drawBuffersWEBGL(drawBuffers);
        }
    }
    function useProgram(program) {
        if (currentProgram !== program) {
            gl.useProgram(program);
            currentProgram = program;
            return true;
        }
        return false;
    }
    const equationToGL = {
        [$084574008ccedf86$export$20183a0484ce21a0]: 32774,
        [$084574008ccedf86$export$73e0df5177988548]: 32778,
        [$084574008ccedf86$export$28e582859cbec660]: 32779
    };
    if (isWebGL2) {
        equationToGL[$084574008ccedf86$export$c8c1508da8d0600c] = 32775;
        equationToGL[$084574008ccedf86$export$99948c02fb51055f] = 32776;
    } else {
        const extension = extensions.get("EXT_blend_minmax");
        if (extension !== null) {
            equationToGL[$084574008ccedf86$export$c8c1508da8d0600c] = extension.MIN_EXT;
            equationToGL[$084574008ccedf86$export$99948c02fb51055f] = extension.MAX_EXT;
        }
    }
    const factorToGL = {
        [$084574008ccedf86$export$2110f05edf778d3d]: 0,
        [$084574008ccedf86$export$8805bad65e24940e]: 1,
        [$084574008ccedf86$export$7fbe15b28d28cf52]: 768,
        [$084574008ccedf86$export$d5773124e86cf28c]: 770,
        [$084574008ccedf86$export$c05e2a1fc8609506]: 776,
        [$084574008ccedf86$export$ef5f2dd8ffac5574]: 774,
        [$084574008ccedf86$export$a78aed1ca2a87192]: 772,
        [$084574008ccedf86$export$947829af9f2c17f6]: 769,
        [$084574008ccedf86$export$11d468cc7f19e971]: 771,
        [$084574008ccedf86$export$56b85b2686ab16]: 775,
        [$084574008ccedf86$export$5d0fe17fd8773bac]: 773
    };
    function setBlending(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha) {
        if (blending === $084574008ccedf86$export$63b8d6b580fc65ba) {
            if (currentBlendingEnabled === true) {
                disable(3042);
                currentBlendingEnabled = false;
            }
            return;
        }
        if (currentBlendingEnabled === false) {
            enable(3042);
            currentBlendingEnabled = true;
        }
        if (blending !== $084574008ccedf86$export$eda4864c68df1fa2) {
            if (blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha) {
                if (currentBlendEquation !== $084574008ccedf86$export$20183a0484ce21a0 || currentBlendEquationAlpha !== $084574008ccedf86$export$20183a0484ce21a0) {
                    gl.blendEquation(32774);
                    currentBlendEquation = $084574008ccedf86$export$20183a0484ce21a0;
                    currentBlendEquationAlpha = $084574008ccedf86$export$20183a0484ce21a0;
                }
                if (premultipliedAlpha) switch(blending){
                    case $084574008ccedf86$export$5b29a26d96ee6af0:
                        gl.blendFuncSeparate(1, 771, 1, 771);
                        break;
                    case $084574008ccedf86$export$777d8f9551c2216b:
                        gl.blendFunc(1, 1);
                        break;
                    case $084574008ccedf86$export$cdfa06f868e2e467:
                        gl.blendFuncSeparate(0, 769, 0, 1);
                        break;
                    case $084574008ccedf86$export$4138e1c684b46a20:
                        gl.blendFuncSeparate(0, 768, 0, 770);
                        break;
                    default:
                        console.error("THREE.WebGLState: Invalid blending: ", blending);
                        break;
                }
                else switch(blending){
                    case $084574008ccedf86$export$5b29a26d96ee6af0:
                        gl.blendFuncSeparate(770, 771, 1, 771);
                        break;
                    case $084574008ccedf86$export$777d8f9551c2216b:
                        gl.blendFunc(770, 1);
                        break;
                    case $084574008ccedf86$export$cdfa06f868e2e467:
                        gl.blendFuncSeparate(0, 769, 0, 1);
                        break;
                    case $084574008ccedf86$export$4138e1c684b46a20:
                        gl.blendFunc(0, 768);
                        break;
                    default:
                        console.error("THREE.WebGLState: Invalid blending: ", blending);
                        break;
                }
                currentBlendSrc = null;
                currentBlendDst = null;
                currentBlendSrcAlpha = null;
                currentBlendDstAlpha = null;
                currentBlending = blending;
                currentPremultipledAlpha = premultipliedAlpha;
            }
            return;
        }
        // custom blending
        blendEquationAlpha = blendEquationAlpha || blendEquation;
        blendSrcAlpha = blendSrcAlpha || blendSrc;
        blendDstAlpha = blendDstAlpha || blendDst;
        if (blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha) {
            gl.blendEquationSeparate(equationToGL[blendEquation], equationToGL[blendEquationAlpha]);
            currentBlendEquation = blendEquation;
            currentBlendEquationAlpha = blendEquationAlpha;
        }
        if (blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha) {
            gl.blendFuncSeparate(factorToGL[blendSrc], factorToGL[blendDst], factorToGL[blendSrcAlpha], factorToGL[blendDstAlpha]);
            currentBlendSrc = blendSrc;
            currentBlendDst = blendDst;
            currentBlendSrcAlpha = blendSrcAlpha;
            currentBlendDstAlpha = blendDstAlpha;
        }
        currentBlending = blending;
        currentPremultipledAlpha = null;
    }
    function setMaterial(material, frontFaceCW) {
        material.side === $084574008ccedf86$export$3b296b6f144d5b03 ? disable(2884) : enable(2884);
        let flipSided = material.side === $084574008ccedf86$export$d9f0486e75b5ace;
        if (frontFaceCW) flipSided = !flipSided;
        setFlipSided(flipSided);
        material.blending === $084574008ccedf86$export$5b29a26d96ee6af0 && material.transparent === false ? setBlending($084574008ccedf86$export$63b8d6b580fc65ba) : setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha);
        depthBuffer.setFunc(material.depthFunc);
        depthBuffer.setTest(material.depthTest);
        depthBuffer.setMask(material.depthWrite);
        colorBuffer.setMask(material.colorWrite);
        const stencilWrite = material.stencilWrite;
        stencilBuffer.setTest(stencilWrite);
        if (stencilWrite) {
            stencilBuffer.setMask(material.stencilWriteMask);
            stencilBuffer.setFunc(material.stencilFunc, material.stencilRef, material.stencilFuncMask);
            stencilBuffer.setOp(material.stencilFail, material.stencilZFail, material.stencilZPass);
        }
        setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
        material.alphaToCoverage === true ? enable(32926) : disable(32926);
    }
    //
    function setFlipSided(flipSided) {
        if (currentFlipSided !== flipSided) {
            if (flipSided) gl.frontFace(2304);
            else gl.frontFace(2305);
            currentFlipSided = flipSided;
        }
    }
    function setCullFace(cullFace) {
        if (cullFace !== $084574008ccedf86$export$3237e1f2c1ea1f44) {
            enable(2884);
            if (cullFace !== currentCullFace) {
                if (cullFace === $084574008ccedf86$export$b9a7b4fc5cb15f9b) gl.cullFace(1029);
                else if (cullFace === $084574008ccedf86$export$b8058bcc7037d3f3) gl.cullFace(1028);
                else gl.cullFace(1032);
            }
        } else disable(2884);
        currentCullFace = cullFace;
    }
    function setLineWidth(width) {
        if (width !== currentLineWidth) {
            if (lineWidthAvailable) gl.lineWidth(width);
            currentLineWidth = width;
        }
    }
    function setPolygonOffset(polygonOffset, factor, units) {
        if (polygonOffset) {
            enable(32823);
            if (currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units) {
                gl.polygonOffset(factor, units);
                currentPolygonOffsetFactor = factor;
                currentPolygonOffsetUnits = units;
            }
        } else disable(32823);
    }
    function setScissorTest(scissorTest) {
        if (scissorTest) enable(3089);
        else disable(3089);
    }
    // texture
    function activeTexture(webglSlot) {
        if (webglSlot === undefined) webglSlot = 33984 + maxTextures - 1;
        if (currentTextureSlot !== webglSlot) {
            gl.activeTexture(webglSlot);
            currentTextureSlot = webglSlot;
        }
    }
    function bindTexture(webglType, webglTexture) {
        if (currentTextureSlot === null) activeTexture();
        let boundTexture = currentBoundTextures[currentTextureSlot];
        if (boundTexture === undefined) {
            boundTexture = {
                type: undefined,
                texture: undefined
            };
            currentBoundTextures[currentTextureSlot] = boundTexture;
        }
        if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {
            gl.bindTexture(webglType, webglTexture || emptyTextures[webglType]);
            boundTexture.type = webglType;
            boundTexture.texture = webglTexture;
        }
    }
    function unbindTexture() {
        const boundTexture = currentBoundTextures[currentTextureSlot];
        if (boundTexture !== undefined && boundTexture.type !== undefined) {
            gl.bindTexture(boundTexture.type, null);
            boundTexture.type = undefined;
            boundTexture.texture = undefined;
        }
    }
    function compressedTexImage2D() {
        try {
            gl.compressedTexImage2D.apply(gl, arguments);
        } catch (error) {
            console.error("THREE.WebGLState:", error);
        }
    }
    function texSubImage2D() {
        try {
            gl.texSubImage2D.apply(gl, arguments);
        } catch (error) {
            console.error("THREE.WebGLState:", error);
        }
    }
    function texSubImage3D() {
        try {
            gl.texSubImage3D.apply(gl, arguments);
        } catch (error) {
            console.error("THREE.WebGLState:", error);
        }
    }
    function compressedTexSubImage2D() {
        try {
            gl.compressedTexSubImage2D.apply(gl, arguments);
        } catch (error) {
            console.error("THREE.WebGLState:", error);
        }
    }
    function texStorage2D() {
        try {
            gl.texStorage2D.apply(gl, arguments);
        } catch (error) {
            console.error("THREE.WebGLState:", error);
        }
    }
    function texStorage3D() {
        try {
            gl.texStorage3D.apply(gl, arguments);
        } catch (error) {
            console.error("THREE.WebGLState:", error);
        }
    }
    function texImage2D() {
        try {
            gl.texImage2D.apply(gl, arguments);
        } catch (error) {
            console.error("THREE.WebGLState:", error);
        }
    }
    function texImage3D() {
        try {
            gl.texImage3D.apply(gl, arguments);
        } catch (error) {
            console.error("THREE.WebGLState:", error);
        }
    }
    //
    function scissor1(scissor) {
        if (currentScissor.equals(scissor) === false) {
            gl.scissor(scissor.x, scissor.y, scissor.z, scissor.w);
            currentScissor.copy(scissor);
        }
    }
    function viewport1(viewport) {
        if (currentViewport.equals(viewport) === false) {
            gl.viewport(viewport.x, viewport.y, viewport.z, viewport.w);
            currentViewport.copy(viewport);
        }
    }
    //
    function reset() {
        // reset state
        gl.disable(3042);
        gl.disable(2884);
        gl.disable(2929);
        gl.disable(32823);
        gl.disable(3089);
        gl.disable(2960);
        gl.disable(32926);
        gl.blendEquation(32774);
        gl.blendFunc(1, 0);
        gl.blendFuncSeparate(1, 0, 1, 0);
        gl.colorMask(true, true, true, true);
        gl.clearColor(0, 0, 0, 0);
        gl.depthMask(true);
        gl.depthFunc(513);
        gl.clearDepth(1);
        gl.stencilMask(0xffffffff);
        gl.stencilFunc(519, 0, 0xffffffff);
        gl.stencilOp(7680, 7680, 7680);
        gl.clearStencil(0);
        gl.cullFace(1029);
        gl.frontFace(2305);
        gl.polygonOffset(0, 0);
        gl.activeTexture(33984);
        gl.bindFramebuffer(36160, null);
        if (isWebGL2 === true) {
            gl.bindFramebuffer(36009, null);
            gl.bindFramebuffer(36008, null);
        }
        gl.useProgram(null);
        gl.lineWidth(1);
        gl.scissor(0, 0, gl.canvas.width, gl.canvas.height);
        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
        // reset internals
        enabledCapabilities = {};
        currentTextureSlot = null;
        currentBoundTextures = {};
        currentBoundFramebuffers = {};
        currentDrawbuffers = new WeakMap();
        defaultDrawbuffers = [];
        currentProgram = null;
        currentBlendingEnabled = false;
        currentBlending = null;
        currentBlendEquation = null;
        currentBlendSrc = null;
        currentBlendDst = null;
        currentBlendEquationAlpha = null;
        currentBlendSrcAlpha = null;
        currentBlendDstAlpha = null;
        currentPremultipledAlpha = false;
        currentFlipSided = null;
        currentCullFace = null;
        currentLineWidth = null;
        currentPolygonOffsetFactor = null;
        currentPolygonOffsetUnits = null;
        currentScissor.set(0, 0, gl.canvas.width, gl.canvas.height);
        currentViewport.set(0, 0, gl.canvas.width, gl.canvas.height);
        colorBuffer.reset();
        depthBuffer.reset();
        stencilBuffer.reset();
    }
    return {
        buffers: {
            color: colorBuffer,
            depth: depthBuffer,
            stencil: stencilBuffer
        },
        enable: enable,
        disable: disable,
        bindFramebuffer: bindFramebuffer,
        drawBuffers: drawBuffers1,
        useProgram: useProgram,
        setBlending: setBlending,
        setMaterial: setMaterial,
        setFlipSided: setFlipSided,
        setCullFace: setCullFace,
        setLineWidth: setLineWidth,
        setPolygonOffset: setPolygonOffset,
        setScissorTest: setScissorTest,
        activeTexture: activeTexture,
        bindTexture: bindTexture,
        unbindTexture: unbindTexture,
        compressedTexImage2D: compressedTexImage2D,
        texImage2D: texImage2D,
        texImage3D: texImage3D,
        texStorage2D: texStorage2D,
        texStorage3D: texStorage3D,
        texSubImage2D: texSubImage2D,
        texSubImage3D: texSubImage3D,
        compressedTexSubImage2D: compressedTexSubImage2D,
        scissor: scissor1,
        viewport: viewport1,
        reset: reset
    };
}
function $084574008ccedf86$var$WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info) {
    const isWebGL2 = capabilities.isWebGL2;
    const maxTextures = capabilities.maxTextures;
    const maxCubemapSize = capabilities.maxCubemapSize;
    const maxTextureSize = capabilities.maxTextureSize;
    const maxSamples = capabilities.maxSamples;
    const multisampledRTTExt = extensions.has("WEBGL_multisampled_render_to_texture") ? extensions.get("WEBGL_multisampled_render_to_texture") : null;
    const supportsInvalidateFramebuffer = /OculusBrowser/g.test(navigator.userAgent);
    const _videoTextures = new WeakMap();
    let _canvas1;
    const _sources = new WeakMap(); // maps WebglTexture objects to instances of Source
    // cordova iOS (as of 5.0) still uses UIWebView, which provides OffscreenCanvas,
    // also OffscreenCanvas.getContext("webgl"), but not OffscreenCanvas.getContext("2d")!
    // Some implementations may only implement OffscreenCanvas partially (e.g. lacking 2d).
    let useOffscreenCanvas = false;
    try {
        useOffscreenCanvas = typeof OffscreenCanvas !== "undefined" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
    } catch (err) {
    // Ignore any errors
    }
    function createCanvas(width, height) {
        // Use OffscreenCanvas when available. Specially needed in web workers
        return useOffscreenCanvas ? // eslint-disable-next-line compat/compat
        new OffscreenCanvas(width, height) : $084574008ccedf86$var$createElementNS("canvas");
    }
    function resizeImage(image, needsPowerOfTwo, needsNewCanvas, maxSize) {
        let scale = 1;
        // handle case if texture exceeds max size
        if (image.width > maxSize || image.height > maxSize) scale = maxSize / Math.max(image.width, image.height);
        // only perform resize if necessary
        if (scale < 1 || needsPowerOfTwo === true) {
            // only perform resize for certain image types
            if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
                const floor = needsPowerOfTwo ? $084574008ccedf86$var$floorPowerOfTwo : Math.floor;
                const width = floor(scale * image.width);
                const height = floor(scale * image.height);
                if (_canvas1 === undefined) _canvas1 = createCanvas(width, height);
                // cube textures can't reuse the same canvas
                const canvas = needsNewCanvas ? createCanvas(width, height) : _canvas1;
                canvas.width = width;
                canvas.height = height;
                const context = canvas.getContext("2d");
                context.drawImage(image, 0, 0, width, height);
                console.warn("THREE.WebGLRenderer: Texture has been resized from (" + image.width + "x" + image.height + ") to (" + width + "x" + height + ").");
                return canvas;
            } else {
                if ("data" in image) console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + image.width + "x" + image.height + ").");
                return image;
            }
        }
        return image;
    }
    function isPowerOfTwo$1(image) {
        return $084574008ccedf86$var$isPowerOfTwo(image.width) && $084574008ccedf86$var$isPowerOfTwo(image.height);
    }
    function textureNeedsPowerOfTwo(texture) {
        if (isWebGL2) return false;
        return texture.wrapS !== $084574008ccedf86$export$9d9334239a5a5e06 || texture.wrapT !== $084574008ccedf86$export$9d9334239a5a5e06 || texture.minFilter !== $084574008ccedf86$export$727aa5ec3fe39bf0 && texture.minFilter !== $084574008ccedf86$export$8a72f490b25c56c8;
    }
    function textureNeedsGenerateMipmaps(texture, supportsMips) {
        return texture.generateMipmaps && supportsMips && texture.minFilter !== $084574008ccedf86$export$727aa5ec3fe39bf0 && texture.minFilter !== $084574008ccedf86$export$8a72f490b25c56c8;
    }
    function generateMipmap(target) {
        _gl.generateMipmap(target);
    }
    function getInternalFormat(internalFormatName, glFormat, glType, encoding, isVideoTexture = false) {
        if (isWebGL2 === false) return glFormat;
        if (internalFormatName !== null) {
            if (_gl[internalFormatName] !== undefined) return _gl[internalFormatName];
            console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + internalFormatName + "'");
        }
        let internalFormat = glFormat;
        if (glFormat === 6403) {
            if (glType === 5126) internalFormat = 33326;
            if (glType === 5131) internalFormat = 33325;
            if (glType === 5121) internalFormat = 33321;
        }
        if (glFormat === 33319) {
            if (glType === 5126) internalFormat = 33328;
            if (glType === 5131) internalFormat = 33327;
            if (glType === 5121) internalFormat = 33323;
        }
        if (glFormat === 6408) {
            if (glType === 5126) internalFormat = 34836;
            if (glType === 5131) internalFormat = 34842;
            if (glType === 5121) internalFormat = encoding === $084574008ccedf86$export$f32388edbb32674 && isVideoTexture === false ? 35907 : 32856;
            if (glType === 32819) internalFormat = 32854;
            if (glType === 32820) internalFormat = 32855;
        }
        if (internalFormat === 33325 || internalFormat === 33326 || internalFormat === 33327 || internalFormat === 33328 || internalFormat === 34842 || internalFormat === 34836) extensions.get("EXT_color_buffer_float");
        return internalFormat;
    }
    function getMipLevels(texture, image, supportsMips) {
        if (textureNeedsGenerateMipmaps(texture, supportsMips) === true || texture.isFramebufferTexture && texture.minFilter !== $084574008ccedf86$export$727aa5ec3fe39bf0 && texture.minFilter !== $084574008ccedf86$export$8a72f490b25c56c8) return Math.log2(Math.max(image.width, image.height)) + 1;
        else if (texture.mipmaps !== undefined && texture.mipmaps.length > 0) // user-defined mipmaps
        return texture.mipmaps.length;
        else if (texture.isCompressedTexture && Array.isArray(texture.image)) return image.mipmaps.length;
        else // texture without mipmaps (only base level)
        return 1;
    }
    // Fallback filters for non-power-of-2 textures
    function filterFallback(f) {
        if (f === $084574008ccedf86$export$727aa5ec3fe39bf0 || f === $084574008ccedf86$export$d129e38cf6feaa8c || f === $084574008ccedf86$export$d2327c1afe5bfdf2) return 9728;
        return 9729;
    }
    //
    function onTextureDispose(event) {
        const texture = event.target;
        texture.removeEventListener("dispose", onTextureDispose);
        deallocateTexture(texture);
        if (texture.isVideoTexture) _videoTextures.delete(texture);
    }
    function onRenderTargetDispose(event) {
        const renderTarget = event.target;
        renderTarget.removeEventListener("dispose", onRenderTargetDispose);
        deallocateRenderTarget(renderTarget);
    }
    //
    function deallocateTexture(texture) {
        const textureProperties = properties.get(texture);
        if (textureProperties.__webglInit === undefined) return;
        // check if it's necessary to remove the WebGLTexture object
        const source = texture.source;
        const webglTextures = _sources.get(source);
        if (webglTextures) {
            const webglTexture = webglTextures[textureProperties.__cacheKey];
            webglTexture.usedTimes--;
            // the WebGLTexture object is not used anymore, remove it
            if (webglTexture.usedTimes === 0) deleteTexture(texture);
            // remove the weak map entry if no WebGLTexture uses the source anymore
            if (Object.keys(webglTextures).length === 0) _sources.delete(source);
        }
        properties.remove(texture);
    }
    function deleteTexture(texture) {
        const textureProperties = properties.get(texture);
        _gl.deleteTexture(textureProperties.__webglTexture);
        const source = texture.source;
        const webglTextures = _sources.get(source);
        delete webglTextures[textureProperties.__cacheKey];
        info.memory.textures--;
    }
    function deallocateRenderTarget(renderTarget) {
        const texture = renderTarget.texture;
        const renderTargetProperties = properties.get(renderTarget);
        const textureProperties = properties.get(texture);
        if (textureProperties.__webglTexture !== undefined) {
            _gl.deleteTexture(textureProperties.__webglTexture);
            info.memory.textures--;
        }
        if (renderTarget.depthTexture) renderTarget.depthTexture.dispose();
        if (renderTarget.isWebGLCubeRenderTarget) for(let i134 = 0; i134 < 6; i134++){
            _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i134]);
            if (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i134]);
        }
        else {
            _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);
            if (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);
            if (renderTargetProperties.__webglMultisampledFramebuffer) _gl.deleteFramebuffer(renderTargetProperties.__webglMultisampledFramebuffer);
            if (renderTargetProperties.__webglColorRenderbuffer) {
                for(let i135 = 0; i135 < renderTargetProperties.__webglColorRenderbuffer.length; i135++)if (renderTargetProperties.__webglColorRenderbuffer[i135]) _gl.deleteRenderbuffer(renderTargetProperties.__webglColorRenderbuffer[i135]);
            }
            if (renderTargetProperties.__webglDepthRenderbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthRenderbuffer);
        }
        if (renderTarget.isWebGLMultipleRenderTargets) for(let i133 = 0, il = texture.length; i133 < il; i133++){
            const attachmentProperties = properties.get(texture[i133]);
            if (attachmentProperties.__webglTexture) {
                _gl.deleteTexture(attachmentProperties.__webglTexture);
                info.memory.textures--;
            }
            properties.remove(texture[i133]);
        }
        properties.remove(texture);
        properties.remove(renderTarget);
    }
    //
    let textureUnits = 0;
    function resetTextureUnits() {
        textureUnits = 0;
    }
    function allocateTextureUnit() {
        const textureUnit = textureUnits;
        if (textureUnit >= maxTextures) console.warn("THREE.WebGLTextures: Trying to use " + textureUnit + " texture units while this GPU supports only " + maxTextures);
        textureUnits += 1;
        return textureUnit;
    }
    function getTextureCacheKey(texture) {
        const array = [];
        array.push(texture.wrapS);
        array.push(texture.wrapT);
        array.push(texture.magFilter);
        array.push(texture.minFilter);
        array.push(texture.anisotropy);
        array.push(texture.internalFormat);
        array.push(texture.format);
        array.push(texture.type);
        array.push(texture.generateMipmaps);
        array.push(texture.premultiplyAlpha);
        array.push(texture.flipY);
        array.push(texture.unpackAlignment);
        array.push(texture.encoding);
        return array.join();
    }
    //
    function setTexture2D(texture, slot) {
        const textureProperties = properties.get(texture);
        if (texture.isVideoTexture) updateVideoTexture(texture);
        if (texture.isRenderTargetTexture === false && texture.version > 0 && textureProperties.__version !== texture.version) {
            const image = texture.image;
            if (image === null) console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
            else if (image.complete === false) console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
            else {
                uploadTexture(textureProperties, texture, slot);
                return;
            }
        }
        state.activeTexture(33984 + slot);
        state.bindTexture(3553, textureProperties.__webglTexture);
    }
    function setTexture2DArray(texture, slot) {
        const textureProperties = properties.get(texture);
        if (texture.version > 0 && textureProperties.__version !== texture.version) {
            uploadTexture(textureProperties, texture, slot);
            return;
        }
        state.activeTexture(33984 + slot);
        state.bindTexture(35866, textureProperties.__webglTexture);
    }
    function setTexture3D(texture, slot) {
        const textureProperties = properties.get(texture);
        if (texture.version > 0 && textureProperties.__version !== texture.version) {
            uploadTexture(textureProperties, texture, slot);
            return;
        }
        state.activeTexture(33984 + slot);
        state.bindTexture(32879, textureProperties.__webglTexture);
    }
    function setTextureCube(texture, slot) {
        const textureProperties = properties.get(texture);
        if (texture.version > 0 && textureProperties.__version !== texture.version) {
            uploadCubeTexture(textureProperties, texture, slot);
            return;
        }
        state.activeTexture(33984 + slot);
        state.bindTexture(34067, textureProperties.__webglTexture);
    }
    const wrappingToGL = {
        [$084574008ccedf86$export$533346c8e8dac0f5]: 10497,
        [$084574008ccedf86$export$9d9334239a5a5e06]: 33071,
        [$084574008ccedf86$export$c7e7c00b14f51a4f]: 33648
    };
    const filterToGL = {
        [$084574008ccedf86$export$727aa5ec3fe39bf0]: 9728,
        [$084574008ccedf86$export$d129e38cf6feaa8c]: 9984,
        [$084574008ccedf86$export$d2327c1afe5bfdf2]: 9986,
        [$084574008ccedf86$export$8a72f490b25c56c8]: 9729,
        [$084574008ccedf86$export$19a719f377145a13]: 9985,
        [$084574008ccedf86$export$5d8599b6a933fb1b]: 9987
    };
    function setTextureParameters(textureType, texture, supportsMips) {
        if (supportsMips) {
            _gl.texParameteri(textureType, 10242, wrappingToGL[texture.wrapS]);
            _gl.texParameteri(textureType, 10243, wrappingToGL[texture.wrapT]);
            if (textureType === 32879 || textureType === 35866) _gl.texParameteri(textureType, 32882, wrappingToGL[texture.wrapR]);
            _gl.texParameteri(textureType, 10240, filterToGL[texture.magFilter]);
            _gl.texParameteri(textureType, 10241, filterToGL[texture.minFilter]);
        } else {
            _gl.texParameteri(textureType, 10242, 33071);
            _gl.texParameteri(textureType, 10243, 33071);
            if (textureType === 32879 || textureType === 35866) _gl.texParameteri(textureType, 32882, 33071);
            if (texture.wrapS !== $084574008ccedf86$export$9d9334239a5a5e06 || texture.wrapT !== $084574008ccedf86$export$9d9334239a5a5e06) console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.");
            _gl.texParameteri(textureType, 10240, filterFallback(texture.magFilter));
            _gl.texParameteri(textureType, 10241, filterFallback(texture.minFilter));
            if (texture.minFilter !== $084574008ccedf86$export$727aa5ec3fe39bf0 && texture.minFilter !== $084574008ccedf86$export$8a72f490b25c56c8) console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.");
        }
        if (extensions.has("EXT_texture_filter_anisotropic") === true) {
            const extension = extensions.get("EXT_texture_filter_anisotropic");
            if (texture.type === $084574008ccedf86$export$f6d331659b644596 && extensions.has("OES_texture_float_linear") === false) return; // verify extension for WebGL 1 and WebGL 2
            if (isWebGL2 === false && texture.type === $084574008ccedf86$export$2697304443f382bc && extensions.has("OES_texture_half_float_linear") === false) return; // verify extension for WebGL 1 only
            if (texture.anisotropy > 1 || properties.get(texture).__currentAnisotropy) {
                _gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, capabilities.getMaxAnisotropy()));
                properties.get(texture).__currentAnisotropy = texture.anisotropy;
            }
        }
    }
    function initTexture(textureProperties, texture) {
        let forceUpload = false;
        if (textureProperties.__webglInit === undefined) {
            textureProperties.__webglInit = true;
            texture.addEventListener("dispose", onTextureDispose);
        }
        // create Source <-> WebGLTextures mapping if necessary
        const source = texture.source;
        let webglTextures = _sources.get(source);
        if (webglTextures === undefined) {
            webglTextures = {};
            _sources.set(source, webglTextures);
        }
        // check if there is already a WebGLTexture object for the given texture parameters
        const textureCacheKey = getTextureCacheKey(texture);
        if (textureCacheKey !== textureProperties.__cacheKey) {
            // if not, create a new instance of WebGLTexture
            if (webglTextures[textureCacheKey] === undefined) {
                // create new entry
                webglTextures[textureCacheKey] = {
                    texture: _gl.createTexture(),
                    usedTimes: 0
                };
                info.memory.textures++;
                // when a new instance of WebGLTexture was created, a texture upload is required
                // even if the image contents are identical
                forceUpload = true;
            }
            webglTextures[textureCacheKey].usedTimes++;
            // every time the texture cache key changes, it's necessary to check if an instance of
            // WebGLTexture can be deleted in order to avoid a memory leak.
            const webglTexture = webglTextures[textureProperties.__cacheKey];
            if (webglTexture !== undefined) {
                webglTextures[textureProperties.__cacheKey].usedTimes--;
                if (webglTexture.usedTimes === 0) deleteTexture(texture);
            }
            // store references to cache key and WebGLTexture object
            textureProperties.__cacheKey = textureCacheKey;
            textureProperties.__webglTexture = webglTextures[textureCacheKey].texture;
        }
        return forceUpload;
    }
    function uploadTexture(textureProperties, texture, slot) {
        let textureType = 3553;
        if (texture.isDataArrayTexture) textureType = 35866;
        if (texture.isData3DTexture) textureType = 32879;
        const forceUpload = initTexture(textureProperties, texture);
        const source = texture.source;
        state.activeTexture(33984 + slot);
        state.bindTexture(textureType, textureProperties.__webglTexture);
        if (source.version !== source.__currentVersion || forceUpload === true) {
            _gl.pixelStorei(37440, texture.flipY);
            _gl.pixelStorei(37441, texture.premultiplyAlpha);
            _gl.pixelStorei(3317, texture.unpackAlignment);
            _gl.pixelStorei(37443, 0);
            const needsPowerOfTwo = textureNeedsPowerOfTwo(texture) && isPowerOfTwo$1(texture.image) === false;
            let image = resizeImage(texture.image, needsPowerOfTwo, false, maxTextureSize);
            image = verifyColorSpace(texture, image);
            const supportsMips = isPowerOfTwo$1(image) || isWebGL2, glFormat = utils.convert(texture.format, texture.encoding);
            let glType = utils.convert(texture.type), glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding, texture.isVideoTexture);
            setTextureParameters(textureType, texture, supportsMips);
            let mipmap;
            const mipmaps = texture.mipmaps;
            const useTexStorage = isWebGL2 && texture.isVideoTexture !== true;
            const allocateMemory = source.__currentVersion === undefined || forceUpload === true;
            const levels = getMipLevels(texture, image, supportsMips);
            if (texture.isDepthTexture) {
                // populate depth texture with dummy data
                glInternalFormat = 6402;
                if (isWebGL2) {
                    if (texture.type === $084574008ccedf86$export$f6d331659b644596) glInternalFormat = 36012;
                    else if (texture.type === $084574008ccedf86$export$c3c7fc4518ebba96) glInternalFormat = 33190;
                    else if (texture.type === $084574008ccedf86$export$6c8ea339bfab1301) glInternalFormat = 35056;
                    else glInternalFormat = 33189; // WebGL2 requires sized internalformat for glTexImage2D
                } else if (texture.type === $084574008ccedf86$export$f6d331659b644596) console.error("WebGLRenderer: Floating point depth texture requires WebGL2.");
                // validation checks for WebGL 1
                if (texture.format === $084574008ccedf86$export$c1b6b5136be58045 && glInternalFormat === 6402) // The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
                // DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT
                // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
                {
                    if (texture.type !== $084574008ccedf86$export$c63dc51868b06a9d && texture.type !== $084574008ccedf86$export$c3c7fc4518ebba96) {
                        console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.");
                        texture.type = $084574008ccedf86$export$c3c7fc4518ebba96;
                        glType = utils.convert(texture.type);
                    }
                }
                if (texture.format === $084574008ccedf86$export$1e113ac2d0905829 && glInternalFormat === 6402) {
                    // Depth stencil textures need the DEPTH_STENCIL internal format
                    // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
                    glInternalFormat = 34041;
                    // The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
                    // DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL.
                    // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
                    if (texture.type !== $084574008ccedf86$export$6c8ea339bfab1301) {
                        console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.");
                        texture.type = $084574008ccedf86$export$6c8ea339bfab1301;
                        glType = utils.convert(texture.type);
                    }
                }
                //
                if (allocateMemory) {
                    if (useTexStorage) state.texStorage2D(3553, 1, glInternalFormat, image.width, image.height);
                    else state.texImage2D(3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null);
                }
            } else if (texture.isDataTexture) {
                // use manually created mipmaps if available
                // if there are no manual mipmaps
                // set 0 level mipmap and then use GL to generate other mipmap levels
                if (mipmaps.length > 0 && supportsMips) {
                    if (useTexStorage && allocateMemory) state.texStorage2D(3553, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height);
                    for(let i136 = 0, il = mipmaps.length; i136 < il; i136++){
                        mipmap = mipmaps[i136];
                        if (useTexStorage) state.texSubImage2D(3553, i136, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data);
                        else state.texImage2D(3553, i136, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
                    }
                    texture.generateMipmaps = false;
                } else if (useTexStorage) {
                    if (allocateMemory) state.texStorage2D(3553, levels, glInternalFormat, image.width, image.height);
                    state.texSubImage2D(3553, 0, 0, 0, image.width, image.height, glFormat, glType, image.data);
                } else state.texImage2D(3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data);
            } else if (texture.isCompressedTexture) {
                if (useTexStorage && allocateMemory) state.texStorage2D(3553, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height);
                for(let i137 = 0, il = mipmaps.length; i137 < il; i137++){
                    mipmap = mipmaps[i137];
                    if (texture.format !== $084574008ccedf86$export$3f8bb04b555a363c) {
                        if (glFormat !== null) {
                            if (useTexStorage) state.compressedTexSubImage2D(3553, i137, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data);
                            else state.compressedTexImage2D(3553, i137, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
                        } else console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
                    } else if (useTexStorage) state.texSubImage2D(3553, i137, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data);
                    else state.texImage2D(3553, i137, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
                }
            } else if (texture.isDataArrayTexture) {
                if (useTexStorage) {
                    if (allocateMemory) state.texStorage3D(35866, levels, glInternalFormat, image.width, image.height, image.depth);
                    state.texSubImage3D(35866, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data);
                } else state.texImage3D(35866, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
            } else if (texture.isData3DTexture) {
                if (useTexStorage) {
                    if (allocateMemory) state.texStorage3D(32879, levels, glInternalFormat, image.width, image.height, image.depth);
                    state.texSubImage3D(32879, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data);
                } else state.texImage3D(32879, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
            } else if (texture.isFramebufferTexture) {
                if (allocateMemory) {
                    if (useTexStorage) state.texStorage2D(3553, levels, glInternalFormat, image.width, image.height);
                    else {
                        let width = image.width, height = image.height;
                        for(let i138 = 0; i138 < levels; i138++){
                            state.texImage2D(3553, i138, glInternalFormat, width, height, 0, glFormat, glType, null);
                            width >>= 1;
                            height >>= 1;
                        }
                    }
                }
            } else {
                // regular Texture (image, video, canvas)
                // use manually created mipmaps if available
                // if there are no manual mipmaps
                // set 0 level mipmap and then use GL to generate other mipmap levels
                if (mipmaps.length > 0 && supportsMips) {
                    if (useTexStorage && allocateMemory) state.texStorage2D(3553, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height);
                    for(let i139 = 0, il = mipmaps.length; i139 < il; i139++){
                        mipmap = mipmaps[i139];
                        if (useTexStorage) state.texSubImage2D(3553, i139, 0, 0, glFormat, glType, mipmap);
                        else state.texImage2D(3553, i139, glInternalFormat, glFormat, glType, mipmap);
                    }
                    texture.generateMipmaps = false;
                } else if (useTexStorage) {
                    if (allocateMemory) state.texStorage2D(3553, levels, glInternalFormat, image.width, image.height);
                    state.texSubImage2D(3553, 0, 0, 0, glFormat, glType, image);
                } else state.texImage2D(3553, 0, glInternalFormat, glFormat, glType, image);
            }
            if (textureNeedsGenerateMipmaps(texture, supportsMips)) generateMipmap(textureType);
            source.__currentVersion = source.version;
            if (texture.onUpdate) texture.onUpdate(texture);
        }
        textureProperties.__version = texture.version;
    }
    function uploadCubeTexture(textureProperties, texture, slot) {
        if (texture.image.length !== 6) return;
        const forceUpload = initTexture(textureProperties, texture);
        const source = texture.source;
        state.activeTexture(33984 + slot);
        state.bindTexture(34067, textureProperties.__webglTexture);
        if (source.version !== source.__currentVersion || forceUpload === true) {
            _gl.pixelStorei(37440, texture.flipY);
            _gl.pixelStorei(37441, texture.premultiplyAlpha);
            _gl.pixelStorei(3317, texture.unpackAlignment);
            _gl.pixelStorei(37443, 0);
            const isCompressed = texture.isCompressedTexture || texture.image[0].isCompressedTexture;
            const isDataTexture = texture.image[0] && texture.image[0].isDataTexture;
            const cubeImage = [];
            for(let i140 = 0; i140 < 6; i140++){
                if (!isCompressed && !isDataTexture) cubeImage[i140] = resizeImage(texture.image[i140], false, true, maxCubemapSize);
                else cubeImage[i140] = isDataTexture ? texture.image[i140].image : texture.image[i140];
                cubeImage[i140] = verifyColorSpace(texture, cubeImage[i140]);
            }
            const image = cubeImage[0], supportsMips = isPowerOfTwo$1(image) || isWebGL2, glFormat = utils.convert(texture.format, texture.encoding), glType = utils.convert(texture.type), glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding);
            const useTexStorage = isWebGL2 && texture.isVideoTexture !== true;
            const allocateMemory = source.__currentVersion === undefined || forceUpload === true;
            let levels = getMipLevels(texture, image, supportsMips);
            setTextureParameters(34067, texture, supportsMips);
            let mipmaps;
            if (isCompressed) {
                if (useTexStorage && allocateMemory) state.texStorage2D(34067, levels, glInternalFormat, image.width, image.height);
                for(let i141 = 0; i141 < 6; i141++){
                    mipmaps = cubeImage[i141].mipmaps;
                    for(let j = 0; j < mipmaps.length; j++){
                        const mipmap = mipmaps[j];
                        if (texture.format !== $084574008ccedf86$export$3f8bb04b555a363c) {
                            if (glFormat !== null) {
                                if (useTexStorage) state.compressedTexSubImage2D(34069 + i141, j, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data);
                                else state.compressedTexImage2D(34069 + i141, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
                            } else console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()");
                        } else if (useTexStorage) state.texSubImage2D(34069 + i141, j, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data);
                        else state.texImage2D(34069 + i141, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
                    }
                }
            } else {
                mipmaps = texture.mipmaps;
                if (useTexStorage && allocateMemory) {
                    // TODO: Uniformly handle mipmap definitions
                    // Normal textures and compressed cube textures define base level + mips with their mipmap array
                    // Uncompressed cube textures use their mipmap array only for mips (no base level)
                    if (mipmaps.length > 0) levels++;
                    state.texStorage2D(34067, levels, glInternalFormat, cubeImage[0].width, cubeImage[0].height);
                }
                for(let i142 = 0; i142 < 6; i142++)if (isDataTexture) {
                    if (useTexStorage) state.texSubImage2D(34069 + i142, 0, 0, 0, cubeImage[i142].width, cubeImage[i142].height, glFormat, glType, cubeImage[i142].data);
                    else state.texImage2D(34069 + i142, 0, glInternalFormat, cubeImage[i142].width, cubeImage[i142].height, 0, glFormat, glType, cubeImage[i142].data);
                    for(let j = 0; j < mipmaps.length; j++){
                        const mipmap = mipmaps[j];
                        const mipmapImage = mipmap.image[i142].image;
                        if (useTexStorage) state.texSubImage2D(34069 + i142, j + 1, 0, 0, mipmapImage.width, mipmapImage.height, glFormat, glType, mipmapImage.data);
                        else state.texImage2D(34069 + i142, j + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data);
                    }
                } else {
                    if (useTexStorage) state.texSubImage2D(34069 + i142, 0, 0, 0, glFormat, glType, cubeImage[i142]);
                    else state.texImage2D(34069 + i142, 0, glInternalFormat, glFormat, glType, cubeImage[i142]);
                    for(let j = 0; j < mipmaps.length; j++){
                        const mipmap = mipmaps[j];
                        if (useTexStorage) state.texSubImage2D(34069 + i142, j + 1, 0, 0, glFormat, glType, mipmap.image[i142]);
                        else state.texImage2D(34069 + i142, j + 1, glInternalFormat, glFormat, glType, mipmap.image[i142]);
                    }
                }
            }
            if (textureNeedsGenerateMipmaps(texture, supportsMips)) // We assume images for cube map have the same size.
            generateMipmap(34067);
            source.__currentVersion = source.version;
            if (texture.onUpdate) texture.onUpdate(texture);
        }
        textureProperties.__version = texture.version;
    }
    // Render targets
    // Setup storage for target texture and bind it to correct framebuffer
    function setupFrameBufferTexture(framebuffer, renderTarget, texture, attachment, textureTarget) {
        const glFormat = utils.convert(texture.format, texture.encoding);
        const glType = utils.convert(texture.type);
        const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding);
        const renderTargetProperties = properties.get(renderTarget);
        if (!renderTargetProperties.__hasExternalTextures) {
            if (textureTarget === 32879 || textureTarget === 35866) state.texImage3D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, renderTarget.depth, 0, glFormat, glType, null);
            else state.texImage2D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null);
        }
        state.bindFramebuffer(36160, framebuffer);
        if (useMultisampledRTT(renderTarget)) multisampledRTTExt.framebufferTexture2DMultisampleEXT(36160, attachment, textureTarget, properties.get(texture).__webglTexture, 0, getRenderTargetSamples(renderTarget));
        else _gl.framebufferTexture2D(36160, attachment, textureTarget, properties.get(texture).__webglTexture, 0);
        state.bindFramebuffer(36160, null);
    }
    // Setup storage for internal depth/stencil buffers and bind to correct framebuffer
    function setupRenderBufferStorage(renderbuffer, renderTarget, isMultisample) {
        _gl.bindRenderbuffer(36161, renderbuffer);
        if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {
            let glInternalFormat = 33189;
            if (isMultisample || useMultisampledRTT(renderTarget)) {
                const depthTexture = renderTarget.depthTexture;
                if (depthTexture && depthTexture.isDepthTexture) {
                    if (depthTexture.type === $084574008ccedf86$export$f6d331659b644596) glInternalFormat = 36012;
                    else if (depthTexture.type === $084574008ccedf86$export$c3c7fc4518ebba96) glInternalFormat = 33190;
                }
                const samples = getRenderTargetSamples(renderTarget);
                if (useMultisampledRTT(renderTarget)) multisampledRTTExt.renderbufferStorageMultisampleEXT(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
                else _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
            } else _gl.renderbufferStorage(36161, glInternalFormat, renderTarget.width, renderTarget.height);
            _gl.framebufferRenderbuffer(36160, 36096, 36161, renderbuffer);
        } else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {
            const samples = getRenderTargetSamples(renderTarget);
            if (isMultisample && useMultisampledRTT(renderTarget) === false) _gl.renderbufferStorageMultisample(36161, samples, 35056, renderTarget.width, renderTarget.height);
            else if (useMultisampledRTT(renderTarget)) multisampledRTTExt.renderbufferStorageMultisampleEXT(36161, samples, 35056, renderTarget.width, renderTarget.height);
            else _gl.renderbufferStorage(36161, 34041, renderTarget.width, renderTarget.height);
            _gl.framebufferRenderbuffer(36160, 33306, 36161, renderbuffer);
        } else {
            const textures = renderTarget.isWebGLMultipleRenderTargets === true ? renderTarget.texture : [
                renderTarget.texture
            ];
            for(let i143 = 0; i143 < textures.length; i143++){
                const texture = textures[i143];
                const glFormat = utils.convert(texture.format, texture.encoding);
                const glType = utils.convert(texture.type);
                const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding);
                const samples = getRenderTargetSamples(renderTarget);
                if (isMultisample && useMultisampledRTT(renderTarget) === false) _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
                else if (useMultisampledRTT(renderTarget)) multisampledRTTExt.renderbufferStorageMultisampleEXT(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
                else _gl.renderbufferStorage(36161, glInternalFormat, renderTarget.width, renderTarget.height);
            }
        }
        _gl.bindRenderbuffer(36161, null);
    }
    // Setup resources for a Depth Texture for a FBO (needs an extension)
    function setupDepthTexture(framebuffer, renderTarget) {
        const isCube = renderTarget && renderTarget.isWebGLCubeRenderTarget;
        if (isCube) throw new Error("Depth Texture with cube render targets is not supported");
        state.bindFramebuffer(36160, framebuffer);
        if (!(renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture)) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
        // upload an empty depth texture with framebuffer size
        if (!properties.get(renderTarget.depthTexture).__webglTexture || renderTarget.depthTexture.image.width !== renderTarget.width || renderTarget.depthTexture.image.height !== renderTarget.height) {
            renderTarget.depthTexture.image.width = renderTarget.width;
            renderTarget.depthTexture.image.height = renderTarget.height;
            renderTarget.depthTexture.needsUpdate = true;
        }
        setTexture2D(renderTarget.depthTexture, 0);
        const webglDepthTexture = properties.get(renderTarget.depthTexture).__webglTexture;
        const samples = getRenderTargetSamples(renderTarget);
        if (renderTarget.depthTexture.format === $084574008ccedf86$export$c1b6b5136be58045) {
            if (useMultisampledRTT(renderTarget)) multisampledRTTExt.framebufferTexture2DMultisampleEXT(36160, 36096, 3553, webglDepthTexture, 0, samples);
            else _gl.framebufferTexture2D(36160, 36096, 3553, webglDepthTexture, 0);
        } else if (renderTarget.depthTexture.format === $084574008ccedf86$export$1e113ac2d0905829) {
            if (useMultisampledRTT(renderTarget)) multisampledRTTExt.framebufferTexture2DMultisampleEXT(36160, 33306, 3553, webglDepthTexture, 0, samples);
            else _gl.framebufferTexture2D(36160, 33306, 3553, webglDepthTexture, 0);
        } else throw new Error("Unknown depthTexture format");
    }
    // Setup GL resources for a non-texture depth buffer
    function setupDepthRenderbuffer(renderTarget) {
        const renderTargetProperties = properties.get(renderTarget);
        const isCube = renderTarget.isWebGLCubeRenderTarget === true;
        if (renderTarget.depthTexture && !renderTargetProperties.__autoAllocateDepthBuffer) {
            if (isCube) throw new Error("target.depthTexture not supported in Cube render targets");
            setupDepthTexture(renderTargetProperties.__webglFramebuffer, renderTarget);
        } else if (isCube) {
            renderTargetProperties.__webglDepthbuffer = [];
            for(let i144 = 0; i144 < 6; i144++){
                state.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer[i144]);
                renderTargetProperties.__webglDepthbuffer[i144] = _gl.createRenderbuffer();
                setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i144], renderTarget, false);
            }
        } else {
            state.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer);
            renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
            setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, renderTarget, false);
        }
        state.bindFramebuffer(36160, null);
    }
    // rebind framebuffer with external textures
    function rebindTextures(renderTarget, colorTexture, depthTexture) {
        const renderTargetProperties = properties.get(renderTarget);
        if (colorTexture !== undefined) setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, renderTarget.texture, 36064, 3553);
        if (depthTexture !== undefined) setupDepthRenderbuffer(renderTarget);
    }
    // Set up GL resources for the render target
    function setupRenderTarget(renderTarget) {
        const texture = renderTarget.texture;
        const renderTargetProperties = properties.get(renderTarget);
        const textureProperties = properties.get(texture);
        renderTarget.addEventListener("dispose", onRenderTargetDispose);
        if (renderTarget.isWebGLMultipleRenderTargets !== true) {
            if (textureProperties.__webglTexture === undefined) textureProperties.__webglTexture = _gl.createTexture();
            textureProperties.__version = texture.version;
            info.memory.textures++;
        }
        const isCube = renderTarget.isWebGLCubeRenderTarget === true;
        const isMultipleRenderTargets = renderTarget.isWebGLMultipleRenderTargets === true;
        const supportsMips = isPowerOfTwo$1(renderTarget) || isWebGL2;
        // Setup framebuffer
        if (isCube) {
            renderTargetProperties.__webglFramebuffer = [];
            for(let i145 = 0; i145 < 6; i145++)renderTargetProperties.__webglFramebuffer[i145] = _gl.createFramebuffer();
        } else {
            renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();
            if (isMultipleRenderTargets) {
                if (capabilities.drawBuffers) {
                    const textures = renderTarget.texture;
                    for(let i146 = 0, il = textures.length; i146 < il; i146++){
                        const attachmentProperties = properties.get(textures[i146]);
                        if (attachmentProperties.__webglTexture === undefined) {
                            attachmentProperties.__webglTexture = _gl.createTexture();
                            info.memory.textures++;
                        }
                    }
                } else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
            }
            if (isWebGL2 && renderTarget.samples > 0 && useMultisampledRTT(renderTarget) === false) {
                const textures = isMultipleRenderTargets ? texture : [
                    texture
                ];
                renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();
                renderTargetProperties.__webglColorRenderbuffer = [];
                state.bindFramebuffer(36160, renderTargetProperties.__webglMultisampledFramebuffer);
                for(let i147 = 0; i147 < textures.length; i147++){
                    const texture = textures[i147];
                    renderTargetProperties.__webglColorRenderbuffer[i147] = _gl.createRenderbuffer();
                    _gl.bindRenderbuffer(36161, renderTargetProperties.__webglColorRenderbuffer[i147]);
                    const glFormat = utils.convert(texture.format, texture.encoding);
                    const glType = utils.convert(texture.type);
                    const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding);
                    const samples = getRenderTargetSamples(renderTarget);
                    _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
                    _gl.framebufferRenderbuffer(36160, 36064 + i147, 36161, renderTargetProperties.__webglColorRenderbuffer[i147]);
                }
                _gl.bindRenderbuffer(36161, null);
                if (renderTarget.depthBuffer) {
                    renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();
                    setupRenderBufferStorage(renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true);
                }
                state.bindFramebuffer(36160, null);
            }
        }
        // Setup color buffer
        if (isCube) {
            state.bindTexture(34067, textureProperties.__webglTexture);
            setTextureParameters(34067, texture, supportsMips);
            for(let i148 = 0; i148 < 6; i148++)setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i148], renderTarget, texture, 36064, 34069 + i148);
            if (textureNeedsGenerateMipmaps(texture, supportsMips)) generateMipmap(34067);
            state.unbindTexture();
        } else if (isMultipleRenderTargets) {
            const textures = renderTarget.texture;
            for(let i149 = 0, il = textures.length; i149 < il; i149++){
                const attachment = textures[i149];
                const attachmentProperties = properties.get(attachment);
                state.bindTexture(3553, attachmentProperties.__webglTexture);
                setTextureParameters(3553, attachment, supportsMips);
                setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, attachment, 36064 + i149, 3553);
                if (textureNeedsGenerateMipmaps(attachment, supportsMips)) generateMipmap(3553);
            }
            state.unbindTexture();
        } else {
            let glTextureType = 3553;
            if (renderTarget.isWebGL3DRenderTarget || renderTarget.isWebGLArrayRenderTarget) {
                if (isWebGL2) glTextureType = renderTarget.isWebGL3DRenderTarget ? 32879 : 35866;
                else console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.");
            }
            state.bindTexture(glTextureType, textureProperties.__webglTexture);
            setTextureParameters(glTextureType, texture, supportsMips);
            setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, texture, 36064, glTextureType);
            if (textureNeedsGenerateMipmaps(texture, supportsMips)) generateMipmap(glTextureType);
            state.unbindTexture();
        }
        // Setup depth and stencil buffers
        if (renderTarget.depthBuffer) setupDepthRenderbuffer(renderTarget);
    }
    function updateRenderTargetMipmap(renderTarget) {
        const supportsMips = isPowerOfTwo$1(renderTarget) || isWebGL2;
        const textures = renderTarget.isWebGLMultipleRenderTargets === true ? renderTarget.texture : [
            renderTarget.texture
        ];
        for(let i150 = 0, il = textures.length; i150 < il; i150++){
            const texture = textures[i150];
            if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
                const target = renderTarget.isWebGLCubeRenderTarget ? 34067 : 3553;
                const webglTexture = properties.get(texture).__webglTexture;
                state.bindTexture(target, webglTexture);
                generateMipmap(target);
                state.unbindTexture();
            }
        }
    }
    function updateMultisampleRenderTarget(renderTarget) {
        if (isWebGL2 && renderTarget.samples > 0 && useMultisampledRTT(renderTarget) === false) {
            const textures = renderTarget.isWebGLMultipleRenderTargets ? renderTarget.texture : [
                renderTarget.texture
            ];
            const width = renderTarget.width;
            const height = renderTarget.height;
            let mask = 16384;
            const invalidationArray = [];
            const depthStyle = renderTarget.stencilBuffer ? 33306 : 36096;
            const renderTargetProperties = properties.get(renderTarget);
            const isMultipleRenderTargets = renderTarget.isWebGLMultipleRenderTargets === true;
            // If MRT we need to remove FBO attachments
            if (isMultipleRenderTargets) for(let i153 = 0; i153 < textures.length; i153++){
                state.bindFramebuffer(36160, renderTargetProperties.__webglMultisampledFramebuffer);
                _gl.framebufferRenderbuffer(36160, 36064 + i153, 36161, null);
                state.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer);
                _gl.framebufferTexture2D(36009, 36064 + i153, 3553, null, 0);
            }
            state.bindFramebuffer(36008, renderTargetProperties.__webglMultisampledFramebuffer);
            state.bindFramebuffer(36009, renderTargetProperties.__webglFramebuffer);
            for(let i151 = 0; i151 < textures.length; i151++){
                invalidationArray.push(36064 + i151);
                if (renderTarget.depthBuffer) invalidationArray.push(depthStyle);
                const ignoreDepthValues = renderTargetProperties.__ignoreDepthValues !== undefined ? renderTargetProperties.__ignoreDepthValues : false;
                if (ignoreDepthValues === false) {
                    if (renderTarget.depthBuffer) mask |= 256;
                    if (renderTarget.stencilBuffer) mask |= 1024;
                }
                if (isMultipleRenderTargets) _gl.framebufferRenderbuffer(36008, 36064, 36161, renderTargetProperties.__webglColorRenderbuffer[i151]);
                if (ignoreDepthValues === true) {
                    _gl.invalidateFramebuffer(36008, [
                        depthStyle
                    ]);
                    _gl.invalidateFramebuffer(36009, [
                        depthStyle
                    ]);
                }
                if (isMultipleRenderTargets) {
                    const webglTexture = properties.get(textures[i151]).__webglTexture;
                    _gl.framebufferTexture2D(36009, 36064, 3553, webglTexture, 0);
                }
                _gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, mask, 9728);
                if (supportsInvalidateFramebuffer) _gl.invalidateFramebuffer(36008, invalidationArray);
            }
            state.bindFramebuffer(36008, null);
            state.bindFramebuffer(36009, null);
            // If MRT since pre-blit we removed the FBO we need to reconstruct the attachments
            if (isMultipleRenderTargets) for(let i152 = 0; i152 < textures.length; i152++){
                state.bindFramebuffer(36160, renderTargetProperties.__webglMultisampledFramebuffer);
                _gl.framebufferRenderbuffer(36160, 36064 + i152, 36161, renderTargetProperties.__webglColorRenderbuffer[i152]);
                const webglTexture = properties.get(textures[i152]).__webglTexture;
                state.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer);
                _gl.framebufferTexture2D(36009, 36064 + i152, 3553, webglTexture, 0);
            }
            state.bindFramebuffer(36009, renderTargetProperties.__webglMultisampledFramebuffer);
        }
    }
    function getRenderTargetSamples(renderTarget) {
        return Math.min(maxSamples, renderTarget.samples);
    }
    function useMultisampledRTT(renderTarget) {
        const renderTargetProperties = properties.get(renderTarget);
        return isWebGL2 && renderTarget.samples > 0 && extensions.has("WEBGL_multisampled_render_to_texture") === true && renderTargetProperties.__useRenderToTexture !== false;
    }
    function updateVideoTexture(texture) {
        const frame = info.render.frame;
        // Check the last frame we updated the VideoTexture
        if (_videoTextures.get(texture) !== frame) {
            _videoTextures.set(texture, frame);
            texture.update();
        }
    }
    function verifyColorSpace(texture, image) {
        const encoding = texture.encoding;
        const format = texture.format;
        const type = texture.type;
        if (texture.isCompressedTexture === true || texture.isVideoTexture === true || texture.format === $084574008ccedf86$export$ca1dce8b5e1de74d) return image;
        if (encoding !== $084574008ccedf86$export$7207336e4151a112) {
            // sRGB
            if (encoding === $084574008ccedf86$export$f32388edbb32674) {
                if (isWebGL2 === false) {
                    // in WebGL 1, try to use EXT_sRGB extension and unsized formats
                    if (extensions.has("EXT_sRGB") === true && format === $084574008ccedf86$export$3f8bb04b555a363c) {
                        texture.format = $084574008ccedf86$export$ca1dce8b5e1de74d;
                        // it's not possible to generate mips in WebGL 1 with this extension
                        texture.minFilter = $084574008ccedf86$export$8a72f490b25c56c8;
                        texture.generateMipmaps = false;
                    } else // slow fallback (CPU decode)
                    image = $084574008ccedf86$export$698882cf06df44aa.sRGBToLinear(image);
                } else // in WebGL 2 uncompressed textures can only be sRGB encoded if they have the RGBA8 format
                if (format !== $084574008ccedf86$export$3f8bb04b555a363c || type !== $084574008ccedf86$export$2e8ce08d3f6f5e10) console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.");
            } else console.error("THREE.WebGLTextures: Unsupported texture encoding:", encoding);
        }
        return image;
    }
    //
    this.allocateTextureUnit = allocateTextureUnit;
    this.resetTextureUnits = resetTextureUnits;
    this.setTexture2D = setTexture2D;
    this.setTexture2DArray = setTexture2DArray;
    this.setTexture3D = setTexture3D;
    this.setTextureCube = setTextureCube;
    this.rebindTextures = rebindTextures;
    this.setupRenderTarget = setupRenderTarget;
    this.updateRenderTargetMipmap = updateRenderTargetMipmap;
    this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;
    this.setupDepthRenderbuffer = setupDepthRenderbuffer;
    this.setupFrameBufferTexture = setupFrameBufferTexture;
    this.useMultisampledRTT = useMultisampledRTT;
}
function $084574008ccedf86$export$ddaebcad857649a8(gl, extensions, capabilities) {
    const isWebGL2 = capabilities.isWebGL2;
    function convert(p, encoding = null) {
        let extension;
        if (p === $084574008ccedf86$export$2e8ce08d3f6f5e10) return 5121;
        if (p === $084574008ccedf86$export$b3969b01faf587f2) return 32819;
        if (p === $084574008ccedf86$export$18886f8ae33e90de) return 32820;
        if (p === $084574008ccedf86$export$545fce0311a9796a) return 5120;
        if (p === $084574008ccedf86$export$88572337f312435f) return 5122;
        if (p === $084574008ccedf86$export$c63dc51868b06a9d) return 5123;
        if (p === $084574008ccedf86$export$5c612977753abe2) return 5124;
        if (p === $084574008ccedf86$export$c3c7fc4518ebba96) return 5125;
        if (p === $084574008ccedf86$export$f6d331659b644596) return 5126;
        if (p === $084574008ccedf86$export$2697304443f382bc) {
            if (isWebGL2) return 5131;
            extension = extensions.get("OES_texture_half_float");
            if (extension !== null) return extension.HALF_FLOAT_OES;
            else return null;
        }
        if (p === $084574008ccedf86$export$988473390501ed4b) return 6406;
        if (p === $084574008ccedf86$export$3f8bb04b555a363c) return 6408;
        if (p === $084574008ccedf86$export$cc09ccbf6d1ed449) return 6409;
        if (p === $084574008ccedf86$export$9053a81c4a69c289) return 6410;
        if (p === $084574008ccedf86$export$c1b6b5136be58045) return 6402;
        if (p === $084574008ccedf86$export$1e113ac2d0905829) return 34041;
        if (p === $084574008ccedf86$export$4e041a7967d15c4b) return 6403;
        if (p === $084574008ccedf86$export$7c67423a5ee6f5eb) {
            console.warn("THREE.WebGLRenderer: THREE.RGBFormat has been removed. Use THREE.RGBAFormat instead. https://github.com/mrdoob/three.js/pull/23228");
            return 6408;
        }
        // WebGL 1 sRGB fallback
        if (p === $084574008ccedf86$export$ca1dce8b5e1de74d) {
            extension = extensions.get("EXT_sRGB");
            if (extension !== null) return extension.SRGB_ALPHA_EXT;
            else return null;
        }
        // WebGL2 formats.
        if (p === $084574008ccedf86$export$aa92e870a709d190) return 36244;
        if (p === $084574008ccedf86$export$6cdf0b461c7ce8a0) return 33319;
        if (p === $084574008ccedf86$export$1ba1c45f9f77d4d7) return 33320;
        if (p === $084574008ccedf86$export$c200e7d26f592f21) return 36249;
        // S3TC
        if (p === $084574008ccedf86$export$21d1799c6d552fc0 || p === $084574008ccedf86$export$afa304c3e981b668 || p === $084574008ccedf86$export$d2a1a68024a3e56c || p === $084574008ccedf86$export$9a79c424327dacf9) {
            if (encoding === $084574008ccedf86$export$f32388edbb32674) {
                extension = extensions.get("WEBGL_compressed_texture_s3tc_srgb");
                if (extension !== null) {
                    if (p === $084574008ccedf86$export$21d1799c6d552fc0) return extension.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                    if (p === $084574008ccedf86$export$afa304c3e981b668) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                    if (p === $084574008ccedf86$export$d2a1a68024a3e56c) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                    if (p === $084574008ccedf86$export$9a79c424327dacf9) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
                } else return null;
            } else {
                extension = extensions.get("WEBGL_compressed_texture_s3tc");
                if (extension !== null) {
                    if (p === $084574008ccedf86$export$21d1799c6d552fc0) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
                    if (p === $084574008ccedf86$export$afa304c3e981b668) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                    if (p === $084574008ccedf86$export$d2a1a68024a3e56c) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                    if (p === $084574008ccedf86$export$9a79c424327dacf9) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
                } else return null;
            }
        }
        // PVRTC
        if (p === $084574008ccedf86$export$19ada9bbb1af3573 || p === $084574008ccedf86$export$d0f0355bb3d948e4 || p === $084574008ccedf86$export$b82296714358084c || p === $084574008ccedf86$export$b71692456c47b6c3) {
            extension = extensions.get("WEBGL_compressed_texture_pvrtc");
            if (extension !== null) {
                if (p === $084574008ccedf86$export$19ada9bbb1af3573) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                if (p === $084574008ccedf86$export$d0f0355bb3d948e4) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                if (p === $084574008ccedf86$export$b82296714358084c) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                if (p === $084574008ccedf86$export$b71692456c47b6c3) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
            } else return null;
        }
        // ETC1
        if (p === $084574008ccedf86$export$6ab91af2d757aee7) {
            extension = extensions.get("WEBGL_compressed_texture_etc1");
            if (extension !== null) return extension.COMPRESSED_RGB_ETC1_WEBGL;
            else return null;
        }
        // ETC2
        if (p === $084574008ccedf86$export$7800993ef8106a6a || p === $084574008ccedf86$export$23ed8300a860e7d8) {
            extension = extensions.get("WEBGL_compressed_texture_etc");
            if (extension !== null) {
                if (p === $084574008ccedf86$export$7800993ef8106a6a) return encoding === $084574008ccedf86$export$f32388edbb32674 ? extension.COMPRESSED_SRGB8_ETC2 : extension.COMPRESSED_RGB8_ETC2;
                if (p === $084574008ccedf86$export$23ed8300a860e7d8) return encoding === $084574008ccedf86$export$f32388edbb32674 ? extension.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : extension.COMPRESSED_RGBA8_ETC2_EAC;
            } else return null;
        }
        // ASTC
        if (p === $084574008ccedf86$export$dc5570b4a2b92d48 || p === $084574008ccedf86$export$68880cd325f8b2fb || p === $084574008ccedf86$export$7d2c0be323373d95 || p === $084574008ccedf86$export$22b52da301fc3a3e || p === $084574008ccedf86$export$c009e2cb4a66485e || p === $084574008ccedf86$export$118fff5afa255b63 || p === $084574008ccedf86$export$120713c829ae0667 || p === $084574008ccedf86$export$c79eeabbf53313e9 || p === $084574008ccedf86$export$443cf6567cdd6424 || p === $084574008ccedf86$export$6573984fc9840780 || p === $084574008ccedf86$export$e7aee563f30091de || p === $084574008ccedf86$export$2eb8634622ddeab7 || p === $084574008ccedf86$export$202b1ce7b5d25742 || p === $084574008ccedf86$export$18ab77abd087e467) {
            extension = extensions.get("WEBGL_compressed_texture_astc");
            if (extension !== null) {
                if (p === $084574008ccedf86$export$dc5570b4a2b92d48) return encoding === $084574008ccedf86$export$f32388edbb32674 ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : extension.COMPRESSED_RGBA_ASTC_4x4_KHR;
                if (p === $084574008ccedf86$export$68880cd325f8b2fb) return encoding === $084574008ccedf86$export$f32388edbb32674 ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : extension.COMPRESSED_RGBA_ASTC_5x4_KHR;
                if (p === $084574008ccedf86$export$7d2c0be323373d95) return encoding === $084574008ccedf86$export$f32388edbb32674 ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : extension.COMPRESSED_RGBA_ASTC_5x5_KHR;
                if (p === $084574008ccedf86$export$22b52da301fc3a3e) return encoding === $084574008ccedf86$export$f32388edbb32674 ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : extension.COMPRESSED_RGBA_ASTC_6x5_KHR;
                if (p === $084574008ccedf86$export$c009e2cb4a66485e) return encoding === $084574008ccedf86$export$f32388edbb32674 ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : extension.COMPRESSED_RGBA_ASTC_6x6_KHR;
                if (p === $084574008ccedf86$export$118fff5afa255b63) return encoding === $084574008ccedf86$export$f32388edbb32674 ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : extension.COMPRESSED_RGBA_ASTC_8x5_KHR;
                if (p === $084574008ccedf86$export$120713c829ae0667) return encoding === $084574008ccedf86$export$f32388edbb32674 ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : extension.COMPRESSED_RGBA_ASTC_8x6_KHR;
                if (p === $084574008ccedf86$export$c79eeabbf53313e9) return encoding === $084574008ccedf86$export$f32388edbb32674 ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : extension.COMPRESSED_RGBA_ASTC_8x8_KHR;
                if (p === $084574008ccedf86$export$443cf6567cdd6424) return encoding === $084574008ccedf86$export$f32388edbb32674 ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : extension.COMPRESSED_RGBA_ASTC_10x5_KHR;
                if (p === $084574008ccedf86$export$6573984fc9840780) return encoding === $084574008ccedf86$export$f32388edbb32674 ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : extension.COMPRESSED_RGBA_ASTC_10x6_KHR;
                if (p === $084574008ccedf86$export$e7aee563f30091de) return encoding === $084574008ccedf86$export$f32388edbb32674 ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : extension.COMPRESSED_RGBA_ASTC_10x8_KHR;
                if (p === $084574008ccedf86$export$2eb8634622ddeab7) return encoding === $084574008ccedf86$export$f32388edbb32674 ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : extension.COMPRESSED_RGBA_ASTC_10x10_KHR;
                if (p === $084574008ccedf86$export$202b1ce7b5d25742) return encoding === $084574008ccedf86$export$f32388edbb32674 ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : extension.COMPRESSED_RGBA_ASTC_12x10_KHR;
                if (p === $084574008ccedf86$export$18ab77abd087e467) return encoding === $084574008ccedf86$export$f32388edbb32674 ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : extension.COMPRESSED_RGBA_ASTC_12x12_KHR;
            } else return null;
        }
        // BPTC
        if (p === $084574008ccedf86$export$ce40b115e188bc81) {
            extension = extensions.get("EXT_texture_compression_bptc");
            if (extension !== null) {
                if (p === $084574008ccedf86$export$ce40b115e188bc81) return encoding === $084574008ccedf86$export$f32388edbb32674 ? extension.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : extension.COMPRESSED_RGBA_BPTC_UNORM_EXT;
            } else return null;
        }
        //
        if (p === $084574008ccedf86$export$6c8ea339bfab1301) {
            if (isWebGL2) return 34042;
            extension = extensions.get("WEBGL_depth_texture");
            if (extension !== null) return extension.UNSIGNED_INT_24_8_WEBGL;
            else return null;
        }
        // if "p" can't be resolved, assume the user defines a WebGL constant as a string (fallback/workaround for packed RGB formats)
        return gl[p] !== undefined ? gl[p] : null;
    }
    return {
        convert: convert
    };
}
class $084574008ccedf86$export$56b937d9e5581166 extends $084574008ccedf86$export$74e4ae24825f68d7 {
    constructor(array = []){
        super();
        this.isArrayCamera = true;
        this.cameras = array;
    }
}
class $084574008ccedf86$export$eb2fcfdbd7ba97d4 extends $084574008ccedf86$export$e4dd07dff30cc924 {
    constructor(){
        super();
        this.isGroup = true;
        this.type = "Group";
    }
}
const $084574008ccedf86$var$_moveEvent = {
    type: "move"
};
class $084574008ccedf86$var$WebXRController {
    constructor(){
        this._targetRay = null;
        this._grip = null;
        this._hand = null;
    }
    getHandSpace() {
        if (this._hand === null) {
            this._hand = new $084574008ccedf86$export$eb2fcfdbd7ba97d4();
            this._hand.matrixAutoUpdate = false;
            this._hand.visible = false;
            this._hand.joints = {};
            this._hand.inputState = {
                pinching: false
            };
        }
        return this._hand;
    }
    getTargetRaySpace() {
        if (this._targetRay === null) {
            this._targetRay = new $084574008ccedf86$export$eb2fcfdbd7ba97d4();
            this._targetRay.matrixAutoUpdate = false;
            this._targetRay.visible = false;
            this._targetRay.hasLinearVelocity = false;
            this._targetRay.linearVelocity = new $084574008ccedf86$export$64b5c384219d3699();
            this._targetRay.hasAngularVelocity = false;
            this._targetRay.angularVelocity = new $084574008ccedf86$export$64b5c384219d3699();
        }
        return this._targetRay;
    }
    getGripSpace() {
        if (this._grip === null) {
            this._grip = new $084574008ccedf86$export$eb2fcfdbd7ba97d4();
            this._grip.matrixAutoUpdate = false;
            this._grip.visible = false;
            this._grip.hasLinearVelocity = false;
            this._grip.linearVelocity = new $084574008ccedf86$export$64b5c384219d3699();
            this._grip.hasAngularVelocity = false;
            this._grip.angularVelocity = new $084574008ccedf86$export$64b5c384219d3699();
        }
        return this._grip;
    }
    dispatchEvent(event) {
        if (this._targetRay !== null) this._targetRay.dispatchEvent(event);
        if (this._grip !== null) this._grip.dispatchEvent(event);
        if (this._hand !== null) this._hand.dispatchEvent(event);
        return this;
    }
    disconnect(inputSource) {
        this.dispatchEvent({
            type: "disconnected",
            data: inputSource
        });
        if (this._targetRay !== null) this._targetRay.visible = false;
        if (this._grip !== null) this._grip.visible = false;
        if (this._hand !== null) this._hand.visible = false;
        return this;
    }
    update(inputSource, frame, referenceSpace) {
        let inputPose = null;
        let gripPose = null;
        let handPose = null;
        const targetRay = this._targetRay;
        const grip = this._grip;
        const hand = this._hand;
        if (inputSource && frame.session.visibilityState !== "visible-blurred") {
            if (targetRay !== null) {
                inputPose = frame.getPose(inputSource.targetRaySpace, referenceSpace);
                if (inputPose !== null) {
                    targetRay.matrix.fromArray(inputPose.transform.matrix);
                    targetRay.matrix.decompose(targetRay.position, targetRay.rotation, targetRay.scale);
                    if (inputPose.linearVelocity) {
                        targetRay.hasLinearVelocity = true;
                        targetRay.linearVelocity.copy(inputPose.linearVelocity);
                    } else targetRay.hasLinearVelocity = false;
                    if (inputPose.angularVelocity) {
                        targetRay.hasAngularVelocity = true;
                        targetRay.angularVelocity.copy(inputPose.angularVelocity);
                    } else targetRay.hasAngularVelocity = false;
                    this.dispatchEvent($084574008ccedf86$var$_moveEvent);
                }
            }
            if (hand && inputSource.hand) {
                handPose = true;
                for (const inputjoint of inputSource.hand.values()){
                    // Update the joints groups with the XRJoint poses
                    const jointPose = frame.getJointPose(inputjoint, referenceSpace);
                    if (hand.joints[inputjoint.jointName] === undefined) {
                        // The transform of this joint will be updated with the joint pose on each frame
                        const joint = new $084574008ccedf86$export$eb2fcfdbd7ba97d4();
                        joint.matrixAutoUpdate = false;
                        joint.visible = false;
                        hand.joints[inputjoint.jointName] = joint;
                        // ??
                        hand.add(joint);
                    }
                    const joint = hand.joints[inputjoint.jointName];
                    if (jointPose !== null) {
                        joint.matrix.fromArray(jointPose.transform.matrix);
                        joint.matrix.decompose(joint.position, joint.rotation, joint.scale);
                        joint.jointRadius = jointPose.radius;
                    }
                    joint.visible = jointPose !== null;
                }
                // Custom events
                // Check pinchz
                const indexTip = hand.joints["index-finger-tip"];
                const thumbTip = hand.joints["thumb-tip"];
                const distance = indexTip.position.distanceTo(thumbTip.position);
                const distanceToPinch = 0.02;
                const threshold = 0.005;
                if (hand.inputState.pinching && distance > distanceToPinch + threshold) {
                    hand.inputState.pinching = false;
                    this.dispatchEvent({
                        type: "pinchend",
                        handedness: inputSource.handedness,
                        target: this
                    });
                } else if (!hand.inputState.pinching && distance <= distanceToPinch - threshold) {
                    hand.inputState.pinching = true;
                    this.dispatchEvent({
                        type: "pinchstart",
                        handedness: inputSource.handedness,
                        target: this
                    });
                }
            } else if (grip !== null && inputSource.gripSpace) {
                gripPose = frame.getPose(inputSource.gripSpace, referenceSpace);
                if (gripPose !== null) {
                    grip.matrix.fromArray(gripPose.transform.matrix);
                    grip.matrix.decompose(grip.position, grip.rotation, grip.scale);
                    if (gripPose.linearVelocity) {
                        grip.hasLinearVelocity = true;
                        grip.linearVelocity.copy(gripPose.linearVelocity);
                    } else grip.hasLinearVelocity = false;
                    if (gripPose.angularVelocity) {
                        grip.hasAngularVelocity = true;
                        grip.angularVelocity.copy(gripPose.angularVelocity);
                    } else grip.hasAngularVelocity = false;
                }
            }
        }
        if (targetRay !== null) targetRay.visible = inputPose !== null;
        if (grip !== null) grip.visible = gripPose !== null;
        if (hand !== null) hand.visible = handPose !== null;
        return this;
    }
}
class $084574008ccedf86$export$fc830aa069cc8c2f extends $084574008ccedf86$export$5431306cf43de24a {
    constructor(width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format){
        format = format !== undefined ? format : $084574008ccedf86$export$c1b6b5136be58045;
        if (format !== $084574008ccedf86$export$c1b6b5136be58045 && format !== $084574008ccedf86$export$1e113ac2d0905829) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
        if (type === undefined && format === $084574008ccedf86$export$c1b6b5136be58045) type = $084574008ccedf86$export$c3c7fc4518ebba96;
        if (type === undefined && format === $084574008ccedf86$export$1e113ac2d0905829) type = $084574008ccedf86$export$6c8ea339bfab1301;
        super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
        this.isDepthTexture = true;
        this.image = {
            width: width,
            height: height
        };
        this.magFilter = magFilter !== undefined ? magFilter : $084574008ccedf86$export$727aa5ec3fe39bf0;
        this.minFilter = minFilter !== undefined ? minFilter : $084574008ccedf86$export$727aa5ec3fe39bf0;
        this.flipY = false;
        this.generateMipmaps = false;
    }
}
class $084574008ccedf86$var$WebXRManager extends $084574008ccedf86$export$ec8b666c5fe2c75a {
    constructor(renderer, gl){
        super();
        const scope = this;
        let session = null;
        let framebufferScaleFactor = 1.0;
        let referenceSpace = null;
        let referenceSpaceType = "local-floor";
        let customReferenceSpace = null;
        let pose = null;
        let glBinding = null;
        let glProjLayer = null;
        let glBaseLayer = null;
        let xrFrame = null;
        const attributes = gl.getContextAttributes();
        let initialRenderTarget = null;
        let newRenderTarget = null;
        const controllers = [];
        const inputSourcesMap = new Map();
        //
        const cameraL1 = new $084574008ccedf86$export$74e4ae24825f68d7();
        cameraL1.layers.enable(1);
        cameraL1.viewport = new $084574008ccedf86$export$fa7daccca11cdbe3();
        const cameraR1 = new $084574008ccedf86$export$74e4ae24825f68d7();
        cameraR1.layers.enable(2);
        cameraR1.viewport = new $084574008ccedf86$export$fa7daccca11cdbe3();
        const cameras1 = [
            cameraL1,
            cameraR1
        ];
        const cameraVR = new $084574008ccedf86$export$56b937d9e5581166();
        cameraVR.layers.enable(1);
        cameraVR.layers.enable(2);
        let _currentDepthNear = null;
        let _currentDepthFar = null;
        //
        this.cameraAutoUpdate = true;
        this.enabled = false;
        this.isPresenting = false;
        this.getController = function(index) {
            let controller = controllers[index];
            if (controller === undefined) {
                controller = new $084574008ccedf86$var$WebXRController();
                controllers[index] = controller;
            }
            return controller.getTargetRaySpace();
        };
        this.getControllerGrip = function(index) {
            let controller = controllers[index];
            if (controller === undefined) {
                controller = new $084574008ccedf86$var$WebXRController();
                controllers[index] = controller;
            }
            return controller.getGripSpace();
        };
        this.getHand = function(index) {
            let controller = controllers[index];
            if (controller === undefined) {
                controller = new $084574008ccedf86$var$WebXRController();
                controllers[index] = controller;
            }
            return controller.getHandSpace();
        };
        //
        function onSessionEvent(event) {
            const controller = inputSourcesMap.get(event.inputSource);
            if (controller !== undefined) controller.dispatchEvent({
                type: event.type,
                data: event.inputSource
            });
        }
        function onSessionEnd() {
            session.removeEventListener("select", onSessionEvent);
            session.removeEventListener("selectstart", onSessionEvent);
            session.removeEventListener("selectend", onSessionEvent);
            session.removeEventListener("squeeze", onSessionEvent);
            session.removeEventListener("squeezestart", onSessionEvent);
            session.removeEventListener("squeezeend", onSessionEvent);
            session.removeEventListener("end", onSessionEnd);
            session.removeEventListener("inputsourceschange", onInputSourcesChange);
            inputSourcesMap.forEach(function(controller, inputSource) {
                if (controller !== undefined) controller.disconnect(inputSource);
            });
            inputSourcesMap.clear();
            _currentDepthNear = null;
            _currentDepthFar = null;
            // restore framebuffer/rendering state
            renderer.setRenderTarget(initialRenderTarget);
            glBaseLayer = null;
            glProjLayer = null;
            glBinding = null;
            session = null;
            newRenderTarget = null;
            //
            animation.stop();
            scope.isPresenting = false;
            scope.dispatchEvent({
                type: "sessionend"
            });
        }
        this.setFramebufferScaleFactor = function(value) {
            framebufferScaleFactor = value;
            if (scope.isPresenting === true) console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
        };
        this.setReferenceSpaceType = function(value) {
            referenceSpaceType = value;
            if (scope.isPresenting === true) console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
        };
        this.getReferenceSpace = function() {
            return customReferenceSpace || referenceSpace;
        };
        this.setReferenceSpace = function(space) {
            customReferenceSpace = space;
        };
        this.getBaseLayer = function() {
            return glProjLayer !== null ? glProjLayer : glBaseLayer;
        };
        this.getBinding = function() {
            return glBinding;
        };
        this.getFrame = function() {
            return xrFrame;
        };
        this.getSession = function() {
            return session;
        };
        this.setSession = async function(value) {
            session = value;
            if (session !== null) {
                initialRenderTarget = renderer.getRenderTarget();
                session.addEventListener("select", onSessionEvent);
                session.addEventListener("selectstart", onSessionEvent);
                session.addEventListener("selectend", onSessionEvent);
                session.addEventListener("squeeze", onSessionEvent);
                session.addEventListener("squeezestart", onSessionEvent);
                session.addEventListener("squeezeend", onSessionEvent);
                session.addEventListener("end", onSessionEnd);
                session.addEventListener("inputsourceschange", onInputSourcesChange);
                if (attributes.xrCompatible !== true) await gl.makeXRCompatible();
                if (session.renderState.layers === undefined || renderer.capabilities.isWebGL2 === false) {
                    const layerInit = {
                        antialias: session.renderState.layers === undefined ? attributes.antialias : true,
                        alpha: attributes.alpha,
                        depth: attributes.depth,
                        stencil: attributes.stencil,
                        framebufferScaleFactor: framebufferScaleFactor
                    };
                    glBaseLayer = new XRWebGLLayer(session, gl, layerInit);
                    session.updateRenderState({
                        baseLayer: glBaseLayer
                    });
                    newRenderTarget = new $084574008ccedf86$export$3c052beb2e51e23f(glBaseLayer.framebufferWidth, glBaseLayer.framebufferHeight, {
                        format: $084574008ccedf86$export$3f8bb04b555a363c,
                        type: $084574008ccedf86$export$2e8ce08d3f6f5e10,
                        encoding: renderer.outputEncoding
                    });
                } else {
                    let depthFormat = null;
                    let depthType = null;
                    let glDepthFormat = null;
                    if (attributes.depth) {
                        glDepthFormat = attributes.stencil ? 35056 : 33190;
                        depthFormat = attributes.stencil ? $084574008ccedf86$export$1e113ac2d0905829 : $084574008ccedf86$export$c1b6b5136be58045;
                        depthType = attributes.stencil ? $084574008ccedf86$export$6c8ea339bfab1301 : $084574008ccedf86$export$c3c7fc4518ebba96;
                    }
                    const projectionlayerInit = {
                        colorFormat: renderer.outputEncoding === $084574008ccedf86$export$f32388edbb32674 ? 35907 : 32856,
                        depthFormat: glDepthFormat,
                        scaleFactor: framebufferScaleFactor
                    };
                    glBinding = new XRWebGLBinding(session, gl);
                    glProjLayer = glBinding.createProjectionLayer(projectionlayerInit);
                    session.updateRenderState({
                        layers: [
                            glProjLayer
                        ]
                    });
                    newRenderTarget = new $084574008ccedf86$export$3c052beb2e51e23f(glProjLayer.textureWidth, glProjLayer.textureHeight, {
                        format: $084574008ccedf86$export$3f8bb04b555a363c,
                        type: $084574008ccedf86$export$2e8ce08d3f6f5e10,
                        depthTexture: new $084574008ccedf86$export$fc830aa069cc8c2f(glProjLayer.textureWidth, glProjLayer.textureHeight, depthType, undefined, undefined, undefined, undefined, undefined, undefined, depthFormat),
                        stencilBuffer: attributes.stencil,
                        encoding: renderer.outputEncoding,
                        samples: attributes.antialias ? 4 : 0
                    });
                    const renderTargetProperties = renderer.properties.get(newRenderTarget);
                    renderTargetProperties.__ignoreDepthValues = glProjLayer.ignoreDepthValues;
                }
                newRenderTarget.isXRRenderTarget = true; // TODO Remove this when possible, see #23278
                // Set foveation to maximum.
                this.setFoveation(1.0);
                customReferenceSpace = null;
                referenceSpace = await session.requestReferenceSpace(referenceSpaceType);
                animation.setContext(session);
                animation.start();
                scope.isPresenting = true;
                scope.dispatchEvent({
                    type: "sessionstart"
                });
            }
        };
        function onInputSourcesChange(event) {
            const inputSources = session.inputSources;
            // Assign controllers to available inputSources
            for(let i156 = 0; i156 < inputSources.length; i156++){
                const index = inputSources[i156].handedness === "right" ? 1 : 0;
                inputSourcesMap.set(inputSources[i156], controllers[index]);
            }
            // Notify disconnected
            for(let i154 = 0; i154 < event.removed.length; i154++){
                const inputSource = event.removed[i154];
                const controller = inputSourcesMap.get(inputSource);
                if (controller) {
                    controller.dispatchEvent({
                        type: "disconnected",
                        data: inputSource
                    });
                    inputSourcesMap.delete(inputSource);
                }
            }
            // Notify connected
            for(let i155 = 0; i155 < event.added.length; i155++){
                const inputSource = event.added[i155];
                const controller = inputSourcesMap.get(inputSource);
                if (controller) controller.dispatchEvent({
                    type: "connected",
                    data: inputSource
                });
            }
        }
        //
        const cameraLPos = new $084574008ccedf86$export$64b5c384219d3699();
        const cameraRPos = new $084574008ccedf86$export$64b5c384219d3699();
        /**
		 * Assumes 2 cameras that are parallel and share an X-axis, and that
		 * the cameras' projection and world matrices have already been set.
		 * And that near and far planes are identical for both cameras.
		 * Visualization of this technique: https://computergraphics.stackexchange.com/a/4765
		 */ function setProjectionFromUnion(camera, cameraL, cameraR) {
            cameraLPos.setFromMatrixPosition(cameraL.matrixWorld);
            cameraRPos.setFromMatrixPosition(cameraR.matrixWorld);
            const ipd = cameraLPos.distanceTo(cameraRPos);
            const projL = cameraL.projectionMatrix.elements;
            const projR = cameraR.projectionMatrix.elements;
            // VR systems will have identical far and near planes, and
            // most likely identical top and bottom frustum extents.
            // Use the left camera for these values.
            const near = projL[14] / (projL[10] - 1);
            const far = projL[14] / (projL[10] + 1);
            const topFov = (projL[9] + 1) / projL[5];
            const bottomFov = (projL[9] - 1) / projL[5];
            const leftFov = (projL[8] - 1) / projL[0];
            const rightFov = (projR[8] + 1) / projR[0];
            const left = near * leftFov;
            const right = near * rightFov;
            // Calculate the new camera's position offset from the
            // left camera. xOffset should be roughly half `ipd`.
            const zOffset = ipd / (-leftFov + rightFov);
            const xOffset = zOffset * -leftFov;
            // TODO: Better way to apply this offset?
            cameraL.matrixWorld.decompose(camera.position, camera.quaternion, camera.scale);
            camera.translateX(xOffset);
            camera.translateZ(zOffset);
            camera.matrixWorld.compose(camera.position, camera.quaternion, camera.scale);
            camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
            // Find the union of the frustum values of the cameras and scale
            // the values so that the near plane's position does not change in world space,
            // although must now be relative to the new union camera.
            const near2 = near + zOffset;
            const far2 = far + zOffset;
            const left2 = left - xOffset;
            const right2 = right + (ipd - xOffset);
            const top2 = topFov * far / far2 * near2;
            const bottom2 = bottomFov * far / far2 * near2;
            camera.projectionMatrix.makePerspective(left2, right2, top2, bottom2, near2, far2);
        }
        function updateCamera(camera, parent) {
            if (parent === null) camera.matrixWorld.copy(camera.matrix);
            else camera.matrixWorld.multiplyMatrices(parent.matrixWorld, camera.matrix);
            camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
        }
        this.updateCamera = function(camera) {
            if (session === null) return;
            cameraVR.near = cameraR1.near = cameraL1.near = camera.near;
            cameraVR.far = cameraR1.far = cameraL1.far = camera.far;
            if (_currentDepthNear !== cameraVR.near || _currentDepthFar !== cameraVR.far) {
                // Note that the new renderState won't apply until the next frame. See #18320
                session.updateRenderState({
                    depthNear: cameraVR.near,
                    depthFar: cameraVR.far
                });
                _currentDepthNear = cameraVR.near;
                _currentDepthFar = cameraVR.far;
            }
            const parent = camera.parent;
            const cameras = cameraVR.cameras;
            updateCamera(cameraVR, parent);
            for(let i158 = 0; i158 < cameras.length; i158++)updateCamera(cameras[i158], parent);
            cameraVR.matrixWorld.decompose(cameraVR.position, cameraVR.quaternion, cameraVR.scale);
            // update user camera and its children
            camera.position.copy(cameraVR.position);
            camera.quaternion.copy(cameraVR.quaternion);
            camera.scale.copy(cameraVR.scale);
            camera.matrix.copy(cameraVR.matrix);
            camera.matrixWorld.copy(cameraVR.matrixWorld);
            const children = camera.children;
            for(let i157 = 0, l = children.length; i157 < l; i157++)children[i157].updateMatrixWorld(true);
            // update projection matrix for proper view frustum culling
            if (cameras.length === 2) setProjectionFromUnion(cameraVR, cameraL1, cameraR1);
            else // assume single camera setup (AR)
            cameraVR.projectionMatrix.copy(cameraL1.projectionMatrix);
        };
        this.getCamera = function() {
            return cameraVR;
        };
        this.getFoveation = function() {
            if (glProjLayer !== null) return glProjLayer.fixedFoveation;
            if (glBaseLayer !== null) return glBaseLayer.fixedFoveation;
            return undefined;
        };
        this.setFoveation = function(foveation) {
            // 0 = no foveation = full resolution
            // 1 = maximum foveation = the edges render at lower resolution
            if (glProjLayer !== null) glProjLayer.fixedFoveation = foveation;
            if (glBaseLayer !== null && glBaseLayer.fixedFoveation !== undefined) glBaseLayer.fixedFoveation = foveation;
        };
        // Animation Loop
        let onAnimationFrameCallback = null;
        function onAnimationFrame(time, frame) {
            pose = frame.getViewerPose(customReferenceSpace || referenceSpace);
            xrFrame = frame;
            if (pose !== null) {
                const views = pose.views;
                if (glBaseLayer !== null) {
                    renderer.setRenderTargetFramebuffer(newRenderTarget, glBaseLayer.framebuffer);
                    renderer.setRenderTarget(newRenderTarget);
                }
                let cameraVRNeedsUpdate = false;
                // check if it's necessary to rebuild cameraVR's camera list
                if (views.length !== cameraVR.cameras.length) {
                    cameraVR.cameras.length = 0;
                    cameraVRNeedsUpdate = true;
                }
                for(let i159 = 0; i159 < views.length; i159++){
                    const view = views[i159];
                    let viewport = null;
                    if (glBaseLayer !== null) viewport = glBaseLayer.getViewport(view);
                    else {
                        const glSubImage = glBinding.getViewSubImage(glProjLayer, view);
                        viewport = glSubImage.viewport;
                        // For side-by-side projection, we only produce a single texture for both eyes.
                        if (i159 === 0) {
                            renderer.setRenderTargetTextures(newRenderTarget, glSubImage.colorTexture, glProjLayer.ignoreDepthValues ? undefined : glSubImage.depthStencilTexture);
                            renderer.setRenderTarget(newRenderTarget);
                        }
                    }
                    let camera = cameras1[i159];
                    if (camera === undefined) {
                        camera = new $084574008ccedf86$export$74e4ae24825f68d7();
                        camera.layers.enable(i159);
                        camera.viewport = new $084574008ccedf86$export$fa7daccca11cdbe3();
                        cameras1[i159] = camera;
                    }
                    camera.matrix.fromArray(view.transform.matrix);
                    camera.projectionMatrix.fromArray(view.projectionMatrix);
                    camera.viewport.set(viewport.x, viewport.y, viewport.width, viewport.height);
                    if (i159 === 0) cameraVR.matrix.copy(camera.matrix);
                    if (cameraVRNeedsUpdate === true) cameraVR.cameras.push(camera);
                }
            }
            //
            const inputSources = session.inputSources;
            for(let i160 = 0; i160 < controllers.length; i160++){
                const inputSource = inputSources[i160];
                const controller = inputSourcesMap.get(inputSource);
                if (controller !== undefined) controller.update(inputSource, frame, customReferenceSpace || referenceSpace);
            }
            if (onAnimationFrameCallback) onAnimationFrameCallback(time, frame);
            xrFrame = null;
        }
        const animation = new $084574008ccedf86$var$WebGLAnimation();
        animation.setAnimationLoop(onAnimationFrame);
        this.setAnimationLoop = function(callback) {
            onAnimationFrameCallback = callback;
        };
        this.dispose = function() {};
    }
}
function $084574008ccedf86$var$WebGLMaterials(renderer, properties) {
    function refreshFogUniforms(uniforms, fog) {
        uniforms.fogColor.value.copy(fog.color);
        if (fog.isFog) {
            uniforms.fogNear.value = fog.near;
            uniforms.fogFar.value = fog.far;
        } else if (fog.isFogExp2) uniforms.fogDensity.value = fog.density;
    }
    function refreshMaterialUniforms(uniforms, material, pixelRatio, height, transmissionRenderTarget) {
        if (material.isMeshBasicMaterial) refreshUniformsCommon(uniforms, material);
        else if (material.isMeshLambertMaterial) refreshUniformsCommon(uniforms, material);
        else if (material.isMeshToonMaterial) {
            refreshUniformsCommon(uniforms, material);
            refreshUniformsToon(uniforms, material);
        } else if (material.isMeshPhongMaterial) {
            refreshUniformsCommon(uniforms, material);
            refreshUniformsPhong(uniforms, material);
        } else if (material.isMeshStandardMaterial) {
            refreshUniformsCommon(uniforms, material);
            refreshUniformsStandard(uniforms, material);
            if (material.isMeshPhysicalMaterial) refreshUniformsPhysical(uniforms, material, transmissionRenderTarget);
        } else if (material.isMeshMatcapMaterial) {
            refreshUniformsCommon(uniforms, material);
            refreshUniformsMatcap(uniforms, material);
        } else if (material.isMeshDepthMaterial) refreshUniformsCommon(uniforms, material);
        else if (material.isMeshDistanceMaterial) {
            refreshUniformsCommon(uniforms, material);
            refreshUniformsDistance(uniforms, material);
        } else if (material.isMeshNormalMaterial) refreshUniformsCommon(uniforms, material);
        else if (material.isLineBasicMaterial) {
            refreshUniformsLine(uniforms, material);
            if (material.isLineDashedMaterial) refreshUniformsDash(uniforms, material);
        } else if (material.isPointsMaterial) refreshUniformsPoints(uniforms, material, pixelRatio, height);
        else if (material.isSpriteMaterial) refreshUniformsSprites(uniforms, material);
        else if (material.isShadowMaterial) {
            uniforms.color.value.copy(material.color);
            uniforms.opacity.value = material.opacity;
        } else if (material.isShaderMaterial) material.uniformsNeedUpdate = false; // #15581
    }
    function refreshUniformsCommon(uniforms, material) {
        uniforms.opacity.value = material.opacity;
        if (material.color) uniforms.diffuse.value.copy(material.color);
        if (material.emissive) uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);
        if (material.map) uniforms.map.value = material.map;
        if (material.alphaMap) uniforms.alphaMap.value = material.alphaMap;
        if (material.bumpMap) {
            uniforms.bumpMap.value = material.bumpMap;
            uniforms.bumpScale.value = material.bumpScale;
            if (material.side === $084574008ccedf86$export$d9f0486e75b5ace) uniforms.bumpScale.value *= -1;
        }
        if (material.displacementMap) {
            uniforms.displacementMap.value = material.displacementMap;
            uniforms.displacementScale.value = material.displacementScale;
            uniforms.displacementBias.value = material.displacementBias;
        }
        if (material.emissiveMap) uniforms.emissiveMap.value = material.emissiveMap;
        if (material.normalMap) {
            uniforms.normalMap.value = material.normalMap;
            uniforms.normalScale.value.copy(material.normalScale);
            if (material.side === $084574008ccedf86$export$d9f0486e75b5ace) uniforms.normalScale.value.negate();
        }
        if (material.specularMap) uniforms.specularMap.value = material.specularMap;
        if (material.alphaTest > 0) uniforms.alphaTest.value = material.alphaTest;
        const envMap = properties.get(material).envMap;
        if (envMap) {
            uniforms.envMap.value = envMap;
            uniforms.flipEnvMap.value = envMap.isCubeTexture && envMap.isRenderTargetTexture === false ? -1 : 1;
            uniforms.reflectivity.value = material.reflectivity;
            uniforms.ior.value = material.ior;
            uniforms.refractionRatio.value = material.refractionRatio;
        }
        if (material.lightMap) {
            uniforms.lightMap.value = material.lightMap;
            // artist-friendly light intensity scaling factor
            const scaleFactor = renderer.physicallyCorrectLights !== true ? Math.PI : 1;
            uniforms.lightMapIntensity.value = material.lightMapIntensity * scaleFactor;
        }
        if (material.aoMap) {
            uniforms.aoMap.value = material.aoMap;
            uniforms.aoMapIntensity.value = material.aoMapIntensity;
        }
        // uv repeat and offset setting priorities
        // 1. color map
        // 2. specular map
        // 3. displacementMap map
        // 4. normal map
        // 5. bump map
        // 6. roughnessMap map
        // 7. metalnessMap map
        // 8. alphaMap map
        // 9. emissiveMap map
        // 10. clearcoat map
        // 11. clearcoat normal map
        // 12. clearcoat roughnessMap map
        // 13. iridescence map
        // 14. iridescence thickness map
        // 15. specular intensity map
        // 16. specular tint map
        // 17. transmission map
        // 18. thickness map
        let uvScaleMap;
        if (material.map) uvScaleMap = material.map;
        else if (material.specularMap) uvScaleMap = material.specularMap;
        else if (material.displacementMap) uvScaleMap = material.displacementMap;
        else if (material.normalMap) uvScaleMap = material.normalMap;
        else if (material.bumpMap) uvScaleMap = material.bumpMap;
        else if (material.roughnessMap) uvScaleMap = material.roughnessMap;
        else if (material.metalnessMap) uvScaleMap = material.metalnessMap;
        else if (material.alphaMap) uvScaleMap = material.alphaMap;
        else if (material.emissiveMap) uvScaleMap = material.emissiveMap;
        else if (material.clearcoatMap) uvScaleMap = material.clearcoatMap;
        else if (material.clearcoatNormalMap) uvScaleMap = material.clearcoatNormalMap;
        else if (material.clearcoatRoughnessMap) uvScaleMap = material.clearcoatRoughnessMap;
        else if (material.iridescenceMap) uvScaleMap = material.iridescenceMap;
        else if (material.iridescenceThicknessMap) uvScaleMap = material.iridescenceThicknessMap;
        else if (material.specularIntensityMap) uvScaleMap = material.specularIntensityMap;
        else if (material.specularColorMap) uvScaleMap = material.specularColorMap;
        else if (material.transmissionMap) uvScaleMap = material.transmissionMap;
        else if (material.thicknessMap) uvScaleMap = material.thicknessMap;
        else if (material.sheenColorMap) uvScaleMap = material.sheenColorMap;
        else if (material.sheenRoughnessMap) uvScaleMap = material.sheenRoughnessMap;
        if (uvScaleMap !== undefined) {
            // backwards compatibility
            if (uvScaleMap.isWebGLRenderTarget) uvScaleMap = uvScaleMap.texture;
            if (uvScaleMap.matrixAutoUpdate === true) uvScaleMap.updateMatrix();
            uniforms.uvTransform.value.copy(uvScaleMap.matrix);
        }
        // uv repeat and offset setting priorities for uv2
        // 1. ao map
        // 2. light map
        let uv2ScaleMap;
        if (material.aoMap) uv2ScaleMap = material.aoMap;
        else if (material.lightMap) uv2ScaleMap = material.lightMap;
        if (uv2ScaleMap !== undefined) {
            // backwards compatibility
            if (uv2ScaleMap.isWebGLRenderTarget) uv2ScaleMap = uv2ScaleMap.texture;
            if (uv2ScaleMap.matrixAutoUpdate === true) uv2ScaleMap.updateMatrix();
            uniforms.uv2Transform.value.copy(uv2ScaleMap.matrix);
        }
    }
    function refreshUniformsLine(uniforms, material) {
        uniforms.diffuse.value.copy(material.color);
        uniforms.opacity.value = material.opacity;
    }
    function refreshUniformsDash(uniforms, material) {
        uniforms.dashSize.value = material.dashSize;
        uniforms.totalSize.value = material.dashSize + material.gapSize;
        uniforms.scale.value = material.scale;
    }
    function refreshUniformsPoints(uniforms, material, pixelRatio, height) {
        uniforms.diffuse.value.copy(material.color);
        uniforms.opacity.value = material.opacity;
        uniforms.size.value = material.size * pixelRatio;
        uniforms.scale.value = height * 0.5;
        if (material.map) uniforms.map.value = material.map;
        if (material.alphaMap) uniforms.alphaMap.value = material.alphaMap;
        if (material.alphaTest > 0) uniforms.alphaTest.value = material.alphaTest;
        // uv repeat and offset setting priorities
        // 1. color map
        // 2. alpha map
        let uvScaleMap;
        if (material.map) uvScaleMap = material.map;
        else if (material.alphaMap) uvScaleMap = material.alphaMap;
        if (uvScaleMap !== undefined) {
            if (uvScaleMap.matrixAutoUpdate === true) uvScaleMap.updateMatrix();
            uniforms.uvTransform.value.copy(uvScaleMap.matrix);
        }
    }
    function refreshUniformsSprites(uniforms, material) {
        uniforms.diffuse.value.copy(material.color);
        uniforms.opacity.value = material.opacity;
        uniforms.rotation.value = material.rotation;
        if (material.map) uniforms.map.value = material.map;
        if (material.alphaMap) uniforms.alphaMap.value = material.alphaMap;
        if (material.alphaTest > 0) uniforms.alphaTest.value = material.alphaTest;
        // uv repeat and offset setting priorities
        // 1. color map
        // 2. alpha map
        let uvScaleMap;
        if (material.map) uvScaleMap = material.map;
        else if (material.alphaMap) uvScaleMap = material.alphaMap;
        if (uvScaleMap !== undefined) {
            if (uvScaleMap.matrixAutoUpdate === true) uvScaleMap.updateMatrix();
            uniforms.uvTransform.value.copy(uvScaleMap.matrix);
        }
    }
    function refreshUniformsPhong(uniforms, material) {
        uniforms.specular.value.copy(material.specular);
        uniforms.shininess.value = Math.max(material.shininess, 1e-4); // to prevent pow( 0.0, 0.0 )
    }
    function refreshUniformsToon(uniforms, material) {
        if (material.gradientMap) uniforms.gradientMap.value = material.gradientMap;
    }
    function refreshUniformsStandard(uniforms, material) {
        uniforms.roughness.value = material.roughness;
        uniforms.metalness.value = material.metalness;
        if (material.roughnessMap) uniforms.roughnessMap.value = material.roughnessMap;
        if (material.metalnessMap) uniforms.metalnessMap.value = material.metalnessMap;
        const envMap = properties.get(material).envMap;
        if (envMap) //uniforms.envMap.value = material.envMap; // part of uniforms common
        uniforms.envMapIntensity.value = material.envMapIntensity;
    }
    function refreshUniformsPhysical(uniforms, material, transmissionRenderTarget) {
        uniforms.ior.value = material.ior; // also part of uniforms common
        if (material.sheen > 0) {
            uniforms.sheenColor.value.copy(material.sheenColor).multiplyScalar(material.sheen);
            uniforms.sheenRoughness.value = material.sheenRoughness;
            if (material.sheenColorMap) uniforms.sheenColorMap.value = material.sheenColorMap;
            if (material.sheenRoughnessMap) uniforms.sheenRoughnessMap.value = material.sheenRoughnessMap;
        }
        if (material.clearcoat > 0) {
            uniforms.clearcoat.value = material.clearcoat;
            uniforms.clearcoatRoughness.value = material.clearcoatRoughness;
            if (material.clearcoatMap) uniforms.clearcoatMap.value = material.clearcoatMap;
            if (material.clearcoatRoughnessMap) uniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap;
            if (material.clearcoatNormalMap) {
                uniforms.clearcoatNormalScale.value.copy(material.clearcoatNormalScale);
                uniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;
                if (material.side === $084574008ccedf86$export$d9f0486e75b5ace) uniforms.clearcoatNormalScale.value.negate();
            }
        }
        if (material.iridescence > 0) {
            uniforms.iridescence.value = material.iridescence;
            uniforms.iridescenceIOR.value = material.iridescenceIOR;
            uniforms.iridescenceThicknessMinimum.value = material.iridescenceThicknessRange[0];
            uniforms.iridescenceThicknessMaximum.value = material.iridescenceThicknessRange[1];
            if (material.iridescenceMap) uniforms.iridescenceMap.value = material.iridescenceMap;
            if (material.iridescenceThicknessMap) uniforms.iridescenceThicknessMap.value = material.iridescenceThicknessMap;
        }
        if (material.transmission > 0) {
            uniforms.transmission.value = material.transmission;
            uniforms.transmissionSamplerMap.value = transmissionRenderTarget.texture;
            uniforms.transmissionSamplerSize.value.set(transmissionRenderTarget.width, transmissionRenderTarget.height);
            if (material.transmissionMap) uniforms.transmissionMap.value = material.transmissionMap;
            uniforms.thickness.value = material.thickness;
            if (material.thicknessMap) uniforms.thicknessMap.value = material.thicknessMap;
            uniforms.attenuationDistance.value = material.attenuationDistance;
            uniforms.attenuationColor.value.copy(material.attenuationColor);
        }
        uniforms.specularIntensity.value = material.specularIntensity;
        uniforms.specularColor.value.copy(material.specularColor);
        if (material.specularIntensityMap) uniforms.specularIntensityMap.value = material.specularIntensityMap;
        if (material.specularColorMap) uniforms.specularColorMap.value = material.specularColorMap;
    }
    function refreshUniformsMatcap(uniforms, material) {
        if (material.matcap) uniforms.matcap.value = material.matcap;
    }
    function refreshUniformsDistance(uniforms, material) {
        uniforms.referencePosition.value.copy(material.referencePosition);
        uniforms.nearDistance.value = material.nearDistance;
        uniforms.farDistance.value = material.farDistance;
    }
    return {
        refreshFogUniforms: refreshFogUniforms,
        refreshMaterialUniforms: refreshMaterialUniforms
    };
}
function $084574008ccedf86$var$createCanvasElement() {
    const canvas = $084574008ccedf86$var$createElementNS("canvas");
    canvas.style.display = "block";
    return canvas;
}
function $084574008ccedf86$export$f6cc00ef28d7cf97(parameters1 = {}) {
    this.isWebGLRenderer = true;
    const _canvas2 = parameters1.canvas !== undefined ? parameters1.canvas : $084574008ccedf86$var$createCanvasElement(), _context1 = parameters1.context !== undefined ? parameters1.context : null, _depth = parameters1.depth !== undefined ? parameters1.depth : true, _stencil = parameters1.stencil !== undefined ? parameters1.stencil : true, _antialias = parameters1.antialias !== undefined ? parameters1.antialias : false, _premultipliedAlpha = parameters1.premultipliedAlpha !== undefined ? parameters1.premultipliedAlpha : true, _preserveDrawingBuffer = parameters1.preserveDrawingBuffer !== undefined ? parameters1.preserveDrawingBuffer : false, _powerPreference = parameters1.powerPreference !== undefined ? parameters1.powerPreference : "default", _failIfMajorPerformanceCaveat = parameters1.failIfMajorPerformanceCaveat !== undefined ? parameters1.failIfMajorPerformanceCaveat : false;
    let _alpha;
    if (_context1 !== null) _alpha = _context1.getContextAttributes().alpha;
    else _alpha = parameters1.alpha !== undefined ? parameters1.alpha : false;
    let currentRenderList1 = null;
    let currentRenderState = null;
    // render() can be called from within a callback triggered by another render.
    // We track this so that the nested render call gets its list and state isolated from the parent render call.
    const renderListStack = [];
    const renderStateStack = [];
    // public properties
    this.domElement = _canvas2;
    // Debug configuration container
    this.debug = {
        /**
		 * Enables error checking and reporting when shader programs are being compiled
		 * @type {boolean}
		 */ checkShaderErrors: true
    };
    // clearing
    this.autoClear = true;
    this.autoClearColor = true;
    this.autoClearDepth = true;
    this.autoClearStencil = true;
    // scene graph
    this.sortObjects = true;
    // user-defined clipping
    this.clippingPlanes = [];
    this.localClippingEnabled = false;
    // physically based shading
    this.outputEncoding = $084574008ccedf86$export$7207336e4151a112;
    // physical lights
    this.physicallyCorrectLights = false;
    // tone mapping
    this.toneMapping = $084574008ccedf86$export$9fcb6b4294603b2;
    this.toneMappingExposure = 1.0;
    //
    Object.defineProperties(this, {
        // @deprecated since r136, 0e21088102b4de7e0a0a33140620b7a3424b9e6d
        gammaFactor: {
            get: function() {
                console.warn("THREE.WebGLRenderer: .gammaFactor has been removed.");
                return 2;
            },
            set: function() {
                console.warn("THREE.WebGLRenderer: .gammaFactor has been removed.");
            }
        }
    });
    // internal properties
    const _this = this;
    let _isContextLost = false;
    // internal state cache
    let _currentActiveCubeFace = 0;
    let _currentActiveMipmapLevel = 0;
    let _currentRenderTarget = null;
    let _currentMaterialId = -1;
    let _currentCamera = null;
    const _currentViewport = new $084574008ccedf86$export$fa7daccca11cdbe3();
    const _currentScissor = new $084574008ccedf86$export$fa7daccca11cdbe3();
    let _currentScissorTest = null;
    //
    let _width = _canvas2.width;
    let _height = _canvas2.height;
    let _pixelRatio = 1;
    let _opaqueSort = null;
    let _transparentSort = null;
    const _viewport = new $084574008ccedf86$export$fa7daccca11cdbe3(0, 0, _width, _height);
    const _scissor = new $084574008ccedf86$export$fa7daccca11cdbe3(0, 0, _width, _height);
    let _scissorTest = false;
    // frustum
    const _frustum = new $084574008ccedf86$export$35efe6f4c85463d2();
    // clipping
    let _clippingEnabled = false;
    let _localClippingEnabled = false;
    // transmission
    let _transmissionRenderTarget = null;
    // camera matrices cache
    const _projScreenMatrix1 = new $084574008ccedf86$export$2ae72fc923e5eb5();
    const _vector21 = new $084574008ccedf86$export$c977b3e384af9ae1();
    const _vector3 = new $084574008ccedf86$export$64b5c384219d3699();
    const _emptyScene = {
        background: null,
        fog: null,
        environment: null,
        overrideMaterial: null,
        isScene: true
    };
    function getTargetPixelRatio() {
        return _currentRenderTarget === null ? _pixelRatio : 1;
    }
    // initialize
    let _gl = _context1;
    function getContext(contextNames, contextAttributes) {
        for(let i161 = 0; i161 < contextNames.length; i161++){
            const contextName = contextNames[i161];
            const context = _canvas2.getContext(contextName, contextAttributes);
            if (context !== null) return context;
        }
        return null;
    }
    try {
        const contextAttributes = {
            alpha: true,
            depth: _depth,
            stencil: _stencil,
            antialias: _antialias,
            premultipliedAlpha: _premultipliedAlpha,
            preserveDrawingBuffer: _preserveDrawingBuffer,
            powerPreference: _powerPreference,
            failIfMajorPerformanceCaveat: _failIfMajorPerformanceCaveat
        };
        // OffscreenCanvas does not have setAttribute, see #22811
        if ("setAttribute" in _canvas2) _canvas2.setAttribute("data-engine", `three.js r${$084574008ccedf86$export$3545e07a80636437}`);
        // event listeners must be registered before WebGL context is created, see #12753
        _canvas2.addEventListener("webglcontextlost", onContextLost, false);
        _canvas2.addEventListener("webglcontextrestored", onContextRestore, false);
        _canvas2.addEventListener("webglcontextcreationerror", onContextCreationError, false);
        if (_gl === null) {
            const contextNames = [
                "webgl2",
                "webgl",
                "experimental-webgl"
            ];
            if (_this.isWebGL1Renderer === true) contextNames.shift();
            _gl = getContext(contextNames, contextAttributes);
            if (_gl === null) {
                if (getContext(contextNames)) throw new Error("Error creating WebGL context with your selected attributes.");
                else throw new Error("Error creating WebGL context.");
            }
        }
        // Some experimental-webgl implementations do not have getShaderPrecisionFormat
        if (_gl.getShaderPrecisionFormat === undefined) _gl.getShaderPrecisionFormat = function() {
            return {
                "rangeMin": 1,
                "rangeMax": 1,
                "precision": 1
            };
        };
    } catch (error) {
        console.error("THREE.WebGLRenderer: " + error.message);
        throw error;
    }
    let extensions, capabilities, state, info;
    let properties, textures, cubemaps, cubeuvmaps, attributes, geometries, objects;
    let programCache, materials, renderLists, renderStates, clipping, shadowMap;
    let background, morphtargets, bufferRenderer, indexedBufferRenderer;
    let utils, bindingStates;
    function initGLContext() {
        extensions = new $084574008ccedf86$var$WebGLExtensions(_gl);
        capabilities = new $084574008ccedf86$var$WebGLCapabilities(_gl, extensions, parameters1);
        extensions.init(capabilities);
        utils = new $084574008ccedf86$export$ddaebcad857649a8(_gl, extensions, capabilities);
        state = new $084574008ccedf86$var$WebGLState(_gl, extensions, capabilities);
        info = new $084574008ccedf86$var$WebGLInfo(_gl);
        properties = new $084574008ccedf86$var$WebGLProperties();
        textures = new $084574008ccedf86$var$WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info);
        cubemaps = new $084574008ccedf86$var$WebGLCubeMaps(_this);
        cubeuvmaps = new $084574008ccedf86$var$WebGLCubeUVMaps(_this);
        attributes = new $084574008ccedf86$var$WebGLAttributes(_gl, capabilities);
        bindingStates = new $084574008ccedf86$var$WebGLBindingStates(_gl, extensions, attributes, capabilities);
        geometries = new $084574008ccedf86$var$WebGLGeometries(_gl, attributes, info, bindingStates);
        objects = new $084574008ccedf86$var$WebGLObjects(_gl, geometries, attributes, info);
        morphtargets = new $084574008ccedf86$var$WebGLMorphtargets(_gl, capabilities, textures);
        clipping = new $084574008ccedf86$var$WebGLClipping(properties);
        programCache = new $084574008ccedf86$var$WebGLPrograms(_this, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping);
        materials = new $084574008ccedf86$var$WebGLMaterials(_this, properties);
        renderLists = new $084574008ccedf86$var$WebGLRenderLists();
        renderStates = new $084574008ccedf86$var$WebGLRenderStates(extensions, capabilities);
        background = new $084574008ccedf86$var$WebGLBackground(_this, cubemaps, state, objects, _alpha, _premultipliedAlpha);
        shadowMap = new $084574008ccedf86$var$WebGLShadowMap(_this, objects, capabilities);
        bufferRenderer = new $084574008ccedf86$var$WebGLBufferRenderer(_gl, extensions, info, capabilities);
        indexedBufferRenderer = new $084574008ccedf86$var$WebGLIndexedBufferRenderer(_gl, extensions, info, capabilities);
        info.programs = programCache.programs;
        _this.capabilities = capabilities;
        _this.extensions = extensions;
        _this.properties = properties;
        _this.renderLists = renderLists;
        _this.shadowMap = shadowMap;
        _this.state = state;
        _this.info = info;
    }
    initGLContext();
    // xr
    const xr = new $084574008ccedf86$var$WebXRManager(_this, _gl);
    this.xr = xr;
    // API
    this.getContext = function() {
        return _gl;
    };
    this.getContextAttributes = function() {
        return _gl.getContextAttributes();
    };
    this.forceContextLoss = function() {
        const extension = extensions.get("WEBGL_lose_context");
        if (extension) extension.loseContext();
    };
    this.forceContextRestore = function() {
        const extension = extensions.get("WEBGL_lose_context");
        if (extension) extension.restoreContext();
    };
    this.getPixelRatio = function() {
        return _pixelRatio;
    };
    this.setPixelRatio = function(value) {
        if (value === undefined) return;
        _pixelRatio = value;
        this.setSize(_width, _height, false);
    };
    this.getSize = function(target) {
        return target.set(_width, _height);
    };
    this.setSize = function(width, height, updateStyle) {
        if (xr.isPresenting) {
            console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
            return;
        }
        _width = width;
        _height = height;
        _canvas2.width = Math.floor(width * _pixelRatio);
        _canvas2.height = Math.floor(height * _pixelRatio);
        if (updateStyle !== false) {
            _canvas2.style.width = width + "px";
            _canvas2.style.height = height + "px";
        }
        this.setViewport(0, 0, width, height);
    };
    this.getDrawingBufferSize = function(target) {
        return target.set(_width * _pixelRatio, _height * _pixelRatio).floor();
    };
    this.setDrawingBufferSize = function(width, height, pixelRatio) {
        _width = width;
        _height = height;
        _pixelRatio = pixelRatio;
        _canvas2.width = Math.floor(width * pixelRatio);
        _canvas2.height = Math.floor(height * pixelRatio);
        this.setViewport(0, 0, width, height);
    };
    this.getCurrentViewport = function(target) {
        return target.copy(_currentViewport);
    };
    this.getViewport = function(target) {
        return target.copy(_viewport);
    };
    this.setViewport = function(x, y, width, height) {
        if (x.isVector4) _viewport.set(x.x, x.y, x.z, x.w);
        else _viewport.set(x, y, width, height);
        state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor());
    };
    this.getScissor = function(target) {
        return target.copy(_scissor);
    };
    this.setScissor = function(x, y, width, height) {
        if (x.isVector4) _scissor.set(x.x, x.y, x.z, x.w);
        else _scissor.set(x, y, width, height);
        state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor());
    };
    this.getScissorTest = function() {
        return _scissorTest;
    };
    this.setScissorTest = function(boolean) {
        state.setScissorTest(_scissorTest = boolean);
    };
    this.setOpaqueSort = function(method) {
        _opaqueSort = method;
    };
    this.setTransparentSort = function(method) {
        _transparentSort = method;
    };
    // Clearing
    this.getClearColor = function(target) {
        return target.copy(background.getClearColor());
    };
    this.setClearColor = function() {
        background.setClearColor.apply(background, arguments);
    };
    this.getClearAlpha = function() {
        return background.getClearAlpha();
    };
    this.setClearAlpha = function() {
        background.setClearAlpha.apply(background, arguments);
    };
    this.clear = function(color = true, depth = true, stencil = true) {
        let bits = 0;
        if (color) bits |= 16384;
        if (depth) bits |= 256;
        if (stencil) bits |= 1024;
        _gl.clear(bits);
    };
    this.clearColor = function() {
        this.clear(true, false, false);
    };
    this.clearDepth = function() {
        this.clear(false, true, false);
    };
    this.clearStencil = function() {
        this.clear(false, false, true);
    };
    //
    this.dispose = function() {
        _canvas2.removeEventListener("webglcontextlost", onContextLost, false);
        _canvas2.removeEventListener("webglcontextrestored", onContextRestore, false);
        _canvas2.removeEventListener("webglcontextcreationerror", onContextCreationError, false);
        renderLists.dispose();
        renderStates.dispose();
        properties.dispose();
        cubemaps.dispose();
        cubeuvmaps.dispose();
        objects.dispose();
        bindingStates.dispose();
        programCache.dispose();
        xr.dispose();
        xr.removeEventListener("sessionstart", onXRSessionStart);
        xr.removeEventListener("sessionend", onXRSessionEnd);
        if (_transmissionRenderTarget) {
            _transmissionRenderTarget.dispose();
            _transmissionRenderTarget = null;
        }
        animation.stop();
    };
    // Events
    function onContextLost(event) {
        event.preventDefault();
        console.log("THREE.WebGLRenderer: Context Lost.");
        _isContextLost = true;
    }
    function onContextRestore() {
        console.log("THREE.WebGLRenderer: Context Restored.");
        _isContextLost = false;
        const infoAutoReset = info.autoReset;
        const shadowMapEnabled = shadowMap.enabled;
        const shadowMapAutoUpdate = shadowMap.autoUpdate;
        const shadowMapNeedsUpdate = shadowMap.needsUpdate;
        const shadowMapType = shadowMap.type;
        initGLContext();
        info.autoReset = infoAutoReset;
        shadowMap.enabled = shadowMapEnabled;
        shadowMap.autoUpdate = shadowMapAutoUpdate;
        shadowMap.needsUpdate = shadowMapNeedsUpdate;
        shadowMap.type = shadowMapType;
    }
    function onContextCreationError(event) {
        console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", event.statusMessage);
    }
    function onMaterialDispose(event) {
        const material = event.target;
        material.removeEventListener("dispose", onMaterialDispose);
        deallocateMaterial(material);
    }
    // Buffer deallocation
    function deallocateMaterial(material) {
        releaseMaterialProgramReferences(material);
        properties.remove(material);
    }
    function releaseMaterialProgramReferences(material) {
        const programs = properties.get(material).programs;
        if (programs !== undefined) {
            programs.forEach(function(program) {
                programCache.releaseProgram(program);
            });
            if (material.isShaderMaterial) programCache.releaseShaderCache(material);
        }
    }
    // Buffer rendering
    this.renderBufferDirect = function(camera, scene, geometry, material, object, group) {
        if (scene === null) scene = _emptyScene; // renderBufferDirect second parameter used to be fog (could be null)
        const frontFaceCW = object.isMesh && object.matrixWorld.determinant() < 0;
        const program = setProgram(camera, scene, geometry, material, object);
        state.setMaterial(material, frontFaceCW);
        //
        let index = geometry.index;
        const position = geometry.attributes.position;
        //
        if (index === null) {
            if (position === undefined || position.count === 0) return;
        } else if (index.count === 0) return;
        //
        let rangeFactor = 1;
        if (material.wireframe === true) {
            index = geometries.getWireframeAttribute(geometry);
            rangeFactor = 2;
        }
        bindingStates.setup(object, material, program, geometry, index);
        let attribute;
        let renderer = bufferRenderer;
        if (index !== null) {
            attribute = attributes.get(index);
            renderer = indexedBufferRenderer;
            renderer.setIndex(attribute);
        }
        //
        const dataCount = index !== null ? index.count : position.count;
        const rangeStart = geometry.drawRange.start * rangeFactor;
        const rangeCount = geometry.drawRange.count * rangeFactor;
        const groupStart = group !== null ? group.start * rangeFactor : 0;
        const groupCount = group !== null ? group.count * rangeFactor : Infinity;
        const drawStart = Math.max(rangeStart, groupStart);
        const drawEnd = Math.min(dataCount, rangeStart + rangeCount, groupStart + groupCount) - 1;
        const drawCount = Math.max(0, drawEnd - drawStart + 1);
        if (drawCount === 0) return;
        //
        if (object.isMesh) {
            if (material.wireframe === true) {
                state.setLineWidth(material.wireframeLinewidth * getTargetPixelRatio());
                renderer.setMode(1);
            } else renderer.setMode(4);
        } else if (object.isLine) {
            let lineWidth = material.linewidth;
            if (lineWidth === undefined) lineWidth = 1; // Not using Line*Material
            state.setLineWidth(lineWidth * getTargetPixelRatio());
            if (object.isLineSegments) renderer.setMode(1);
            else if (object.isLineLoop) renderer.setMode(2);
            else renderer.setMode(3);
        } else if (object.isPoints) renderer.setMode(0);
        else if (object.isSprite) renderer.setMode(4);
        if (object.isInstancedMesh) renderer.renderInstances(drawStart, drawCount, object.count);
        else if (geometry.isInstancedBufferGeometry) {
            const instanceCount = Math.min(geometry.instanceCount, geometry._maxInstanceCount);
            renderer.renderInstances(drawStart, drawCount, instanceCount);
        } else renderer.render(drawStart, drawCount);
    };
    // Compile
    this.compile = function(scene, camera) {
        currentRenderState = renderStates.get(scene);
        currentRenderState.init();
        renderStateStack.push(currentRenderState);
        scene.traverseVisible(function(object) {
            if (object.isLight && object.layers.test(camera.layers)) {
                currentRenderState.pushLight(object);
                if (object.castShadow) currentRenderState.pushShadow(object);
            }
        });
        currentRenderState.setupLights(_this.physicallyCorrectLights);
        scene.traverse(function(object) {
            const material = object.material;
            if (material) {
                if (Array.isArray(material)) for(let i162 = 0; i162 < material.length; i162++){
                    const material2 = material[i162];
                    getProgram(material2, scene, object);
                }
                else getProgram(material, scene, object);
            }
        });
        renderStateStack.pop();
        currentRenderState = null;
    };
    // Animation Loop
    let onAnimationFrameCallback = null;
    function onAnimationFrame(time) {
        if (onAnimationFrameCallback) onAnimationFrameCallback(time);
    }
    function onXRSessionStart() {
        animation.stop();
    }
    function onXRSessionEnd() {
        animation.start();
    }
    const animation = new $084574008ccedf86$var$WebGLAnimation();
    animation.setAnimationLoop(onAnimationFrame);
    if (typeof self !== "undefined") animation.setContext(self);
    this.setAnimationLoop = function(callback) {
        onAnimationFrameCallback = callback;
        xr.setAnimationLoop(callback);
        callback === null ? animation.stop() : animation.start();
    };
    xr.addEventListener("sessionstart", onXRSessionStart);
    xr.addEventListener("sessionend", onXRSessionEnd);
    // Rendering
    this.render = function(scene, camera) {
        if (camera !== undefined && camera.isCamera !== true) {
            console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
            return;
        }
        if (_isContextLost === true) return;
        // update scene graph
        if (scene.autoUpdate === true) scene.updateMatrixWorld();
        // update camera matrices and frustum
        if (camera.parent === null) camera.updateMatrixWorld();
        if (xr.enabled === true && xr.isPresenting === true) {
            if (xr.cameraAutoUpdate === true) xr.updateCamera(camera);
            camera = xr.getCamera(); // use XR camera for rendering
        }
        //
        if (scene.isScene === true) scene.onBeforeRender(_this, scene, camera, _currentRenderTarget);
        currentRenderState = renderStates.get(scene, renderStateStack.length);
        currentRenderState.init();
        renderStateStack.push(currentRenderState);
        _projScreenMatrix1.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
        _frustum.setFromProjectionMatrix(_projScreenMatrix1);
        _localClippingEnabled = this.localClippingEnabled;
        _clippingEnabled = clipping.init(this.clippingPlanes, _localClippingEnabled, camera);
        currentRenderList1 = renderLists.get(scene, renderListStack.length);
        currentRenderList1.init();
        renderListStack.push(currentRenderList1);
        projectObject(scene, camera, 0, _this.sortObjects);
        currentRenderList1.finish();
        if (_this.sortObjects === true) currentRenderList1.sort(_opaqueSort, _transparentSort);
        //
        if (_clippingEnabled === true) clipping.beginShadows();
        const shadowsArray = currentRenderState.state.shadowsArray;
        shadowMap.render(shadowsArray, scene, camera);
        if (_clippingEnabled === true) clipping.endShadows();
        //
        if (this.info.autoReset === true) this.info.reset();
        //
        background.render(currentRenderList1, scene);
        // render scene
        currentRenderState.setupLights(_this.physicallyCorrectLights);
        if (camera.isArrayCamera) {
            const cameras = camera.cameras;
            for(let i163 = 0, l = cameras.length; i163 < l; i163++){
                const camera2 = cameras[i163];
                renderScene(currentRenderList1, scene, camera2, camera2.viewport);
            }
        } else renderScene(currentRenderList1, scene, camera);
        //
        if (_currentRenderTarget !== null) {
            // resolve multisample renderbuffers to a single-sample texture if necessary
            textures.updateMultisampleRenderTarget(_currentRenderTarget);
            // Generate mipmap if we're using any kind of mipmap filtering
            textures.updateRenderTargetMipmap(_currentRenderTarget);
        }
        //
        if (scene.isScene === true) scene.onAfterRender(_this, scene, camera);
        // _gl.finish();
        bindingStates.resetDefaultState();
        _currentMaterialId = -1;
        _currentCamera = null;
        renderStateStack.pop();
        if (renderStateStack.length > 0) currentRenderState = renderStateStack[renderStateStack.length - 1];
        else currentRenderState = null;
        renderListStack.pop();
        if (renderListStack.length > 0) currentRenderList1 = renderListStack[renderListStack.length - 1];
        else currentRenderList1 = null;
    };
    function projectObject(object, camera, groupOrder, sortObjects) {
        if (object.visible === false) return;
        const visible = object.layers.test(camera.layers);
        if (visible) {
            if (object.isGroup) groupOrder = object.renderOrder;
            else if (object.isLOD) {
                if (object.autoUpdate === true) object.update(camera);
            } else if (object.isLight) {
                currentRenderState.pushLight(object);
                if (object.castShadow) currentRenderState.pushShadow(object);
            } else if (object.isSprite) {
                if (!object.frustumCulled || _frustum.intersectsSprite(object)) {
                    if (sortObjects) _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix1);
                    const geometry = objects.update(object);
                    const material = object.material;
                    if (material.visible) currentRenderList1.push(object, geometry, material, groupOrder, _vector3.z, null);
                }
            } else if (object.isMesh || object.isLine || object.isPoints) {
                if (object.isSkinnedMesh) // update skeleton only once in a frame
                {
                    if (object.skeleton.frame !== info.render.frame) {
                        object.skeleton.update();
                        object.skeleton.frame = info.render.frame;
                    }
                }
                if (!object.frustumCulled || _frustum.intersectsObject(object)) {
                    if (sortObjects) _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix1);
                    const geometry = objects.update(object);
                    const material = object.material;
                    if (Array.isArray(material)) {
                        const groups = geometry.groups;
                        for(let i164 = 0, l = groups.length; i164 < l; i164++){
                            const group = groups[i164];
                            const groupMaterial = material[group.materialIndex];
                            if (groupMaterial && groupMaterial.visible) currentRenderList1.push(object, geometry, groupMaterial, groupOrder, _vector3.z, group);
                        }
                    } else if (material.visible) currentRenderList1.push(object, geometry, material, groupOrder, _vector3.z, null);
                }
            }
        }
        const children = object.children;
        for(let i165 = 0, l = children.length; i165 < l; i165++)projectObject(children[i165], camera, groupOrder, sortObjects);
    }
    function renderScene(currentRenderList, scene, camera, viewport) {
        const opaqueObjects = currentRenderList.opaque;
        const transmissiveObjects = currentRenderList.transmissive;
        const transparentObjects = currentRenderList.transparent;
        currentRenderState.setupLightsView(camera);
        if (transmissiveObjects.length > 0) renderTransmissionPass(opaqueObjects, scene, camera);
        if (viewport) state.viewport(_currentViewport.copy(viewport));
        if (opaqueObjects.length > 0) renderObjects(opaqueObjects, scene, camera);
        if (transmissiveObjects.length > 0) renderObjects(transmissiveObjects, scene, camera);
        if (transparentObjects.length > 0) renderObjects(transparentObjects, scene, camera);
        // Ensure depth buffer writing is enabled so it can be cleared on next render
        state.buffers.depth.setTest(true);
        state.buffers.depth.setMask(true);
        state.buffers.color.setMask(true);
        state.setPolygonOffset(false);
    }
    function renderTransmissionPass(opaqueObjects, scene, camera) {
        const isWebGL2 = capabilities.isWebGL2;
        if (_transmissionRenderTarget === null) _transmissionRenderTarget = new $084574008ccedf86$export$3c052beb2e51e23f(1, 1, {
            generateMipmaps: true,
            type: extensions.has("EXT_color_buffer_half_float") ? $084574008ccedf86$export$2697304443f382bc : $084574008ccedf86$export$2e8ce08d3f6f5e10,
            minFilter: $084574008ccedf86$export$5d8599b6a933fb1b,
            samples: isWebGL2 && _antialias === true ? 4 : 0
        });
        _this.getDrawingBufferSize(_vector21);
        if (isWebGL2) _transmissionRenderTarget.setSize(_vector21.x, _vector21.y);
        else _transmissionRenderTarget.setSize($084574008ccedf86$var$floorPowerOfTwo(_vector21.x), $084574008ccedf86$var$floorPowerOfTwo(_vector21.y));
        //
        const currentRenderTarget = _this.getRenderTarget();
        _this.setRenderTarget(_transmissionRenderTarget);
        _this.clear();
        // Turn off the features which can affect the frag color for opaque objects pass.
        // Otherwise they are applied twice in opaque objects pass and transmission objects pass.
        const currentToneMapping = _this.toneMapping;
        _this.toneMapping = $084574008ccedf86$export$9fcb6b4294603b2;
        renderObjects(opaqueObjects, scene, camera);
        _this.toneMapping = currentToneMapping;
        textures.updateMultisampleRenderTarget(_transmissionRenderTarget);
        textures.updateRenderTargetMipmap(_transmissionRenderTarget);
        _this.setRenderTarget(currentRenderTarget);
    }
    function renderObjects(renderList, scene, camera) {
        const overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;
        for(let i166 = 0, l = renderList.length; i166 < l; i166++){
            const renderItem = renderList[i166];
            const object = renderItem.object;
            const geometry = renderItem.geometry;
            const material = overrideMaterial === null ? renderItem.material : overrideMaterial;
            const group = renderItem.group;
            if (object.layers.test(camera.layers)) renderObject(object, scene, camera, geometry, material, group);
        }
    }
    function renderObject(object, scene, camera, geometry, material, group) {
        object.onBeforeRender(_this, scene, camera, geometry, material, group);
        object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
        object.normalMatrix.getNormalMatrix(object.modelViewMatrix);
        material.onBeforeRender(_this, scene, camera, geometry, object, group);
        if (material.transparent === true && material.side === $084574008ccedf86$export$3b296b6f144d5b03) {
            material.side = $084574008ccedf86$export$d9f0486e75b5ace;
            material.needsUpdate = true;
            _this.renderBufferDirect(camera, scene, geometry, material, object, group);
            material.side = $084574008ccedf86$export$2ede184fc2998901;
            material.needsUpdate = true;
            _this.renderBufferDirect(camera, scene, geometry, material, object, group);
            material.side = $084574008ccedf86$export$3b296b6f144d5b03;
        } else _this.renderBufferDirect(camera, scene, geometry, material, object, group);
        object.onAfterRender(_this, scene, camera, geometry, material, group);
    }
    function getProgram(material, scene, object) {
        if (scene.isScene !== true) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...
        const materialProperties = properties.get(material);
        const lights = currentRenderState.state.lights;
        const shadowsArray = currentRenderState.state.shadowsArray;
        const lightsStateVersion = lights.state.version;
        const parameters = programCache.getParameters(material, lights.state, shadowsArray, scene, object);
        const programCacheKey = programCache.getProgramCacheKey(parameters);
        let programs = materialProperties.programs;
        // always update environment and fog - changing these trigger an getProgram call, but it's possible that the program doesn't change
        materialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null;
        materialProperties.fog = scene.fog;
        materialProperties.envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || materialProperties.environment);
        if (programs === undefined) {
            // new material
            material.addEventListener("dispose", onMaterialDispose);
            programs = new Map();
            materialProperties.programs = programs;
        }
        let program = programs.get(programCacheKey);
        if (program !== undefined) // early out if program and light state is identical
        {
            if (materialProperties.currentProgram === program && materialProperties.lightsStateVersion === lightsStateVersion) {
                updateCommonMaterialProperties(material, parameters);
                return program;
            }
        } else {
            parameters.uniforms = programCache.getUniforms(material);
            material.onBuild(object, parameters, _this);
            material.onBeforeCompile(parameters, _this);
            program = programCache.acquireProgram(parameters, programCacheKey);
            programs.set(programCacheKey, program);
            materialProperties.uniforms = parameters.uniforms;
        }
        const uniforms = materialProperties.uniforms;
        if (!material.isShaderMaterial && !material.isRawShaderMaterial || material.clipping === true) uniforms.clippingPlanes = clipping.uniform;
        updateCommonMaterialProperties(material, parameters);
        // store the light setup it was created for
        materialProperties.needsLights = materialNeedsLights(material);
        materialProperties.lightsStateVersion = lightsStateVersion;
        if (materialProperties.needsLights) {
            // wire up the material to this renderer's lighting state
            uniforms.ambientLightColor.value = lights.state.ambient;
            uniforms.lightProbe.value = lights.state.probe;
            uniforms.directionalLights.value = lights.state.directional;
            uniforms.directionalLightShadows.value = lights.state.directionalShadow;
            uniforms.spotLights.value = lights.state.spot;
            uniforms.spotLightShadows.value = lights.state.spotShadow;
            uniforms.rectAreaLights.value = lights.state.rectArea;
            uniforms.ltc_1.value = lights.state.rectAreaLTC1;
            uniforms.ltc_2.value = lights.state.rectAreaLTC2;
            uniforms.pointLights.value = lights.state.point;
            uniforms.pointLightShadows.value = lights.state.pointShadow;
            uniforms.hemisphereLights.value = lights.state.hemi;
            uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
            uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
            uniforms.spotShadowMap.value = lights.state.spotShadowMap;
            uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;
            uniforms.pointShadowMap.value = lights.state.pointShadowMap;
            uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;
        // TODO (abelnation): add area lights shadow info to uniforms
        }
        const progUniforms = program.getUniforms();
        const uniformsList = $084574008ccedf86$var$WebGLUniforms.seqWithValue(progUniforms.seq, uniforms);
        materialProperties.currentProgram = program;
        materialProperties.uniformsList = uniformsList;
        return program;
    }
    function updateCommonMaterialProperties(material, parameters) {
        const materialProperties = properties.get(material);
        materialProperties.outputEncoding = parameters.outputEncoding;
        materialProperties.instancing = parameters.instancing;
        materialProperties.skinning = parameters.skinning;
        materialProperties.morphTargets = parameters.morphTargets;
        materialProperties.morphNormals = parameters.morphNormals;
        materialProperties.morphColors = parameters.morphColors;
        materialProperties.morphTargetsCount = parameters.morphTargetsCount;
        materialProperties.numClippingPlanes = parameters.numClippingPlanes;
        materialProperties.numIntersection = parameters.numClipIntersection;
        materialProperties.vertexAlphas = parameters.vertexAlphas;
        materialProperties.vertexTangents = parameters.vertexTangents;
        materialProperties.toneMapping = parameters.toneMapping;
    }
    function setProgram(camera, scene, geometry, material, object) {
        if (scene.isScene !== true) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...
        textures.resetTextureUnits();
        const fog = scene.fog;
        const environment = material.isMeshStandardMaterial ? scene.environment : null;
        const encoding = _currentRenderTarget === null ? _this.outputEncoding : _currentRenderTarget.isXRRenderTarget === true ? _currentRenderTarget.texture.encoding : $084574008ccedf86$export$7207336e4151a112;
        const envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || environment);
        const vertexAlphas = material.vertexColors === true && !!geometry.attributes.color && geometry.attributes.color.itemSize === 4;
        const vertexTangents = !!material.normalMap && !!geometry.attributes.tangent;
        const morphTargets = !!geometry.morphAttributes.position;
        const morphNormals = !!geometry.morphAttributes.normal;
        const morphColors = !!geometry.morphAttributes.color;
        const toneMapping = material.toneMapped ? _this.toneMapping : $084574008ccedf86$export$9fcb6b4294603b2;
        const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
        const morphTargetsCount = morphAttribute !== undefined ? morphAttribute.length : 0;
        const materialProperties = properties.get(material);
        const lights = currentRenderState.state.lights;
        if (_clippingEnabled === true) {
            if (_localClippingEnabled === true || camera !== _currentCamera) {
                const useCache = camera === _currentCamera && material.id === _currentMaterialId;
                // we might want to call this function with some ClippingGroup
                // object instead of the material, once it becomes feasible
                // (#8465, #8379)
                clipping.setState(material, camera, useCache);
            }
        }
        //
        let needsProgramChange = false;
        if (material.version === materialProperties.__version) {
            if (materialProperties.needsLights && materialProperties.lightsStateVersion !== lights.state.version) needsProgramChange = true;
            else if (materialProperties.outputEncoding !== encoding) needsProgramChange = true;
            else if (object.isInstancedMesh && materialProperties.instancing === false) needsProgramChange = true;
            else if (!object.isInstancedMesh && materialProperties.instancing === true) needsProgramChange = true;
            else if (object.isSkinnedMesh && materialProperties.skinning === false) needsProgramChange = true;
            else if (!object.isSkinnedMesh && materialProperties.skinning === true) needsProgramChange = true;
            else if (materialProperties.envMap !== envMap) needsProgramChange = true;
            else if (material.fog === true && materialProperties.fog !== fog) needsProgramChange = true;
            else if (materialProperties.numClippingPlanes !== undefined && (materialProperties.numClippingPlanes !== clipping.numPlanes || materialProperties.numIntersection !== clipping.numIntersection)) needsProgramChange = true;
            else if (materialProperties.vertexAlphas !== vertexAlphas) needsProgramChange = true;
            else if (materialProperties.vertexTangents !== vertexTangents) needsProgramChange = true;
            else if (materialProperties.morphTargets !== morphTargets) needsProgramChange = true;
            else if (materialProperties.morphNormals !== morphNormals) needsProgramChange = true;
            else if (materialProperties.morphColors !== morphColors) needsProgramChange = true;
            else if (materialProperties.toneMapping !== toneMapping) needsProgramChange = true;
            else if (capabilities.isWebGL2 === true && materialProperties.morphTargetsCount !== morphTargetsCount) needsProgramChange = true;
        } else {
            needsProgramChange = true;
            materialProperties.__version = material.version;
        }
        //
        let program = materialProperties.currentProgram;
        if (needsProgramChange === true) program = getProgram(material, scene, object);
        let refreshProgram = false;
        let refreshMaterial = false;
        let refreshLights = false;
        const p_uniforms = program.getUniforms(), m_uniforms = materialProperties.uniforms;
        if (state.useProgram(program.program)) {
            refreshProgram = true;
            refreshMaterial = true;
            refreshLights = true;
        }
        if (material.id !== _currentMaterialId) {
            _currentMaterialId = material.id;
            refreshMaterial = true;
        }
        if (refreshProgram || _currentCamera !== camera) {
            p_uniforms.setValue(_gl, "projectionMatrix", camera.projectionMatrix);
            if (capabilities.logarithmicDepthBuffer) p_uniforms.setValue(_gl, "logDepthBufFC", 2.0 / (Math.log(camera.far + 1.0) / Math.LN2));
            if (_currentCamera !== camera) {
                _currentCamera = camera;
                // lighting uniforms depend on the camera so enforce an update
                // now, in case this material supports lights - or later, when
                // the next material that does gets activated:
                refreshMaterial = true; // set to true on material change
                refreshLights = true; // remains set until update done
            }
            // load material specific uniforms
            // (shader material also gets them for the sake of genericity)
            if (material.isShaderMaterial || material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshStandardMaterial || material.envMap) {
                const uCamPos = p_uniforms.map.cameraPosition;
                if (uCamPos !== undefined) uCamPos.setValue(_gl, _vector3.setFromMatrixPosition(camera.matrixWorld));
            }
            if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial) p_uniforms.setValue(_gl, "isOrthographic", camera.isOrthographicCamera === true);
            if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial || material.isShadowMaterial || object.isSkinnedMesh) p_uniforms.setValue(_gl, "viewMatrix", camera.matrixWorldInverse);
        }
        // skinning and morph target uniforms must be set even if material didn't change
        // auto-setting of texture unit for bone and morph texture must go before other textures
        // otherwise textures used for skinning and morphing can take over texture units reserved for other material textures
        if (object.isSkinnedMesh) {
            p_uniforms.setOptional(_gl, object, "bindMatrix");
            p_uniforms.setOptional(_gl, object, "bindMatrixInverse");
            const skeleton = object.skeleton;
            if (skeleton) {
                if (capabilities.floatVertexTextures) {
                    if (skeleton.boneTexture === null) skeleton.computeBoneTexture();
                    p_uniforms.setValue(_gl, "boneTexture", skeleton.boneTexture, textures);
                    p_uniforms.setValue(_gl, "boneTextureSize", skeleton.boneTextureSize);
                } else console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required.");
            }
        }
        const morphAttributes = geometry.morphAttributes;
        if (morphAttributes.position !== undefined || morphAttributes.normal !== undefined || morphAttributes.color !== undefined && capabilities.isWebGL2 === true) morphtargets.update(object, geometry, material, program);
        if (refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow) {
            materialProperties.receiveShadow = object.receiveShadow;
            p_uniforms.setValue(_gl, "receiveShadow", object.receiveShadow);
        }
        if (refreshMaterial) {
            p_uniforms.setValue(_gl, "toneMappingExposure", _this.toneMappingExposure);
            if (materialProperties.needsLights) // the current material requires lighting info
            // note: all lighting uniforms are always set correctly
            // they simply reference the renderer's state for their
            // values
            //
            // use the current material's .needsUpdate flags to set
            // the GL state when required
            markUniformsLightsNeedsUpdate(m_uniforms, refreshLights);
            // refresh uniforms common to several materials
            if (fog && material.fog === true) materials.refreshFogUniforms(m_uniforms, fog);
            materials.refreshMaterialUniforms(m_uniforms, material, _pixelRatio, _height, _transmissionRenderTarget);
            $084574008ccedf86$var$WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
        }
        if (material.isShaderMaterial && material.uniformsNeedUpdate === true) {
            $084574008ccedf86$var$WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
            material.uniformsNeedUpdate = false;
        }
        if (material.isSpriteMaterial) p_uniforms.setValue(_gl, "center", object.center);
        // common matrices
        p_uniforms.setValue(_gl, "modelViewMatrix", object.modelViewMatrix);
        p_uniforms.setValue(_gl, "normalMatrix", object.normalMatrix);
        p_uniforms.setValue(_gl, "modelMatrix", object.matrixWorld);
        return program;
    }
    // If uniforms are marked as clean, they don't need to be loaded to the GPU.
    function markUniformsLightsNeedsUpdate(uniforms, value) {
        uniforms.ambientLightColor.needsUpdate = value;
        uniforms.lightProbe.needsUpdate = value;
        uniforms.directionalLights.needsUpdate = value;
        uniforms.directionalLightShadows.needsUpdate = value;
        uniforms.pointLights.needsUpdate = value;
        uniforms.pointLightShadows.needsUpdate = value;
        uniforms.spotLights.needsUpdate = value;
        uniforms.spotLightShadows.needsUpdate = value;
        uniforms.rectAreaLights.needsUpdate = value;
        uniforms.hemisphereLights.needsUpdate = value;
    }
    function materialNeedsLights(material) {
        return material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial || material.isShadowMaterial || material.isShaderMaterial && material.lights === true;
    }
    this.getActiveCubeFace = function() {
        return _currentActiveCubeFace;
    };
    this.getActiveMipmapLevel = function() {
        return _currentActiveMipmapLevel;
    };
    this.getRenderTarget = function() {
        return _currentRenderTarget;
    };
    this.setRenderTargetTextures = function(renderTarget, colorTexture, depthTexture) {
        properties.get(renderTarget.texture).__webglTexture = colorTexture;
        properties.get(renderTarget.depthTexture).__webglTexture = depthTexture;
        const renderTargetProperties = properties.get(renderTarget);
        renderTargetProperties.__hasExternalTextures = true;
        if (renderTargetProperties.__hasExternalTextures) {
            renderTargetProperties.__autoAllocateDepthBuffer = depthTexture === undefined;
            if (!renderTargetProperties.__autoAllocateDepthBuffer) // The multisample_render_to_texture extension doesn't work properly if there
            // are midframe flushes and an external depth buffer. Disable use of the extension.
            {
                if (extensions.has("WEBGL_multisampled_render_to_texture") === true) {
                    console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided");
                    renderTargetProperties.__useRenderToTexture = false;
                }
            }
        }
    };
    this.setRenderTargetFramebuffer = function(renderTarget, defaultFramebuffer) {
        const renderTargetProperties = properties.get(renderTarget);
        renderTargetProperties.__webglFramebuffer = defaultFramebuffer;
        renderTargetProperties.__useDefaultFramebuffer = defaultFramebuffer === undefined;
    };
    this.setRenderTarget = function(renderTarget, activeCubeFace = 0, activeMipmapLevel = 0) {
        _currentRenderTarget = renderTarget;
        _currentActiveCubeFace = activeCubeFace;
        _currentActiveMipmapLevel = activeMipmapLevel;
        let useDefaultFramebuffer = true;
        if (renderTarget) {
            const renderTargetProperties = properties.get(renderTarget);
            if (renderTargetProperties.__useDefaultFramebuffer !== undefined) {
                // We need to make sure to rebind the framebuffer.
                state.bindFramebuffer(36160, null);
                useDefaultFramebuffer = false;
            } else if (renderTargetProperties.__webglFramebuffer === undefined) textures.setupRenderTarget(renderTarget);
            else if (renderTargetProperties.__hasExternalTextures) // Color and depth texture must be rebound in order for the swapchain to update.
            textures.rebindTextures(renderTarget, properties.get(renderTarget.texture).__webglTexture, properties.get(renderTarget.depthTexture).__webglTexture);
        }
        let framebuffer = null;
        let isCube = false;
        let isRenderTarget3D = false;
        if (renderTarget) {
            const texture = renderTarget.texture;
            if (texture.isData3DTexture || texture.isDataArrayTexture) isRenderTarget3D = true;
            const __webglFramebuffer = properties.get(renderTarget).__webglFramebuffer;
            if (renderTarget.isWebGLCubeRenderTarget) {
                framebuffer = __webglFramebuffer[activeCubeFace];
                isCube = true;
            } else if (capabilities.isWebGL2 && renderTarget.samples > 0 && textures.useMultisampledRTT(renderTarget) === false) framebuffer = properties.get(renderTarget).__webglMultisampledFramebuffer;
            else framebuffer = __webglFramebuffer;
            _currentViewport.copy(renderTarget.viewport);
            _currentScissor.copy(renderTarget.scissor);
            _currentScissorTest = renderTarget.scissorTest;
        } else {
            _currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor();
            _currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor();
            _currentScissorTest = _scissorTest;
        }
        const framebufferBound = state.bindFramebuffer(36160, framebuffer);
        if (framebufferBound && capabilities.drawBuffers && useDefaultFramebuffer) state.drawBuffers(renderTarget, framebuffer);
        state.viewport(_currentViewport);
        state.scissor(_currentScissor);
        state.setScissorTest(_currentScissorTest);
        if (isCube) {
            const textureProperties = properties.get(renderTarget.texture);
            _gl.framebufferTexture2D(36160, 36064, 34069 + activeCubeFace, textureProperties.__webglTexture, activeMipmapLevel);
        } else if (isRenderTarget3D) {
            const textureProperties = properties.get(renderTarget.texture);
            const layer = activeCubeFace || 0;
            _gl.framebufferTextureLayer(36160, 36064, textureProperties.__webglTexture, activeMipmapLevel || 0, layer);
        }
        _currentMaterialId = -1; // reset current material to ensure correct uniform bindings
    };
    this.readRenderTargetPixels = function(renderTarget, x, y, width, height, buffer, activeCubeFaceIndex) {
        if (!(renderTarget && renderTarget.isWebGLRenderTarget)) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
            return;
        }
        let framebuffer = properties.get(renderTarget).__webglFramebuffer;
        if (renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== undefined) framebuffer = framebuffer[activeCubeFaceIndex];
        if (framebuffer) {
            state.bindFramebuffer(36160, framebuffer);
            try {
                const texture = renderTarget.texture;
                const textureFormat = texture.format;
                const textureType = texture.type;
                if (textureFormat !== $084574008ccedf86$export$3f8bb04b555a363c && utils.convert(textureFormat) !== _gl.getParameter(35739)) {
                    console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                    return;
                }
                const halfFloatSupportedByExt = textureType === $084574008ccedf86$export$2697304443f382bc && (extensions.has("EXT_color_buffer_half_float") || capabilities.isWebGL2 && extensions.has("EXT_color_buffer_float"));
                if (textureType !== $084574008ccedf86$export$2e8ce08d3f6f5e10 && utils.convert(textureType) !== _gl.getParameter(35738) && !(textureType === $084574008ccedf86$export$f6d331659b644596 && (capabilities.isWebGL2 || extensions.has("OES_texture_float") || extensions.has("WEBGL_color_buffer_float"))) && !halfFloatSupportedByExt) {
                    console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                    return;
                }
                // the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)
                if (x >= 0 && x <= renderTarget.width - width && y >= 0 && y <= renderTarget.height - height) _gl.readPixels(x, y, width, height, utils.convert(textureFormat), utils.convert(textureType), buffer);
            } finally{
                // restore framebuffer of current render target if necessary
                const framebuffer = _currentRenderTarget !== null ? properties.get(_currentRenderTarget).__webglFramebuffer : null;
                state.bindFramebuffer(36160, framebuffer);
            }
        }
    };
    this.copyFramebufferToTexture = function(position, texture, level = 0) {
        const levelScale = Math.pow(2, -level);
        const width = Math.floor(texture.image.width * levelScale);
        const height = Math.floor(texture.image.height * levelScale);
        textures.setTexture2D(texture, 0);
        _gl.copyTexSubImage2D(3553, level, 0, 0, position.x, position.y, width, height);
        state.unbindTexture();
    };
    this.copyTextureToTexture = function(position, srcTexture, dstTexture, level = 0) {
        const width = srcTexture.image.width;
        const height = srcTexture.image.height;
        const glFormat = utils.convert(dstTexture.format);
        const glType = utils.convert(dstTexture.type);
        textures.setTexture2D(dstTexture, 0);
        // As another texture upload may have changed pixelStorei
        // parameters, make sure they are correct for the dstTexture
        _gl.pixelStorei(37440, dstTexture.flipY);
        _gl.pixelStorei(37441, dstTexture.premultiplyAlpha);
        _gl.pixelStorei(3317, dstTexture.unpackAlignment);
        if (srcTexture.isDataTexture) _gl.texSubImage2D(3553, level, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data);
        else if (srcTexture.isCompressedTexture) _gl.compressedTexSubImage2D(3553, level, position.x, position.y, srcTexture.mipmaps[0].width, srcTexture.mipmaps[0].height, glFormat, srcTexture.mipmaps[0].data);
        else _gl.texSubImage2D(3553, level, position.x, position.y, glFormat, glType, srcTexture.image);
        // Generate mipmaps only when copying level 0
        if (level === 0 && dstTexture.generateMipmaps) _gl.generateMipmap(3553);
        state.unbindTexture();
    };
    this.copyTextureToTexture3D = function(sourceBox, position, srcTexture, dstTexture, level = 0) {
        if (_this.isWebGL1Renderer) {
            console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
            return;
        }
        const width = sourceBox.max.x - sourceBox.min.x + 1;
        const height = sourceBox.max.y - sourceBox.min.y + 1;
        const depth = sourceBox.max.z - sourceBox.min.z + 1;
        const glFormat = utils.convert(dstTexture.format);
        const glType = utils.convert(dstTexture.type);
        let glTarget;
        if (dstTexture.isData3DTexture) {
            textures.setTexture3D(dstTexture, 0);
            glTarget = 32879;
        } else if (dstTexture.isDataArrayTexture) {
            textures.setTexture2DArray(dstTexture, 0);
            glTarget = 35866;
        } else {
            console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
            return;
        }
        _gl.pixelStorei(37440, dstTexture.flipY);
        _gl.pixelStorei(37441, dstTexture.premultiplyAlpha);
        _gl.pixelStorei(3317, dstTexture.unpackAlignment);
        const unpackRowLen = _gl.getParameter(3314);
        const unpackImageHeight = _gl.getParameter(32878);
        const unpackSkipPixels = _gl.getParameter(3316);
        const unpackSkipRows = _gl.getParameter(3315);
        const unpackSkipImages = _gl.getParameter(32877);
        const image = srcTexture.isCompressedTexture ? srcTexture.mipmaps[0] : srcTexture.image;
        _gl.pixelStorei(3314, image.width);
        _gl.pixelStorei(32878, image.height);
        _gl.pixelStorei(3316, sourceBox.min.x);
        _gl.pixelStorei(3315, sourceBox.min.y);
        _gl.pixelStorei(32877, sourceBox.min.z);
        if (srcTexture.isDataTexture || srcTexture.isData3DTexture) _gl.texSubImage3D(glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, glType, image.data);
        else if (srcTexture.isCompressedTexture) {
            console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture.");
            _gl.compressedTexSubImage3D(glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, image.data);
        } else _gl.texSubImage3D(glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, glType, image);
        _gl.pixelStorei(3314, unpackRowLen);
        _gl.pixelStorei(32878, unpackImageHeight);
        _gl.pixelStorei(3316, unpackSkipPixels);
        _gl.pixelStorei(3315, unpackSkipRows);
        _gl.pixelStorei(32877, unpackSkipImages);
        // Generate mipmaps only when copying level 0
        if (level === 0 && dstTexture.generateMipmaps) _gl.generateMipmap(glTarget);
        state.unbindTexture();
    };
    this.initTexture = function(texture) {
        textures.setTexture2D(texture, 0);
        state.unbindTexture();
    };
    this.resetState = function() {
        _currentActiveCubeFace = 0;
        _currentActiveMipmapLevel = 0;
        _currentRenderTarget = null;
        state.reset();
        bindingStates.reset();
    };
    if (typeof __THREE_DEVTOOLS__ !== "undefined") __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
        detail: this
    }));
}
class $084574008ccedf86$export$a2f65229194348f9 extends $084574008ccedf86$export$f6cc00ef28d7cf97 {
}
$084574008ccedf86$export$a2f65229194348f9.prototype.isWebGL1Renderer = true;
class $084574008ccedf86$export$6f1519f023b8d0f6 {
    constructor(color, density = 0.00025){
        this.isFogExp2 = true;
        this.name = "";
        this.color = new $084574008ccedf86$export$892596cec99bc70e(color);
        this.density = density;
    }
    clone() {
        return new $084574008ccedf86$export$6f1519f023b8d0f6(this.color, this.density);
    }
    toJSON() {
        return {
            type: "FogExp2",
            color: this.color.getHex(),
            density: this.density
        };
    }
}
class $084574008ccedf86$export$3c890837b09508d4 {
    constructor(color, near = 1, far = 1000){
        this.isFog = true;
        this.name = "";
        this.color = new $084574008ccedf86$export$892596cec99bc70e(color);
        this.near = near;
        this.far = far;
    }
    clone() {
        return new $084574008ccedf86$export$3c890837b09508d4(this.color, this.near, this.far);
    }
    toJSON() {
        return {
            type: "Fog",
            color: this.color.getHex(),
            near: this.near,
            far: this.far
        };
    }
}
class $084574008ccedf86$export$38af1803e3442a7f extends $084574008ccedf86$export$e4dd07dff30cc924 {
    constructor(){
        super();
        this.isScene = true;
        this.type = "Scene";
        this.background = null;
        this.environment = null;
        this.fog = null;
        this.overrideMaterial = null;
        this.autoUpdate = true; // checked by the renderer
        if (typeof __THREE_DEVTOOLS__ !== "undefined") __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
            detail: this
        }));
    }
    copy(source, recursive) {
        super.copy(source, recursive);
        if (source.background !== null) this.background = source.background.clone();
        if (source.environment !== null) this.environment = source.environment.clone();
        if (source.fog !== null) this.fog = source.fog.clone();
        if (source.overrideMaterial !== null) this.overrideMaterial = source.overrideMaterial.clone();
        this.autoUpdate = source.autoUpdate;
        this.matrixAutoUpdate = source.matrixAutoUpdate;
        return this;
    }
    toJSON(meta) {
        const data = super.toJSON(meta);
        if (this.fog !== null) data.object.fog = this.fog.toJSON();
        return data;
    }
}
class $084574008ccedf86$export$3d5cd879f108f53f {
    constructor(array, stride){
        this.isInterleavedBuffer = true;
        this.array = array;
        this.stride = stride;
        this.count = array !== undefined ? array.length / stride : 0;
        this.usage = $084574008ccedf86$export$763e8360f4d7f77d;
        this.updateRange = {
            offset: 0,
            count: -1
        };
        this.version = 0;
        this.uuid = $084574008ccedf86$var$generateUUID();
    }
    onUploadCallback() {}
    set needsUpdate(value) {
        if (value === true) this.version++;
    }
    setUsage(value) {
        this.usage = value;
        return this;
    }
    copy(source) {
        this.array = new source.array.constructor(source.array);
        this.count = source.count;
        this.stride = source.stride;
        this.usage = source.usage;
        return this;
    }
    copyAt(index1, attribute, index2) {
        index1 *= this.stride;
        index2 *= attribute.stride;
        for(let i167 = 0, l = this.stride; i167 < l; i167++)this.array[index1 + i167] = attribute.array[index2 + i167];
        return this;
    }
    set(value, offset = 0) {
        this.array.set(value, offset);
        return this;
    }
    clone(data) {
        if (data.arrayBuffers === undefined) data.arrayBuffers = {};
        if (this.array.buffer._uuid === undefined) this.array.buffer._uuid = $084574008ccedf86$var$generateUUID();
        if (data.arrayBuffers[this.array.buffer._uuid] === undefined) data.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer;
        const array = new this.array.constructor(data.arrayBuffers[this.array.buffer._uuid]);
        const ib = new this.constructor(array, this.stride);
        ib.setUsage(this.usage);
        return ib;
    }
    onUpload(callback) {
        this.onUploadCallback = callback;
        return this;
    }
    toJSON(data) {
        if (data.arrayBuffers === undefined) data.arrayBuffers = {};
        // generate UUID for array buffer if necessary
        if (this.array.buffer._uuid === undefined) this.array.buffer._uuid = $084574008ccedf86$var$generateUUID();
        if (data.arrayBuffers[this.array.buffer._uuid] === undefined) data.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer));
        //
        return {
            uuid: this.uuid,
            buffer: this.array.buffer._uuid,
            type: this.array.constructor.name,
            stride: this.stride
        };
    }
}
const $084574008ccedf86$var$_vector$6 = /*@__PURE__*/ new $084574008ccedf86$export$64b5c384219d3699();
class $084574008ccedf86$export$920b6d07334599c7 {
    constructor(interleavedBuffer, itemSize, offset, normalized = false){
        this.isInterleavedBufferAttribute = true;
        this.name = "";
        this.data = interleavedBuffer;
        this.itemSize = itemSize;
        this.offset = offset;
        this.normalized = normalized === true;
    }
    get count() {
        return this.data.count;
    }
    get array() {
        return this.data.array;
    }
    set needsUpdate(value) {
        this.data.needsUpdate = value;
    }
    applyMatrix4(m) {
        for(let i168 = 0, l = this.data.count; i168 < l; i168++){
            $084574008ccedf86$var$_vector$6.fromBufferAttribute(this, i168);
            $084574008ccedf86$var$_vector$6.applyMatrix4(m);
            this.setXYZ(i168, $084574008ccedf86$var$_vector$6.x, $084574008ccedf86$var$_vector$6.y, $084574008ccedf86$var$_vector$6.z);
        }
        return this;
    }
    applyNormalMatrix(m) {
        for(let i169 = 0, l = this.count; i169 < l; i169++){
            $084574008ccedf86$var$_vector$6.fromBufferAttribute(this, i169);
            $084574008ccedf86$var$_vector$6.applyNormalMatrix(m);
            this.setXYZ(i169, $084574008ccedf86$var$_vector$6.x, $084574008ccedf86$var$_vector$6.y, $084574008ccedf86$var$_vector$6.z);
        }
        return this;
    }
    transformDirection(m) {
        for(let i170 = 0, l = this.count; i170 < l; i170++){
            $084574008ccedf86$var$_vector$6.fromBufferAttribute(this, i170);
            $084574008ccedf86$var$_vector$6.transformDirection(m);
            this.setXYZ(i170, $084574008ccedf86$var$_vector$6.x, $084574008ccedf86$var$_vector$6.y, $084574008ccedf86$var$_vector$6.z);
        }
        return this;
    }
    setX(index, x) {
        this.data.array[index * this.data.stride + this.offset] = x;
        return this;
    }
    setY(index, y) {
        this.data.array[index * this.data.stride + this.offset + 1] = y;
        return this;
    }
    setZ(index, z) {
        this.data.array[index * this.data.stride + this.offset + 2] = z;
        return this;
    }
    setW(index, w) {
        this.data.array[index * this.data.stride + this.offset + 3] = w;
        return this;
    }
    getX(index) {
        return this.data.array[index * this.data.stride + this.offset];
    }
    getY(index) {
        return this.data.array[index * this.data.stride + this.offset + 1];
    }
    getZ(index) {
        return this.data.array[index * this.data.stride + this.offset + 2];
    }
    getW(index) {
        return this.data.array[index * this.data.stride + this.offset + 3];
    }
    setXY(index, x, y) {
        index = index * this.data.stride + this.offset;
        this.data.array[index + 0] = x;
        this.data.array[index + 1] = y;
        return this;
    }
    setXYZ(index, x, y, z) {
        index = index * this.data.stride + this.offset;
        this.data.array[index + 0] = x;
        this.data.array[index + 1] = y;
        this.data.array[index + 2] = z;
        return this;
    }
    setXYZW(index, x, y, z, w) {
        index = index * this.data.stride + this.offset;
        this.data.array[index + 0] = x;
        this.data.array[index + 1] = y;
        this.data.array[index + 2] = z;
        this.data.array[index + 3] = w;
        return this;
    }
    clone(data) {
        if (data === undefined) {
            console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");
            const array = [];
            for(let i171 = 0; i171 < this.count; i171++){
                const index = i171 * this.data.stride + this.offset;
                for(let j = 0; j < this.itemSize; j++)array.push(this.data.array[index + j]);
            }
            return new $084574008ccedf86$export$8dea267bd6bde117(new this.array.constructor(array), this.itemSize, this.normalized);
        } else {
            if (data.interleavedBuffers === undefined) data.interleavedBuffers = {};
            if (data.interleavedBuffers[this.data.uuid] === undefined) data.interleavedBuffers[this.data.uuid] = this.data.clone(data);
            return new $084574008ccedf86$export$920b6d07334599c7(data.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
        }
    }
    toJSON(data) {
        if (data === undefined) {
            console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");
            const array = [];
            for(let i172 = 0; i172 < this.count; i172++){
                const index = i172 * this.data.stride + this.offset;
                for(let j = 0; j < this.itemSize; j++)array.push(this.data.array[index + j]);
            }
            // deinterleave data and save it as an ordinary buffer attribute for now
            return {
                itemSize: this.itemSize,
                type: this.array.constructor.name,
                array: array,
                normalized: this.normalized
            };
        } else {
            // save as true interlaved attribtue
            if (data.interleavedBuffers === undefined) data.interleavedBuffers = {};
            if (data.interleavedBuffers[this.data.uuid] === undefined) data.interleavedBuffers[this.data.uuid] = this.data.toJSON(data);
            return {
                isInterleavedBufferAttribute: true,
                itemSize: this.itemSize,
                data: this.data.uuid,
                offset: this.offset,
                normalized: this.normalized
            };
        }
    }
}
class $084574008ccedf86$export$5ec7dd1c6994bf8e extends $084574008ccedf86$export$a2d8b23205c25948 {
    constructor(parameters){
        super();
        this.isSpriteMaterial = true;
        this.type = "SpriteMaterial";
        this.color = new $084574008ccedf86$export$892596cec99bc70e(0xffffff);
        this.map = null;
        this.alphaMap = null;
        this.rotation = 0;
        this.sizeAttenuation = true;
        this.transparent = true;
        this.fog = true;
        this.setValues(parameters);
    }
    copy(source) {
        super.copy(source);
        this.color.copy(source.color);
        this.map = source.map;
        this.alphaMap = source.alphaMap;
        this.rotation = source.rotation;
        this.sizeAttenuation = source.sizeAttenuation;
        this.fog = source.fog;
        return this;
    }
}
let $084574008ccedf86$var$_geometry;
const $084574008ccedf86$var$_intersectPoint = /*@__PURE__*/ new $084574008ccedf86$export$64b5c384219d3699();
const $084574008ccedf86$var$_worldScale = /*@__PURE__*/ new $084574008ccedf86$export$64b5c384219d3699();
const $084574008ccedf86$var$_mvPosition = /*@__PURE__*/ new $084574008ccedf86$export$64b5c384219d3699();
const $084574008ccedf86$var$_alignedPosition = /*@__PURE__*/ new $084574008ccedf86$export$c977b3e384af9ae1();
const $084574008ccedf86$var$_rotatedPosition = /*@__PURE__*/ new $084574008ccedf86$export$c977b3e384af9ae1();
const $084574008ccedf86$var$_viewWorldMatrix = /*@__PURE__*/ new $084574008ccedf86$export$2ae72fc923e5eb5();
const $084574008ccedf86$var$_vA = /*@__PURE__*/ new $084574008ccedf86$export$64b5c384219d3699();
const $084574008ccedf86$var$_vB = /*@__PURE__*/ new $084574008ccedf86$export$64b5c384219d3699();
const $084574008ccedf86$var$_vC = /*@__PURE__*/ new $084574008ccedf86$export$64b5c384219d3699();
const $084574008ccedf86$var$_uvA = /*@__PURE__*/ new $084574008ccedf86$export$c977b3e384af9ae1();
const $084574008ccedf86$var$_uvB = /*@__PURE__*/ new $084574008ccedf86$export$c977b3e384af9ae1();
const $084574008ccedf86$var$_uvC = /*@__PURE__*/ new $084574008ccedf86$export$c977b3e384af9ae1();
class $084574008ccedf86$export$3075603db8e6204c extends $084574008ccedf86$export$e4dd07dff30cc924 {
    constructor(material){
        super();
        this.isSprite = true;
        this.type = "Sprite";
        if ($084574008ccedf86$var$_geometry === undefined) {
            $084574008ccedf86$var$_geometry = new $084574008ccedf86$export$b7be63a67df8959();
            const float32Array = new Float32Array([
                -0.5,
                -0.5,
                0,
                0,
                0,
                0.5,
                -0.5,
                0,
                1,
                0,
                0.5,
                0.5,
                0,
                1,
                1,
                -0.5,
                0.5,
                0,
                0,
                1
            ]);
            const interleavedBuffer = new $084574008ccedf86$export$3d5cd879f108f53f(float32Array, 5);
            $084574008ccedf86$var$_geometry.setIndex([
                0,
                1,
                2,
                0,
                2,
                3
            ]);
            $084574008ccedf86$var$_geometry.setAttribute("position", new $084574008ccedf86$export$920b6d07334599c7(interleavedBuffer, 3, 0, false));
            $084574008ccedf86$var$_geometry.setAttribute("uv", new $084574008ccedf86$export$920b6d07334599c7(interleavedBuffer, 2, 3, false));
        }
        this.geometry = $084574008ccedf86$var$_geometry;
        this.material = material !== undefined ? material : new $084574008ccedf86$export$5ec7dd1c6994bf8e();
        this.center = new $084574008ccedf86$export$c977b3e384af9ae1(0.5, 0.5);
    }
    raycast(raycaster, intersects2) {
        if (raycaster.camera === null) console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.');
        $084574008ccedf86$var$_worldScale.setFromMatrixScale(this.matrixWorld);
        $084574008ccedf86$var$_viewWorldMatrix.copy(raycaster.camera.matrixWorld);
        this.modelViewMatrix.multiplyMatrices(raycaster.camera.matrixWorldInverse, this.matrixWorld);
        $084574008ccedf86$var$_mvPosition.setFromMatrixPosition(this.modelViewMatrix);
        if (raycaster.camera.isPerspectiveCamera && this.material.sizeAttenuation === false) $084574008ccedf86$var$_worldScale.multiplyScalar(-$084574008ccedf86$var$_mvPosition.z);
        const rotation = this.material.rotation;
        let sin, cos;
        if (rotation !== 0) {
            cos = Math.cos(rotation);
            sin = Math.sin(rotation);
        }
        const center = this.center;
        $084574008ccedf86$var$transformVertex($084574008ccedf86$var$_vA.set(-0.5, -0.5, 0), $084574008ccedf86$var$_mvPosition, center, $084574008ccedf86$var$_worldScale, sin, cos);
        $084574008ccedf86$var$transformVertex($084574008ccedf86$var$_vB.set(0.5, -0.5, 0), $084574008ccedf86$var$_mvPosition, center, $084574008ccedf86$var$_worldScale, sin, cos);
        $084574008ccedf86$var$transformVertex($084574008ccedf86$var$_vC.set(0.5, 0.5, 0), $084574008ccedf86$var$_mvPosition, center, $084574008ccedf86$var$_worldScale, sin, cos);
        $084574008ccedf86$var$_uvA.set(0, 0);
        $084574008ccedf86$var$_uvB.set(1, 0);
        $084574008ccedf86$var$_uvC.set(1, 1);
        // check first triangle
        let intersect = raycaster.ray.intersectTriangle($084574008ccedf86$var$_vA, $084574008ccedf86$var$_vB, $084574008ccedf86$var$_vC, false, $084574008ccedf86$var$_intersectPoint);
        if (intersect === null) {
            // check second triangle
            $084574008ccedf86$var$transformVertex($084574008ccedf86$var$_vB.set(-0.5, 0.5, 0), $084574008ccedf86$var$_mvPosition, center, $084574008ccedf86$var$_worldScale, sin, cos);
            $084574008ccedf86$var$_uvB.set(0, 1);
            intersect = raycaster.ray.intersectTriangle($084574008ccedf86$var$_vA, $084574008ccedf86$var$_vC, $084574008ccedf86$var$_vB, false, $084574008ccedf86$var$_intersectPoint);
            if (intersect === null) return;
        }
        const distance = raycaster.ray.origin.distanceTo($084574008ccedf86$var$_intersectPoint);
        if (distance < raycaster.near || distance > raycaster.far) return;
        intersects2.push({
            distance: distance,
            point: $084574008ccedf86$var$_intersectPoint.clone(),
            uv: $084574008ccedf86$export$5a465592bfe74b48.getUV($084574008ccedf86$var$_intersectPoint, $084574008ccedf86$var$_vA, $084574008ccedf86$var$_vB, $084574008ccedf86$var$_vC, $084574008ccedf86$var$_uvA, $084574008ccedf86$var$_uvB, $084574008ccedf86$var$_uvC, new $084574008ccedf86$export$c977b3e384af9ae1()),
            face: null,
            object: this
        });
    }
    copy(source, recursive) {
        super.copy(source, recursive);
        if (source.center !== undefined) this.center.copy(source.center);
        this.material = source.material;
        return this;
    }
}
function $084574008ccedf86$var$transformVertex(vertexPosition, mvPosition, center, scale, sin, cos) {
    // compute position in camera space
    $084574008ccedf86$var$_alignedPosition.subVectors(vertexPosition, center).addScalar(0.5).multiply(scale);
    // to check if rotation is not zero
    if (sin !== undefined) {
        $084574008ccedf86$var$_rotatedPosition.x = cos * $084574008ccedf86$var$_alignedPosition.x - sin * $084574008ccedf86$var$_alignedPosition.y;
        $084574008ccedf86$var$_rotatedPosition.y = sin * $084574008ccedf86$var$_alignedPosition.x + cos * $084574008ccedf86$var$_alignedPosition.y;
    } else $084574008ccedf86$var$_rotatedPosition.copy($084574008ccedf86$var$_alignedPosition);
    vertexPosition.copy(mvPosition);
    vertexPosition.x += $084574008ccedf86$var$_rotatedPosition.x;
    vertexPosition.y += $084574008ccedf86$var$_rotatedPosition.y;
    // transform to world space
    vertexPosition.applyMatrix4($084574008ccedf86$var$_viewWorldMatrix);
}
const $084574008ccedf86$var$_v1$2 = /*@__PURE__*/ new $084574008ccedf86$export$64b5c384219d3699();
const $084574008ccedf86$var$_v2$1 = /*@__PURE__*/ new $084574008ccedf86$export$64b5c384219d3699();
class $084574008ccedf86$export$112e7237be0c5f30 extends $084574008ccedf86$export$e4dd07dff30cc924 {
    constructor(){
        super();
        this._currentLevel = 0;
        this.type = "LOD";
        Object.defineProperties(this, {
            levels: {
                enumerable: true,
                value: []
            },
            isLOD: {
                value: true
            }
        });
        this.autoUpdate = true;
    }
    copy(source) {
        super.copy(source, false);
        const levels = source.levels;
        for(let i173 = 0, l = levels.length; i173 < l; i173++){
            const level = levels[i173];
            this.addLevel(level.object.clone(), level.distance);
        }
        this.autoUpdate = source.autoUpdate;
        return this;
    }
    addLevel(object, distance = 0) {
        distance = Math.abs(distance);
        const levels = this.levels;
        let l;
        for(l = 0; l < levels.length; l++){
            if (distance < levels[l].distance) break;
        }
        levels.splice(l, 0, {
            distance: distance,
            object: object
        });
        this.add(object);
        return this;
    }
    getCurrentLevel() {
        return this._currentLevel;
    }
    getObjectForDistance(distance) {
        const levels = this.levels;
        if (levels.length > 0) {
            let i174, l;
            for(i174 = 1, l = levels.length; i174 < l; i174++){
                if (distance < levels[i174].distance) break;
            }
            return levels[i174 - 1].object;
        }
        return null;
    }
    raycast(raycaster, intersects3) {
        const levels = this.levels;
        if (levels.length > 0) {
            $084574008ccedf86$var$_v1$2.setFromMatrixPosition(this.matrixWorld);
            const distance = raycaster.ray.origin.distanceTo($084574008ccedf86$var$_v1$2);
            this.getObjectForDistance(distance).raycast(raycaster, intersects3);
        }
    }
    update(camera) {
        const levels = this.levels;
        if (levels.length > 1) {
            $084574008ccedf86$var$_v1$2.setFromMatrixPosition(camera.matrixWorld);
            $084574008ccedf86$var$_v2$1.setFromMatrixPosition(this.matrixWorld);
            const distance = $084574008ccedf86$var$_v1$2.distanceTo($084574008ccedf86$var$_v2$1) / camera.zoom;
            levels[0].object.visible = true;
            let i175, l;
            for(i175 = 1, l = levels.length; i175 < l; i175++){
                if (distance >= levels[i175].distance) {
                    levels[i175 - 1].object.visible = false;
                    levels[i175].object.visible = true;
                } else break;
            }
            this._currentLevel = i175 - 1;
            for(; i175 < l; i175++)levels[i175].object.visible = false;
        }
    }
    toJSON(meta) {
        const data = super.toJSON(meta);
        if (this.autoUpdate === false) data.object.autoUpdate = false;
        data.object.levels = [];
        const levels = this.levels;
        for(let i176 = 0, l = levels.length; i176 < l; i176++){
            const level = levels[i176];
            data.object.levels.push({
                object: level.object.uuid,
                distance: level.distance
            });
        }
        return data;
    }
}
const $084574008ccedf86$var$_basePosition = /*@__PURE__*/ new $084574008ccedf86$export$64b5c384219d3699();
const $084574008ccedf86$var$_skinIndex = /*@__PURE__*/ new $084574008ccedf86$export$fa7daccca11cdbe3();
const $084574008ccedf86$var$_skinWeight = /*@__PURE__*/ new $084574008ccedf86$export$fa7daccca11cdbe3();
const $084574008ccedf86$var$_vector$5 = /*@__PURE__*/ new $084574008ccedf86$export$64b5c384219d3699();
const $084574008ccedf86$var$_matrix = /*@__PURE__*/ new $084574008ccedf86$export$2ae72fc923e5eb5();
class $084574008ccedf86$export$b303577035157ecf extends $084574008ccedf86$export$e176487c05830cc5 {
    constructor(geometry, material){
        super(geometry, material);
        this.isSkinnedMesh = true;
        this.type = "SkinnedMesh";
        this.bindMode = "attached";
        this.bindMatrix = new $084574008ccedf86$export$2ae72fc923e5eb5();
        this.bindMatrixInverse = new $084574008ccedf86$export$2ae72fc923e5eb5();
    }
    copy(source, recursive) {
        super.copy(source, recursive);
        this.bindMode = source.bindMode;
        this.bindMatrix.copy(source.bindMatrix);
        this.bindMatrixInverse.copy(source.bindMatrixInverse);
        this.skeleton = source.skeleton;
        return this;
    }
    bind(skeleton, bindMatrix) {
        this.skeleton = skeleton;
        if (bindMatrix === undefined) {
            this.updateMatrixWorld(true);
            this.skeleton.calculateInverses();
            bindMatrix = this.matrixWorld;
        }
        this.bindMatrix.copy(bindMatrix);
        this.bindMatrixInverse.copy(bindMatrix).invert();
    }
    pose() {
        this.skeleton.pose();
    }
    normalizeSkinWeights() {
        const vector = new $084574008ccedf86$export$fa7daccca11cdbe3();
        const skinWeight = this.geometry.attributes.skinWeight;
        for(let i177 = 0, l = skinWeight.count; i177 < l; i177++){
            vector.fromBufferAttribute(skinWeight, i177);
            const scale = 1.0 / vector.manhattanLength();
            if (scale !== Infinity) vector.multiplyScalar(scale);
            else vector.set(1, 0, 0, 0); // do something reasonable
            skinWeight.setXYZW(i177, vector.x, vector.y, vector.z, vector.w);
        }
    }
    updateMatrixWorld(force) {
        super.updateMatrixWorld(force);
        if (this.bindMode === "attached") this.bindMatrixInverse.copy(this.matrixWorld).invert();
        else if (this.bindMode === "detached") this.bindMatrixInverse.copy(this.bindMatrix).invert();
        else console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
    }
    boneTransform(index, target) {
        const skeleton = this.skeleton;
        const geometry = this.geometry;
        $084574008ccedf86$var$_skinIndex.fromBufferAttribute(geometry.attributes.skinIndex, index);
        $084574008ccedf86$var$_skinWeight.fromBufferAttribute(geometry.attributes.skinWeight, index);
        $084574008ccedf86$var$_basePosition.copy(target).applyMatrix4(this.bindMatrix);
        target.set(0, 0, 0);
        for(let i178 = 0; i178 < 4; i178++){
            const weight = $084574008ccedf86$var$_skinWeight.getComponent(i178);
            if (weight !== 0) {
                const boneIndex = $084574008ccedf86$var$_skinIndex.getComponent(i178);
                $084574008ccedf86$var$_matrix.multiplyMatrices(skeleton.bones[boneIndex].matrixWorld, skeleton.boneInverses[boneIndex]);
                target.addScaledVector($084574008ccedf86$var$_vector$5.copy($084574008ccedf86$var$_basePosition).applyMatrix4($084574008ccedf86$var$_matrix), weight);
            }
        }
        return target.applyMatrix4(this.bindMatrixInverse);
    }
}
class $084574008ccedf86$export$b127726e56765aa4 extends $084574008ccedf86$export$e4dd07dff30cc924 {
    constructor(){
        super();
        this.isBone = true;
        this.type = "Bone";
    }
}
class $084574008ccedf86$export$b691f601014eabe1 extends $084574008ccedf86$export$5431306cf43de24a {
    constructor(data = null, width = 1, height = 1, format, type, mapping, wrapS, wrapT, magFilter = $084574008ccedf86$export$727aa5ec3fe39bf0, minFilter = $084574008ccedf86$export$727aa5ec3fe39bf0, anisotropy, encoding){
        super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
        this.isDataTexture = true;
        this.image = {
            data: data,
            width: width,
            height: height
        };
        this.generateMipmaps = false;
        this.flipY = false;
        this.unpackAlignment = 1;
    }
}
const $084574008ccedf86$var$_offsetMatrix = /*@__PURE__*/ new $084574008ccedf86$export$2ae72fc923e5eb5();
const $084574008ccedf86$var$_identityMatrix = /*@__PURE__*/ new $084574008ccedf86$export$2ae72fc923e5eb5();
class $084574008ccedf86$export$8f31e4c4a37b8e9c {
    constructor(bones = [], boneInverses = []){
        this.uuid = $084574008ccedf86$var$generateUUID();
        this.bones = bones.slice(0);
        this.boneInverses = boneInverses;
        this.boneMatrices = null;
        this.boneTexture = null;
        this.boneTextureSize = 0;
        this.frame = -1;
        this.init();
    }
    init() {
        const bones = this.bones;
        const boneInverses = this.boneInverses;
        this.boneMatrices = new Float32Array(bones.length * 16);
        // calculate inverse bone matrices if necessary
        if (boneInverses.length === 0) this.calculateInverses();
        else // handle special case
        if (bones.length !== boneInverses.length) {
            console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.");
            this.boneInverses = [];
            for(let i179 = 0, il = this.bones.length; i179 < il; i179++)this.boneInverses.push(new $084574008ccedf86$export$2ae72fc923e5eb5());
        }
    }
    calculateInverses() {
        this.boneInverses.length = 0;
        for(let i180 = 0, il = this.bones.length; i180 < il; i180++){
            const inverse = new $084574008ccedf86$export$2ae72fc923e5eb5();
            if (this.bones[i180]) inverse.copy(this.bones[i180].matrixWorld).invert();
            this.boneInverses.push(inverse);
        }
    }
    pose() {
        // recover the bind-time world matrices
        for(let i182 = 0, il = this.bones.length; i182 < il; i182++){
            const bone = this.bones[i182];
            if (bone) bone.matrixWorld.copy(this.boneInverses[i182]).invert();
        }
        // compute the local matrices, positions, rotations and scales
        for(let i181 = 0, il6 = this.bones.length; i181 < il6; i181++){
            const bone = this.bones[i181];
            if (bone) {
                if (bone.parent && bone.parent.isBone) {
                    bone.matrix.copy(bone.parent.matrixWorld).invert();
                    bone.matrix.multiply(bone.matrixWorld);
                } else bone.matrix.copy(bone.matrixWorld);
                bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);
            }
        }
    }
    update() {
        const bones = this.bones;
        const boneInverses = this.boneInverses;
        const boneMatrices = this.boneMatrices;
        const boneTexture = this.boneTexture;
        // flatten bone matrices to array
        for(let i183 = 0, il = bones.length; i183 < il; i183++){
            // compute the offset between the current and the original transform
            const matrix = bones[i183] ? bones[i183].matrixWorld : $084574008ccedf86$var$_identityMatrix;
            $084574008ccedf86$var$_offsetMatrix.multiplyMatrices(matrix, boneInverses[i183]);
            $084574008ccedf86$var$_offsetMatrix.toArray(boneMatrices, i183 * 16);
        }
        if (boneTexture !== null) boneTexture.needsUpdate = true;
    }
    clone() {
        return new $084574008ccedf86$export$8f31e4c4a37b8e9c(this.bones, this.boneInverses);
    }
    computeBoneTexture() {
        // layout (1 matrix = 4 pixels)
        //      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
        //  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
        //       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
        //       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
        //       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)
        let size = Math.sqrt(this.bones.length * 4); // 4 pixels needed for 1 matrix
        size = $084574008ccedf86$var$ceilPowerOfTwo(size);
        size = Math.max(size, 4);
        const boneMatrices = new Float32Array(size * size * 4); // 4 floats per RGBA pixel
        boneMatrices.set(this.boneMatrices); // copy current values
        const boneTexture = new $084574008ccedf86$export$b691f601014eabe1(boneMatrices, size, size, $084574008ccedf86$export$3f8bb04b555a363c, $084574008ccedf86$export$f6d331659b644596);
        boneTexture.needsUpdate = true;
        this.boneMatrices = boneMatrices;
        this.boneTexture = boneTexture;
        this.boneTextureSize = size;
        return this;
    }
    getBoneByName(name) {
        for(let i184 = 0, il = this.bones.length; i184 < il; i184++){
            const bone = this.bones[i184];
            if (bone.name === name) return bone;
        }
        return undefined;
    }
    dispose() {
        if (this.boneTexture !== null) {
            this.boneTexture.dispose();
            this.boneTexture = null;
        }
    }
    fromJSON(json, bones) {
        this.uuid = json.uuid;
        for(let i185 = 0, l = json.bones.length; i185 < l; i185++){
            const uuid = json.bones[i185];
            let bone = bones[uuid];
            if (bone === undefined) {
                console.warn("THREE.Skeleton: No bone found with UUID:", uuid);
                bone = new $084574008ccedf86$export$b127726e56765aa4();
            }
            this.bones.push(bone);
            this.boneInverses.push(new $084574008ccedf86$export$2ae72fc923e5eb5().fromArray(json.boneInverses[i185]));
        }
        this.init();
        return this;
    }
    toJSON() {
        const data = {
            metadata: {
                version: 4.5,
                type: "Skeleton",
                generator: "Skeleton.toJSON"
            },
            bones: [],
            boneInverses: []
        };
        data.uuid = this.uuid;
        const bones = this.bones;
        const boneInverses = this.boneInverses;
        for(let i186 = 0, l = bones.length; i186 < l; i186++){
            const bone = bones[i186];
            data.bones.push(bone.uuid);
            const boneInverse = boneInverses[i186];
            data.boneInverses.push(boneInverse.toArray());
        }
        return data;
    }
}
class $084574008ccedf86$export$32ea87a8b54d744a extends $084574008ccedf86$export$8dea267bd6bde117 {
    constructor(array, itemSize, normalized, meshPerAttribute = 1){
        if (typeof normalized === "number") {
            meshPerAttribute = normalized;
            normalized = false;
            console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.");
        }
        super(array, itemSize, normalized);
        this.isInstancedBufferAttribute = true;
        this.meshPerAttribute = meshPerAttribute;
    }
    copy(source) {
        super.copy(source);
        this.meshPerAttribute = source.meshPerAttribute;
        return this;
    }
    toJSON() {
        const data = super.toJSON();
        data.meshPerAttribute = this.meshPerAttribute;
        data.isInstancedBufferAttribute = true;
        return data;
    }
}
const $084574008ccedf86$var$_instanceLocalMatrix = /*@__PURE__*/ new $084574008ccedf86$export$2ae72fc923e5eb5();
const $084574008ccedf86$var$_instanceWorldMatrix = /*@__PURE__*/ new $084574008ccedf86$export$2ae72fc923e5eb5();
const $084574008ccedf86$var$_instanceIntersects = [];
const $084574008ccedf86$var$_mesh = /*@__PURE__*/ new $084574008ccedf86$export$e176487c05830cc5();
class $084574008ccedf86$export$f3c979c331175ad7 extends $084574008ccedf86$export$e176487c05830cc5 {
    constructor(geometry, material, count){
        super(geometry, material);
        this.isInstancedMesh = true;
        this.instanceMatrix = new $084574008ccedf86$export$32ea87a8b54d744a(new Float32Array(count * 16), 16);
        this.instanceColor = null;
        this.count = count;
        this.frustumCulled = false;
    }
    copy(source, recursive) {
        super.copy(source, recursive);
        this.instanceMatrix.copy(source.instanceMatrix);
        if (source.instanceColor !== null) this.instanceColor = source.instanceColor.clone();
        this.count = source.count;
        return this;
    }
    getColorAt(index, color) {
        color.fromArray(this.instanceColor.array, index * 3);
    }
    getMatrixAt(index, matrix) {
        matrix.fromArray(this.instanceMatrix.array, index * 16);
    }
    raycast(raycaster, intersects4) {
        const matrixWorld = this.matrixWorld;
        const raycastTimes = this.count;
        $084574008ccedf86$var$_mesh.geometry = this.geometry;
        $084574008ccedf86$var$_mesh.material = this.material;
        if ($084574008ccedf86$var$_mesh.material === undefined) return;
        for(let instanceId = 0; instanceId < raycastTimes; instanceId++){
            // calculate the world matrix for each instance
            this.getMatrixAt(instanceId, $084574008ccedf86$var$_instanceLocalMatrix);
            $084574008ccedf86$var$_instanceWorldMatrix.multiplyMatrices(matrixWorld, $084574008ccedf86$var$_instanceLocalMatrix);
            // the mesh represents this single instance
            $084574008ccedf86$var$_mesh.matrixWorld = $084574008ccedf86$var$_instanceWorldMatrix;
            $084574008ccedf86$var$_mesh.raycast(raycaster, $084574008ccedf86$var$_instanceIntersects);
            // process the result of raycast
            for(let i187 = 0, l = $084574008ccedf86$var$_instanceIntersects.length; i187 < l; i187++){
                const intersect = $084574008ccedf86$var$_instanceIntersects[i187];
                intersect.instanceId = instanceId;
                intersect.object = this;
                intersects4.push(intersect);
            }
            $084574008ccedf86$var$_instanceIntersects.length = 0;
        }
    }
    setColorAt(index, color) {
        if (this.instanceColor === null) this.instanceColor = new $084574008ccedf86$export$32ea87a8b54d744a(new Float32Array(this.instanceMatrix.count * 3), 3);
        color.toArray(this.instanceColor.array, index * 3);
    }
    setMatrixAt(index, matrix) {
        matrix.toArray(this.instanceMatrix.array, index * 16);
    }
    updateMorphTargets() {}
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        });
    }
}
class $084574008ccedf86$export$fbaaa33907730a0c extends $084574008ccedf86$export$a2d8b23205c25948 {
    constructor(parameters){
        super();
        this.isLineBasicMaterial = true;
        this.type = "LineBasicMaterial";
        this.color = new $084574008ccedf86$export$892596cec99bc70e(0xffffff);
        this.linewidth = 1;
        this.linecap = "round";
        this.linejoin = "round";
        this.fog = true;
        this.setValues(parameters);
    }
    copy(source) {
        super.copy(source);
        this.color.copy(source.color);
        this.linewidth = source.linewidth;
        this.linecap = source.linecap;
        this.linejoin = source.linejoin;
        this.fog = source.fog;
        return this;
    }
}
const $084574008ccedf86$var$_start$1 = /*@__PURE__*/ new $084574008ccedf86$export$64b5c384219d3699();
const $084574008ccedf86$var$_end$1 = /*@__PURE__*/ new $084574008ccedf86$export$64b5c384219d3699();
const $084574008ccedf86$var$_inverseMatrix$1 = /*@__PURE__*/ new $084574008ccedf86$export$2ae72fc923e5eb5();
const $084574008ccedf86$var$_ray$1 = /*@__PURE__*/ new $084574008ccedf86$export$a186db52eed6d40e();
const $084574008ccedf86$var$_sphere$1 = /*@__PURE__*/ new $084574008ccedf86$export$805e8b72413ccaba();
class $084574008ccedf86$export$17d680238e50603e extends $084574008ccedf86$export$e4dd07dff30cc924 {
    constructor(geometry = new $084574008ccedf86$export$b7be63a67df8959(), material = new $084574008ccedf86$export$fbaaa33907730a0c()){
        super();
        this.isLine = true;
        this.type = "Line";
        this.geometry = geometry;
        this.material = material;
        this.updateMorphTargets();
    }
    copy(source, recursive) {
        super.copy(source, recursive);
        this.material = source.material;
        this.geometry = source.geometry;
        return this;
    }
    computeLineDistances() {
        const geometry = this.geometry;
        // we assume non-indexed geometry
        if (geometry.index === null) {
            const positionAttribute = geometry.attributes.position;
            const lineDistances = [
                0
            ];
            for(let i188 = 1, l = positionAttribute.count; i188 < l; i188++){
                $084574008ccedf86$var$_start$1.fromBufferAttribute(positionAttribute, i188 - 1);
                $084574008ccedf86$var$_end$1.fromBufferAttribute(positionAttribute, i188);
                lineDistances[i188] = lineDistances[i188 - 1];
                lineDistances[i188] += $084574008ccedf86$var$_start$1.distanceTo($084574008ccedf86$var$_end$1);
            }
            geometry.setAttribute("lineDistance", new $084574008ccedf86$export$cbe7a62641830ebd(lineDistances, 1));
        } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
        return this;
    }
    raycast(raycaster, intersects5) {
        const geometry = this.geometry;
        const matrixWorld = this.matrixWorld;
        const threshold = raycaster.params.Line.threshold;
        const drawRange = geometry.drawRange;
        // Checking boundingSphere distance to ray
        if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
        $084574008ccedf86$var$_sphere$1.copy(geometry.boundingSphere);
        $084574008ccedf86$var$_sphere$1.applyMatrix4(matrixWorld);
        $084574008ccedf86$var$_sphere$1.radius += threshold;
        if (raycaster.ray.intersectsSphere($084574008ccedf86$var$_sphere$1) === false) return;
        //
        $084574008ccedf86$var$_inverseMatrix$1.copy(matrixWorld).invert();
        $084574008ccedf86$var$_ray$1.copy(raycaster.ray).applyMatrix4($084574008ccedf86$var$_inverseMatrix$1);
        const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
        const localThresholdSq = localThreshold * localThreshold;
        const vStart = new $084574008ccedf86$export$64b5c384219d3699();
        const vEnd = new $084574008ccedf86$export$64b5c384219d3699();
        const interSegment = new $084574008ccedf86$export$64b5c384219d3699();
        const interRay = new $084574008ccedf86$export$64b5c384219d3699();
        const step = this.isLineSegments ? 2 : 1;
        const index = geometry.index;
        const attributes = geometry.attributes;
        const positionAttribute = attributes.position;
        if (index !== null) {
            const start = Math.max(0, drawRange.start);
            const end = Math.min(index.count, drawRange.start + drawRange.count);
            for(let i189 = start, l = end - 1; i189 < l; i189 += step){
                const a = index.getX(i189);
                const b = index.getX(i189 + 1);
                vStart.fromBufferAttribute(positionAttribute, a);
                vEnd.fromBufferAttribute(positionAttribute, b);
                const distSq = $084574008ccedf86$var$_ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
                if (distSq > localThresholdSq) continue;
                interRay.applyMatrix4(this.matrixWorld); //Move back to world space for distance calculation
                const distance = raycaster.ray.origin.distanceTo(interRay);
                if (distance < raycaster.near || distance > raycaster.far) continue;
                intersects5.push({
                    distance: distance,
                    // What do we want? intersection point on the ray or on the segment??
                    // point: raycaster.ray.at( distance ),
                    point: interSegment.clone().applyMatrix4(this.matrixWorld),
                    index: i189,
                    face: null,
                    faceIndex: null,
                    object: this
                });
            }
        } else {
            const start = Math.max(0, drawRange.start);
            const end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);
            for(let i190 = start, l = end - 1; i190 < l; i190 += step){
                vStart.fromBufferAttribute(positionAttribute, i190);
                vEnd.fromBufferAttribute(positionAttribute, i190 + 1);
                const distSq = $084574008ccedf86$var$_ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
                if (distSq > localThresholdSq) continue;
                interRay.applyMatrix4(this.matrixWorld); //Move back to world space for distance calculation
                const distance = raycaster.ray.origin.distanceTo(interRay);
                if (distance < raycaster.near || distance > raycaster.far) continue;
                intersects5.push({
                    distance: distance,
                    // What do we want? intersection point on the ray or on the segment??
                    // point: raycaster.ray.at( distance ),
                    point: interSegment.clone().applyMatrix4(this.matrixWorld),
                    index: i190,
                    face: null,
                    faceIndex: null,
                    object: this
                });
            }
        }
    }
    updateMorphTargets() {
        const geometry = this.geometry;
        const morphAttributes = geometry.morphAttributes;
        const keys = Object.keys(morphAttributes);
        if (keys.length > 0) {
            const morphAttribute = morphAttributes[keys[0]];
            if (morphAttribute !== undefined) {
                this.morphTargetInfluences = [];
                this.morphTargetDictionary = {};
                for(let m = 0, ml = morphAttribute.length; m < ml; m++){
                    const name = morphAttribute[m].name || String(m);
                    this.morphTargetInfluences.push(0);
                    this.morphTargetDictionary[name] = m;
                }
            }
        }
    }
}
const $084574008ccedf86$var$_start = /*@__PURE__*/ new $084574008ccedf86$export$64b5c384219d3699();
const $084574008ccedf86$var$_end = /*@__PURE__*/ new $084574008ccedf86$export$64b5c384219d3699();
class $084574008ccedf86$export$ff1ed10fedfdd604 extends $084574008ccedf86$export$17d680238e50603e {
    constructor(geometry, material){
        super(geometry, material);
        this.isLineSegments = true;
        this.type = "LineSegments";
    }
    computeLineDistances() {
        const geometry = this.geometry;
        // we assume non-indexed geometry
        if (geometry.index === null) {
            const positionAttribute = geometry.attributes.position;
            const lineDistances = [];
            for(let i191 = 0, l = positionAttribute.count; i191 < l; i191 += 2){
                $084574008ccedf86$var$_start.fromBufferAttribute(positionAttribute, i191);
                $084574008ccedf86$var$_end.fromBufferAttribute(positionAttribute, i191 + 1);
                lineDistances[i191] = i191 === 0 ? 0 : lineDistances[i191 - 1];
                lineDistances[i191 + 1] = lineDistances[i191] + $084574008ccedf86$var$_start.distanceTo($084574008ccedf86$var$_end);
            }
            geometry.setAttribute("lineDistance", new $084574008ccedf86$export$cbe7a62641830ebd(lineDistances, 1));
        } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
        return this;
    }
}
class $084574008ccedf86$export$f85a24d745e4f17d extends $084574008ccedf86$export$17d680238e50603e {
    constructor(geometry, material){
        super(geometry, material);
        this.isLineLoop = true;
        this.type = "LineLoop";
    }
}
class $084574008ccedf86$export$a178c45366ce5d6b extends $084574008ccedf86$export$a2d8b23205c25948 {
    constructor(parameters){
        super();
        this.isPointsMaterial = true;
        this.type = "PointsMaterial";
        this.color = new $084574008ccedf86$export$892596cec99bc70e(0xffffff);
        this.map = null;
        this.alphaMap = null;
        this.size = 1;
        this.sizeAttenuation = true;
        this.fog = true;
        this.setValues(parameters);
    }
    copy(source) {
        super.copy(source);
        this.color.copy(source.color);
        this.map = source.map;
        this.alphaMap = source.alphaMap;
        this.size = source.size;
        this.sizeAttenuation = source.sizeAttenuation;
        this.fog = source.fog;
        return this;
    }
}
const $084574008ccedf86$var$_inverseMatrix = /*@__PURE__*/ new $084574008ccedf86$export$2ae72fc923e5eb5();
const $084574008ccedf86$var$_ray = /*@__PURE__*/ new $084574008ccedf86$export$a186db52eed6d40e();
const $084574008ccedf86$var$_sphere = /*@__PURE__*/ new $084574008ccedf86$export$805e8b72413ccaba();
const $084574008ccedf86$var$_position$2 = /*@__PURE__*/ new $084574008ccedf86$export$64b5c384219d3699();
class $084574008ccedf86$export$1c787534cb11aa3e extends $084574008ccedf86$export$e4dd07dff30cc924 {
    constructor(geometry = new $084574008ccedf86$export$b7be63a67df8959(), material = new $084574008ccedf86$export$a178c45366ce5d6b()){
        super();
        this.isPoints = true;
        this.type = "Points";
        this.geometry = geometry;
        this.material = material;
        this.updateMorphTargets();
    }
    copy(source, recursive) {
        super.copy(source, recursive);
        this.material = source.material;
        this.geometry = source.geometry;
        return this;
    }
    raycast(raycaster, intersects6) {
        const geometry = this.geometry;
        const matrixWorld = this.matrixWorld;
        const threshold = raycaster.params.Points.threshold;
        const drawRange = geometry.drawRange;
        // Checking boundingSphere distance to ray
        if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
        $084574008ccedf86$var$_sphere.copy(geometry.boundingSphere);
        $084574008ccedf86$var$_sphere.applyMatrix4(matrixWorld);
        $084574008ccedf86$var$_sphere.radius += threshold;
        if (raycaster.ray.intersectsSphere($084574008ccedf86$var$_sphere) === false) return;
        //
        $084574008ccedf86$var$_inverseMatrix.copy(matrixWorld).invert();
        $084574008ccedf86$var$_ray.copy(raycaster.ray).applyMatrix4($084574008ccedf86$var$_inverseMatrix);
        const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
        const localThresholdSq = localThreshold * localThreshold;
        const index = geometry.index;
        const attributes = geometry.attributes;
        const positionAttribute = attributes.position;
        if (index !== null) {
            const start = Math.max(0, drawRange.start);
            const end = Math.min(index.count, drawRange.start + drawRange.count);
            for(let i192 = start, il = end; i192 < il; i192++){
                const a = index.getX(i192);
                $084574008ccedf86$var$_position$2.fromBufferAttribute(positionAttribute, a);
                $084574008ccedf86$var$testPoint($084574008ccedf86$var$_position$2, a, localThresholdSq, matrixWorld, raycaster, intersects6, this);
            }
        } else {
            const start = Math.max(0, drawRange.start);
            const end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);
            for(let i193 = start, l = end; i193 < l; i193++){
                $084574008ccedf86$var$_position$2.fromBufferAttribute(positionAttribute, i193);
                $084574008ccedf86$var$testPoint($084574008ccedf86$var$_position$2, i193, localThresholdSq, matrixWorld, raycaster, intersects6, this);
            }
        }
    }
    updateMorphTargets() {
        const geometry = this.geometry;
        const morphAttributes = geometry.morphAttributes;
        const keys = Object.keys(morphAttributes);
        if (keys.length > 0) {
            const morphAttribute = morphAttributes[keys[0]];
            if (morphAttribute !== undefined) {
                this.morphTargetInfluences = [];
                this.morphTargetDictionary = {};
                for(let m = 0, ml = morphAttribute.length; m < ml; m++){
                    const name = morphAttribute[m].name || String(m);
                    this.morphTargetInfluences.push(0);
                    this.morphTargetDictionary[name] = m;
                }
            }
        }
    }
}
function $084574008ccedf86$var$testPoint(point, index, localThresholdSq, matrixWorld, raycaster, intersects7, object) {
    const rayPointDistanceSq = $084574008ccedf86$var$_ray.distanceSqToPoint(point);
    if (rayPointDistanceSq < localThresholdSq) {
        const intersectPoint = new $084574008ccedf86$export$64b5c384219d3699();
        $084574008ccedf86$var$_ray.closestPointToPoint(point, intersectPoint);
        intersectPoint.applyMatrix4(matrixWorld);
        const distance = raycaster.ray.origin.distanceTo(intersectPoint);
        if (distance < raycaster.near || distance > raycaster.far) return;
        intersects7.push({
            distance: distance,
            distanceToRay: Math.sqrt(rayPointDistanceSq),
            point: intersectPoint,
            index: index,
            face: null,
            object: object
        });
    }
}
class $084574008ccedf86$export$6e09d1edf8d5a25c extends $084574008ccedf86$export$5431306cf43de24a {
    constructor(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy){
        super(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
        this.isVideoTexture = true;
        this.minFilter = minFilter !== undefined ? minFilter : $084574008ccedf86$export$8a72f490b25c56c8;
        this.magFilter = magFilter !== undefined ? magFilter : $084574008ccedf86$export$8a72f490b25c56c8;
        this.generateMipmaps = false;
        const scope = this;
        function updateVideo() {
            scope.needsUpdate = true;
            video.requestVideoFrameCallback(updateVideo);
        }
        if ("requestVideoFrameCallback" in video) video.requestVideoFrameCallback(updateVideo);
    }
    clone() {
        return new this.constructor(this.image).copy(this);
    }
    update() {
        const video = this.image;
        const hasVideoFrameCallback = "requestVideoFrameCallback" in video;
        if (hasVideoFrameCallback === false && video.readyState >= video.HAVE_CURRENT_DATA) this.needsUpdate = true;
    }
}
class $084574008ccedf86$export$9270d786f73ce6fe extends $084574008ccedf86$export$5431306cf43de24a {
    constructor(width, height, format){
        super({
            width: width,
            height: height
        });
        this.isFramebufferTexture = true;
        this.format = format;
        this.magFilter = $084574008ccedf86$export$727aa5ec3fe39bf0;
        this.minFilter = $084574008ccedf86$export$727aa5ec3fe39bf0;
        this.generateMipmaps = false;
        this.needsUpdate = true;
    }
}
class $084574008ccedf86$export$3466bac9141a5cc4 extends $084574008ccedf86$export$5431306cf43de24a {
    constructor(mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding){
        super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
        this.isCompressedTexture = true;
        this.image = {
            width: width,
            height: height
        };
        this.mipmaps = mipmaps;
        // no flipping for cube textures
        // (also flipping doesn't work for compressed textures )
        this.flipY = false;
        // can't generate mipmaps for compressed textures
        // mips must be embedded in DDS files
        this.generateMipmaps = false;
    }
}
class $084574008ccedf86$export$f7189e49152d1c13 extends $084574008ccedf86$export$5431306cf43de24a {
    constructor(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy){
        super(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
        this.isCanvasTexture = true;
        this.needsUpdate = true;
    }
}
/**
 * Extensible curve object.
 *
 * Some common of curve methods:
 * .getPoint( t, optionalTarget ), .getTangent( t, optionalTarget )
 * .getPointAt( u, optionalTarget ), .getTangentAt( u, optionalTarget )
 * .getPoints(), .getSpacedPoints()
 * .getLength()
 * .updateArcLengths()
 *
 * This following curves inherit from THREE.Curve:
 *
 * -- 2D curves --
 * THREE.ArcCurve
 * THREE.CubicBezierCurve
 * THREE.EllipseCurve
 * THREE.LineCurve
 * THREE.QuadraticBezierCurve
 * THREE.SplineCurve
 *
 * -- 3D curves --
 * THREE.CatmullRomCurve3
 * THREE.CubicBezierCurve3
 * THREE.LineCurve3
 * THREE.QuadraticBezierCurve3
 *
 * A series of curves can be represented as a THREE.CurvePath.
 *
 **/ class $084574008ccedf86$export$b0e83c3ef8d2db1 {
    constructor(){
        this.type = "Curve";
        this.arcLengthDivisions = 200;
    }
    // Virtual base class method to overwrite and implement in subclasses
    //	- t [0 .. 1]
    getPoint() {
        console.warn("THREE.Curve: .getPoint() not implemented.");
        return null;
    }
    // Get point at relative position in curve according to arc length
    // - u [0 .. 1]
    getPointAt(u, optionalTarget) {
        const t = this.getUtoTmapping(u);
        return this.getPoint(t, optionalTarget);
    }
    // Get sequence of points using getPoint( t )
    getPoints(divisions = 5) {
        const points = [];
        for(let d = 0; d <= divisions; d++)points.push(this.getPoint(d / divisions));
        return points;
    }
    // Get sequence of points using getPointAt( u )
    getSpacedPoints(divisions = 5) {
        const points = [];
        for(let d = 0; d <= divisions; d++)points.push(this.getPointAt(d / divisions));
        return points;
    }
    // Get total curve arc length
    getLength() {
        const lengths = this.getLengths();
        return lengths[lengths.length - 1];
    }
    // Get list of cumulative segment lengths
    getLengths(divisions = this.arcLengthDivisions) {
        if (this.cacheArcLengths && this.cacheArcLengths.length === divisions + 1 && !this.needsUpdate) return this.cacheArcLengths;
        this.needsUpdate = false;
        const cache = [];
        let current, last = this.getPoint(0);
        let sum = 0;
        cache.push(0);
        for(let p = 1; p <= divisions; p++){
            current = this.getPoint(p / divisions);
            sum += current.distanceTo(last);
            cache.push(sum);
            last = current;
        }
        this.cacheArcLengths = cache;
        return cache; // { sums: cache, sum: sum }; Sum is in the last element.
    }
    updateArcLengths() {
        this.needsUpdate = true;
        this.getLengths();
    }
    // Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant
    getUtoTmapping(u, distance) {
        const arcLengths = this.getLengths();
        let i194 = 0;
        const il = arcLengths.length;
        let targetArcLength; // The targeted u distance value to get
        if (distance) targetArcLength = distance;
        else targetArcLength = u * arcLengths[il - 1];
        // binary search for the index with largest value smaller than target u distance
        let low = 0, high = il - 1, comparison;
        while(low <= high){
            i194 = Math.floor(low + (high - low) / 2); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats
            comparison = arcLengths[i194] - targetArcLength;
            if (comparison < 0) low = i194 + 1;
            else if (comparison > 0) high = i194 - 1;
            else {
                high = i194;
                break;
            // DONE
            }
        }
        i194 = high;
        if (arcLengths[i194] === targetArcLength) return i194 / (il - 1);
        // we could get finer grain at lengths, or use simple interpolation between two points
        const lengthBefore = arcLengths[i194];
        const lengthAfter = arcLengths[i194 + 1];
        const segmentLength = lengthAfter - lengthBefore;
        // determine where we are between the 'before' and 'after' points
        const segmentFraction = (targetArcLength - lengthBefore) / segmentLength;
        // add that fractional amount to t
        const t = (i194 + segmentFraction) / (il - 1);
        return t;
    }
    // Returns a unit vector tangent at t
    // In case any sub curve does not implement its tangent derivation,
    // 2 points a small delta apart will be used to find its gradient
    // which seems to give a reasonable approximation
    getTangent(t, optionalTarget) {
        const delta = 0.0001;
        let t1 = t - delta;
        let t2 = t + delta;
        // Capping in case of danger
        if (t1 < 0) t1 = 0;
        if (t2 > 1) t2 = 1;
        const pt1 = this.getPoint(t1);
        const pt2 = this.getPoint(t2);
        const tangent = optionalTarget || (pt1.isVector2 ? new $084574008ccedf86$export$c977b3e384af9ae1() : new $084574008ccedf86$export$64b5c384219d3699());
        tangent.copy(pt2).sub(pt1).normalize();
        return tangent;
    }
    getTangentAt(u, optionalTarget) {
        const t = this.getUtoTmapping(u);
        return this.getTangent(t, optionalTarget);
    }
    computeFrenetFrames(segments, closed) {
        // see http://www.cs.indiana.edu/pub/techreports/TR425.pdf
        const normal = new $084574008ccedf86$export$64b5c384219d3699();
        const tangents = [];
        const normals = [];
        const binormals = [];
        const vec = new $084574008ccedf86$export$64b5c384219d3699();
        const mat = new $084574008ccedf86$export$2ae72fc923e5eb5();
        // compute the tangent vectors for each segment on the curve
        for(let i196 = 0; i196 <= segments; i196++){
            const u = i196 / segments;
            tangents[i196] = this.getTangentAt(u, new $084574008ccedf86$export$64b5c384219d3699());
        }
        // select an initial normal vector perpendicular to the first tangent vector,
        // and in the direction of the minimum tangent xyz component
        normals[0] = new $084574008ccedf86$export$64b5c384219d3699();
        binormals[0] = new $084574008ccedf86$export$64b5c384219d3699();
        let min = Number.MAX_VALUE;
        const tx = Math.abs(tangents[0].x);
        const ty = Math.abs(tangents[0].y);
        const tz = Math.abs(tangents[0].z);
        if (tx <= min) {
            min = tx;
            normal.set(1, 0, 0);
        }
        if (ty <= min) {
            min = ty;
            normal.set(0, 1, 0);
        }
        if (tz <= min) normal.set(0, 0, 1);
        vec.crossVectors(tangents[0], normal).normalize();
        normals[0].crossVectors(tangents[0], vec);
        binormals[0].crossVectors(tangents[0], normals[0]);
        // compute the slowly-varying normal and binormal vectors for each segment on the curve
        for(let i195 = 1; i195 <= segments; i195++){
            normals[i195] = normals[i195 - 1].clone();
            binormals[i195] = binormals[i195 - 1].clone();
            vec.crossVectors(tangents[i195 - 1], tangents[i195]);
            if (vec.length() > Number.EPSILON) {
                vec.normalize();
                const theta = Math.acos($084574008ccedf86$var$clamp(tangents[i195 - 1].dot(tangents[i195]), -1, 1)); // clamp for floating pt errors
                normals[i195].applyMatrix4(mat.makeRotationAxis(vec, theta));
            }
            binormals[i195].crossVectors(tangents[i195], normals[i195]);
        }
        // if the curve is closed, postprocess the vectors so the first and last normal vectors are the same
        if (closed === true) {
            let theta = Math.acos($084574008ccedf86$var$clamp(normals[0].dot(normals[segments]), -1, 1));
            theta /= segments;
            if (tangents[0].dot(vec.crossVectors(normals[0], normals[segments])) > 0) theta = -theta;
            for(let i197 = 1; i197 <= segments; i197++){
                // twist a little...
                normals[i197].applyMatrix4(mat.makeRotationAxis(tangents[i197], theta * i197));
                binormals[i197].crossVectors(tangents[i197], normals[i197]);
            }
        }
        return {
            tangents: tangents,
            normals: normals,
            binormals: binormals
        };
    }
    clone() {
        return new this.constructor().copy(this);
    }
    copy(source) {
        this.arcLengthDivisions = source.arcLengthDivisions;
        return this;
    }
    toJSON() {
        const data = {
            metadata: {
                version: 4.5,
                type: "Curve",
                generator: "Curve.toJSON"
            }
        };
        data.arcLengthDivisions = this.arcLengthDivisions;
        data.type = this.type;
        return data;
    }
    fromJSON(json) {
        this.arcLengthDivisions = json.arcLengthDivisions;
        return this;
    }
}
class $084574008ccedf86$export$3f87a931616cde04 extends $084574008ccedf86$export$b0e83c3ef8d2db1 {
    constructor(aX = 0, aY = 0, xRadius = 1, yRadius = 1, aStartAngle = 0, aEndAngle = Math.PI * 2, aClockwise = false, aRotation = 0){
        super();
        this.isEllipseCurve = true;
        this.type = "EllipseCurve";
        this.aX = aX;
        this.aY = aY;
        this.xRadius = xRadius;
        this.yRadius = yRadius;
        this.aStartAngle = aStartAngle;
        this.aEndAngle = aEndAngle;
        this.aClockwise = aClockwise;
        this.aRotation = aRotation;
    }
    getPoint(t, optionalTarget) {
        const point = optionalTarget || new $084574008ccedf86$export$c977b3e384af9ae1();
        const twoPi = Math.PI * 2;
        let deltaAngle = this.aEndAngle - this.aStartAngle;
        const samePoints = Math.abs(deltaAngle) < Number.EPSILON;
        // ensures that deltaAngle is 0 .. 2 PI
        while(deltaAngle < 0)deltaAngle += twoPi;
        while(deltaAngle > twoPi)deltaAngle -= twoPi;
        if (deltaAngle < Number.EPSILON) {
            if (samePoints) deltaAngle = 0;
            else deltaAngle = twoPi;
        }
        if (this.aClockwise === true && !samePoints) {
            if (deltaAngle === twoPi) deltaAngle = -twoPi;
            else deltaAngle = deltaAngle - twoPi;
        }
        const angle = this.aStartAngle + t * deltaAngle;
        let x = this.aX + this.xRadius * Math.cos(angle);
        let y = this.aY + this.yRadius * Math.sin(angle);
        if (this.aRotation !== 0) {
            const cos = Math.cos(this.aRotation);
            const sin = Math.sin(this.aRotation);
            const tx = x - this.aX;
            const ty = y - this.aY;
            // Rotate the point about the center of the ellipse.
            x = tx * cos - ty * sin + this.aX;
            y = tx * sin + ty * cos + this.aY;
        }
        return point.set(x, y);
    }
    copy(source) {
        super.copy(source);
        this.aX = source.aX;
        this.aY = source.aY;
        this.xRadius = source.xRadius;
        this.yRadius = source.yRadius;
        this.aStartAngle = source.aStartAngle;
        this.aEndAngle = source.aEndAngle;
        this.aClockwise = source.aClockwise;
        this.aRotation = source.aRotation;
        return this;
    }
    toJSON() {
        const data = super.toJSON();
        data.aX = this.aX;
        data.aY = this.aY;
        data.xRadius = this.xRadius;
        data.yRadius = this.yRadius;
        data.aStartAngle = this.aStartAngle;
        data.aEndAngle = this.aEndAngle;
        data.aClockwise = this.aClockwise;
        data.aRotation = this.aRotation;
        return data;
    }
    fromJSON(json) {
        super.fromJSON(json);
        this.aX = json.aX;
        this.aY = json.aY;
        this.xRadius = json.xRadius;
        this.yRadius = json.yRadius;
        this.aStartAngle = json.aStartAngle;
        this.aEndAngle = json.aEndAngle;
        this.aClockwise = json.aClockwise;
        this.aRotation = json.aRotation;
        return this;
    }
}
class $084574008ccedf86$export$b1eedc9aab6300e8 extends $084574008ccedf86$export$3f87a931616cde04 {
    constructor(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise){
        super(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
        this.isArcCurve = true;
        this.type = "ArcCurve";
    }
}
/**
 * Centripetal CatmullRom Curve - which is useful for avoiding
 * cusps and self-intersections in non-uniform catmull rom curves.
 * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
 *
 * curve.type accepts centripetal(default), chordal and catmullrom
 * curve.tension is used for catmullrom which defaults to 0.5
 */ /*
Based on an optimized c++ solution in
 - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
 - http://ideone.com/NoEbVM

This CubicPoly class could be used for reusing some variables and calculations,
but for three.js curve use, it could be possible inlined and flatten into a single function call
which can be placed in CurveUtils.
*/ function $084574008ccedf86$var$CubicPoly() {
    let c0 = 0, c1 = 0, c2 = 0, c3 = 0;
    /*
	 * Compute coefficients for a cubic polynomial
	 *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3
	 * such that
	 *   p(0) = x0, p(1) = x1
	 *  and
	 *   p'(0) = t0, p'(1) = t1.
	 */ function init(x0, x1, t0, t1) {
        c0 = x0;
        c1 = t0;
        c2 = -3 * x0 + 3 * x1 - 2 * t0 - t1;
        c3 = 2 * x0 - 2 * x1 + t0 + t1;
    }
    return {
        initCatmullRom: function(x0, x1, x2, x3, tension) {
            init(x1, x2, tension * (x2 - x0), tension * (x3 - x1));
        },
        initNonuniformCatmullRom: function(x0, x1, x2, x3, dt0, dt1, dt2) {
            // compute tangents when parameterized in [t1,t2]
            let t1 = (x1 - x0) / dt0 - (x2 - x0) / (dt0 + dt1) + (x2 - x1) / dt1;
            let t2 = (x2 - x1) / dt1 - (x3 - x1) / (dt1 + dt2) + (x3 - x2) / dt2;
            // rescale tangents for parametrization in [0,1]
            t1 *= dt1;
            t2 *= dt1;
            init(x1, x2, t1, t2);
        },
        calc: function(t) {
            const t2 = t * t;
            const t3 = t2 * t;
            return c0 + c1 * t + c2 * t2 + c3 * t3;
        }
    };
}
//
const $084574008ccedf86$var$tmp = new $084574008ccedf86$export$64b5c384219d3699();
const $084574008ccedf86$var$px = new $084574008ccedf86$var$CubicPoly(), $084574008ccedf86$var$py = new $084574008ccedf86$var$CubicPoly(), $084574008ccedf86$var$pz = new $084574008ccedf86$var$CubicPoly();
class $084574008ccedf86$export$b9146b27c24b744c extends $084574008ccedf86$export$b0e83c3ef8d2db1 {
    constructor(points = [], closed = false, curveType = "centripetal", tension = 0.5){
        super();
        this.isCatmullRomCurve3 = true;
        this.type = "CatmullRomCurve3";
        this.points = points;
        this.closed = closed;
        this.curveType = curveType;
        this.tension = tension;
    }
    getPoint(t, optionalTarget = new $084574008ccedf86$export$64b5c384219d3699()) {
        const point = optionalTarget;
        const points = this.points;
        const l = points.length;
        const p = (l - (this.closed ? 0 : 1)) * t;
        let intPoint = Math.floor(p);
        let weight = p - intPoint;
        if (this.closed) intPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / l) + 1) * l;
        else if (weight === 0 && intPoint === l - 1) {
            intPoint = l - 2;
            weight = 1;
        }
        let p0, p3; // 4 points (p1 & p2 defined below)
        if (this.closed || intPoint > 0) p0 = points[(intPoint - 1) % l];
        else {
            // extrapolate first point
            $084574008ccedf86$var$tmp.subVectors(points[0], points[1]).add(points[0]);
            p0 = $084574008ccedf86$var$tmp;
        }
        const p1 = points[intPoint % l];
        const p2 = points[(intPoint + 1) % l];
        if (this.closed || intPoint + 2 < l) p3 = points[(intPoint + 2) % l];
        else {
            // extrapolate last point
            $084574008ccedf86$var$tmp.subVectors(points[l - 1], points[l - 2]).add(points[l - 1]);
            p3 = $084574008ccedf86$var$tmp;
        }
        if (this.curveType === "centripetal" || this.curveType === "chordal") {
            // init Centripetal / Chordal Catmull-Rom
            const pow = this.curveType === "chordal" ? 0.5 : 0.25;
            let dt0 = Math.pow(p0.distanceToSquared(p1), pow);
            let dt1 = Math.pow(p1.distanceToSquared(p2), pow);
            let dt2 = Math.pow(p2.distanceToSquared(p3), pow);
            // safety check for repeated points
            if (dt1 < 1e-4) dt1 = 1.0;
            if (dt0 < 1e-4) dt0 = dt1;
            if (dt2 < 1e-4) dt2 = dt1;
            $084574008ccedf86$var$px.initNonuniformCatmullRom(p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2);
            $084574008ccedf86$var$py.initNonuniformCatmullRom(p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2);
            $084574008ccedf86$var$pz.initNonuniformCatmullRom(p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2);
        } else if (this.curveType === "catmullrom") {
            $084574008ccedf86$var$px.initCatmullRom(p0.x, p1.x, p2.x, p3.x, this.tension);
            $084574008ccedf86$var$py.initCatmullRom(p0.y, p1.y, p2.y, p3.y, this.tension);
            $084574008ccedf86$var$pz.initCatmullRom(p0.z, p1.z, p2.z, p3.z, this.tension);
        }
        point.set($084574008ccedf86$var$px.calc(weight), $084574008ccedf86$var$py.calc(weight), $084574008ccedf86$var$pz.calc(weight));
        return point;
    }
    copy(source) {
        super.copy(source);
        this.points = [];
        for(let i198 = 0, l = source.points.length; i198 < l; i198++){
            const point = source.points[i198];
            this.points.push(point.clone());
        }
        this.closed = source.closed;
        this.curveType = source.curveType;
        this.tension = source.tension;
        return this;
    }
    toJSON() {
        const data = super.toJSON();
        data.points = [];
        for(let i199 = 0, l = this.points.length; i199 < l; i199++){
            const point = this.points[i199];
            data.points.push(point.toArray());
        }
        data.closed = this.closed;
        data.curveType = this.curveType;
        data.tension = this.tension;
        return data;
    }
    fromJSON(json) {
        super.fromJSON(json);
        this.points = [];
        for(let i200 = 0, l = json.points.length; i200 < l; i200++){
            const point = json.points[i200];
            this.points.push(new $084574008ccedf86$export$64b5c384219d3699().fromArray(point));
        }
        this.closed = json.closed;
        this.curveType = json.curveType;
        this.tension = json.tension;
        return this;
    }
}
/**
 * Bezier Curves formulas obtained from
 * https://en.wikipedia.org/wiki/B%C3%A9zier_curve
 */ function $084574008ccedf86$var$CatmullRom(t, p0, p1, p2, p3) {
    const v0 = (p2 - p0) * 0.5;
    const v1 = (p3 - p1) * 0.5;
    const t2 = t * t;
    const t3 = t * t2;
    return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
}
//
function $084574008ccedf86$var$QuadraticBezierP0(t, p) {
    const k = 1 - t;
    return k * k * p;
}
function $084574008ccedf86$var$QuadraticBezierP1(t, p) {
    return 2 * (1 - t) * t * p;
}
function $084574008ccedf86$var$QuadraticBezierP2(t, p) {
    return t * t * p;
}
function $084574008ccedf86$var$QuadraticBezier(t, p0, p1, p2) {
    return $084574008ccedf86$var$QuadraticBezierP0(t, p0) + $084574008ccedf86$var$QuadraticBezierP1(t, p1) + $084574008ccedf86$var$QuadraticBezierP2(t, p2);
}
//
function $084574008ccedf86$var$CubicBezierP0(t, p) {
    const k = 1 - t;
    return k * k * k * p;
}
function $084574008ccedf86$var$CubicBezierP1(t, p) {
    const k = 1 - t;
    return 3 * k * k * t * p;
}
function $084574008ccedf86$var$CubicBezierP2(t, p) {
    return 3 * (1 - t) * t * t * p;
}
function $084574008ccedf86$var$CubicBezierP3(t, p) {
    return t * t * t * p;
}
function $084574008ccedf86$var$CubicBezier(t, p0, p1, p2, p3) {
    return $084574008ccedf86$var$CubicBezierP0(t, p0) + $084574008ccedf86$var$CubicBezierP1(t, p1) + $084574008ccedf86$var$CubicBezierP2(t, p2) + $084574008ccedf86$var$CubicBezierP3(t, p3);
}
class $084574008ccedf86$export$e36650d36468bb39 extends $084574008ccedf86$export$b0e83c3ef8d2db1 {
    constructor(v0 = new $084574008ccedf86$export$c977b3e384af9ae1(), v1 = new $084574008ccedf86$export$c977b3e384af9ae1(), v2 = new $084574008ccedf86$export$c977b3e384af9ae1(), v3 = new $084574008ccedf86$export$c977b3e384af9ae1()){
        super();
        this.isCubicBezierCurve = true;
        this.type = "CubicBezierCurve";
        this.v0 = v0;
        this.v1 = v1;
        this.v2 = v2;
        this.v3 = v3;
    }
    getPoint(t, optionalTarget = new $084574008ccedf86$export$c977b3e384af9ae1()) {
        const point = optionalTarget;
        const v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;
        point.set($084574008ccedf86$var$CubicBezier(t, v0.x, v1.x, v2.x, v3.x), $084574008ccedf86$var$CubicBezier(t, v0.y, v1.y, v2.y, v3.y));
        return point;
    }
    copy(source) {
        super.copy(source);
        this.v0.copy(source.v0);
        this.v1.copy(source.v1);
        this.v2.copy(source.v2);
        this.v3.copy(source.v3);
        return this;
    }
    toJSON() {
        const data = super.toJSON();
        data.v0 = this.v0.toArray();
        data.v1 = this.v1.toArray();
        data.v2 = this.v2.toArray();
        data.v3 = this.v3.toArray();
        return data;
    }
    fromJSON(json) {
        super.fromJSON(json);
        this.v0.fromArray(json.v0);
        this.v1.fromArray(json.v1);
        this.v2.fromArray(json.v2);
        this.v3.fromArray(json.v3);
        return this;
    }
}
class $084574008ccedf86$export$13d5f1c9525f246c extends $084574008ccedf86$export$b0e83c3ef8d2db1 {
    constructor(v0 = new $084574008ccedf86$export$64b5c384219d3699(), v1 = new $084574008ccedf86$export$64b5c384219d3699(), v2 = new $084574008ccedf86$export$64b5c384219d3699(), v3 = new $084574008ccedf86$export$64b5c384219d3699()){
        super();
        this.isCubicBezierCurve3 = true;
        this.type = "CubicBezierCurve3";
        this.v0 = v0;
        this.v1 = v1;
        this.v2 = v2;
        this.v3 = v3;
    }
    getPoint(t, optionalTarget = new $084574008ccedf86$export$64b5c384219d3699()) {
        const point = optionalTarget;
        const v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;
        point.set($084574008ccedf86$var$CubicBezier(t, v0.x, v1.x, v2.x, v3.x), $084574008ccedf86$var$CubicBezier(t, v0.y, v1.y, v2.y, v3.y), $084574008ccedf86$var$CubicBezier(t, v0.z, v1.z, v2.z, v3.z));
        return point;
    }
    copy(source) {
        super.copy(source);
        this.v0.copy(source.v0);
        this.v1.copy(source.v1);
        this.v2.copy(source.v2);
        this.v3.copy(source.v3);
        return this;
    }
    toJSON() {
        const data = super.toJSON();
        data.v0 = this.v0.toArray();
        data.v1 = this.v1.toArray();
        data.v2 = this.v2.toArray();
        data.v3 = this.v3.toArray();
        return data;
    }
    fromJSON(json) {
        super.fromJSON(json);
        this.v0.fromArray(json.v0);
        this.v1.fromArray(json.v1);
        this.v2.fromArray(json.v2);
        this.v3.fromArray(json.v3);
        return this;
    }
}
class $084574008ccedf86$export$ab2e07e76531a47e extends $084574008ccedf86$export$b0e83c3ef8d2db1 {
    constructor(v1 = new $084574008ccedf86$export$c977b3e384af9ae1(), v2 = new $084574008ccedf86$export$c977b3e384af9ae1()){
        super();
        this.isLineCurve = true;
        this.type = "LineCurve";
        this.v1 = v1;
        this.v2 = v2;
    }
    getPoint(t, optionalTarget = new $084574008ccedf86$export$c977b3e384af9ae1()) {
        const point = optionalTarget;
        if (t === 1) point.copy(this.v2);
        else {
            point.copy(this.v2).sub(this.v1);
            point.multiplyScalar(t).add(this.v1);
        }
        return point;
    }
    // Line curve is linear, so we can overwrite default getPointAt
    getPointAt(u, optionalTarget) {
        return this.getPoint(u, optionalTarget);
    }
    getTangent(t, optionalTarget) {
        const tangent = optionalTarget || new $084574008ccedf86$export$c977b3e384af9ae1();
        tangent.copy(this.v2).sub(this.v1).normalize();
        return tangent;
    }
    copy(source) {
        super.copy(source);
        this.v1.copy(source.v1);
        this.v2.copy(source.v2);
        return this;
    }
    toJSON() {
        const data = super.toJSON();
        data.v1 = this.v1.toArray();
        data.v2 = this.v2.toArray();
        return data;
    }
    fromJSON(json) {
        super.fromJSON(json);
        this.v1.fromArray(json.v1);
        this.v2.fromArray(json.v2);
        return this;
    }
}
class $084574008ccedf86$export$1fdfd9d9cf487600 extends $084574008ccedf86$export$b0e83c3ef8d2db1 {
    constructor(v1 = new $084574008ccedf86$export$64b5c384219d3699(), v2 = new $084574008ccedf86$export$64b5c384219d3699()){
        super();
        this.isLineCurve3 = true;
        this.type = "LineCurve3";
        this.v1 = v1;
        this.v2 = v2;
    }
    getPoint(t, optionalTarget = new $084574008ccedf86$export$64b5c384219d3699()) {
        const point = optionalTarget;
        if (t === 1) point.copy(this.v2);
        else {
            point.copy(this.v2).sub(this.v1);
            point.multiplyScalar(t).add(this.v1);
        }
        return point;
    }
    // Line curve is linear, so we can overwrite default getPointAt
    getPointAt(u, optionalTarget) {
        return this.getPoint(u, optionalTarget);
    }
    copy(source) {
        super.copy(source);
        this.v1.copy(source.v1);
        this.v2.copy(source.v2);
        return this;
    }
    toJSON() {
        const data = super.toJSON();
        data.v1 = this.v1.toArray();
        data.v2 = this.v2.toArray();
        return data;
    }
    fromJSON(json) {
        super.fromJSON(json);
        this.v1.fromArray(json.v1);
        this.v2.fromArray(json.v2);
        return this;
    }
}
class $084574008ccedf86$export$5938c4ee491a43ad extends $084574008ccedf86$export$b0e83c3ef8d2db1 {
    constructor(v0 = new $084574008ccedf86$export$c977b3e384af9ae1(), v1 = new $084574008ccedf86$export$c977b3e384af9ae1(), v2 = new $084574008ccedf86$export$c977b3e384af9ae1()){
        super();
        this.isQuadraticBezierCurve = true;
        this.type = "QuadraticBezierCurve";
        this.v0 = v0;
        this.v1 = v1;
        this.v2 = v2;
    }
    getPoint(t, optionalTarget = new $084574008ccedf86$export$c977b3e384af9ae1()) {
        const point = optionalTarget;
        const v0 = this.v0, v1 = this.v1, v2 = this.v2;
        point.set($084574008ccedf86$var$QuadraticBezier(t, v0.x, v1.x, v2.x), $084574008ccedf86$var$QuadraticBezier(t, v0.y, v1.y, v2.y));
        return point;
    }
    copy(source) {
        super.copy(source);
        this.v0.copy(source.v0);
        this.v1.copy(source.v1);
        this.v2.copy(source.v2);
        return this;
    }
    toJSON() {
        const data = super.toJSON();
        data.v0 = this.v0.toArray();
        data.v1 = this.v1.toArray();
        data.v2 = this.v2.toArray();
        return data;
    }
    fromJSON(json) {
        super.fromJSON(json);
        this.v0.fromArray(json.v0);
        this.v1.fromArray(json.v1);
        this.v2.fromArray(json.v2);
        return this;
    }
}
class $084574008ccedf86$export$bf3f4c7e459f90fc extends $084574008ccedf86$export$b0e83c3ef8d2db1 {
    constructor(v0 = new $084574008ccedf86$export$64b5c384219d3699(), v1 = new $084574008ccedf86$export$64b5c384219d3699(), v2 = new $084574008ccedf86$export$64b5c384219d3699()){
        super();
        this.isQuadraticBezierCurve3 = true;
        this.type = "QuadraticBezierCurve3";
        this.v0 = v0;
        this.v1 = v1;
        this.v2 = v2;
    }
    getPoint(t, optionalTarget = new $084574008ccedf86$export$64b5c384219d3699()) {
        const point = optionalTarget;
        const v0 = this.v0, v1 = this.v1, v2 = this.v2;
        point.set($084574008ccedf86$var$QuadraticBezier(t, v0.x, v1.x, v2.x), $084574008ccedf86$var$QuadraticBezier(t, v0.y, v1.y, v2.y), $084574008ccedf86$var$QuadraticBezier(t, v0.z, v1.z, v2.z));
        return point;
    }
    copy(source) {
        super.copy(source);
        this.v0.copy(source.v0);
        this.v1.copy(source.v1);
        this.v2.copy(source.v2);
        return this;
    }
    toJSON() {
        const data = super.toJSON();
        data.v0 = this.v0.toArray();
        data.v1 = this.v1.toArray();
        data.v2 = this.v2.toArray();
        return data;
    }
    fromJSON(json) {
        super.fromJSON(json);
        this.v0.fromArray(json.v0);
        this.v1.fromArray(json.v1);
        this.v2.fromArray(json.v2);
        return this;
    }
}
class $084574008ccedf86$export$d3bdd77da77afc1b extends $084574008ccedf86$export$b0e83c3ef8d2db1 {
    constructor(points = []){
        super();
        this.isSplineCurve = true;
        this.type = "SplineCurve";
        this.points = points;
    }
    getPoint(t, optionalTarget = new $084574008ccedf86$export$c977b3e384af9ae1()) {
        const point = optionalTarget;
        const points = this.points;
        const p = (points.length - 1) * t;
        const intPoint = Math.floor(p);
        const weight = p - intPoint;
        const p0 = points[intPoint === 0 ? intPoint : intPoint - 1];
        const p1 = points[intPoint];
        const p2 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];
        const p3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];
        point.set($084574008ccedf86$var$CatmullRom(weight, p0.x, p1.x, p2.x, p3.x), $084574008ccedf86$var$CatmullRom(weight, p0.y, p1.y, p2.y, p3.y));
        return point;
    }
    copy(source) {
        super.copy(source);
        this.points = [];
        for(let i201 = 0, l = source.points.length; i201 < l; i201++){
            const point = source.points[i201];
            this.points.push(point.clone());
        }
        return this;
    }
    toJSON() {
        const data = super.toJSON();
        data.points = [];
        for(let i202 = 0, l = this.points.length; i202 < l; i202++){
            const point = this.points[i202];
            data.points.push(point.toArray());
        }
        return data;
    }
    fromJSON(json) {
        super.fromJSON(json);
        this.points = [];
        for(let i203 = 0, l = json.points.length; i203 < l; i203++){
            const point = json.points[i203];
            this.points.push(new $084574008ccedf86$export$c977b3e384af9ae1().fromArray(point));
        }
        return this;
    }
}
var $084574008ccedf86$var$Curves = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    ArcCurve: $084574008ccedf86$export$b1eedc9aab6300e8,
    CatmullRomCurve3: $084574008ccedf86$export$b9146b27c24b744c,
    CubicBezierCurve: $084574008ccedf86$export$e36650d36468bb39,
    CubicBezierCurve3: $084574008ccedf86$export$13d5f1c9525f246c,
    EllipseCurve: $084574008ccedf86$export$3f87a931616cde04,
    LineCurve: $084574008ccedf86$export$ab2e07e76531a47e,
    LineCurve3: $084574008ccedf86$export$1fdfd9d9cf487600,
    QuadraticBezierCurve: $084574008ccedf86$export$5938c4ee491a43ad,
    QuadraticBezierCurve3: $084574008ccedf86$export$bf3f4c7e459f90fc,
    SplineCurve: $084574008ccedf86$export$d3bdd77da77afc1b
});
/**************************************************************
 *	Curved Path - a curve path is simply a array of connected
 *  curves, but retains the api of a curve
 **************************************************************/ class $084574008ccedf86$export$4aaf9b66af1bbf2c extends $084574008ccedf86$export$b0e83c3ef8d2db1 {
    constructor(){
        super();
        this.type = "CurvePath";
        this.curves = [];
        this.autoClose = false; // Automatically closes the path
    }
    add(curve) {
        this.curves.push(curve);
    }
    closePath() {
        // Add a line curve if start and end of lines are not connected
        const startPoint = this.curves[0].getPoint(0);
        const endPoint = this.curves[this.curves.length - 1].getPoint(1);
        if (!startPoint.equals(endPoint)) this.curves.push(new $084574008ccedf86$export$ab2e07e76531a47e(endPoint, startPoint));
    }
    // To get accurate point with reference to
    // entire path distance at time t,
    // following has to be done:
    // 1. Length of each sub path have to be known
    // 2. Locate and identify type of curve
    // 3. Get t for the curve
    // 4. Return curve.getPointAt(t')
    getPoint(t, optionalTarget) {
        const d = t * this.getLength();
        const curveLengths = this.getCurveLengths();
        let i204 = 0;
        // To think about boundaries points.
        while(i204 < curveLengths.length){
            if (curveLengths[i204] >= d) {
                const diff = curveLengths[i204] - d;
                const curve = this.curves[i204];
                const segmentLength = curve.getLength();
                const u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;
                return curve.getPointAt(u, optionalTarget);
            }
            i204++;
        }
        return null;
    // loop where sum != 0, sum > d , sum+1 <d
    }
    // We cannot use the default THREE.Curve getPoint() with getLength() because in
    // THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
    // getPoint() depends on getLength
    getLength() {
        const lens = this.getCurveLengths();
        return lens[lens.length - 1];
    }
    // cacheLengths must be recalculated.
    updateArcLengths() {
        this.needsUpdate = true;
        this.cacheLengths = null;
        this.getCurveLengths();
    }
    // Compute lengths and cache them
    // We cannot overwrite getLengths() because UtoT mapping uses it.
    getCurveLengths() {
        // We use cache values if curves and cache array are same length
        if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
        // Get length of sub-curve
        // Push sums into cached array
        const lengths = [];
        let sums = 0;
        for(let i205 = 0, l = this.curves.length; i205 < l; i205++){
            sums += this.curves[i205].getLength();
            lengths.push(sums);
        }
        this.cacheLengths = lengths;
        return lengths;
    }
    getSpacedPoints(divisions = 40) {
        const points = [];
        for(let i206 = 0; i206 <= divisions; i206++)points.push(this.getPoint(i206 / divisions));
        if (this.autoClose) points.push(points[0]);
        return points;
    }
    getPoints(divisions = 12) {
        const points = [];
        let last;
        for(let i207 = 0, curves = this.curves; i207 < curves.length; i207++){
            const curve = curves[i207];
            const resolution = curve.isEllipseCurve ? divisions * 2 : curve.isLineCurve || curve.isLineCurve3 ? 1 : curve.isSplineCurve ? divisions * curve.points.length : divisions;
            const pts = curve.getPoints(resolution);
            for(let j = 0; j < pts.length; j++){
                const point = pts[j];
                if (last && last.equals(point)) continue; // ensures no consecutive points are duplicates
                points.push(point);
                last = point;
            }
        }
        if (this.autoClose && points.length > 1 && !points[points.length - 1].equals(points[0])) points.push(points[0]);
        return points;
    }
    copy(source) {
        super.copy(source);
        this.curves = [];
        for(let i208 = 0, l = source.curves.length; i208 < l; i208++){
            const curve = source.curves[i208];
            this.curves.push(curve.clone());
        }
        this.autoClose = source.autoClose;
        return this;
    }
    toJSON() {
        const data = super.toJSON();
        data.autoClose = this.autoClose;
        data.curves = [];
        for(let i209 = 0, l = this.curves.length; i209 < l; i209++){
            const curve = this.curves[i209];
            data.curves.push(curve.toJSON());
        }
        return data;
    }
    fromJSON(json) {
        super.fromJSON(json);
        this.autoClose = json.autoClose;
        this.curves = [];
        for(let i210 = 0, l = json.curves.length; i210 < l; i210++){
            const curve = json.curves[i210];
            this.curves.push(new $084574008ccedf86$var$Curves[curve.type]().fromJSON(curve));
        }
        return this;
    }
}
class $084574008ccedf86$export$4b2950bdac9b6ee9 extends $084574008ccedf86$export$4aaf9b66af1bbf2c {
    constructor(points){
        super();
        this.type = "Path";
        this.currentPoint = new $084574008ccedf86$export$c977b3e384af9ae1();
        if (points) this.setFromPoints(points);
    }
    setFromPoints(points) {
        this.moveTo(points[0].x, points[0].y);
        for(let i211 = 1, l = points.length; i211 < l; i211++)this.lineTo(points[i211].x, points[i211].y);
        return this;
    }
    moveTo(x, y) {
        this.currentPoint.set(x, y); // TODO consider referencing vectors instead of copying?
        return this;
    }
    lineTo(x, y) {
        const curve = new $084574008ccedf86$export$ab2e07e76531a47e(this.currentPoint.clone(), new $084574008ccedf86$export$c977b3e384af9ae1(x, y));
        this.curves.push(curve);
        this.currentPoint.set(x, y);
        return this;
    }
    quadraticCurveTo(aCPx, aCPy, aX, aY) {
        const curve = new $084574008ccedf86$export$5938c4ee491a43ad(this.currentPoint.clone(), new $084574008ccedf86$export$c977b3e384af9ae1(aCPx, aCPy), new $084574008ccedf86$export$c977b3e384af9ae1(aX, aY));
        this.curves.push(curve);
        this.currentPoint.set(aX, aY);
        return this;
    }
    bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
        const curve = new $084574008ccedf86$export$e36650d36468bb39(this.currentPoint.clone(), new $084574008ccedf86$export$c977b3e384af9ae1(aCP1x, aCP1y), new $084574008ccedf86$export$c977b3e384af9ae1(aCP2x, aCP2y), new $084574008ccedf86$export$c977b3e384af9ae1(aX, aY));
        this.curves.push(curve);
        this.currentPoint.set(aX, aY);
        return this;
    }
    splineThru(pts /*Array of Vector*/ ) {
        const npts = [
            this.currentPoint.clone()
        ].concat(pts);
        const curve = new $084574008ccedf86$export$d3bdd77da77afc1b(npts);
        this.curves.push(curve);
        this.currentPoint.copy(pts[pts.length - 1]);
        return this;
    }
    arc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
        const x0 = this.currentPoint.x;
        const y0 = this.currentPoint.y;
        this.absarc(aX + x0, aY + y0, aRadius, aStartAngle, aEndAngle, aClockwise);
        return this;
    }
    absarc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
        this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
        return this;
    }
    ellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
        const x0 = this.currentPoint.x;
        const y0 = this.currentPoint.y;
        this.absellipse(aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
        return this;
    }
    absellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
        const curve = new $084574008ccedf86$export$3f87a931616cde04(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
        if (this.curves.length > 0) {
            // if a previous curve is present, attempt to join
            const firstPoint = curve.getPoint(0);
            if (!firstPoint.equals(this.currentPoint)) this.lineTo(firstPoint.x, firstPoint.y);
        }
        this.curves.push(curve);
        const lastPoint = curve.getPoint(1);
        this.currentPoint.copy(lastPoint);
        return this;
    }
    copy(source) {
        super.copy(source);
        this.currentPoint.copy(source.currentPoint);
        return this;
    }
    toJSON() {
        const data = super.toJSON();
        data.currentPoint = this.currentPoint.toArray();
        return data;
    }
    fromJSON(json) {
        super.fromJSON(json);
        this.currentPoint.fromArray(json.currentPoint);
        return this;
    }
}
class $084574008ccedf86$export$dc3e1273c1dd9240 extends $084574008ccedf86$export$b7be63a67df8959 {
    constructor(points = [
        new $084574008ccedf86$export$c977b3e384af9ae1(0, 0.5),
        new $084574008ccedf86$export$c977b3e384af9ae1(0.5, 0),
        new $084574008ccedf86$export$c977b3e384af9ae1(0, -0.5)
    ], segments = 12, phiStart = 0, phiLength = Math.PI * 2){
        super();
        this.type = "LatheGeometry";
        this.parameters = {
            points: points,
            segments: segments,
            phiStart: phiStart,
            phiLength: phiLength
        };
        segments = Math.floor(segments);
        // clamp phiLength so it's in range of [ 0, 2PI ]
        phiLength = $084574008ccedf86$var$clamp(phiLength, 0, Math.PI * 2);
        // buffers
        const indices = [];
        const vertices = [];
        const uvs = [];
        const initNormals = [];
        const normals = [];
        // helper variables
        const inverseSegments = 1.0 / segments;
        const vertex1 = new $084574008ccedf86$export$64b5c384219d3699();
        const uv = new $084574008ccedf86$export$c977b3e384af9ae1();
        const normal = new $084574008ccedf86$export$64b5c384219d3699();
        const curNormal = new $084574008ccedf86$export$64b5c384219d3699();
        const prevNormal = new $084574008ccedf86$export$64b5c384219d3699();
        let dx = 0;
        let dy = 0;
        // pre-compute normals for initial "meridian"
        for(let j = 0; j <= points.length - 1; j++)switch(j){
            case 0:
                dx = points[j + 1].x - points[j].x;
                dy = points[j + 1].y - points[j].y;
                normal.x = dy * 1.0;
                normal.y = -dx;
                normal.z = dy * 0.0;
                prevNormal.copy(normal);
                normal.normalize();
                initNormals.push(normal.x, normal.y, normal.z);
                break;
            case points.length - 1:
                initNormals.push(prevNormal.x, prevNormal.y, prevNormal.z);
                break;
            default:
                dx = points[j + 1].x - points[j].x;
                dy = points[j + 1].y - points[j].y;
                normal.x = dy * 1.0;
                normal.y = -dx;
                normal.z = dy * 0.0;
                curNormal.copy(normal);
                normal.x += prevNormal.x;
                normal.y += prevNormal.y;
                normal.z += prevNormal.z;
                normal.normalize();
                initNormals.push(normal.x, normal.y, normal.z);
                prevNormal.copy(curNormal);
        }
        // generate vertices, uvs and normals
        for(let i213 = 0; i213 <= segments; i213++){
            const phi = phiStart + i213 * inverseSegments * phiLength;
            const sin = Math.sin(phi);
            const cos = Math.cos(phi);
            for(let j = 0; j <= points.length - 1; j++){
                // vertex
                vertex1.x = points[j].x * sin;
                vertex1.y = points[j].y;
                vertex1.z = points[j].x * cos;
                vertices.push(vertex1.x, vertex1.y, vertex1.z);
                // uv
                uv.x = i213 / segments;
                uv.y = j / (points.length - 1);
                uvs.push(uv.x, uv.y);
                // normal
                const x = initNormals[3 * j + 0] * sin;
                const y = initNormals[3 * j + 1];
                const z = initNormals[3 * j + 0] * cos;
                normals.push(x, y, z);
            }
        }
        // indices
        for(let i212 = 0; i212 < segments; i212++)for(let j1 = 0; j1 < points.length - 1; j1++){
            const base = j1 + i212 * points.length;
            const a = base;
            const b = base + points.length;
            const c = base + points.length + 1;
            const d = base + 1;
            // faces
            indices.push(a, b, d);
            indices.push(c, d, b);
        }
        // build geometry
        this.setIndex(indices);
        this.setAttribute("position", new $084574008ccedf86$export$cbe7a62641830ebd(vertices, 3));
        this.setAttribute("uv", new $084574008ccedf86$export$cbe7a62641830ebd(uvs, 2));
        this.setAttribute("normal", new $084574008ccedf86$export$cbe7a62641830ebd(normals, 3));
    }
    static fromJSON(data) {
        return new $084574008ccedf86$export$dc3e1273c1dd9240(data.points, data.segments, data.phiStart, data.phiLength);
    }
}
class $084574008ccedf86$export$f036d76f832848a extends $084574008ccedf86$export$dc3e1273c1dd9240 {
    constructor(radius = 1, length = 1, capSegments = 4, radialSegments = 8){
        const path = new $084574008ccedf86$export$4b2950bdac9b6ee9();
        path.absarc(0, -length / 2, radius, Math.PI * 1.5, 0);
        path.absarc(0, length / 2, radius, 0, Math.PI * 0.5);
        super(path.getPoints(capSegments), radialSegments);
        this.type = "CapsuleGeometry";
        this.parameters = {
            radius: radius,
            height: length,
            capSegments: capSegments,
            radialSegments: radialSegments
        };
    }
    static fromJSON(data) {
        return new $084574008ccedf86$export$f036d76f832848a(data.radius, data.length, data.capSegments, data.radialSegments);
    }
}
class $084574008ccedf86$export$3f74fe60decf7462 extends $084574008ccedf86$export$b7be63a67df8959 {
    constructor(radius = 1, segments = 8, thetaStart = 0, thetaLength = Math.PI * 2){
        super();
        this.type = "CircleGeometry";
        this.parameters = {
            radius: radius,
            segments: segments,
            thetaStart: thetaStart,
            thetaLength: thetaLength
        };
        segments = Math.max(3, segments);
        // buffers
        const indices = [];
        const vertices = [];
        const normals = [];
        const uvs = [];
        // helper variables
        const vertex2 = new $084574008ccedf86$export$64b5c384219d3699();
        const uv = new $084574008ccedf86$export$c977b3e384af9ae1();
        // center point
        vertices.push(0, 0, 0);
        normals.push(0, 0, 1);
        uvs.push(0.5, 0.5);
        for(let s = 0, i215 = 3; s <= segments; s++, i215 += 3){
            const segment = thetaStart + s / segments * thetaLength;
            // vertex
            vertex2.x = radius * Math.cos(segment);
            vertex2.y = radius * Math.sin(segment);
            vertices.push(vertex2.x, vertex2.y, vertex2.z);
            // normal
            normals.push(0, 0, 1);
            // uvs
            uv.x = (vertices[i215] / radius + 1) / 2;
            uv.y = (vertices[i215 + 1] / radius + 1) / 2;
            uvs.push(uv.x, uv.y);
        }
        // indices
        for(let i214 = 1; i214 <= segments; i214++)indices.push(i214, i214 + 1, 0);
        // build geometry
        this.setIndex(indices);
        this.setAttribute("position", new $084574008ccedf86$export$cbe7a62641830ebd(vertices, 3));
        this.setAttribute("normal", new $084574008ccedf86$export$cbe7a62641830ebd(normals, 3));
        this.setAttribute("uv", new $084574008ccedf86$export$cbe7a62641830ebd(uvs, 2));
    }
    static fromJSON(data) {
        return new $084574008ccedf86$export$3f74fe60decf7462(data.radius, data.segments, data.thetaStart, data.thetaLength);
    }
}
class $084574008ccedf86$export$d4345c83207d7c68 extends $084574008ccedf86$export$b7be63a67df8959 {
    constructor(radiusTop = 1, radiusBottom = 1, height = 1, radialSegments = 8, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2){
        super();
        this.type = "CylinderGeometry";
        this.parameters = {
            radiusTop: radiusTop,
            radiusBottom: radiusBottom,
            height: height,
            radialSegments: radialSegments,
            heightSegments: heightSegments,
            openEnded: openEnded,
            thetaStart: thetaStart,
            thetaLength: thetaLength
        };
        const scope = this;
        radialSegments = Math.floor(radialSegments);
        heightSegments = Math.floor(heightSegments);
        // buffers
        const indices = [];
        const vertices = [];
        const normals = [];
        const uvs = [];
        // helper variables
        let index = 0;
        const indexArray = [];
        const halfHeight = height / 2;
        let groupStart = 0;
        // generate geometry
        generateTorso();
        if (openEnded === false) {
            if (radiusTop > 0) generateCap(true);
            if (radiusBottom > 0) generateCap(false);
        }
        // build geometry
        this.setIndex(indices);
        this.setAttribute("position", new $084574008ccedf86$export$cbe7a62641830ebd(vertices, 3));
        this.setAttribute("normal", new $084574008ccedf86$export$cbe7a62641830ebd(normals, 3));
        this.setAttribute("uv", new $084574008ccedf86$export$cbe7a62641830ebd(uvs, 2));
        function generateTorso() {
            const normal = new $084574008ccedf86$export$64b5c384219d3699();
            const vertex3 = new $084574008ccedf86$export$64b5c384219d3699();
            let groupCount = 0;
            // this will be used to calculate the normal
            const slope = (radiusBottom - radiusTop) / height;
            // generate vertices, normals and uvs
            for(let y = 0; y <= heightSegments; y++){
                const indexRow = [];
                const v = y / heightSegments;
                // calculate the radius of the current row
                const radius = v * (radiusBottom - radiusTop) + radiusTop;
                for(let x = 0; x <= radialSegments; x++){
                    const u = x / radialSegments;
                    const theta = u * thetaLength + thetaStart;
                    const sinTheta = Math.sin(theta);
                    const cosTheta = Math.cos(theta);
                    // vertex
                    vertex3.x = radius * sinTheta;
                    vertex3.y = -v * height + halfHeight;
                    vertex3.z = radius * cosTheta;
                    vertices.push(vertex3.x, vertex3.y, vertex3.z);
                    // normal
                    normal.set(sinTheta, slope, cosTheta).normalize();
                    normals.push(normal.x, normal.y, normal.z);
                    // uv
                    uvs.push(u, 1 - v);
                    // save index of vertex in respective row
                    indexRow.push(index++);
                }
                // now save vertices of the row in our index array
                indexArray.push(indexRow);
            }
            // generate indices
            for(let x = 0; x < radialSegments; x++)for(let y3 = 0; y3 < heightSegments; y3++){
                // we use the index array to access the correct indices
                const a = indexArray[y3][x];
                const b = indexArray[y3 + 1][x];
                const c = indexArray[y3 + 1][x + 1];
                const d = indexArray[y3][x + 1];
                // faces
                indices.push(a, b, d);
                indices.push(b, c, d);
                // update group counter
                groupCount += 6;
            }
            // add a group to the geometry. this will ensure multi material support
            scope.addGroup(groupStart, groupCount, 0);
            // calculate new start value for groups
            groupStart += groupCount;
        }
        function generateCap(top) {
            // save the index of the first center vertex
            const centerIndexStart = index;
            const uv = new $084574008ccedf86$export$c977b3e384af9ae1();
            const vertex4 = new $084574008ccedf86$export$64b5c384219d3699();
            let groupCount = 0;
            const radius = top === true ? radiusTop : radiusBottom;
            const sign2 = top === true ? 1 : -1;
            // first we generate the center vertex data of the cap.
            // because the geometry needs one set of uvs per face,
            // we must generate a center vertex per face/segment
            for(let x = 1; x <= radialSegments; x++){
                // vertex
                vertices.push(0, halfHeight * sign2, 0);
                // normal
                normals.push(0, sign2, 0);
                // uv
                uvs.push(0.5, 0.5);
                // increase index
                index++;
            }
            // save the index of the last center vertex
            const centerIndexEnd = index;
            // now we generate the surrounding vertices, normals and uvs
            for(let x4 = 0; x4 <= radialSegments; x4++){
                const u = x4 / radialSegments;
                const theta = u * thetaLength + thetaStart;
                const cosTheta = Math.cos(theta);
                const sinTheta = Math.sin(theta);
                // vertex
                vertex4.x = radius * sinTheta;
                vertex4.y = halfHeight * sign2;
                vertex4.z = radius * cosTheta;
                vertices.push(vertex4.x, vertex4.y, vertex4.z);
                // normal
                normals.push(0, sign2, 0);
                // uv
                uv.x = cosTheta * 0.5 + 0.5;
                uv.y = sinTheta * 0.5 * sign2 + 0.5;
                uvs.push(uv.x, uv.y);
                // increase index
                index++;
            }
            // generate indices
            for(let x5 = 0; x5 < radialSegments; x5++){
                const c = centerIndexStart + x5;
                const i216 = centerIndexEnd + x5;
                if (top === true) // face top
                indices.push(i216, i216 + 1, c);
                else // face bottom
                indices.push(i216 + 1, i216, c);
                groupCount += 3;
            }
            // add a group to the geometry. this will ensure multi material support
            scope.addGroup(groupStart, groupCount, top === true ? 1 : 2);
            // calculate new start value for groups
            groupStart += groupCount;
        }
    }
    static fromJSON(data) {
        return new $084574008ccedf86$export$d4345c83207d7c68(data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
    }
}
class $084574008ccedf86$export$59d971120dc8b6e7 extends $084574008ccedf86$export$d4345c83207d7c68 {
    constructor(radius = 1, height = 1, radialSegments = 8, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2){
        super(0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);
        this.type = "ConeGeometry";
        this.parameters = {
            radius: radius,
            height: height,
            radialSegments: radialSegments,
            heightSegments: heightSegments,
            openEnded: openEnded,
            thetaStart: thetaStart,
            thetaLength: thetaLength
        };
    }
    static fromJSON(data) {
        return new $084574008ccedf86$export$59d971120dc8b6e7(data.radius, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
    }
}
class $084574008ccedf86$export$38789b531813345c extends $084574008ccedf86$export$b7be63a67df8959 {
    constructor(vertices = [], indices = [], radius1 = 1, detail1 = 0){
        super();
        this.type = "PolyhedronGeometry";
        this.parameters = {
            vertices: vertices,
            indices: indices,
            radius: radius1,
            detail: detail1
        };
        // default buffer data
        const vertexBuffer = [];
        const uvBuffer = [];
        // the subdivision creates the vertex buffer data
        subdivide(detail1);
        // all vertices should lie on a conceptual sphere with a given radius
        applyRadius(radius1);
        // finally, create the uv data
        generateUVs();
        // build non-indexed geometry
        this.setAttribute("position", new $084574008ccedf86$export$cbe7a62641830ebd(vertexBuffer, 3));
        this.setAttribute("normal", new $084574008ccedf86$export$cbe7a62641830ebd(vertexBuffer.slice(), 3));
        this.setAttribute("uv", new $084574008ccedf86$export$cbe7a62641830ebd(uvBuffer, 2));
        if (detail1 === 0) this.computeVertexNormals(); // flat normals
        else this.normalizeNormals(); // smooth normals
        // helper functions
        function subdivide(detail) {
            const a = new $084574008ccedf86$export$64b5c384219d3699();
            const b = new $084574008ccedf86$export$64b5c384219d3699();
            const c = new $084574008ccedf86$export$64b5c384219d3699();
            // iterate over all faces and apply a subdivison with the given detail value
            for(let i217 = 0; i217 < indices.length; i217 += 3){
                // get the vertices of the face
                getVertexByIndex(indices[i217 + 0], a);
                getVertexByIndex(indices[i217 + 1], b);
                getVertexByIndex(indices[i217 + 2], c);
                // perform subdivision
                subdivideFace(a, b, c, detail);
            }
        }
        function subdivideFace(a, b, c, detail) {
            const cols = detail + 1;
            // we use this multidimensional array as a data structure for creating the subdivision
            const v = [];
            // construct all of the vertices for this subdivision
            for(let i219 = 0; i219 <= cols; i219++){
                v[i219] = [];
                const aj = a.clone().lerp(c, i219 / cols);
                const bj = b.clone().lerp(c, i219 / cols);
                const rows = cols - i219;
                for(let j = 0; j <= rows; j++)if (j === 0 && i219 === cols) v[i219][j] = aj;
                else v[i219][j] = aj.clone().lerp(bj, j / rows);
            }
            // construct all of the faces
            for(let i218 = 0; i218 < cols; i218++)for(let j = 0; j < 2 * (cols - i218) - 1; j++){
                const k = Math.floor(j / 2);
                if (j % 2 === 0) {
                    pushVertex(v[i218][k + 1]);
                    pushVertex(v[i218 + 1][k]);
                    pushVertex(v[i218][k]);
                } else {
                    pushVertex(v[i218][k + 1]);
                    pushVertex(v[i218 + 1][k + 1]);
                    pushVertex(v[i218 + 1][k]);
                }
            }
        }
        function applyRadius(radius) {
            const vertex5 = new $084574008ccedf86$export$64b5c384219d3699();
            // iterate over the entire buffer and apply the radius to each vertex
            for(let i220 = 0; i220 < vertexBuffer.length; i220 += 3){
                vertex5.x = vertexBuffer[i220 + 0];
                vertex5.y = vertexBuffer[i220 + 1];
                vertex5.z = vertexBuffer[i220 + 2];
                vertex5.normalize().multiplyScalar(radius);
                vertexBuffer[i220 + 0] = vertex5.x;
                vertexBuffer[i220 + 1] = vertex5.y;
                vertexBuffer[i220 + 2] = vertex5.z;
            }
        }
        function generateUVs() {
            const vertex6 = new $084574008ccedf86$export$64b5c384219d3699();
            for(let i221 = 0; i221 < vertexBuffer.length; i221 += 3){
                vertex6.x = vertexBuffer[i221 + 0];
                vertex6.y = vertexBuffer[i221 + 1];
                vertex6.z = vertexBuffer[i221 + 2];
                const u = azimuth1(vertex6) / 2 / Math.PI + 0.5;
                const v = inclination(vertex6) / Math.PI + 0.5;
                uvBuffer.push(u, 1 - v);
            }
            correctUVs();
            correctSeam();
        }
        function correctSeam() {
            // handle case when face straddles the seam, see #3269
            for(let i222 = 0; i222 < uvBuffer.length; i222 += 6){
                // uv data of a single face
                const x0 = uvBuffer[i222 + 0];
                const x1 = uvBuffer[i222 + 2];
                const x2 = uvBuffer[i222 + 4];
                const max = Math.max(x0, x1, x2);
                const min = Math.min(x0, x1, x2);
                // 0.9 is somewhat arbitrary
                if (max > 0.9 && min < 0.1) {
                    if (x0 < 0.2) uvBuffer[i222 + 0] += 1;
                    if (x1 < 0.2) uvBuffer[i222 + 2] += 1;
                    if (x2 < 0.2) uvBuffer[i222 + 4] += 1;
                }
            }
        }
        function pushVertex(vertex7) {
            vertexBuffer.push(vertex7.x, vertex7.y, vertex7.z);
        }
        function getVertexByIndex(index, vertex8) {
            const stride = index * 3;
            vertex8.x = vertices[stride + 0];
            vertex8.y = vertices[stride + 1];
            vertex8.z = vertices[stride + 2];
        }
        function correctUVs() {
            const a = new $084574008ccedf86$export$64b5c384219d3699();
            const b = new $084574008ccedf86$export$64b5c384219d3699();
            const c = new $084574008ccedf86$export$64b5c384219d3699();
            const centroid = new $084574008ccedf86$export$64b5c384219d3699();
            const uvA = new $084574008ccedf86$export$c977b3e384af9ae1();
            const uvB = new $084574008ccedf86$export$c977b3e384af9ae1();
            const uvC = new $084574008ccedf86$export$c977b3e384af9ae1();
            for(let i223 = 0, j = 0; i223 < vertexBuffer.length; i223 += 9, j += 6){
                a.set(vertexBuffer[i223 + 0], vertexBuffer[i223 + 1], vertexBuffer[i223 + 2]);
                b.set(vertexBuffer[i223 + 3], vertexBuffer[i223 + 4], vertexBuffer[i223 + 5]);
                c.set(vertexBuffer[i223 + 6], vertexBuffer[i223 + 7], vertexBuffer[i223 + 8]);
                uvA.set(uvBuffer[j + 0], uvBuffer[j + 1]);
                uvB.set(uvBuffer[j + 2], uvBuffer[j + 3]);
                uvC.set(uvBuffer[j + 4], uvBuffer[j + 5]);
                centroid.copy(a).add(b).add(c).divideScalar(3);
                const azi = azimuth1(centroid);
                correctUV(uvA, j + 0, a, azi);
                correctUV(uvB, j + 2, b, azi);
                correctUV(uvC, j + 4, c, azi);
            }
        }
        function correctUV(uv, stride, vector, azimuth) {
            if (azimuth < 0 && uv.x === 1) uvBuffer[stride] = uv.x - 1;
            if (vector.x === 0 && vector.z === 0) uvBuffer[stride] = azimuth / 2 / Math.PI + 0.5;
        }
        // Angle around the Y axis, counter-clockwise when looking from above.
        function azimuth1(vector) {
            return Math.atan2(vector.z, -vector.x);
        }
        // Angle above the XZ plane.
        function inclination(vector) {
            return Math.atan2(-vector.y, Math.sqrt(vector.x * vector.x + vector.z * vector.z));
        }
    }
    static fromJSON(data) {
        return new $084574008ccedf86$export$38789b531813345c(data.vertices, data.indices, data.radius, data.details);
    }
}
class $084574008ccedf86$export$37cd4e52cce48c4c extends $084574008ccedf86$export$38789b531813345c {
    constructor(radius = 1, detail = 0){
        const t = (1 + Math.sqrt(5)) / 2;
        const r = 1 / t;
        const vertices = [
            // (1, 1, 1)
            -1,
            -1,
            -1,
            -1,
            -1,
            1,
            -1,
            1,
            -1,
            -1,
            1,
            1,
            1,
            -1,
            -1,
            1,
            -1,
            1,
            1,
            1,
            -1,
            1,
            1,
            1,
            // (0, 1/, )
            0,
            -r,
            -t,
            0,
            -r,
            t,
            0,
            r,
            -t,
            0,
            r,
            t,
            // (1/, , 0)
            -r,
            -t,
            0,
            -r,
            t,
            0,
            r,
            -t,
            0,
            r,
            t,
            0,
            // (, 0, 1/)
            -t,
            0,
            -r,
            t,
            0,
            -r,
            -t,
            0,
            r,
            t,
            0,
            r
        ];
        const indices = [
            3,
            11,
            7,
            3,
            7,
            15,
            3,
            15,
            13,
            7,
            19,
            17,
            7,
            17,
            6,
            7,
            6,
            15,
            17,
            4,
            8,
            17,
            8,
            10,
            17,
            10,
            6,
            8,
            0,
            16,
            8,
            16,
            2,
            8,
            2,
            10,
            0,
            12,
            1,
            0,
            1,
            18,
            0,
            18,
            16,
            6,
            10,
            2,
            6,
            2,
            13,
            6,
            13,
            15,
            2,
            16,
            18,
            2,
            18,
            3,
            2,
            3,
            13,
            18,
            1,
            9,
            18,
            9,
            11,
            18,
            11,
            3,
            4,
            14,
            12,
            4,
            12,
            0,
            4,
            0,
            8,
            11,
            9,
            5,
            11,
            5,
            19,
            11,
            19,
            7,
            19,
            5,
            14,
            19,
            14,
            4,
            19,
            4,
            17,
            1,
            12,
            14,
            1,
            14,
            5,
            1,
            5,
            9
        ];
        super(vertices, indices, radius, detail);
        this.type = "DodecahedronGeometry";
        this.parameters = {
            radius: radius,
            detail: detail
        };
    }
    static fromJSON(data) {
        return new $084574008ccedf86$export$37cd4e52cce48c4c(data.radius, data.detail);
    }
}
const $084574008ccedf86$var$_v0 = new $084574008ccedf86$export$64b5c384219d3699();
const $084574008ccedf86$var$_v1$1 = new $084574008ccedf86$export$64b5c384219d3699();
const $084574008ccedf86$var$_normal = new $084574008ccedf86$export$64b5c384219d3699();
const $084574008ccedf86$var$_triangle = new $084574008ccedf86$export$5a465592bfe74b48();
class $084574008ccedf86$export$4730b1542707547f extends $084574008ccedf86$export$b7be63a67df8959 {
    constructor(geometry = null, thresholdAngle = 1){
        super();
        this.type = "EdgesGeometry";
        this.parameters = {
            geometry: geometry,
            thresholdAngle: thresholdAngle
        };
        if (geometry !== null) {
            const precisionPoints = 4;
            const precision = Math.pow(10, precisionPoints);
            const thresholdDot = Math.cos($084574008ccedf86$var$DEG2RAD * thresholdAngle);
            const indexAttr = geometry.getIndex();
            const positionAttr = geometry.getAttribute("position");
            const indexCount = indexAttr ? indexAttr.count : positionAttr.count;
            const indexArr = [
                0,
                0,
                0
            ];
            const vertKeys = [
                "a",
                "b",
                "c"
            ];
            const hashes = new Array(3);
            const edgeData = {};
            const vertices = [];
            for(let i224 = 0; i224 < indexCount; i224 += 3){
                if (indexAttr) {
                    indexArr[0] = indexAttr.getX(i224);
                    indexArr[1] = indexAttr.getX(i224 + 1);
                    indexArr[2] = indexAttr.getX(i224 + 2);
                } else {
                    indexArr[0] = i224;
                    indexArr[1] = i224 + 1;
                    indexArr[2] = i224 + 2;
                }
                const { a: a , b: b , c: c  } = $084574008ccedf86$var$_triangle;
                a.fromBufferAttribute(positionAttr, indexArr[0]);
                b.fromBufferAttribute(positionAttr, indexArr[1]);
                c.fromBufferAttribute(positionAttr, indexArr[2]);
                $084574008ccedf86$var$_triangle.getNormal($084574008ccedf86$var$_normal);
                // create hashes for the edge from the vertices
                hashes[0] = `${Math.round(a.x * precision)},${Math.round(a.y * precision)},${Math.round(a.z * precision)}`;
                hashes[1] = `${Math.round(b.x * precision)},${Math.round(b.y * precision)},${Math.round(b.z * precision)}`;
                hashes[2] = `${Math.round(c.x * precision)},${Math.round(c.y * precision)},${Math.round(c.z * precision)}`;
                // skip degenerate triangles
                if (hashes[0] === hashes[1] || hashes[1] === hashes[2] || hashes[2] === hashes[0]) continue;
                // iterate over every edge
                for(let j = 0; j < 3; j++){
                    // get the first and next vertex making up the edge
                    const jNext = (j + 1) % 3;
                    const vecHash0 = hashes[j];
                    const vecHash1 = hashes[jNext];
                    const v0 = $084574008ccedf86$var$_triangle[vertKeys[j]];
                    const v1 = $084574008ccedf86$var$_triangle[vertKeys[jNext]];
                    const hash = `${vecHash0}_${vecHash1}`;
                    const reverseHash = `${vecHash1}_${vecHash0}`;
                    if (reverseHash in edgeData && edgeData[reverseHash]) {
                        // if we found a sibling edge add it into the vertex array if
                        // it meets the angle threshold and delete the edge from the map.
                        if ($084574008ccedf86$var$_normal.dot(edgeData[reverseHash].normal) <= thresholdDot) {
                            vertices.push(v0.x, v0.y, v0.z);
                            vertices.push(v1.x, v1.y, v1.z);
                        }
                        edgeData[reverseHash] = null;
                    } else if (!(hash in edgeData)) // if we've already got an edge here then skip adding a new one
                    edgeData[hash] = {
                        index0: indexArr[j],
                        index1: indexArr[jNext],
                        normal: $084574008ccedf86$var$_normal.clone()
                    };
                }
            }
            // iterate over all remaining, unmatched edges and add them to the vertex array
            for(const key in edgeData)if (edgeData[key]) {
                const { index0: index0 , index1: index1  } = edgeData[key];
                $084574008ccedf86$var$_v0.fromBufferAttribute(positionAttr, index0);
                $084574008ccedf86$var$_v1$1.fromBufferAttribute(positionAttr, index1);
                vertices.push($084574008ccedf86$var$_v0.x, $084574008ccedf86$var$_v0.y, $084574008ccedf86$var$_v0.z);
                vertices.push($084574008ccedf86$var$_v1$1.x, $084574008ccedf86$var$_v1$1.y, $084574008ccedf86$var$_v1$1.z);
            }
            this.setAttribute("position", new $084574008ccedf86$export$cbe7a62641830ebd(vertices, 3));
        }
    }
}
class $084574008ccedf86$export$6428a7f2611ef1fa extends $084574008ccedf86$export$4b2950bdac9b6ee9 {
    constructor(points){
        super(points);
        this.uuid = $084574008ccedf86$var$generateUUID();
        this.type = "Shape";
        this.holes = [];
    }
    getPointsHoles(divisions) {
        const holesPts = [];
        for(let i225 = 0, l = this.holes.length; i225 < l; i225++)holesPts[i225] = this.holes[i225].getPoints(divisions);
        return holesPts;
    }
    // get points of shape and holes (keypoints based on segments parameter)
    extractPoints(divisions) {
        return {
            shape: this.getPoints(divisions),
            holes: this.getPointsHoles(divisions)
        };
    }
    copy(source) {
        super.copy(source);
        this.holes = [];
        for(let i226 = 0, l = source.holes.length; i226 < l; i226++){
            const hole = source.holes[i226];
            this.holes.push(hole.clone());
        }
        return this;
    }
    toJSON() {
        const data = super.toJSON();
        data.uuid = this.uuid;
        data.holes = [];
        for(let i227 = 0, l = this.holes.length; i227 < l; i227++){
            const hole = this.holes[i227];
            data.holes.push(hole.toJSON());
        }
        return data;
    }
    fromJSON(json) {
        super.fromJSON(json);
        this.uuid = json.uuid;
        this.holes = [];
        for(let i228 = 0, l = json.holes.length; i228 < l; i228++){
            const hole = json.holes[i228];
            this.holes.push(new $084574008ccedf86$export$4b2950bdac9b6ee9().fromJSON(hole));
        }
        return this;
    }
}
/**
 * Port from https://github.com/mapbox/earcut (v2.2.2)
 */ const $084574008ccedf86$var$Earcut = {
    triangulate: function(data, holeIndices, dim = 2) {
        const hasHoles = holeIndices && holeIndices.length;
        const outerLen = hasHoles ? holeIndices[0] * dim : data.length;
        let outerNode = $084574008ccedf86$var$linkedList(data, 0, outerLen, dim, true);
        const triangles = [];
        if (!outerNode || outerNode.next === outerNode.prev) return triangles;
        let minX, minY, maxX, maxY, x, y, invSize;
        if (hasHoles) outerNode = $084574008ccedf86$var$eliminateHoles(data, holeIndices, outerNode, dim);
        // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
        if (data.length > 80 * dim) {
            minX = maxX = data[0];
            minY = maxY = data[1];
            for(let i229 = dim; i229 < outerLen; i229 += dim){
                x = data[i229];
                y = data[i229 + 1];
                if (x < minX) minX = x;
                if (y < minY) minY = y;
                if (x > maxX) maxX = x;
                if (y > maxY) maxY = y;
            }
            // minX, minY and invSize are later used to transform coords into integers for z-order calculation
            invSize = Math.max(maxX - minX, maxY - minY);
            invSize = invSize !== 0 ? 1 / invSize : 0;
        }
        $084574008ccedf86$var$earcutLinked(outerNode, triangles, dim, minX, minY, invSize);
        return triangles;
    }
};
// create a circular doubly linked list from polygon points in the specified winding order
function $084574008ccedf86$var$linkedList(data, start, end, dim, clockwise) {
    let i230, last;
    if (clockwise === $084574008ccedf86$var$signedArea(data, start, end, dim) > 0) for(i230 = start; i230 < end; i230 += dim)last = $084574008ccedf86$var$insertNode(i230, data[i230], data[i230 + 1], last);
    else for(i230 = end - dim; i230 >= start; i230 -= dim)last = $084574008ccedf86$var$insertNode(i230, data[i230], data[i230 + 1], last);
    if (last && $084574008ccedf86$var$equals(last, last.next)) {
        $084574008ccedf86$var$removeNode(last);
        last = last.next;
    }
    return last;
}
// eliminate colinear or duplicate points
function $084574008ccedf86$var$filterPoints(start, end) {
    if (!start) return start;
    if (!end) end = start;
    let p = start, again;
    do {
        again = false;
        if (!p.steiner && ($084574008ccedf86$var$equals(p, p.next) || $084574008ccedf86$var$area(p.prev, p, p.next) === 0)) {
            $084574008ccedf86$var$removeNode(p);
            p = end = p.prev;
            if (p === p.next) break;
            again = true;
        } else p = p.next;
    }while (again || p !== end);
    return end;
}
// main ear slicing loop which triangulates a polygon (given as a linked list)
function $084574008ccedf86$var$earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
    if (!ear) return;
    // interlink polygon nodes in z-order
    if (!pass && invSize) $084574008ccedf86$var$indexCurve(ear, minX, minY, invSize);
    let stop = ear, prev, next;
    // iterate through ears, slicing them one by one
    while(ear.prev !== ear.next){
        prev = ear.prev;
        next = ear.next;
        if (invSize ? $084574008ccedf86$var$isEarHashed(ear, minX, minY, invSize) : $084574008ccedf86$var$isEar(ear)) {
            // cut off the triangle
            triangles.push(prev.i / dim);
            triangles.push(ear.i / dim);
            triangles.push(next.i / dim);
            $084574008ccedf86$var$removeNode(ear);
            // skipping the next vertex leads to less sliver triangles
            ear = next.next;
            stop = next.next;
            continue;
        }
        ear = next;
        // if we looped through the whole remaining polygon and can't find any more ears
        if (ear === stop) {
            // try filtering points and slicing again
            if (!pass) $084574008ccedf86$var$earcutLinked($084574008ccedf86$var$filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
            else if (pass === 1) {
                ear = $084574008ccedf86$var$cureLocalIntersections($084574008ccedf86$var$filterPoints(ear), triangles, dim);
                $084574008ccedf86$var$earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
            // as a last resort, try splitting the remaining polygon into two
            } else if (pass === 2) $084574008ccedf86$var$splitEarcut(ear, triangles, dim, minX, minY, invSize);
            break;
        }
    }
}
// check whether a polygon node forms a valid ear with adjacent nodes
function $084574008ccedf86$var$isEar(ear) {
    const a = ear.prev, b = ear, c = ear.next;
    if ($084574008ccedf86$var$area(a, b, c) >= 0) return false; // reflex, can't be an ear
    // now make sure we don't have other points inside the potential ear
    let p = ear.next.next;
    while(p !== ear.prev){
        if ($084574008ccedf86$var$pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && $084574008ccedf86$var$area(p.prev, p, p.next) >= 0) return false;
        p = p.next;
    }
    return true;
}
function $084574008ccedf86$var$isEarHashed(ear, minX, minY, invSize) {
    const a = ear.prev, b = ear, c = ear.next;
    if ($084574008ccedf86$var$area(a, b, c) >= 0) return false; // reflex, can't be an ear
    // triangle bbox; min & max are calculated like this for speed
    const minTX = a.x < b.x ? a.x < c.x ? a.x : c.x : b.x < c.x ? b.x : c.x, minTY = a.y < b.y ? a.y < c.y ? a.y : c.y : b.y < c.y ? b.y : c.y, maxTX = a.x > b.x ? a.x > c.x ? a.x : c.x : b.x > c.x ? b.x : c.x, maxTY = a.y > b.y ? a.y > c.y ? a.y : c.y : b.y > c.y ? b.y : c.y;
    // z-order range for the current triangle bbox;
    const minZ = $084574008ccedf86$var$zOrder(minTX, minTY, minX, minY, invSize), maxZ = $084574008ccedf86$var$zOrder(maxTX, maxTY, minX, minY, invSize);
    let p = ear.prevZ, n = ear.nextZ;
    // look for points inside the triangle in both directions
    while(p && p.z >= minZ && n && n.z <= maxZ){
        if (p !== ear.prev && p !== ear.next && $084574008ccedf86$var$pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && $084574008ccedf86$var$area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;
        if (n !== ear.prev && n !== ear.next && $084574008ccedf86$var$pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && $084574008ccedf86$var$area(n.prev, n, n.next) >= 0) return false;
        n = n.nextZ;
    }
    // look for remaining points in decreasing z-order
    while(p && p.z >= minZ){
        if (p !== ear.prev && p !== ear.next && $084574008ccedf86$var$pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && $084574008ccedf86$var$area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;
    }
    // look for remaining points in increasing z-order
    while(n && n.z <= maxZ){
        if (n !== ear.prev && n !== ear.next && $084574008ccedf86$var$pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && $084574008ccedf86$var$area(n.prev, n, n.next) >= 0) return false;
        n = n.nextZ;
    }
    return true;
}
// go through all polygon nodes and cure small local self-intersections
function $084574008ccedf86$var$cureLocalIntersections(start, triangles, dim) {
    let p = start;
    do {
        const a = p.prev, b = p.next.next;
        if (!$084574008ccedf86$var$equals(a, b) && $084574008ccedf86$var$intersects(a, p, p.next, b) && $084574008ccedf86$var$locallyInside(a, b) && $084574008ccedf86$var$locallyInside(b, a)) {
            triangles.push(a.i / dim);
            triangles.push(p.i / dim);
            triangles.push(b.i / dim);
            // remove two nodes involved
            $084574008ccedf86$var$removeNode(p);
            $084574008ccedf86$var$removeNode(p.next);
            p = start = b;
        }
        p = p.next;
    }while (p !== start);
    return $084574008ccedf86$var$filterPoints(p);
}
// try splitting polygon into two and triangulate them independently
function $084574008ccedf86$var$splitEarcut(start, triangles, dim, minX, minY, invSize) {
    // look for a valid diagonal that divides the polygon into two
    let a = start;
    do {
        let b = a.next.next;
        while(b !== a.prev){
            if (a.i !== b.i && $084574008ccedf86$var$isValidDiagonal(a, b)) {
                // split the polygon in two by the diagonal
                let c = $084574008ccedf86$var$splitPolygon(a, b);
                // filter colinear points around the cuts
                a = $084574008ccedf86$var$filterPoints(a, a.next);
                c = $084574008ccedf86$var$filterPoints(c, c.next);
                // run earcut on each half
                $084574008ccedf86$var$earcutLinked(a, triangles, dim, minX, minY, invSize);
                $084574008ccedf86$var$earcutLinked(c, triangles, dim, minX, minY, invSize);
                return;
            }
            b = b.next;
        }
        a = a.next;
    }while (a !== start);
}
// link every hole into the outer loop, producing a single-ring polygon without holes
function $084574008ccedf86$var$eliminateHoles(data, holeIndices, outerNode, dim) {
    const queue = [];
    let i231, len, start, end, list;
    for(i231 = 0, len = holeIndices.length; i231 < len; i231++){
        start = holeIndices[i231] * dim;
        end = i231 < len - 1 ? holeIndices[i231 + 1] * dim : data.length;
        list = $084574008ccedf86$var$linkedList(data, start, end, dim, false);
        if (list === list.next) list.steiner = true;
        queue.push($084574008ccedf86$var$getLeftmost(list));
    }
    queue.sort($084574008ccedf86$var$compareX);
    // process holes from left to right
    for(i231 = 0; i231 < queue.length; i231++){
        $084574008ccedf86$var$eliminateHole(queue[i231], outerNode);
        outerNode = $084574008ccedf86$var$filterPoints(outerNode, outerNode.next);
    }
    return outerNode;
}
function $084574008ccedf86$var$compareX(a, b) {
    return a.x - b.x;
}
// find a bridge between vertices that connects hole with an outer ring and link it
function $084574008ccedf86$var$eliminateHole(hole, outerNode) {
    outerNode = $084574008ccedf86$var$findHoleBridge(hole, outerNode);
    if (outerNode) {
        const b = $084574008ccedf86$var$splitPolygon(outerNode, hole);
        // filter collinear points around the cuts
        $084574008ccedf86$var$filterPoints(outerNode, outerNode.next);
        $084574008ccedf86$var$filterPoints(b, b.next);
    }
}
// David Eberly's algorithm for finding a bridge between hole and outer polygon
function $084574008ccedf86$var$findHoleBridge(hole, outerNode) {
    let p = outerNode;
    const hx = hole.x;
    const hy = hole.y;
    let qx = -Infinity, m;
    // find a segment intersected by a ray from the hole's leftmost point to the left;
    // segment's endpoint with lesser x will be potential connection point
    do {
        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
            const x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
            if (x <= hx && x > qx) {
                qx = x;
                if (x === hx) {
                    if (hy === p.y) return p;
                    if (hy === p.next.y) return p.next;
                }
                m = p.x < p.next.x ? p : p.next;
            }
        }
        p = p.next;
    }while (p !== outerNode);
    if (!m) return null;
    if (hx === qx) return m; // hole touches outer segment; pick leftmost endpoint
    // look for points inside the triangle of hole point, segment intersection and endpoint;
    // if there are no points found, we have a valid connection;
    // otherwise choose the point of the minimum angle with the ray as connection point
    const stop = m, mx = m.x, my = m.y;
    let tanMin = Infinity, tan;
    p = m;
    do {
        if (hx >= p.x && p.x >= mx && hx !== p.x && $084574008ccedf86$var$pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential
            if ($084574008ccedf86$var$locallyInside(p, hole) && (tan < tanMin || tan === tanMin && (p.x > m.x || p.x === m.x && $084574008ccedf86$var$sectorContainsSector(m, p)))) {
                m = p;
                tanMin = tan;
            }
        }
        p = p.next;
    }while (p !== stop);
    return m;
}
// whether sector in vertex m contains sector in vertex p in the same coordinates
function $084574008ccedf86$var$sectorContainsSector(m, p) {
    return $084574008ccedf86$var$area(m.prev, m, p.prev) < 0 && $084574008ccedf86$var$area(p.next, m, m.next) < 0;
}
// interlink polygon nodes in z-order
function $084574008ccedf86$var$indexCurve(start, minX, minY, invSize) {
    let p = start;
    do {
        if (p.z === null) p.z = $084574008ccedf86$var$zOrder(p.x, p.y, minX, minY, invSize);
        p.prevZ = p.prev;
        p.nextZ = p.next;
        p = p.next;
    }while (p !== start);
    p.prevZ.nextZ = null;
    p.prevZ = null;
    $084574008ccedf86$var$sortLinked(p);
}
// Simon Tatham's linked list merge sort algorithm
// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
function $084574008ccedf86$var$sortLinked(list) {
    let i232, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;
    do {
        p = list;
        list = null;
        tail = null;
        numMerges = 0;
        while(p){
            numMerges++;
            q = p;
            pSize = 0;
            for(i232 = 0; i232 < inSize; i232++){
                pSize++;
                q = q.nextZ;
                if (!q) break;
            }
            qSize = inSize;
            while(pSize > 0 || qSize > 0 && q){
                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
                    e = p;
                    p = p.nextZ;
                    pSize--;
                } else {
                    e = q;
                    q = q.nextZ;
                    qSize--;
                }
                if (tail) tail.nextZ = e;
                else list = e;
                e.prevZ = tail;
                tail = e;
            }
            p = q;
        }
        tail.nextZ = null;
        inSize *= 2;
    }while (numMerges > 1);
    return list;
}
// z-order of a point given coords and inverse of the longer side of data bbox
function $084574008ccedf86$var$zOrder(x, y, minX, minY, invSize) {
    // coords are transformed into non-negative 15-bit integer range
    x = 32767 * (x - minX) * invSize;
    y = 32767 * (y - minY) * invSize;
    x = (x | x << 8) & 0x00FF00FF;
    x = (x | x << 4) & 0x0F0F0F0F;
    x = (x | x << 2) & 0x33333333;
    x = (x | x << 1) & 0x55555555;
    y = (y | y << 8) & 0x00FF00FF;
    y = (y | y << 4) & 0x0F0F0F0F;
    y = (y | y << 2) & 0x33333333;
    y = (y | y << 1) & 0x55555555;
    return x | y << 1;
}
// find the leftmost node of a polygon ring
function $084574008ccedf86$var$getLeftmost(start) {
    let p = start, leftmost = start;
    do {
        if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y) leftmost = p;
        p = p.next;
    }while (p !== start);
    return leftmost;
}
// check if a point lies within a convex triangle
function $084574008ccedf86$var$pointInTriangle(ax, ay, bx, by, cx, cy, px1, py1) {
    return (cx - px1) * (ay - py1) - (ax - px1) * (cy - py1) >= 0 && (ax - px1) * (by - py1) - (bx - px1) * (ay - py1) >= 0 && (bx - px1) * (cy - py1) - (cx - px1) * (by - py1) >= 0;
}
// check if a diagonal between two polygon nodes is valid (lies in polygon interior)
function $084574008ccedf86$var$isValidDiagonal(a, b) {
    return a.next.i !== b.i && a.prev.i !== b.i && !$084574008ccedf86$var$intersectsPolygon(a, b) && ($084574008ccedf86$var$locallyInside(a, b) && $084574008ccedf86$var$locallyInside(b, a) && $084574008ccedf86$var$middleInside(a, b) && ($084574008ccedf86$var$area(a.prev, a, b.prev) || $084574008ccedf86$var$area(a, b.prev, b)) || $084574008ccedf86$var$equals(a, b) && $084574008ccedf86$var$area(a.prev, a, a.next) > 0 && $084574008ccedf86$var$area(b.prev, b, b.next) > 0); // special zero-length case
}
// signed area of a triangle
function $084574008ccedf86$var$area(p, q, r) {
    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
}
// check if two points are equal
function $084574008ccedf86$var$equals(p1, p2) {
    return p1.x === p2.x && p1.y === p2.y;
}
// check if two segments intersect
function $084574008ccedf86$var$intersects(p1, q1, p2, q2) {
    const o1 = $084574008ccedf86$var$sign($084574008ccedf86$var$area(p1, q1, p2));
    const o2 = $084574008ccedf86$var$sign($084574008ccedf86$var$area(p1, q1, q2));
    const o3 = $084574008ccedf86$var$sign($084574008ccedf86$var$area(p2, q2, p1));
    const o4 = $084574008ccedf86$var$sign($084574008ccedf86$var$area(p2, q2, q1));
    if (o1 !== o2 && o3 !== o4) return true; // general case
    if (o1 === 0 && $084574008ccedf86$var$onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1
    if (o2 === 0 && $084574008ccedf86$var$onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1
    if (o3 === 0 && $084574008ccedf86$var$onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2
    if (o4 === 0 && $084574008ccedf86$var$onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2
    return false;
}
// for collinear points p, q, r, check if point q lies on segment pr
function $084574008ccedf86$var$onSegment(p, q, r) {
    return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
}
function $084574008ccedf86$var$sign(num) {
    return num > 0 ? 1 : num < 0 ? -1 : 0;
}
// check if a polygon diagonal intersects any polygon segments
function $084574008ccedf86$var$intersectsPolygon(a, b) {
    let p = a;
    do {
        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && $084574008ccedf86$var$intersects(p, p.next, a, b)) return true;
        p = p.next;
    }while (p !== a);
    return false;
}
// check if a polygon diagonal is locally inside the polygon
function $084574008ccedf86$var$locallyInside(a, b) {
    return $084574008ccedf86$var$area(a.prev, a, a.next) < 0 ? $084574008ccedf86$var$area(a, b, a.next) >= 0 && $084574008ccedf86$var$area(a, a.prev, b) >= 0 : $084574008ccedf86$var$area(a, b, a.prev) < 0 || $084574008ccedf86$var$area(a, a.next, b) < 0;
}
// check if the middle point of a polygon diagonal is inside the polygon
function $084574008ccedf86$var$middleInside(a, b) {
    let p = a, inside = false;
    const px2 = (a.x + b.x) / 2, py2 = (a.y + b.y) / 2;
    do {
        if (p.y > py2 !== p.next.y > py2 && p.next.y !== p.y && px2 < (p.next.x - p.x) * (py2 - p.y) / (p.next.y - p.y) + p.x) inside = !inside;
        p = p.next;
    }while (p !== a);
    return inside;
}
// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
// if one belongs to the outer ring and another to a hole, it merges it into a single ring
function $084574008ccedf86$var$splitPolygon(a, b) {
    const a2 = new $084574008ccedf86$var$Node(a.i, a.x, a.y), b2 = new $084574008ccedf86$var$Node(b.i, b.x, b.y), an = a.next, bp = b.prev;
    a.next = b;
    b.prev = a;
    a2.next = an;
    an.prev = a2;
    b2.next = a2;
    a2.prev = b2;
    bp.next = b2;
    b2.prev = bp;
    return b2;
}
// create a node and optionally link it with previous one (in a circular doubly linked list)
function $084574008ccedf86$var$insertNode(i233, x, y, last) {
    const p = new $084574008ccedf86$var$Node(i233, x, y);
    if (!last) {
        p.prev = p;
        p.next = p;
    } else {
        p.next = last.next;
        p.prev = last;
        last.next.prev = p;
        last.next = p;
    }
    return p;
}
function $084574008ccedf86$var$removeNode(p) {
    p.next.prev = p.prev;
    p.prev.next = p.next;
    if (p.prevZ) p.prevZ.nextZ = p.nextZ;
    if (p.nextZ) p.nextZ.prevZ = p.prevZ;
}
function $084574008ccedf86$var$Node(i234, x, y) {
    // vertex index in coordinates array
    this.i = i234;
    // vertex coordinates
    this.x = x;
    this.y = y;
    // previous and next vertex nodes in a polygon ring
    this.prev = null;
    this.next = null;
    // z-order curve value
    this.z = null;
    // previous and next nodes in z-order
    this.prevZ = null;
    this.nextZ = null;
    // indicates whether this is a steiner point
    this.steiner = false;
}
function $084574008ccedf86$var$signedArea(data, start, end, dim) {
    let sum = 0;
    for(let i235 = start, j = end - dim; i235 < end; i235 += dim){
        sum += (data[j] - data[i235]) * (data[i235 + 1] + data[j + 1]);
        j = i235;
    }
    return sum;
}
class $084574008ccedf86$export$96bdf6d9c66d7ba8 {
    // calculate area of the contour polygon
    static area(contour) {
        const n = contour.length;
        let a = 0.0;
        for(let p = n - 1, q = 0; q < n; p = q++)a += contour[p].x * contour[q].y - contour[q].x * contour[p].y;
        return a * 0.5;
    }
    static isClockWise(pts) {
        return $084574008ccedf86$export$96bdf6d9c66d7ba8.area(pts) < 0;
    }
    static triangulateShape(contour, holes) {
        const vertices = []; // flat array of vertices like [ x0,y0, x1,y1, x2,y2, ... ]
        const holeIndices = []; // array of hole indices
        const faces = []; // final array of vertex indices like [ [ a,b,d ], [ b,c,d ] ]
        $084574008ccedf86$var$removeDupEndPts(contour);
        $084574008ccedf86$var$addContour(vertices, contour);
        //
        let holeIndex = contour.length;
        holes.forEach($084574008ccedf86$var$removeDupEndPts);
        for(let i237 = 0; i237 < holes.length; i237++){
            holeIndices.push(holeIndex);
            holeIndex += holes[i237].length;
            $084574008ccedf86$var$addContour(vertices, holes[i237]);
        }
        //
        const triangles = $084574008ccedf86$var$Earcut.triangulate(vertices, holeIndices);
        //
        for(let i236 = 0; i236 < triangles.length; i236 += 3)faces.push(triangles.slice(i236, i236 + 3));
        return faces;
    }
}
function $084574008ccedf86$var$removeDupEndPts(points) {
    const l = points.length;
    if (l > 2 && points[l - 1].equals(points[0])) points.pop();
}
function $084574008ccedf86$var$addContour(vertices, contour) {
    for(let i238 = 0; i238 < contour.length; i238++){
        vertices.push(contour[i238].x);
        vertices.push(contour[i238].y);
    }
}
/**
 * Creates extruded geometry from a path shape.
 *
 * parameters = {
 *
 *  curveSegments: <int>, // number of points on the curves
 *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too
 *  depth: <float>, // Depth to extrude the shape
 *
 *  bevelEnabled: <bool>, // turn on bevel
 *  bevelThickness: <float>, // how deep into the original shape bevel goes
 *  bevelSize: <float>, // how far from shape outline (including bevelOffset) is bevel
 *  bevelOffset: <float>, // how far from shape outline does bevel start
 *  bevelSegments: <int>, // number of bevel layers
 *
 *  extrudePath: <THREE.Curve> // curve to extrude shape along
 *
 *  UVGenerator: <Object> // object that provides UV generator functions
 *
 * }
 */ class $084574008ccedf86$export$91836d01b9f75a58 extends $084574008ccedf86$export$b7be63a67df8959 {
    constructor(shapes = new $084574008ccedf86$export$6428a7f2611ef1fa([
        new $084574008ccedf86$export$c977b3e384af9ae1(0.5, 0.5),
        new $084574008ccedf86$export$c977b3e384af9ae1(-0.5, 0.5),
        new $084574008ccedf86$export$c977b3e384af9ae1(-0.5, -0.5),
        new $084574008ccedf86$export$c977b3e384af9ae1(0.5, -0.5)
    ]), options = {}){
        super();
        this.type = "ExtrudeGeometry";
        this.parameters = {
            shapes: shapes,
            options: options
        };
        shapes = Array.isArray(shapes) ? shapes : [
            shapes
        ];
        const scope = this;
        const verticesArray = [];
        const uvArray = [];
        for(let i239 = 0, l = shapes.length; i239 < l; i239++){
            const shape = shapes[i239];
            addShape(shape);
        }
        // build geometry
        this.setAttribute("position", new $084574008ccedf86$export$cbe7a62641830ebd(verticesArray, 3));
        this.setAttribute("uv", new $084574008ccedf86$export$cbe7a62641830ebd(uvArray, 2));
        this.computeVertexNormals();
        // functions
        function addShape(shape) {
            const placeholder = [];
            // options
            const curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
            const steps = options.steps !== undefined ? options.steps : 1;
            let depth = options.depth !== undefined ? options.depth : 1;
            let bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true;
            let bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 0.2;
            let bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 0.1;
            let bevelOffset = options.bevelOffset !== undefined ? options.bevelOffset : 0;
            let bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;
            const extrudePath = options.extrudePath;
            const uvgen = options.UVGenerator !== undefined ? options.UVGenerator : $084574008ccedf86$var$WorldUVGenerator;
            // deprecated options
            if (options.amount !== undefined) {
                console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth.");
                depth = options.amount;
            }
            //
            let extrudePts, extrudeByPath = false;
            let splineTube, binormal, normal, position2;
            if (extrudePath) {
                extrudePts = extrudePath.getSpacedPoints(steps);
                extrudeByPath = true;
                bevelEnabled = false; // bevels not supported for path extrusion
                // SETUP TNB variables
                // TODO1 - have a .isClosed in spline?
                splineTube = extrudePath.computeFrenetFrames(steps, false);
                // console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);
                binormal = new $084574008ccedf86$export$64b5c384219d3699();
                normal = new $084574008ccedf86$export$64b5c384219d3699();
                position2 = new $084574008ccedf86$export$64b5c384219d3699();
            }
            // Safeguards if bevels are not enabled
            if (!bevelEnabled) {
                bevelSegments = 0;
                bevelThickness = 0;
                bevelSize = 0;
                bevelOffset = 0;
            }
            // Variables initialization
            const shapePoints = shape.extractPoints(curveSegments);
            let vertices = shapePoints.shape;
            const holes = shapePoints.holes;
            const reverse = !$084574008ccedf86$export$96bdf6d9c66d7ba8.isClockWise(vertices);
            if (reverse) {
                vertices = vertices.reverse();
                // Maybe we should also check if holes are in the opposite direction, just to be safe ...
                for(let h = 0, hl = holes.length; h < hl; h++){
                    const ahole = holes[h];
                    if ($084574008ccedf86$export$96bdf6d9c66d7ba8.isClockWise(ahole)) holes[h] = ahole.reverse();
                }
            }
            const faces = $084574008ccedf86$export$96bdf6d9c66d7ba8.triangulateShape(vertices, holes);
            /* Vertices */ const contour1 = vertices; // vertices has all points but contour has only points of circumference
            for(let h2 = 0, hl2 = holes.length; h2 < hl2; h2++){
                const ahole = holes[h2];
                vertices = vertices.concat(ahole);
            }
            function scalePt2(pt, vec, size) {
                if (!vec) console.error("THREE.ExtrudeGeometry: vec does not exist");
                return vec.clone().multiplyScalar(size).add(pt);
            }
            const vlen = vertices.length, flen = faces.length;
            // Find directions for point movement
            function getBevelVec(inPt, inPrev, inNext) {
                // computes for inPt the corresponding point inPt' on a new contour
                //   shifted by 1 unit (length of normalized vector) to the left
                // if we walk along contour clockwise, this new contour is outside the old one
                //
                // inPt' is the intersection of the two lines parallel to the two
                //  adjacent edges of inPt at a distance of 1 unit on the left side.
                let v_trans_x, v_trans_y, shrink_by; // resulting translation vector for inPt
                // good reading for geometry algorithms (here: line-line intersection)
                // http://geomalgorithms.com/a05-_intersect-1.html
                const v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;
                const v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;
                const v_prev_lensq = v_prev_x * v_prev_x + v_prev_y * v_prev_y;
                // check for collinear edges
                const collinear0 = v_prev_x * v_next_y - v_prev_y * v_next_x;
                if (Math.abs(collinear0) > Number.EPSILON) {
                    // not collinear
                    // length of vectors for normalizing
                    const v_prev_len = Math.sqrt(v_prev_lensq);
                    const v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y);
                    // shift adjacent points by unit vectors to the left
                    const ptPrevShift_x = inPrev.x - v_prev_y / v_prev_len;
                    const ptPrevShift_y = inPrev.y + v_prev_x / v_prev_len;
                    const ptNextShift_x = inNext.x - v_next_y / v_next_len;
                    const ptNextShift_y = inNext.y + v_next_x / v_next_len;
                    // scaling factor for v_prev to intersection point
                    const sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y - (ptNextShift_y - ptPrevShift_y) * v_next_x) / (v_prev_x * v_next_y - v_prev_y * v_next_x);
                    // vector from inPt to intersection point
                    v_trans_x = ptPrevShift_x + v_prev_x * sf - inPt.x;
                    v_trans_y = ptPrevShift_y + v_prev_y * sf - inPt.y;
                    // Don't normalize!, otherwise sharp corners become ugly
                    //  but prevent crazy spikes
                    const v_trans_lensq = v_trans_x * v_trans_x + v_trans_y * v_trans_y;
                    if (v_trans_lensq <= 2) return new $084574008ccedf86$export$c977b3e384af9ae1(v_trans_x, v_trans_y);
                    else shrink_by = Math.sqrt(v_trans_lensq / 2);
                } else {
                    // handle special case of collinear edges
                    let direction_eq = false; // assumes: opposite
                    if (v_prev_x > Number.EPSILON) {
                        if (v_next_x > Number.EPSILON) direction_eq = true;
                    } else {
                        if (v_prev_x < -Number.EPSILON) {
                            if (v_next_x < -Number.EPSILON) direction_eq = true;
                        } else if (Math.sign(v_prev_y) === Math.sign(v_next_y)) direction_eq = true;
                    }
                    if (direction_eq) {
                        // console.log("Warning: lines are a straight sequence");
                        v_trans_x = -v_prev_y;
                        v_trans_y = v_prev_x;
                        shrink_by = Math.sqrt(v_prev_lensq);
                    } else {
                        // console.log("Warning: lines are a straight spike");
                        v_trans_x = v_prev_x;
                        v_trans_y = v_prev_y;
                        shrink_by = Math.sqrt(v_prev_lensq / 2);
                    }
                }
                return new $084574008ccedf86$export$c977b3e384af9ae1(v_trans_x / shrink_by, v_trans_y / shrink_by);
            }
            const contourMovements = [];
            for(let i242 = 0, il = contour1.length, j2 = il - 1, k1 = i242 + 1; i242 < il; i242++, j2++, k1++){
                if (j2 === il) j2 = 0;
                if (k1 === il) k1 = 0;
                //  (j)---(i)---(k)
                // console.log('i,j,k', i, j , k)
                contourMovements[i242] = getBevelVec(contour1[i242], contour1[j2], contour1[k1]);
            }
            const holesMovements = [];
            let oneHoleMovements, verticesMovements = contourMovements.concat();
            for(let h1 = 0, hl1 = holes.length; h1 < hl1; h1++){
                const ahole = holes[h1];
                oneHoleMovements = [];
                for(let i243 = 0, il = ahole.length, j = il - 1, k = i243 + 1; i243 < il; i243++, j++, k++){
                    if (j === il) j = 0;
                    if (k === il) k = 0;
                    //  (j)---(i)---(k)
                    oneHoleMovements[i243] = getBevelVec(ahole[i243], ahole[j], ahole[k]);
                }
                holesMovements.push(oneHoleMovements);
                verticesMovements = verticesMovements.concat(oneHoleMovements);
            }
            // Loop bevelSegments, 1 for the front, 1 for the back
            for(let b4 = 0; b4 < bevelSegments; b4++){
                //for ( b = bevelSegments; b > 0; b -- ) {
                const t = b4 / bevelSegments;
                const z = bevelThickness * Math.cos(t * Math.PI / 2);
                const bs = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset;
                // contract shape
                for(let i244 = 0, il = contour1.length; i244 < il; i244++){
                    const vert = scalePt2(contour1[i244], contourMovements[i244], bs);
                    v(vert.x, vert.y, -z);
                }
                // expand holes
                for(let h = 0, hl = holes.length; h < hl; h++){
                    const ahole = holes[h];
                    oneHoleMovements = holesMovements[h];
                    for(let i245 = 0, il = ahole.length; i245 < il; i245++){
                        const vert = scalePt2(ahole[i245], oneHoleMovements[i245], bs);
                        v(vert.x, vert.y, -z);
                    }
                }
            }
            const bs = bevelSize + bevelOffset;
            // Back facing vertices
            for(let i240 = 0; i240 < vlen; i240++){
                const vert = bevelEnabled ? scalePt2(vertices[i240], verticesMovements[i240], bs) : vertices[i240];
                if (!extrudeByPath) v(vert.x, vert.y, 0);
                else {
                    // v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );
                    normal.copy(splineTube.normals[0]).multiplyScalar(vert.x);
                    binormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y);
                    position2.copy(extrudePts[0]).add(normal).add(binormal);
                    v(position2.x, position2.y, position2.z);
                }
            }
            // Add stepped vertices...
            // Including front facing vertices
            for(let s4 = 1; s4 <= steps; s4++)for(let i241 = 0; i241 < vlen; i241++){
                const vert = bevelEnabled ? scalePt2(vertices[i241], verticesMovements[i241], bs) : vertices[i241];
                if (!extrudeByPath) v(vert.x, vert.y, depth / steps * s4);
                else {
                    // v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );
                    normal.copy(splineTube.normals[s4]).multiplyScalar(vert.x);
                    binormal.copy(splineTube.binormals[s4]).multiplyScalar(vert.y);
                    position2.copy(extrudePts[s4]).add(normal).add(binormal);
                    v(position2.x, position2.y, position2.z);
                }
            }
            // Add bevel segments planes
            //for ( b = 1; b <= bevelSegments; b ++ ) {
            for(let b3 = bevelSegments - 1; b3 >= 0; b3--){
                const t = b3 / bevelSegments;
                const z = bevelThickness * Math.cos(t * Math.PI / 2);
                const bs = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset;
                // contract shape
                for(let i246 = 0, il = contour1.length; i246 < il; i246++){
                    const vert = scalePt2(contour1[i246], contourMovements[i246], bs);
                    v(vert.x, vert.y, depth + z);
                }
                // expand holes
                for(let h = 0, hl = holes.length; h < hl; h++){
                    const ahole = holes[h];
                    oneHoleMovements = holesMovements[h];
                    for(let i247 = 0, il = ahole.length; i247 < il; i247++){
                        const vert = scalePt2(ahole[i247], oneHoleMovements[i247], bs);
                        if (!extrudeByPath) v(vert.x, vert.y, depth + z);
                        else v(vert.x, vert.y + extrudePts[steps - 1].y, extrudePts[steps - 1].x + z);
                    }
                }
            }
            /* Faces */ // Top and bottom faces
            buildLidFaces();
            // Sides faces
            buildSideFaces();
            /////  Internal functions
            function buildLidFaces() {
                const start = verticesArray.length / 3;
                if (bevelEnabled) {
                    let layer = 0; // steps + 1
                    let offset = vlen * layer;
                    // Bottom faces
                    for(let i249 = 0; i249 < flen; i249++){
                        const face = faces[i249];
                        f3(face[2] + offset, face[1] + offset, face[0] + offset);
                    }
                    layer = steps + bevelSegments * 2;
                    offset = vlen * layer;
                    // Top faces
                    for(let i248 = 0; i248 < flen; i248++){
                        const face = faces[i248];
                        f3(face[0] + offset, face[1] + offset, face[2] + offset);
                    }
                } else {
                    // Bottom faces
                    for(let i251 = 0; i251 < flen; i251++){
                        const face = faces[i251];
                        f3(face[2], face[1], face[0]);
                    }
                    // Top faces
                    for(let i250 = 0; i250 < flen; i250++){
                        const face = faces[i250];
                        f3(face[0] + vlen * steps, face[1] + vlen * steps, face[2] + vlen * steps);
                    }
                }
                scope.addGroup(start, verticesArray.length / 3 - start, 0);
            }
            // Create faces for the z-sides of the shape
            function buildSideFaces() {
                const start = verticesArray.length / 3;
                let layeroffset = 0;
                sidewalls(contour1, layeroffset);
                layeroffset += contour1.length;
                for(let h = 0, hl = holes.length; h < hl; h++){
                    const ahole = holes[h];
                    sidewalls(ahole, layeroffset);
                    //, true
                    layeroffset += ahole.length;
                }
                scope.addGroup(start, verticesArray.length / 3 - start, 1);
            }
            function sidewalls(contour, layeroffset) {
                let i252 = contour.length;
                while(--i252 >= 0){
                    const j = i252;
                    let k = i252 - 1;
                    if (k < 0) k = contour.length - 1;
                    //console.log('b', i,j, i-1, k,vertices.length);
                    for(let s = 0, sl = steps + bevelSegments * 2; s < sl; s++){
                        const slen1 = vlen * s;
                        const slen2 = vlen * (s + 1);
                        const a = layeroffset + j + slen1, b = layeroffset + k + slen1, c = layeroffset + k + slen2, d = layeroffset + j + slen2;
                        f4(a, b, c, d);
                    }
                }
            }
            function v(x, y, z) {
                placeholder.push(x);
                placeholder.push(y);
                placeholder.push(z);
            }
            function f3(a, b, c) {
                addVertex(a);
                addVertex(b);
                addVertex(c);
                const nextIndex = verticesArray.length / 3;
                const uvs = uvgen.generateTopUV(scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1);
                addUV(uvs[0]);
                addUV(uvs[1]);
                addUV(uvs[2]);
            }
            function f4(a, b, c, d) {
                addVertex(a);
                addVertex(b);
                addVertex(d);
                addVertex(b);
                addVertex(c);
                addVertex(d);
                const nextIndex = verticesArray.length / 3;
                const uvs = uvgen.generateSideWallUV(scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1);
                addUV(uvs[0]);
                addUV(uvs[1]);
                addUV(uvs[3]);
                addUV(uvs[1]);
                addUV(uvs[2]);
                addUV(uvs[3]);
            }
            function addVertex(index) {
                verticesArray.push(placeholder[index * 3 + 0]);
                verticesArray.push(placeholder[index * 3 + 1]);
                verticesArray.push(placeholder[index * 3 + 2]);
            }
            function addUV(vector2) {
                uvArray.push(vector2.x);
                uvArray.push(vector2.y);
            }
        }
    }
    toJSON() {
        const data = super.toJSON();
        const shapes = this.parameters.shapes;
        const options = this.parameters.options;
        return $084574008ccedf86$var$toJSON$1(shapes, options, data);
    }
    static fromJSON(data, shapes) {
        const geometryShapes = [];
        for(let j = 0, jl = data.shapes.length; j < jl; j++){
            const shape = shapes[data.shapes[j]];
            geometryShapes.push(shape);
        }
        const extrudePath = data.options.extrudePath;
        if (extrudePath !== undefined) data.options.extrudePath = new $084574008ccedf86$var$Curves[extrudePath.type]().fromJSON(extrudePath);
        return new $084574008ccedf86$export$91836d01b9f75a58(geometryShapes, data.options);
    }
}
const $084574008ccedf86$var$WorldUVGenerator = {
    generateTopUV: function(geometry, vertices, indexA, indexB, indexC) {
        const a_x = vertices[indexA * 3];
        const a_y = vertices[indexA * 3 + 1];
        const b_x = vertices[indexB * 3];
        const b_y = vertices[indexB * 3 + 1];
        const c_x = vertices[indexC * 3];
        const c_y = vertices[indexC * 3 + 1];
        return [
            new $084574008ccedf86$export$c977b3e384af9ae1(a_x, a_y),
            new $084574008ccedf86$export$c977b3e384af9ae1(b_x, b_y),
            new $084574008ccedf86$export$c977b3e384af9ae1(c_x, c_y)
        ];
    },
    generateSideWallUV: function(geometry, vertices, indexA, indexB, indexC, indexD) {
        const a_x = vertices[indexA * 3];
        const a_y = vertices[indexA * 3 + 1];
        const a_z = vertices[indexA * 3 + 2];
        const b_x = vertices[indexB * 3];
        const b_y = vertices[indexB * 3 + 1];
        const b_z = vertices[indexB * 3 + 2];
        const c_x = vertices[indexC * 3];
        const c_y = vertices[indexC * 3 + 1];
        const c_z = vertices[indexC * 3 + 2];
        const d_x = vertices[indexD * 3];
        const d_y = vertices[indexD * 3 + 1];
        const d_z = vertices[indexD * 3 + 2];
        if (Math.abs(a_y - b_y) < Math.abs(a_x - b_x)) return [
            new $084574008ccedf86$export$c977b3e384af9ae1(a_x, 1 - a_z),
            new $084574008ccedf86$export$c977b3e384af9ae1(b_x, 1 - b_z),
            new $084574008ccedf86$export$c977b3e384af9ae1(c_x, 1 - c_z),
            new $084574008ccedf86$export$c977b3e384af9ae1(d_x, 1 - d_z)
        ];
        else return [
            new $084574008ccedf86$export$c977b3e384af9ae1(a_y, 1 - a_z),
            new $084574008ccedf86$export$c977b3e384af9ae1(b_y, 1 - b_z),
            new $084574008ccedf86$export$c977b3e384af9ae1(c_y, 1 - c_z),
            new $084574008ccedf86$export$c977b3e384af9ae1(d_y, 1 - d_z)
        ];
    }
};
function $084574008ccedf86$var$toJSON$1(shapes, options, data) {
    data.shapes = [];
    if (Array.isArray(shapes)) for(let i253 = 0, l = shapes.length; i253 < l; i253++){
        const shape = shapes[i253];
        data.shapes.push(shape.uuid);
    }
    else data.shapes.push(shapes.uuid);
    data.options = Object.assign({}, options);
    if (options.extrudePath !== undefined) data.options.extrudePath = options.extrudePath.toJSON();
    return data;
}
class $084574008ccedf86$export$731fd4feef063ea2 extends $084574008ccedf86$export$38789b531813345c {
    constructor(radius = 1, detail = 0){
        const t = (1 + Math.sqrt(5)) / 2;
        const vertices = [
            -1,
            t,
            0,
            1,
            t,
            0,
            -1,
            -t,
            0,
            1,
            -t,
            0,
            0,
            -1,
            t,
            0,
            1,
            t,
            0,
            -1,
            -t,
            0,
            1,
            -t,
            t,
            0,
            -1,
            t,
            0,
            1,
            -t,
            0,
            -1,
            -t,
            0,
            1
        ];
        const indices = [
            0,
            11,
            5,
            0,
            5,
            1,
            0,
            1,
            7,
            0,
            7,
            10,
            0,
            10,
            11,
            1,
            5,
            9,
            5,
            11,
            4,
            11,
            10,
            2,
            10,
            7,
            6,
            7,
            1,
            8,
            3,
            9,
            4,
            3,
            4,
            2,
            3,
            2,
            6,
            3,
            6,
            8,
            3,
            8,
            9,
            4,
            9,
            5,
            2,
            4,
            11,
            6,
            2,
            10,
            8,
            6,
            7,
            9,
            8,
            1
        ];
        super(vertices, indices, radius, detail);
        this.type = "IcosahedronGeometry";
        this.parameters = {
            radius: radius,
            detail: detail
        };
    }
    static fromJSON(data) {
        return new $084574008ccedf86$export$731fd4feef063ea2(data.radius, data.detail);
    }
}
class $084574008ccedf86$export$8e05fc91596f4752 extends $084574008ccedf86$export$38789b531813345c {
    constructor(radius = 1, detail = 0){
        const vertices = [
            1,
            0,
            0,
            -1,
            0,
            0,
            0,
            1,
            0,
            0,
            -1,
            0,
            0,
            0,
            1,
            0,
            0,
            -1
        ];
        const indices = [
            0,
            2,
            4,
            0,
            4,
            3,
            0,
            3,
            5,
            0,
            5,
            2,
            1,
            2,
            5,
            1,
            5,
            3,
            1,
            3,
            4,
            1,
            4,
            2
        ];
        super(vertices, indices, radius, detail);
        this.type = "OctahedronGeometry";
        this.parameters = {
            radius: radius,
            detail: detail
        };
    }
    static fromJSON(data) {
        return new $084574008ccedf86$export$8e05fc91596f4752(data.radius, data.detail);
    }
}
class $084574008ccedf86$export$ee8b85b34b7d9cad extends $084574008ccedf86$export$b7be63a67df8959 {
    constructor(innerRadius = 0.5, outerRadius = 1, thetaSegments = 8, phiSegments = 1, thetaStart = 0, thetaLength = Math.PI * 2){
        super();
        this.type = "RingGeometry";
        this.parameters = {
            innerRadius: innerRadius,
            outerRadius: outerRadius,
            thetaSegments: thetaSegments,
            phiSegments: phiSegments,
            thetaStart: thetaStart,
            thetaLength: thetaLength
        };
        thetaSegments = Math.max(3, thetaSegments);
        phiSegments = Math.max(1, phiSegments);
        // buffers
        const indices = [];
        const vertices = [];
        const normals = [];
        const uvs = [];
        // some helper variables
        let radius = innerRadius;
        const radiusStep = (outerRadius - innerRadius) / phiSegments;
        const vertex9 = new $084574008ccedf86$export$64b5c384219d3699();
        const uv = new $084574008ccedf86$export$c977b3e384af9ae1();
        // generate vertices, normals and uvs
        for(let j = 0; j <= phiSegments; j++){
            for(let i254 = 0; i254 <= thetaSegments; i254++){
                // values are generate from the inside of the ring to the outside
                const segment = thetaStart + i254 / thetaSegments * thetaLength;
                // vertex
                vertex9.x = radius * Math.cos(segment);
                vertex9.y = radius * Math.sin(segment);
                vertices.push(vertex9.x, vertex9.y, vertex9.z);
                // normal
                normals.push(0, 0, 1);
                // uv
                uv.x = (vertex9.x / outerRadius + 1) / 2;
                uv.y = (vertex9.y / outerRadius + 1) / 2;
                uvs.push(uv.x, uv.y);
            }
            // increase the radius for next row of vertices
            radius += radiusStep;
        }
        // indices
        for(let j3 = 0; j3 < phiSegments; j3++){
            const thetaSegmentLevel = j3 * (thetaSegments + 1);
            for(let i255 = 0; i255 < thetaSegments; i255++){
                const segment = i255 + thetaSegmentLevel;
                const a = segment;
                const b = segment + thetaSegments + 1;
                const c = segment + thetaSegments + 2;
                const d = segment + 1;
                // faces
                indices.push(a, b, d);
                indices.push(b, c, d);
            }
        }
        // build geometry
        this.setIndex(indices);
        this.setAttribute("position", new $084574008ccedf86$export$cbe7a62641830ebd(vertices, 3));
        this.setAttribute("normal", new $084574008ccedf86$export$cbe7a62641830ebd(normals, 3));
        this.setAttribute("uv", new $084574008ccedf86$export$cbe7a62641830ebd(uvs, 2));
    }
    static fromJSON(data) {
        return new $084574008ccedf86$export$ee8b85b34b7d9cad(data.innerRadius, data.outerRadius, data.thetaSegments, data.phiSegments, data.thetaStart, data.thetaLength);
    }
}
class $084574008ccedf86$export$233afc324766bed8 extends $084574008ccedf86$export$b7be63a67df8959 {
    constructor(shapes = new $084574008ccedf86$export$6428a7f2611ef1fa([
        new $084574008ccedf86$export$c977b3e384af9ae1(0, 0.5),
        new $084574008ccedf86$export$c977b3e384af9ae1(-0.5, -0.5),
        new $084574008ccedf86$export$c977b3e384af9ae1(0.5, -0.5)
    ]), curveSegments = 12){
        super();
        this.type = "ShapeGeometry";
        this.parameters = {
            shapes: shapes,
            curveSegments: curveSegments
        };
        // buffers
        const indices = [];
        const vertices = [];
        const normals = [];
        const uvs = [];
        // helper variables
        let groupStart = 0;
        let groupCount = 0;
        // allow single and array values for "shapes" parameter
        if (Array.isArray(shapes) === false) addShape(shapes);
        else for(let i256 = 0; i256 < shapes.length; i256++){
            addShape(shapes[i256]);
            this.addGroup(groupStart, groupCount, i256); // enables MultiMaterial support
            groupStart += groupCount;
            groupCount = 0;
        }
        // build geometry
        this.setIndex(indices);
        this.setAttribute("position", new $084574008ccedf86$export$cbe7a62641830ebd(vertices, 3));
        this.setAttribute("normal", new $084574008ccedf86$export$cbe7a62641830ebd(normals, 3));
        this.setAttribute("uv", new $084574008ccedf86$export$cbe7a62641830ebd(uvs, 2));
        // helper functions
        function addShape(shape) {
            const indexOffset = vertices.length / 3;
            const points = shape.extractPoints(curveSegments);
            let shapeVertices = points.shape;
            const shapeHoles = points.holes;
            // check direction of vertices
            if ($084574008ccedf86$export$96bdf6d9c66d7ba8.isClockWise(shapeVertices) === false) shapeVertices = shapeVertices.reverse();
            for(let i260 = 0, l = shapeHoles.length; i260 < l; i260++){
                const shapeHole = shapeHoles[i260];
                if ($084574008ccedf86$export$96bdf6d9c66d7ba8.isClockWise(shapeHole) === true) shapeHoles[i260] = shapeHole.reverse();
            }
            const faces = $084574008ccedf86$export$96bdf6d9c66d7ba8.triangulateShape(shapeVertices, shapeHoles);
            // join vertices of inner and outer paths to a single array
            for(let i257 = 0, l3 = shapeHoles.length; i257 < l3; i257++){
                const shapeHole = shapeHoles[i257];
                shapeVertices = shapeVertices.concat(shapeHole);
            }
            // vertices, normals, uvs
            for(let i258 = 0, l4 = shapeVertices.length; i258 < l4; i258++){
                const vertex10 = shapeVertices[i258];
                vertices.push(vertex10.x, vertex10.y, 0);
                normals.push(0, 0, 1);
                uvs.push(vertex10.x, vertex10.y); // world uvs
            }
            // incides
            for(let i259 = 0, l5 = faces.length; i259 < l5; i259++){
                const face = faces[i259];
                const a = face[0] + indexOffset;
                const b = face[1] + indexOffset;
                const c = face[2] + indexOffset;
                indices.push(a, b, c);
                groupCount += 3;
            }
        }
    }
    toJSON() {
        const data = super.toJSON();
        const shapes = this.parameters.shapes;
        return $084574008ccedf86$var$toJSON(shapes, data);
    }
    static fromJSON(data, shapes) {
        const geometryShapes = [];
        for(let j = 0, jl = data.shapes.length; j < jl; j++){
            const shape = shapes[data.shapes[j]];
            geometryShapes.push(shape);
        }
        return new $084574008ccedf86$export$233afc324766bed8(geometryShapes, data.curveSegments);
    }
}
function $084574008ccedf86$var$toJSON(shapes, data) {
    data.shapes = [];
    if (Array.isArray(shapes)) for(let i261 = 0, l = shapes.length; i261 < l; i261++){
        const shape = shapes[i261];
        data.shapes.push(shape.uuid);
    }
    else data.shapes.push(shapes.uuid);
    return data;
}
class $084574008ccedf86$export$d5d06a966fec4192 extends $084574008ccedf86$export$b7be63a67df8959 {
    constructor(radius = 1, widthSegments = 32, heightSegments = 16, phiStart = 0, phiLength = Math.PI * 2, thetaStart = 0, thetaLength = Math.PI){
        super();
        this.type = "SphereGeometry";
        this.parameters = {
            radius: radius,
            widthSegments: widthSegments,
            heightSegments: heightSegments,
            phiStart: phiStart,
            phiLength: phiLength,
            thetaStart: thetaStart,
            thetaLength: thetaLength
        };
        widthSegments = Math.max(3, Math.floor(widthSegments));
        heightSegments = Math.max(2, Math.floor(heightSegments));
        const thetaEnd = Math.min(thetaStart + thetaLength, Math.PI);
        let index = 0;
        const grid = [];
        const vertex11 = new $084574008ccedf86$export$64b5c384219d3699();
        const normal = new $084574008ccedf86$export$64b5c384219d3699();
        // buffers
        const indices = [];
        const vertices = [];
        const normals = [];
        const uvs = [];
        // generate vertices, normals and uvs
        for(let iy = 0; iy <= heightSegments; iy++){
            const verticesRow = [];
            const v = iy / heightSegments;
            // special case for the poles
            let uOffset = 0;
            if (iy == 0 && thetaStart == 0) uOffset = 0.5 / widthSegments;
            else if (iy == heightSegments && thetaEnd == Math.PI) uOffset = -0.5 / widthSegments;
            for(let ix = 0; ix <= widthSegments; ix++){
                const u = ix / widthSegments;
                // vertex
                vertex11.x = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
                vertex11.y = radius * Math.cos(thetaStart + v * thetaLength);
                vertex11.z = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
                vertices.push(vertex11.x, vertex11.y, vertex11.z);
                // normal
                normal.copy(vertex11).normalize();
                normals.push(normal.x, normal.y, normal.z);
                // uv
                uvs.push(u + uOffset, 1 - v);
                verticesRow.push(index++);
            }
            grid.push(verticesRow);
        }
        // indices
        for(let iy3 = 0; iy3 < heightSegments; iy3++)for(let ix = 0; ix < widthSegments; ix++){
            const a = grid[iy3][ix + 1];
            const b = grid[iy3][ix];
            const c = grid[iy3 + 1][ix];
            const d = grid[iy3 + 1][ix + 1];
            if (iy3 !== 0 || thetaStart > 0) indices.push(a, b, d);
            if (iy3 !== heightSegments - 1 || thetaEnd < Math.PI) indices.push(b, c, d);
        }
        // build geometry
        this.setIndex(indices);
        this.setAttribute("position", new $084574008ccedf86$export$cbe7a62641830ebd(vertices, 3));
        this.setAttribute("normal", new $084574008ccedf86$export$cbe7a62641830ebd(normals, 3));
        this.setAttribute("uv", new $084574008ccedf86$export$cbe7a62641830ebd(uvs, 2));
    }
    static fromJSON(data) {
        return new $084574008ccedf86$export$d5d06a966fec4192(data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength);
    }
}
class $084574008ccedf86$export$369e08f62a796c65 extends $084574008ccedf86$export$38789b531813345c {
    constructor(radius = 1, detail = 0){
        const vertices = [
            1,
            1,
            1,
            -1,
            -1,
            1,
            -1,
            1,
            -1,
            1,
            -1,
            -1
        ];
        const indices = [
            2,
            1,
            0,
            0,
            3,
            2,
            1,
            3,
            0,
            2,
            3,
            1
        ];
        super(vertices, indices, radius, detail);
        this.type = "TetrahedronGeometry";
        this.parameters = {
            radius: radius,
            detail: detail
        };
    }
    static fromJSON(data) {
        return new $084574008ccedf86$export$369e08f62a796c65(data.radius, data.detail);
    }
}
class $084574008ccedf86$export$19d55f905fa4f2cb extends $084574008ccedf86$export$b7be63a67df8959 {
    constructor(radius = 1, tube = 0.4, radialSegments = 8, tubularSegments = 6, arc = Math.PI * 2){
        super();
        this.type = "TorusGeometry";
        this.parameters = {
            radius: radius,
            tube: tube,
            radialSegments: radialSegments,
            tubularSegments: tubularSegments,
            arc: arc
        };
        radialSegments = Math.floor(radialSegments);
        tubularSegments = Math.floor(tubularSegments);
        // buffers
        const indices = [];
        const vertices = [];
        const normals = [];
        const uvs = [];
        // helper variables
        const center = new $084574008ccedf86$export$64b5c384219d3699();
        const vertex12 = new $084574008ccedf86$export$64b5c384219d3699();
        const normal = new $084574008ccedf86$export$64b5c384219d3699();
        // generate vertices, normals and uvs
        for(let j = 0; j <= radialSegments; j++)for(let i263 = 0; i263 <= tubularSegments; i263++){
            const u = i263 / tubularSegments * arc;
            const v = j / radialSegments * Math.PI * 2;
            // vertex
            vertex12.x = (radius + tube * Math.cos(v)) * Math.cos(u);
            vertex12.y = (radius + tube * Math.cos(v)) * Math.sin(u);
            vertex12.z = tube * Math.sin(v);
            vertices.push(vertex12.x, vertex12.y, vertex12.z);
            // normal
            center.x = radius * Math.cos(u);
            center.y = radius * Math.sin(u);
            normal.subVectors(vertex12, center).normalize();
            normals.push(normal.x, normal.y, normal.z);
            // uv
            uvs.push(i263 / tubularSegments);
            uvs.push(j / radialSegments);
        }
        // generate indices
        for(let j4 = 1; j4 <= radialSegments; j4++)for(let i262 = 1; i262 <= tubularSegments; i262++){
            // indices
            const a = (tubularSegments + 1) * j4 + i262 - 1;
            const b = (tubularSegments + 1) * (j4 - 1) + i262 - 1;
            const c = (tubularSegments + 1) * (j4 - 1) + i262;
            const d = (tubularSegments + 1) * j4 + i262;
            // faces
            indices.push(a, b, d);
            indices.push(b, c, d);
        }
        // build geometry
        this.setIndex(indices);
        this.setAttribute("position", new $084574008ccedf86$export$cbe7a62641830ebd(vertices, 3));
        this.setAttribute("normal", new $084574008ccedf86$export$cbe7a62641830ebd(normals, 3));
        this.setAttribute("uv", new $084574008ccedf86$export$cbe7a62641830ebd(uvs, 2));
    }
    static fromJSON(data) {
        return new $084574008ccedf86$export$19d55f905fa4f2cb(data.radius, data.tube, data.radialSegments, data.tubularSegments, data.arc);
    }
}
class $084574008ccedf86$export$2b32466f4274fe5c extends $084574008ccedf86$export$b7be63a67df8959 {
    constructor(radius3 = 1, tube = 0.4, tubularSegments = 64, radialSegments = 8, p6 = 2, q3 = 3){
        super();
        this.type = "TorusKnotGeometry";
        this.parameters = {
            radius: radius3,
            tube: tube,
            tubularSegments: tubularSegments,
            radialSegments: radialSegments,
            p: p6,
            q: q3
        };
        tubularSegments = Math.floor(tubularSegments);
        radialSegments = Math.floor(radialSegments);
        // buffers
        const indices = [];
        const vertices = [];
        const normals = [];
        const uvs = [];
        // helper variables
        const vertex13 = new $084574008ccedf86$export$64b5c384219d3699();
        const normal = new $084574008ccedf86$export$64b5c384219d3699();
        const P1 = new $084574008ccedf86$export$64b5c384219d3699();
        const P2 = new $084574008ccedf86$export$64b5c384219d3699();
        const B = new $084574008ccedf86$export$64b5c384219d3699();
        const T = new $084574008ccedf86$export$64b5c384219d3699();
        const N = new $084574008ccedf86$export$64b5c384219d3699();
        // generate vertices, normals and uvs
        for(let i265 = 0; i265 <= tubularSegments; ++i265){
            // the radian "u" is used to calculate the position on the torus curve of the current tubular segment
            const u = i265 / tubularSegments * p6 * Math.PI * 2;
            // now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.
            // these points are used to create a special "coordinate space", which is necessary to calculate the correct vertex positions
            calculatePositionOnCurve(u, p6, q3, radius3, P1);
            calculatePositionOnCurve(u + 0.01, p6, q3, radius3, P2);
            // calculate orthonormal basis
            T.subVectors(P2, P1);
            N.addVectors(P2, P1);
            B.crossVectors(T, N);
            N.crossVectors(B, T);
            // normalize B, N. T can be ignored, we don't use it
            B.normalize();
            N.normalize();
            for(let j = 0; j <= radialSegments; ++j){
                // now calculate the vertices. they are nothing more than an extrusion of the torus curve.
                // because we extrude a shape in the xy-plane, there is no need to calculate a z-value.
                const v = j / radialSegments * Math.PI * 2;
                const cx = -tube * Math.cos(v);
                const cy = tube * Math.sin(v);
                // now calculate the final vertex position.
                // first we orient the extrusion with our basis vectors, then we add it to the current position on the curve
                vertex13.x = P1.x + (cx * N.x + cy * B.x);
                vertex13.y = P1.y + (cx * N.y + cy * B.y);
                vertex13.z = P1.z + (cx * N.z + cy * B.z);
                vertices.push(vertex13.x, vertex13.y, vertex13.z);
                // normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)
                normal.subVectors(vertex13, P1).normalize();
                normals.push(normal.x, normal.y, normal.z);
                // uv
                uvs.push(i265 / tubularSegments);
                uvs.push(j / radialSegments);
            }
        }
        // generate indices
        for(let j = 1; j <= tubularSegments; j++)for(let i264 = 1; i264 <= radialSegments; i264++){
            // indices
            const a = (radialSegments + 1) * (j - 1) + (i264 - 1);
            const b = (radialSegments + 1) * j + (i264 - 1);
            const c = (radialSegments + 1) * j + i264;
            const d = (radialSegments + 1) * (j - 1) + i264;
            // faces
            indices.push(a, b, d);
            indices.push(b, c, d);
        }
        // build geometry
        this.setIndex(indices);
        this.setAttribute("position", new $084574008ccedf86$export$cbe7a62641830ebd(vertices, 3));
        this.setAttribute("normal", new $084574008ccedf86$export$cbe7a62641830ebd(normals, 3));
        this.setAttribute("uv", new $084574008ccedf86$export$cbe7a62641830ebd(uvs, 2));
        // this function calculates the current position on the torus curve
        function calculatePositionOnCurve(u, p, q, radius, position) {
            const cu = Math.cos(u);
            const su = Math.sin(u);
            const quOverP = q / p * u;
            const cs = Math.cos(quOverP);
            position.x = radius * (2 + cs) * 0.5 * cu;
            position.y = radius * (2 + cs) * su * 0.5;
            position.z = radius * Math.sin(quOverP) * 0.5;
        }
    }
    static fromJSON(data) {
        return new $084574008ccedf86$export$2b32466f4274fe5c(data.radius, data.tube, data.tubularSegments, data.radialSegments, data.p, data.q);
    }
}
class $084574008ccedf86$export$d97a193ce44e691b extends $084574008ccedf86$export$b7be63a67df8959 {
    constructor(path = new $084574008ccedf86$export$bf3f4c7e459f90fc(new $084574008ccedf86$export$64b5c384219d3699(-1, -1, 0), new $084574008ccedf86$export$64b5c384219d3699(-1, 1, 0), new $084574008ccedf86$export$64b5c384219d3699(1, 1, 0)), tubularSegments = 64, radius = 1, radialSegments = 8, closed = false){
        super();
        this.type = "TubeGeometry";
        this.parameters = {
            path: path,
            tubularSegments: tubularSegments,
            radius: radius,
            radialSegments: radialSegments,
            closed: closed
        };
        const frames = path.computeFrenetFrames(tubularSegments, closed);
        // expose internals
        this.tangents = frames.tangents;
        this.normals = frames.normals;
        this.binormals = frames.binormals;
        // helper variables
        const vertex14 = new $084574008ccedf86$export$64b5c384219d3699();
        const normal = new $084574008ccedf86$export$64b5c384219d3699();
        const uv = new $084574008ccedf86$export$c977b3e384af9ae1();
        let P = new $084574008ccedf86$export$64b5c384219d3699();
        // buffer
        const vertices = [];
        const normals = [];
        const uvs = [];
        const indices = [];
        // create buffer data
        generateBufferData();
        // build geometry
        this.setIndex(indices);
        this.setAttribute("position", new $084574008ccedf86$export$cbe7a62641830ebd(vertices, 3));
        this.setAttribute("normal", new $084574008ccedf86$export$cbe7a62641830ebd(normals, 3));
        this.setAttribute("uv", new $084574008ccedf86$export$cbe7a62641830ebd(uvs, 2));
        // functions
        function generateBufferData() {
            for(let i266 = 0; i266 < tubularSegments; i266++)generateSegment(i266);
            // if the geometry is not closed, generate the last row of vertices and normals
            // at the regular position on the given path
            //
            // if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)
            generateSegment(closed === false ? tubularSegments : 0);
            // uvs are generated in a separate function.
            // this makes it easy compute correct values for closed geometries
            generateUVs();
            // finally create faces
            generateIndices();
        }
        function generateSegment(i267) {
            // we use getPointAt to sample evenly distributed points from the given path
            P = path.getPointAt(i267 / tubularSegments, P);
            // retrieve corresponding normal and binormal
            const N = frames.normals[i267];
            const B = frames.binormals[i267];
            // generate normals and vertices for the current segment
            for(let j = 0; j <= radialSegments; j++){
                const v = j / radialSegments * Math.PI * 2;
                const sin = Math.sin(v);
                const cos = -Math.cos(v);
                // normal
                normal.x = cos * N.x + sin * B.x;
                normal.y = cos * N.y + sin * B.y;
                normal.z = cos * N.z + sin * B.z;
                normal.normalize();
                normals.push(normal.x, normal.y, normal.z);
                // vertex
                vertex14.x = P.x + radius * normal.x;
                vertex14.y = P.y + radius * normal.y;
                vertex14.z = P.z + radius * normal.z;
                vertices.push(vertex14.x, vertex14.y, vertex14.z);
            }
        }
        function generateIndices() {
            for(let j = 1; j <= tubularSegments; j++)for(let i268 = 1; i268 <= radialSegments; i268++){
                const a = (radialSegments + 1) * (j - 1) + (i268 - 1);
                const b = (radialSegments + 1) * j + (i268 - 1);
                const c = (radialSegments + 1) * j + i268;
                const d = (radialSegments + 1) * (j - 1) + i268;
                // faces
                indices.push(a, b, d);
                indices.push(b, c, d);
            }
        }
        function generateUVs() {
            for(let i269 = 0; i269 <= tubularSegments; i269++)for(let j = 0; j <= radialSegments; j++){
                uv.x = i269 / tubularSegments;
                uv.y = j / radialSegments;
                uvs.push(uv.x, uv.y);
            }
        }
    }
    toJSON() {
        const data = super.toJSON();
        data.path = this.parameters.path.toJSON();
        return data;
    }
    static fromJSON(data) {
        // This only works for built-in curves (e.g. CatmullRomCurve3).
        // User defined curves or instances of CurvePath will not be deserialized.
        return new $084574008ccedf86$export$d97a193ce44e691b(new $084574008ccedf86$var$Curves[data.path.type]().fromJSON(data.path), data.tubularSegments, data.radius, data.radialSegments, data.closed);
    }
}
class $084574008ccedf86$export$4b739da06d24892b extends $084574008ccedf86$export$b7be63a67df8959 {
    constructor(geometry = null){
        super();
        this.type = "WireframeGeometry";
        this.parameters = {
            geometry: geometry
        };
        if (geometry !== null) {
            // buffer
            const vertices = [];
            const edges = new Set();
            // helper variables
            const start = new $084574008ccedf86$export$64b5c384219d3699();
            const end = new $084574008ccedf86$export$64b5c384219d3699();
            if (geometry.index !== null) {
                // indexed BufferGeometry
                const position = geometry.attributes.position;
                const indices = geometry.index;
                let groups = geometry.groups;
                if (groups.length === 0) groups = [
                    {
                        start: 0,
                        count: indices.count,
                        materialIndex: 0
                    }
                ];
                // create a data structure that contains all edges without duplicates
                for(let o = 0, ol = groups.length; o < ol; ++o){
                    const group = groups[o];
                    const groupStart = group.start;
                    const groupCount = group.count;
                    for(let i270 = groupStart, l = groupStart + groupCount; i270 < l; i270 += 3)for(let j = 0; j < 3; j++){
                        const index1 = indices.getX(i270 + j);
                        const index2 = indices.getX(i270 + (j + 1) % 3);
                        start.fromBufferAttribute(position, index1);
                        end.fromBufferAttribute(position, index2);
                        if ($084574008ccedf86$var$isUniqueEdge(start, end, edges) === true) {
                            vertices.push(start.x, start.y, start.z);
                            vertices.push(end.x, end.y, end.z);
                        }
                    }
                }
            } else {
                // non-indexed BufferGeometry
                const position = geometry.attributes.position;
                for(let i271 = 0, l = position.count / 3; i271 < l; i271++)for(let j = 0; j < 3; j++){
                    // three edges per triangle, an edge is represented as (index1, index2)
                    // e.g. the first triangle has the following edges: (0,1),(1,2),(2,0)
                    const index1 = 3 * i271 + j;
                    const index2 = 3 * i271 + (j + 1) % 3;
                    start.fromBufferAttribute(position, index1);
                    end.fromBufferAttribute(position, index2);
                    if ($084574008ccedf86$var$isUniqueEdge(start, end, edges) === true) {
                        vertices.push(start.x, start.y, start.z);
                        vertices.push(end.x, end.y, end.z);
                    }
                }
            }
            // build geometry
            this.setAttribute("position", new $084574008ccedf86$export$cbe7a62641830ebd(vertices, 3));
        }
    }
}
function $084574008ccedf86$var$isUniqueEdge(start, end, edges) {
    const hash1 = `${start.x},${start.y},${start.z}-${end.x},${end.y},${end.z}`;
    const hash2 = `${end.x},${end.y},${end.z}-${start.x},${start.y},${start.z}`; // coincident edge
    if (edges.has(hash1) === true || edges.has(hash2) === true) return false;
    else {
        edges.add(hash1);
        edges.add(hash2);
        return true;
    }
}
var $084574008ccedf86$var$Geometries = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    BoxGeometry: $084574008ccedf86$export$ab3456a079aa7d80,
    BoxBufferGeometry: $084574008ccedf86$export$ab3456a079aa7d80,
    CapsuleGeometry: $084574008ccedf86$export$f036d76f832848a,
    CapsuleBufferGeometry: $084574008ccedf86$export$f036d76f832848a,
    CircleGeometry: $084574008ccedf86$export$3f74fe60decf7462,
    CircleBufferGeometry: $084574008ccedf86$export$3f74fe60decf7462,
    ConeGeometry: $084574008ccedf86$export$59d971120dc8b6e7,
    ConeBufferGeometry: $084574008ccedf86$export$59d971120dc8b6e7,
    CylinderGeometry: $084574008ccedf86$export$d4345c83207d7c68,
    CylinderBufferGeometry: $084574008ccedf86$export$d4345c83207d7c68,
    DodecahedronGeometry: $084574008ccedf86$export$37cd4e52cce48c4c,
    DodecahedronBufferGeometry: $084574008ccedf86$export$37cd4e52cce48c4c,
    EdgesGeometry: $084574008ccedf86$export$4730b1542707547f,
    ExtrudeGeometry: $084574008ccedf86$export$91836d01b9f75a58,
    ExtrudeBufferGeometry: $084574008ccedf86$export$91836d01b9f75a58,
    IcosahedronGeometry: $084574008ccedf86$export$731fd4feef063ea2,
    IcosahedronBufferGeometry: $084574008ccedf86$export$731fd4feef063ea2,
    LatheGeometry: $084574008ccedf86$export$dc3e1273c1dd9240,
    LatheBufferGeometry: $084574008ccedf86$export$dc3e1273c1dd9240,
    OctahedronGeometry: $084574008ccedf86$export$8e05fc91596f4752,
    OctahedronBufferGeometry: $084574008ccedf86$export$8e05fc91596f4752,
    PlaneGeometry: $084574008ccedf86$export$e789a11a194ca4e0,
    PlaneBufferGeometry: $084574008ccedf86$export$e789a11a194ca4e0,
    PolyhedronGeometry: $084574008ccedf86$export$38789b531813345c,
    PolyhedronBufferGeometry: $084574008ccedf86$export$38789b531813345c,
    RingGeometry: $084574008ccedf86$export$ee8b85b34b7d9cad,
    RingBufferGeometry: $084574008ccedf86$export$ee8b85b34b7d9cad,
    ShapeGeometry: $084574008ccedf86$export$233afc324766bed8,
    ShapeBufferGeometry: $084574008ccedf86$export$233afc324766bed8,
    SphereGeometry: $084574008ccedf86$export$d5d06a966fec4192,
    SphereBufferGeometry: $084574008ccedf86$export$d5d06a966fec4192,
    TetrahedronGeometry: $084574008ccedf86$export$369e08f62a796c65,
    TetrahedronBufferGeometry: $084574008ccedf86$export$369e08f62a796c65,
    TorusGeometry: $084574008ccedf86$export$19d55f905fa4f2cb,
    TorusBufferGeometry: $084574008ccedf86$export$19d55f905fa4f2cb,
    TorusKnotGeometry: $084574008ccedf86$export$2b32466f4274fe5c,
    TorusKnotBufferGeometry: $084574008ccedf86$export$2b32466f4274fe5c,
    TubeGeometry: $084574008ccedf86$export$d97a193ce44e691b,
    TubeBufferGeometry: $084574008ccedf86$export$d97a193ce44e691b,
    WireframeGeometry: $084574008ccedf86$export$4b739da06d24892b
});
class $084574008ccedf86$export$e8564da406055a3 extends $084574008ccedf86$export$a2d8b23205c25948 {
    constructor(parameters){
        super();
        this.isShadowMaterial = true;
        this.type = "ShadowMaterial";
        this.color = new $084574008ccedf86$export$892596cec99bc70e(0x000000);
        this.transparent = true;
        this.fog = true;
        this.setValues(parameters);
    }
    copy(source) {
        super.copy(source);
        this.color.copy(source.color);
        this.fog = source.fog;
        return this;
    }
}
class $084574008ccedf86$export$21c421a2e1df9d22 extends $084574008ccedf86$export$83c7d75d550a8b0d {
    constructor(parameters){
        super(parameters);
        this.isRawShaderMaterial = true;
        this.type = "RawShaderMaterial";
    }
}
class $084574008ccedf86$export$f2980790215acccd extends $084574008ccedf86$export$a2d8b23205c25948 {
    constructor(parameters){
        super();
        this.isMeshStandardMaterial = true;
        this.defines = {
            "STANDARD": ""
        };
        this.type = "MeshStandardMaterial";
        this.color = new $084574008ccedf86$export$892596cec99bc70e(0xffffff); // diffuse
        this.roughness = 1.0;
        this.metalness = 0.0;
        this.map = null;
        this.lightMap = null;
        this.lightMapIntensity = 1.0;
        this.aoMap = null;
        this.aoMapIntensity = 1.0;
        this.emissive = new $084574008ccedf86$export$892596cec99bc70e(0x000000);
        this.emissiveIntensity = 1.0;
        this.emissiveMap = null;
        this.bumpMap = null;
        this.bumpScale = 1;
        this.normalMap = null;
        this.normalMapType = $084574008ccedf86$export$2852a58ebdac27b8;
        this.normalScale = new $084574008ccedf86$export$c977b3e384af9ae1(1, 1);
        this.displacementMap = null;
        this.displacementScale = 1;
        this.displacementBias = 0;
        this.roughnessMap = null;
        this.metalnessMap = null;
        this.alphaMap = null;
        this.envMap = null;
        this.envMapIntensity = 1.0;
        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.wireframeLinecap = "round";
        this.wireframeLinejoin = "round";
        this.flatShading = false;
        this.fog = true;
        this.setValues(parameters);
    }
    copy(source) {
        super.copy(source);
        this.defines = {
            "STANDARD": ""
        };
        this.color.copy(source.color);
        this.roughness = source.roughness;
        this.metalness = source.metalness;
        this.map = source.map;
        this.lightMap = source.lightMap;
        this.lightMapIntensity = source.lightMapIntensity;
        this.aoMap = source.aoMap;
        this.aoMapIntensity = source.aoMapIntensity;
        this.emissive.copy(source.emissive);
        this.emissiveMap = source.emissiveMap;
        this.emissiveIntensity = source.emissiveIntensity;
        this.bumpMap = source.bumpMap;
        this.bumpScale = source.bumpScale;
        this.normalMap = source.normalMap;
        this.normalMapType = source.normalMapType;
        this.normalScale.copy(source.normalScale);
        this.displacementMap = source.displacementMap;
        this.displacementScale = source.displacementScale;
        this.displacementBias = source.displacementBias;
        this.roughnessMap = source.roughnessMap;
        this.metalnessMap = source.metalnessMap;
        this.alphaMap = source.alphaMap;
        this.envMap = source.envMap;
        this.envMapIntensity = source.envMapIntensity;
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        this.wireframeLinecap = source.wireframeLinecap;
        this.wireframeLinejoin = source.wireframeLinejoin;
        this.flatShading = source.flatShading;
        this.fog = source.fog;
        return this;
    }
}
class $084574008ccedf86$export$28d04986c4269c9f extends $084574008ccedf86$export$f2980790215acccd {
    constructor(parameters){
        super();
        this.isMeshPhysicalMaterial = true;
        this.defines = {
            "STANDARD": "",
            "PHYSICAL": ""
        };
        this.type = "MeshPhysicalMaterial";
        this.clearcoatMap = null;
        this.clearcoatRoughness = 0.0;
        this.clearcoatRoughnessMap = null;
        this.clearcoatNormalScale = new $084574008ccedf86$export$c977b3e384af9ae1(1, 1);
        this.clearcoatNormalMap = null;
        this.ior = 1.5;
        Object.defineProperty(this, "reflectivity", {
            get: function() {
                return $084574008ccedf86$var$clamp(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1);
            },
            set: function(reflectivity) {
                this.ior = (1 + 0.4 * reflectivity) / (1 - 0.4 * reflectivity);
            }
        });
        this.iridescenceMap = null;
        this.iridescenceIOR = 1.3;
        this.iridescenceThicknessRange = [
            100,
            400
        ];
        this.iridescenceThicknessMap = null;
        this.sheenColor = new $084574008ccedf86$export$892596cec99bc70e(0x000000);
        this.sheenColorMap = null;
        this.sheenRoughness = 1.0;
        this.sheenRoughnessMap = null;
        this.transmissionMap = null;
        this.thickness = 0;
        this.thicknessMap = null;
        this.attenuationDistance = 0.0;
        this.attenuationColor = new $084574008ccedf86$export$892596cec99bc70e(1, 1, 1);
        this.specularIntensity = 1.0;
        this.specularIntensityMap = null;
        this.specularColor = new $084574008ccedf86$export$892596cec99bc70e(1, 1, 1);
        this.specularColorMap = null;
        this._sheen = 0.0;
        this._clearcoat = 0;
        this._iridescence = 0;
        this._transmission = 0;
        this.setValues(parameters);
    }
    get sheen() {
        return this._sheen;
    }
    set sheen(value) {
        if (this._sheen > 0 !== value > 0) this.version++;
        this._sheen = value;
    }
    get clearcoat() {
        return this._clearcoat;
    }
    set clearcoat(value) {
        if (this._clearcoat > 0 !== value > 0) this.version++;
        this._clearcoat = value;
    }
    get iridescence() {
        return this._iridescence;
    }
    set iridescence(value) {
        if (this._iridescence > 0 !== value > 0) this.version++;
        this._iridescence = value;
    }
    get transmission() {
        return this._transmission;
    }
    set transmission(value) {
        if (this._transmission > 0 !== value > 0) this.version++;
        this._transmission = value;
    }
    copy(source) {
        super.copy(source);
        this.defines = {
            "STANDARD": "",
            "PHYSICAL": ""
        };
        this.clearcoat = source.clearcoat;
        this.clearcoatMap = source.clearcoatMap;
        this.clearcoatRoughness = source.clearcoatRoughness;
        this.clearcoatRoughnessMap = source.clearcoatRoughnessMap;
        this.clearcoatNormalMap = source.clearcoatNormalMap;
        this.clearcoatNormalScale.copy(source.clearcoatNormalScale);
        this.ior = source.ior;
        this.iridescence = source.iridescence;
        this.iridescenceMap = source.iridescenceMap;
        this.iridescenceIOR = source.iridescenceIOR;
        this.iridescenceThicknessRange = [
            ...source.iridescenceThicknessRange
        ];
        this.iridescenceThicknessMap = source.iridescenceThicknessMap;
        this.sheen = source.sheen;
        this.sheenColor.copy(source.sheenColor);
        this.sheenColorMap = source.sheenColorMap;
        this.sheenRoughness = source.sheenRoughness;
        this.sheenRoughnessMap = source.sheenRoughnessMap;
        this.transmission = source.transmission;
        this.transmissionMap = source.transmissionMap;
        this.thickness = source.thickness;
        this.thicknessMap = source.thicknessMap;
        this.attenuationDistance = source.attenuationDistance;
        this.attenuationColor.copy(source.attenuationColor);
        this.specularIntensity = source.specularIntensity;
        this.specularIntensityMap = source.specularIntensityMap;
        this.specularColor.copy(source.specularColor);
        this.specularColorMap = source.specularColorMap;
        return this;
    }
}
class $084574008ccedf86$export$24c72f71cbaf0678 extends $084574008ccedf86$export$a2d8b23205c25948 {
    constructor(parameters){
        super();
        this.isMeshPhongMaterial = true;
        this.type = "MeshPhongMaterial";
        this.color = new $084574008ccedf86$export$892596cec99bc70e(0xffffff); // diffuse
        this.specular = new $084574008ccedf86$export$892596cec99bc70e(0x111111);
        this.shininess = 30;
        this.map = null;
        this.lightMap = null;
        this.lightMapIntensity = 1.0;
        this.aoMap = null;
        this.aoMapIntensity = 1.0;
        this.emissive = new $084574008ccedf86$export$892596cec99bc70e(0x000000);
        this.emissiveIntensity = 1.0;
        this.emissiveMap = null;
        this.bumpMap = null;
        this.bumpScale = 1;
        this.normalMap = null;
        this.normalMapType = $084574008ccedf86$export$2852a58ebdac27b8;
        this.normalScale = new $084574008ccedf86$export$c977b3e384af9ae1(1, 1);
        this.displacementMap = null;
        this.displacementScale = 1;
        this.displacementBias = 0;
        this.specularMap = null;
        this.alphaMap = null;
        this.envMap = null;
        this.combine = $084574008ccedf86$export$e50ac29801f1774d;
        this.reflectivity = 1;
        this.refractionRatio = 0.98;
        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.wireframeLinecap = "round";
        this.wireframeLinejoin = "round";
        this.flatShading = false;
        this.fog = true;
        this.setValues(parameters);
    }
    copy(source) {
        super.copy(source);
        this.color.copy(source.color);
        this.specular.copy(source.specular);
        this.shininess = source.shininess;
        this.map = source.map;
        this.lightMap = source.lightMap;
        this.lightMapIntensity = source.lightMapIntensity;
        this.aoMap = source.aoMap;
        this.aoMapIntensity = source.aoMapIntensity;
        this.emissive.copy(source.emissive);
        this.emissiveMap = source.emissiveMap;
        this.emissiveIntensity = source.emissiveIntensity;
        this.bumpMap = source.bumpMap;
        this.bumpScale = source.bumpScale;
        this.normalMap = source.normalMap;
        this.normalMapType = source.normalMapType;
        this.normalScale.copy(source.normalScale);
        this.displacementMap = source.displacementMap;
        this.displacementScale = source.displacementScale;
        this.displacementBias = source.displacementBias;
        this.specularMap = source.specularMap;
        this.alphaMap = source.alphaMap;
        this.envMap = source.envMap;
        this.combine = source.combine;
        this.reflectivity = source.reflectivity;
        this.refractionRatio = source.refractionRatio;
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        this.wireframeLinecap = source.wireframeLinecap;
        this.wireframeLinejoin = source.wireframeLinejoin;
        this.flatShading = source.flatShading;
        this.fog = source.fog;
        return this;
    }
}
class $084574008ccedf86$export$df893cf97e765622 extends $084574008ccedf86$export$a2d8b23205c25948 {
    constructor(parameters){
        super();
        this.isMeshToonMaterial = true;
        this.defines = {
            "TOON": ""
        };
        this.type = "MeshToonMaterial";
        this.color = new $084574008ccedf86$export$892596cec99bc70e(0xffffff);
        this.map = null;
        this.gradientMap = null;
        this.lightMap = null;
        this.lightMapIntensity = 1.0;
        this.aoMap = null;
        this.aoMapIntensity = 1.0;
        this.emissive = new $084574008ccedf86$export$892596cec99bc70e(0x000000);
        this.emissiveIntensity = 1.0;
        this.emissiveMap = null;
        this.bumpMap = null;
        this.bumpScale = 1;
        this.normalMap = null;
        this.normalMapType = $084574008ccedf86$export$2852a58ebdac27b8;
        this.normalScale = new $084574008ccedf86$export$c977b3e384af9ae1(1, 1);
        this.displacementMap = null;
        this.displacementScale = 1;
        this.displacementBias = 0;
        this.alphaMap = null;
        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.wireframeLinecap = "round";
        this.wireframeLinejoin = "round";
        this.fog = true;
        this.setValues(parameters);
    }
    copy(source) {
        super.copy(source);
        this.color.copy(source.color);
        this.map = source.map;
        this.gradientMap = source.gradientMap;
        this.lightMap = source.lightMap;
        this.lightMapIntensity = source.lightMapIntensity;
        this.aoMap = source.aoMap;
        this.aoMapIntensity = source.aoMapIntensity;
        this.emissive.copy(source.emissive);
        this.emissiveMap = source.emissiveMap;
        this.emissiveIntensity = source.emissiveIntensity;
        this.bumpMap = source.bumpMap;
        this.bumpScale = source.bumpScale;
        this.normalMap = source.normalMap;
        this.normalMapType = source.normalMapType;
        this.normalScale.copy(source.normalScale);
        this.displacementMap = source.displacementMap;
        this.displacementScale = source.displacementScale;
        this.displacementBias = source.displacementBias;
        this.alphaMap = source.alphaMap;
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        this.wireframeLinecap = source.wireframeLinecap;
        this.wireframeLinejoin = source.wireframeLinejoin;
        this.fog = source.fog;
        return this;
    }
}
class $084574008ccedf86$export$bfe8c0a091f41ae7 extends $084574008ccedf86$export$a2d8b23205c25948 {
    constructor(parameters){
        super();
        this.isMeshNormalMaterial = true;
        this.type = "MeshNormalMaterial";
        this.bumpMap = null;
        this.bumpScale = 1;
        this.normalMap = null;
        this.normalMapType = $084574008ccedf86$export$2852a58ebdac27b8;
        this.normalScale = new $084574008ccedf86$export$c977b3e384af9ae1(1, 1);
        this.displacementMap = null;
        this.displacementScale = 1;
        this.displacementBias = 0;
        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.flatShading = false;
        this.setValues(parameters);
    }
    copy(source) {
        super.copy(source);
        this.bumpMap = source.bumpMap;
        this.bumpScale = source.bumpScale;
        this.normalMap = source.normalMap;
        this.normalMapType = source.normalMapType;
        this.normalScale.copy(source.normalScale);
        this.displacementMap = source.displacementMap;
        this.displacementScale = source.displacementScale;
        this.displacementBias = source.displacementBias;
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        this.flatShading = source.flatShading;
        return this;
    }
}
class $084574008ccedf86$export$5023a9a8114806b8 extends $084574008ccedf86$export$a2d8b23205c25948 {
    constructor(parameters){
        super();
        this.isMeshLambertMaterial = true;
        this.type = "MeshLambertMaterial";
        this.color = new $084574008ccedf86$export$892596cec99bc70e(0xffffff); // diffuse
        this.map = null;
        this.lightMap = null;
        this.lightMapIntensity = 1.0;
        this.aoMap = null;
        this.aoMapIntensity = 1.0;
        this.emissive = new $084574008ccedf86$export$892596cec99bc70e(0x000000);
        this.emissiveIntensity = 1.0;
        this.emissiveMap = null;
        this.specularMap = null;
        this.alphaMap = null;
        this.envMap = null;
        this.combine = $084574008ccedf86$export$e50ac29801f1774d;
        this.reflectivity = 1;
        this.refractionRatio = 0.98;
        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.wireframeLinecap = "round";
        this.wireframeLinejoin = "round";
        this.fog = true;
        this.setValues(parameters);
    }
    copy(source) {
        super.copy(source);
        this.color.copy(source.color);
        this.map = source.map;
        this.lightMap = source.lightMap;
        this.lightMapIntensity = source.lightMapIntensity;
        this.aoMap = source.aoMap;
        this.aoMapIntensity = source.aoMapIntensity;
        this.emissive.copy(source.emissive);
        this.emissiveMap = source.emissiveMap;
        this.emissiveIntensity = source.emissiveIntensity;
        this.specularMap = source.specularMap;
        this.alphaMap = source.alphaMap;
        this.envMap = source.envMap;
        this.combine = source.combine;
        this.reflectivity = source.reflectivity;
        this.refractionRatio = source.refractionRatio;
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        this.wireframeLinecap = source.wireframeLinecap;
        this.wireframeLinejoin = source.wireframeLinejoin;
        this.fog = source.fog;
        return this;
    }
}
class $084574008ccedf86$export$6f5fef6235ec12ee extends $084574008ccedf86$export$a2d8b23205c25948 {
    constructor(parameters){
        super();
        this.isMeshMatcapMaterial = true;
        this.defines = {
            "MATCAP": ""
        };
        this.type = "MeshMatcapMaterial";
        this.color = new $084574008ccedf86$export$892596cec99bc70e(0xffffff); // diffuse
        this.matcap = null;
        this.map = null;
        this.bumpMap = null;
        this.bumpScale = 1;
        this.normalMap = null;
        this.normalMapType = $084574008ccedf86$export$2852a58ebdac27b8;
        this.normalScale = new $084574008ccedf86$export$c977b3e384af9ae1(1, 1);
        this.displacementMap = null;
        this.displacementScale = 1;
        this.displacementBias = 0;
        this.alphaMap = null;
        this.flatShading = false;
        this.fog = true;
        this.setValues(parameters);
    }
    copy(source) {
        super.copy(source);
        this.defines = {
            "MATCAP": ""
        };
        this.color.copy(source.color);
        this.matcap = source.matcap;
        this.map = source.map;
        this.bumpMap = source.bumpMap;
        this.bumpScale = source.bumpScale;
        this.normalMap = source.normalMap;
        this.normalMapType = source.normalMapType;
        this.normalScale.copy(source.normalScale);
        this.displacementMap = source.displacementMap;
        this.displacementScale = source.displacementScale;
        this.displacementBias = source.displacementBias;
        this.alphaMap = source.alphaMap;
        this.flatShading = source.flatShading;
        this.fog = source.fog;
        return this;
    }
}
class $084574008ccedf86$export$327886a3efaeaebe extends $084574008ccedf86$export$fbaaa33907730a0c {
    constructor(parameters){
        super();
        this.isLineDashedMaterial = true;
        this.type = "LineDashedMaterial";
        this.scale = 1;
        this.dashSize = 3;
        this.gapSize = 1;
        this.setValues(parameters);
    }
    copy(source) {
        super.copy(source);
        this.scale = source.scale;
        this.dashSize = source.dashSize;
        this.gapSize = source.gapSize;
        return this;
    }
}
const $084574008ccedf86$var$materialLib = {
    ShadowMaterial: $084574008ccedf86$export$e8564da406055a3,
    SpriteMaterial: $084574008ccedf86$export$5ec7dd1c6994bf8e,
    RawShaderMaterial: $084574008ccedf86$export$21c421a2e1df9d22,
    ShaderMaterial: $084574008ccedf86$export$83c7d75d550a8b0d,
    PointsMaterial: $084574008ccedf86$export$a178c45366ce5d6b,
    MeshPhysicalMaterial: $084574008ccedf86$export$28d04986c4269c9f,
    MeshStandardMaterial: $084574008ccedf86$export$f2980790215acccd,
    MeshPhongMaterial: $084574008ccedf86$export$24c72f71cbaf0678,
    MeshToonMaterial: $084574008ccedf86$export$df893cf97e765622,
    MeshNormalMaterial: $084574008ccedf86$export$bfe8c0a091f41ae7,
    MeshLambertMaterial: $084574008ccedf86$export$5023a9a8114806b8,
    MeshDepthMaterial: $084574008ccedf86$export$2698c22ec13825db,
    MeshDistanceMaterial: $084574008ccedf86$export$33e187ed002f2a19,
    MeshBasicMaterial: $084574008ccedf86$export$55cbcc9b622fe1f5,
    MeshMatcapMaterial: $084574008ccedf86$export$6f5fef6235ec12ee,
    LineDashedMaterial: $084574008ccedf86$export$327886a3efaeaebe,
    LineBasicMaterial: $084574008ccedf86$export$fbaaa33907730a0c,
    Material: $084574008ccedf86$export$a2d8b23205c25948
};
$084574008ccedf86$export$a2d8b23205c25948.fromType = function(type) {
    return new $084574008ccedf86$var$materialLib[type]();
};
const $084574008ccedf86$export$7ee8caa573e71ad1 = {
    // same as Array.prototype.slice, but also works on typed arrays
    arraySlice: function(array, from, to) {
        if ($084574008ccedf86$export$7ee8caa573e71ad1.isTypedArray(array)) // in ios9 array.subarray(from, undefined) will return empty array
        // but array.subarray(from) or array.subarray(from, len) is correct
        return new array.constructor(array.subarray(from, to !== undefined ? to : array.length));
        return array.slice(from, to);
    },
    // converts an array to a specific type
    convertArray: function(array, type, forceClone) {
        if (!array || !forceClone && array.constructor === type) return array;
        if (typeof type.BYTES_PER_ELEMENT === "number") return new type(array); // create typed array
        return Array.prototype.slice.call(array); // create Array
    },
    isTypedArray: function(object) {
        return ArrayBuffer.isView(object) && !(object instanceof DataView);
    },
    // returns an array by which times and values can be sorted
    getKeyframeOrder: function(times) {
        function compareTime(i273, j) {
            return times[i273] - times[j];
        }
        const n = times.length;
        const result = new Array(n);
        for(let i272 = 0; i272 !== n; ++i272)result[i272] = i272;
        result.sort(compareTime);
        return result;
    },
    // uses the array previously returned by 'getKeyframeOrder' to sort data
    sortedArray: function(values, stride, order) {
        const nValues = values.length;
        const result = new values.constructor(nValues);
        for(let i274 = 0, dstOffset = 0; dstOffset !== nValues; ++i274){
            const srcOffset = order[i274] * stride;
            for(let j = 0; j !== stride; ++j)result[dstOffset++] = values[srcOffset + j];
        }
        return result;
    },
    // function for parsing AOS keyframe formats
    flattenJSON: function(jsonKeys, times, values, valuePropertyName) {
        let i275 = 1, key = jsonKeys[0];
        while(key !== undefined && key[valuePropertyName] === undefined)key = jsonKeys[i275++];
        if (key === undefined) return; // no data
        let value = key[valuePropertyName];
        if (value === undefined) return; // no data
        if (Array.isArray(value)) do {
            value = key[valuePropertyName];
            if (value !== undefined) {
                times.push(key.time);
                values.push.apply(values, value); // push all elements
            }
            key = jsonKeys[i275++];
        }while (key !== undefined);
        else if (value.toArray !== undefined) // ...assume THREE.Math-ish
        do {
            value = key[valuePropertyName];
            if (value !== undefined) {
                times.push(key.time);
                value.toArray(values, values.length);
            }
            key = jsonKeys[i275++];
        }while (key !== undefined);
        else // otherwise push as-is
        do {
            value = key[valuePropertyName];
            if (value !== undefined) {
                times.push(key.time);
                values.push(value);
            }
            key = jsonKeys[i275++];
        }while (key !== undefined);
    },
    subclip: function(sourceClip, name, startFrame, endFrame, fps = 30) {
        const clip = sourceClip.clone();
        clip.name = name;
        const tracks = [];
        for(let i278 = 0; i278 < clip.tracks.length; ++i278){
            const track = clip.tracks[i278];
            const valueSize = track.getValueSize();
            const times = [];
            const values = [];
            for(let j = 0; j < track.times.length; ++j){
                const frame = track.times[j] * fps;
                if (frame < startFrame || frame >= endFrame) continue;
                times.push(track.times[j]);
                for(let k = 0; k < valueSize; ++k)values.push(track.values[j * valueSize + k]);
            }
            if (times.length === 0) continue;
            track.times = $084574008ccedf86$export$7ee8caa573e71ad1.convertArray(times, track.times.constructor);
            track.values = $084574008ccedf86$export$7ee8caa573e71ad1.convertArray(values, track.values.constructor);
            tracks.push(track);
        }
        clip.tracks = tracks;
        // find minimum .times value across all tracks in the trimmed clip
        let minStartTime = Infinity;
        for(let i276 = 0; i276 < clip.tracks.length; ++i276)if (minStartTime > clip.tracks[i276].times[0]) minStartTime = clip.tracks[i276].times[0];
        // shift all tracks such that clip begins at t=0
        for(let i277 = 0; i277 < clip.tracks.length; ++i277)clip.tracks[i277].shift(-1 * minStartTime);
        clip.resetDuration();
        return clip;
    },
    makeClipAdditive: function(targetClip, referenceFrame = 0, referenceClip = targetClip, fps = 30) {
        if (fps <= 0) fps = 30;
        const numTracks = referenceClip.tracks.length;
        const referenceTime = referenceFrame / fps;
        // Make each track's values relative to the values at the reference frame
        for(let i279 = 0; i279 < numTracks; ++i279){
            const referenceTrack = referenceClip.tracks[i279];
            const referenceTrackType = referenceTrack.ValueTypeName;
            // Skip this track if it's non-numeric
            if (referenceTrackType === "bool" || referenceTrackType === "string") continue;
            // Find the track in the target clip whose name and type matches the reference track
            const targetTrack = targetClip.tracks.find(function(track) {
                return track.name === referenceTrack.name && track.ValueTypeName === referenceTrackType;
            });
            if (targetTrack === undefined) continue;
            let referenceOffset = 0;
            const referenceValueSize = referenceTrack.getValueSize();
            if (referenceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) referenceOffset = referenceValueSize / 3;
            let targetOffset = 0;
            const targetValueSize = targetTrack.getValueSize();
            if (targetTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) targetOffset = targetValueSize / 3;
            const lastIndex = referenceTrack.times.length - 1;
            let referenceValue;
            // Find the value to subtract out of the track
            if (referenceTime <= referenceTrack.times[0]) {
                // Reference frame is earlier than the first keyframe, so just use the first keyframe
                const startIndex = referenceOffset;
                const endIndex = referenceValueSize - referenceOffset;
                referenceValue = $084574008ccedf86$export$7ee8caa573e71ad1.arraySlice(referenceTrack.values, startIndex, endIndex);
            } else if (referenceTime >= referenceTrack.times[lastIndex]) {
                // Reference frame is after the last keyframe, so just use the last keyframe
                const startIndex = lastIndex * referenceValueSize + referenceOffset;
                const endIndex = startIndex + referenceValueSize - referenceOffset;
                referenceValue = $084574008ccedf86$export$7ee8caa573e71ad1.arraySlice(referenceTrack.values, startIndex, endIndex);
            } else {
                // Interpolate to the reference value
                const interpolant = referenceTrack.createInterpolant();
                const startIndex = referenceOffset;
                const endIndex = referenceValueSize - referenceOffset;
                interpolant.evaluate(referenceTime);
                referenceValue = $084574008ccedf86$export$7ee8caa573e71ad1.arraySlice(interpolant.resultBuffer, startIndex, endIndex);
            }
            // Conjugate the quaternion
            if (referenceTrackType === "quaternion") {
                const referenceQuat = new $084574008ccedf86$export$23d6a54f0bbc85a3().fromArray(referenceValue).normalize().conjugate();
                referenceQuat.toArray(referenceValue);
            }
            // Subtract the reference value from all of the track values
            const numTimes = targetTrack.times.length;
            for(let j = 0; j < numTimes; ++j){
                const valueStart = j * targetValueSize + targetOffset;
                if (referenceTrackType === "quaternion") // Multiply the conjugate for quaternion track types
                $084574008ccedf86$export$23d6a54f0bbc85a3.multiplyQuaternionsFlat(targetTrack.values, valueStart, referenceValue, 0, targetTrack.values, valueStart);
                else {
                    const valueEnd = targetValueSize - targetOffset * 2;
                    // Subtract each value for all other numeric track types
                    for(let k = 0; k < valueEnd; ++k)targetTrack.values[valueStart + k] -= referenceValue[k];
                }
            }
        }
        targetClip.blendMode = $084574008ccedf86$export$d875e029ef558d3;
        return targetClip;
    }
};
/**
 * Abstract base class of interpolants over parametric samples.
 *
 * The parameter domain is one dimensional, typically the time or a path
 * along a curve defined by the data.
 *
 * The sample values can have any dimensionality and derived classes may
 * apply special interpretations to the data.
 *
 * This class provides the interval seek in a Template Method, deferring
 * the actual interpolation to derived classes.
 *
 * Time complexity is O(1) for linear access crossing at most two points
 * and O(log N) for random access, where N is the number of positions.
 *
 * References:
 *
 * 		http://www.oodesign.com/template-method-pattern.html
 *
 */ class $084574008ccedf86$export$b558baee9c0f72d3 {
    constructor(parameterPositions, sampleValues, sampleSize, resultBuffer){
        this.parameterPositions = parameterPositions;
        this._cachedIndex = 0;
        this.resultBuffer = resultBuffer !== undefined ? resultBuffer : new sampleValues.constructor(sampleSize);
        this.sampleValues = sampleValues;
        this.valueSize = sampleSize;
        this.settings = null;
        this.DefaultSettings_ = {};
    }
    evaluate(t) {
        const pp = this.parameterPositions;
        let i1100 = this._cachedIndex, t1 = pp[i1100], t0 = pp[i1100 - 1];
        validate_interval: {
            seek: {
                let right;
                linear_scan: {
                    //- See http://jsperf.com/comparison-to-undefined/3
                    //- slower code:
                    //-
                    //- 				if ( t >= t1 || t1 === undefined ) {
                    forward_scan: if (!(t < t1)) {
                        for(let giveUpAt = i1100 + 2;;){
                            if (t1 === undefined) {
                                if (t < t0) break forward_scan;
                                // after end
                                i1100 = pp.length;
                                this._cachedIndex = i1100;
                                return this.copySampleValue_(i1100 - 1);
                            }
                            if (i1100 === giveUpAt) break; // this loop
                            t0 = t1;
                            t1 = pp[++i1100];
                            if (t < t1) break seek;
                        }
                        // prepare binary search on the right side of the index
                        right = pp.length;
                        break linear_scan;
                    }
                    //- slower code:
                    //-					if ( t < t0 || t0 === undefined ) {
                    if (!(t >= t0)) {
                        // looping?
                        const t1global = pp[1];
                        if (t < t1global) {
                            i1100 = 2; // + 1, using the scan for the details
                            t0 = t1global;
                        }
                        // linear reverse scan
                        for(let giveUpAt = i1100 - 2;;){
                            if (t0 === undefined) {
                                // before start
                                this._cachedIndex = 0;
                                return this.copySampleValue_(0);
                            }
                            if (i1100 === giveUpAt) break; // this loop
                            t1 = t0;
                            t0 = pp[--i1100 - 1];
                            if (t >= t0) break seek;
                        }
                        // prepare binary search on the left side of the index
                        right = i1100;
                        i1100 = 0;
                        break linear_scan;
                    }
                    break validate_interval;
                } // linear scan
                // binary search
                while(i1100 < right){
                    const mid = i1100 + right >>> 1;
                    if (t < pp[mid]) right = mid;
                    else i1100 = mid + 1;
                }
                t1 = pp[i1100];
                t0 = pp[i1100 - 1];
                // check boundary cases, again
                if (t0 === undefined) {
                    this._cachedIndex = 0;
                    return this.copySampleValue_(0);
                }
                if (t1 === undefined) {
                    i1100 = pp.length;
                    this._cachedIndex = i1100;
                    return this.copySampleValue_(i1100 - 1);
                }
            } // seek
            this._cachedIndex = i1100;
            this.intervalChanged_(i1100, t0, t1);
        } // validate_interval
        return this.interpolate_(i1100, t0, t, t1);
    }
    getSettings_() {
        return this.settings || this.DefaultSettings_;
    }
    copySampleValue_(index) {
        // copies a sample value to the result buffer
        const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset = index * stride;
        for(let i280 = 0; i280 !== stride; ++i280)result[i280] = values[offset + i280];
        return result;
    }
    // Template methods for derived classes:
    interpolate_() {
        throw new Error("call to abstract method");
    // implementations shall return this.resultBuffer
    }
    intervalChanged_() {
    // empty
    }
}
/**
 * Fast and simple cubic spline interpolant.
 *
 * It was derived from a Hermitian construction setting the first derivative
 * at each sample position to the linear slope between neighboring positions
 * over their parameter interval.
 */ class $084574008ccedf86$export$3646682e7a3959 extends $084574008ccedf86$export$b558baee9c0f72d3 {
    constructor(parameterPositions, sampleValues, sampleSize, resultBuffer){
        super(parameterPositions, sampleValues, sampleSize, resultBuffer);
        this._weightPrev = -0;
        this._offsetPrev = -0;
        this._weightNext = -0;
        this._offsetNext = -0;
        this.DefaultSettings_ = {
            endingStart: $084574008ccedf86$export$7f795934b84ab523,
            endingEnd: $084574008ccedf86$export$7f795934b84ab523
        };
    }
    intervalChanged_(i1101, t0, t1) {
        const pp = this.parameterPositions;
        let iPrev = i1101 - 2, iNext = i1101 + 1, tPrev = pp[iPrev], tNext = pp[iNext];
        if (tPrev === undefined) switch(this.getSettings_().endingStart){
            case $084574008ccedf86$export$24a4ccb5099273b5:
                // f'(t0) = 0
                iPrev = i1101;
                tPrev = 2 * t0 - t1;
                break;
            case $084574008ccedf86$export$8e8c3ecdcd8e1fee:
                // use the other end of the curve
                iPrev = pp.length - 2;
                tPrev = t0 + pp[iPrev] - pp[iPrev + 1];
                break;
            default:
                // f''(t0) = 0 a.k.a. Natural Spline
                iPrev = i1101;
                tPrev = t1;
        }
        if (tNext === undefined) switch(this.getSettings_().endingEnd){
            case $084574008ccedf86$export$24a4ccb5099273b5:
                // f'(tN) = 0
                iNext = i1101;
                tNext = 2 * t1 - t0;
                break;
            case $084574008ccedf86$export$8e8c3ecdcd8e1fee:
                // use the other end of the curve
                iNext = 1;
                tNext = t1 + pp[1] - pp[0];
                break;
            default:
                // f''(tN) = 0, a.k.a. Natural Spline
                iNext = i1101 - 1;
                tNext = t0;
        }
        const halfDt = (t1 - t0) * 0.5, stride = this.valueSize;
        this._weightPrev = halfDt / (t0 - tPrev);
        this._weightNext = halfDt / (tNext - t1);
        this._offsetPrev = iPrev * stride;
        this._offsetNext = iNext * stride;
    }
    interpolate_(i1102, t0, t, t1) {
        const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, o1 = i1102 * stride, o0 = o1 - stride, oP = this._offsetPrev, oN = this._offsetNext, wP = this._weightPrev, wN = this._weightNext, p = (t - t0) / (t1 - t0), pp = p * p, ppp = pp * p;
        // evaluate polynomials
        const sP = -wP * ppp + 2 * wP * pp - wP * p;
        const s0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-0.5 + wP) * p + 1;
        const s1 = (-1 - wN) * ppp + (1.5 + wN) * pp + 0.5 * p;
        const sN = wN * ppp - wN * pp;
        // combine data linearly
        for(let i281 = 0; i281 !== stride; ++i281)result[i281] = sP * values[oP + i281] + s0 * values[o0 + i281] + s1 * values[o1 + i281] + sN * values[oN + i281];
        return result;
    }
}
class $084574008ccedf86$export$a8e6009059f51e1a extends $084574008ccedf86$export$b558baee9c0f72d3 {
    constructor(parameterPositions, sampleValues, sampleSize, resultBuffer){
        super(parameterPositions, sampleValues, sampleSize, resultBuffer);
    }
    interpolate_(i1103, t0, t, t1) {
        const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset1 = i1103 * stride, offset0 = offset1 - stride, weight1 = (t - t0) / (t1 - t0), weight0 = 1 - weight1;
        for(let i282 = 0; i282 !== stride; ++i282)result[i282] = values[offset0 + i282] * weight0 + values[offset1 + i282] * weight1;
        return result;
    }
}
/**
 *
 * Interpolant that evaluates to the sample value at the position preceding
 * the parameter.
 */ class $084574008ccedf86$export$fb9758ef7ef8d5cc extends $084574008ccedf86$export$b558baee9c0f72d3 {
    constructor(parameterPositions, sampleValues, sampleSize, resultBuffer){
        super(parameterPositions, sampleValues, sampleSize, resultBuffer);
    }
    interpolate_(i1104 /*, t0, t, t1 */ ) {
        return this.copySampleValue_(i1104 - 1);
    }
}
class $084574008ccedf86$export$b0e479f45b7006d6 {
    constructor(name, times, values, interpolation){
        if (name === undefined) throw new Error("THREE.KeyframeTrack: track name is undefined");
        if (times === undefined || times.length === 0) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + name);
        this.name = name;
        this.times = $084574008ccedf86$export$7ee8caa573e71ad1.convertArray(times, this.TimeBufferType);
        this.values = $084574008ccedf86$export$7ee8caa573e71ad1.convertArray(values, this.ValueBufferType);
        this.setInterpolation(interpolation || this.DefaultInterpolation);
    }
    // Serialization (in static context, because of constructor invocation
    // and automatic invocation of .toJSON):
    static toJSON(track) {
        const trackType = track.constructor;
        let json;
        // derived classes can define a static toJSON method
        if (trackType.toJSON !== this.toJSON) json = trackType.toJSON(track);
        else {
            // by default, we assume the data can be serialized as-is
            json = {
                "name": track.name,
                "times": $084574008ccedf86$export$7ee8caa573e71ad1.convertArray(track.times, Array),
                "values": $084574008ccedf86$export$7ee8caa573e71ad1.convertArray(track.values, Array)
            };
            const interpolation = track.getInterpolation();
            if (interpolation !== track.DefaultInterpolation) json.interpolation = interpolation;
        }
        json.type = track.ValueTypeName; // mandatory
        return json;
    }
    InterpolantFactoryMethodDiscrete(result) {
        return new $084574008ccedf86$export$fb9758ef7ef8d5cc(this.times, this.values, this.getValueSize(), result);
    }
    InterpolantFactoryMethodLinear(result) {
        return new $084574008ccedf86$export$a8e6009059f51e1a(this.times, this.values, this.getValueSize(), result);
    }
    InterpolantFactoryMethodSmooth(result) {
        return new $084574008ccedf86$export$3646682e7a3959(this.times, this.values, this.getValueSize(), result);
    }
    setInterpolation(interpolation) {
        let factoryMethod;
        switch(interpolation){
            case $084574008ccedf86$export$995b32462a65e855:
                factoryMethod = this.InterpolantFactoryMethodDiscrete;
                break;
            case $084574008ccedf86$export$30fac1aace31cf4d:
                factoryMethod = this.InterpolantFactoryMethodLinear;
                break;
            case $084574008ccedf86$export$198b11ff4c72bb30:
                factoryMethod = this.InterpolantFactoryMethodSmooth;
                break;
        }
        if (factoryMethod === undefined) {
            const message = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
            if (this.createInterpolant === undefined) {
                // fall back to default, unless the default itself is messed up
                if (interpolation !== this.DefaultInterpolation) this.setInterpolation(this.DefaultInterpolation);
                else throw new Error(message); // fatal, in this case
            }
            console.warn("THREE.KeyframeTrack:", message);
            return this;
        }
        this.createInterpolant = factoryMethod;
        return this;
    }
    getInterpolation() {
        switch(this.createInterpolant){
            case this.InterpolantFactoryMethodDiscrete:
                return $084574008ccedf86$export$995b32462a65e855;
            case this.InterpolantFactoryMethodLinear:
                return $084574008ccedf86$export$30fac1aace31cf4d;
            case this.InterpolantFactoryMethodSmooth:
                return $084574008ccedf86$export$198b11ff4c72bb30;
        }
    }
    getValueSize() {
        return this.values.length / this.times.length;
    }
    // move all keyframes either forwards or backwards in time
    shift(timeOffset) {
        if (timeOffset !== 0.0) {
            const times = this.times;
            for(let i283 = 0, n = times.length; i283 !== n; ++i283)times[i283] += timeOffset;
        }
        return this;
    }
    // scale all keyframe times by a factor (useful for frame <-> seconds conversions)
    scale(timeScale) {
        if (timeScale !== 1.0) {
            const times = this.times;
            for(let i284 = 0, n = times.length; i284 !== n; ++i284)times[i284] *= timeScale;
        }
        return this;
    }
    // removes keyframes before and after animation without changing any values within the range [startTime, endTime].
    // IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
    trim(startTime, endTime) {
        const times = this.times, nKeys = times.length;
        let from = 0, to = nKeys - 1;
        while(from !== nKeys && times[from] < startTime)++from;
        while(to !== -1 && times[to] > endTime)--to;
        ++to; // inclusive -> exclusive bound
        if (from !== 0 || to !== nKeys) {
            // empty tracks are forbidden, so keep at least one keyframe
            if (from >= to) {
                to = Math.max(to, 1);
                from = to - 1;
            }
            const stride = this.getValueSize();
            this.times = $084574008ccedf86$export$7ee8caa573e71ad1.arraySlice(times, from, to);
            this.values = $084574008ccedf86$export$7ee8caa573e71ad1.arraySlice(this.values, from * stride, to * stride);
        }
        return this;
    }
    // ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
    validate() {
        let valid = true;
        const valueSize = this.getValueSize();
        if (valueSize - Math.floor(valueSize) !== 0) {
            console.error("THREE.KeyframeTrack: Invalid value size in track.", this);
            valid = false;
        }
        const times = this.times, values = this.values, nKeys = times.length;
        if (nKeys === 0) {
            console.error("THREE.KeyframeTrack: Track is empty.", this);
            valid = false;
        }
        let prevTime = null;
        for(let i285 = 0; i285 !== nKeys; i285++){
            const currTime = times[i285];
            if (typeof currTime === "number" && isNaN(currTime)) {
                console.error("THREE.KeyframeTrack: Time is not a valid number.", this, i285, currTime);
                valid = false;
                break;
            }
            if (prevTime !== null && prevTime > currTime) {
                console.error("THREE.KeyframeTrack: Out of order keys.", this, i285, currTime, prevTime);
                valid = false;
                break;
            }
            prevTime = currTime;
        }
        if (values !== undefined) {
            if ($084574008ccedf86$export$7ee8caa573e71ad1.isTypedArray(values)) for(let i286 = 0, n = values.length; i286 !== n; ++i286){
                const value = values[i286];
                if (isNaN(value)) {
                    console.error("THREE.KeyframeTrack: Value is not a valid number.", this, i286, value);
                    valid = false;
                    break;
                }
            }
        }
        return valid;
    }
    // removes equivalent sequential keys as common in morph target sequences
    // (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
    optimize() {
        // times or values may be shared with other tracks, so overwriting is unsafe
        const times = $084574008ccedf86$export$7ee8caa573e71ad1.arraySlice(this.times), values = $084574008ccedf86$export$7ee8caa573e71ad1.arraySlice(this.values), stride = this.getValueSize(), smoothInterpolation = this.getInterpolation() === $084574008ccedf86$export$198b11ff4c72bb30, lastIndex = times.length - 1;
        let writeIndex = 1;
        for(let i287 = 1; i287 < lastIndex; ++i287){
            let keep = false;
            const time = times[i287];
            const timeNext = times[i287 + 1];
            // remove adjacent keyframes scheduled at the same time
            if (time !== timeNext && (i287 !== 1 || time !== times[0])) {
                if (!smoothInterpolation) {
                    // remove unnecessary keyframes same as their neighbors
                    const offset = i287 * stride, offsetP = offset - stride, offsetN = offset + stride;
                    for(let j = 0; j !== stride; ++j){
                        const value = values[offset + j];
                        if (value !== values[offsetP + j] || value !== values[offsetN + j]) {
                            keep = true;
                            break;
                        }
                    }
                } else keep = true;
            }
            // in-place compaction
            if (keep) {
                if (i287 !== writeIndex) {
                    times[writeIndex] = times[i287];
                    const readOffset = i287 * stride, writeOffset = writeIndex * stride;
                    for(let j = 0; j !== stride; ++j)values[writeOffset + j] = values[readOffset + j];
                }
                ++writeIndex;
            }
        }
        // flush last keyframe (compaction looks ahead)
        if (lastIndex > 0) {
            times[writeIndex] = times[lastIndex];
            for(let readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++j)values[writeOffset + j] = values[readOffset + j];
            ++writeIndex;
        }
        if (writeIndex !== times.length) {
            this.times = $084574008ccedf86$export$7ee8caa573e71ad1.arraySlice(times, 0, writeIndex);
            this.values = $084574008ccedf86$export$7ee8caa573e71ad1.arraySlice(values, 0, writeIndex * stride);
        } else {
            this.times = times;
            this.values = values;
        }
        return this;
    }
    clone() {
        const times = $084574008ccedf86$export$7ee8caa573e71ad1.arraySlice(this.times, 0);
        const values = $084574008ccedf86$export$7ee8caa573e71ad1.arraySlice(this.values, 0);
        const TypedKeyframeTrack = this.constructor;
        const track = new TypedKeyframeTrack(this.name, times, values);
        // Interpolant argument to constructor is not saved, so copy the factory method directly.
        track.createInterpolant = this.createInterpolant;
        return track;
    }
}
$084574008ccedf86$export$b0e479f45b7006d6.prototype.TimeBufferType = Float32Array;
$084574008ccedf86$export$b0e479f45b7006d6.prototype.ValueBufferType = Float32Array;
$084574008ccedf86$export$b0e479f45b7006d6.prototype.DefaultInterpolation = $084574008ccedf86$export$30fac1aace31cf4d;
/**
 * A Track of Boolean keyframe values.
 */ class $084574008ccedf86$export$d3a344b98cf0b775 extends $084574008ccedf86$export$b0e479f45b7006d6 {
}
$084574008ccedf86$export$d3a344b98cf0b775.prototype.ValueTypeName = "bool";
$084574008ccedf86$export$d3a344b98cf0b775.prototype.ValueBufferType = Array;
$084574008ccedf86$export$d3a344b98cf0b775.prototype.DefaultInterpolation = $084574008ccedf86$export$995b32462a65e855;
$084574008ccedf86$export$d3a344b98cf0b775.prototype.InterpolantFactoryMethodLinear = undefined;
$084574008ccedf86$export$d3a344b98cf0b775.prototype.InterpolantFactoryMethodSmooth = undefined;
/**
 * A Track of keyframe values that represent color.
 */ class $084574008ccedf86$export$83444c5d885347d8 extends $084574008ccedf86$export$b0e479f45b7006d6 {
}
$084574008ccedf86$export$83444c5d885347d8.prototype.ValueTypeName = "color";
/**
 * A Track of numeric keyframe values.
 */ class $084574008ccedf86$export$d45f0d1a4d9a9314 extends $084574008ccedf86$export$b0e479f45b7006d6 {
}
$084574008ccedf86$export$d45f0d1a4d9a9314.prototype.ValueTypeName = "number";
/**
 * Spherical linear unit quaternion interpolant.
 */ class $084574008ccedf86$export$2db1cfb7923d931e extends $084574008ccedf86$export$b558baee9c0f72d3 {
    constructor(parameterPositions, sampleValues, sampleSize, resultBuffer){
        super(parameterPositions, sampleValues, sampleSize, resultBuffer);
    }
    interpolate_(i1105, t0, t, t1) {
        const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, alpha = (t - t0) / (t1 - t0);
        let offset = i1105 * stride;
        for(let end = offset + stride; offset !== end; offset += 4)$084574008ccedf86$export$23d6a54f0bbc85a3.slerpFlat(result, 0, values, offset - stride, values, offset, alpha);
        return result;
    }
}
/**
 * A Track of quaternion keyframe values.
 */ class $084574008ccedf86$export$b8043f12b5aafbd7 extends $084574008ccedf86$export$b0e479f45b7006d6 {
    InterpolantFactoryMethodLinear(result) {
        return new $084574008ccedf86$export$2db1cfb7923d931e(this.times, this.values, this.getValueSize(), result);
    }
}
$084574008ccedf86$export$b8043f12b5aafbd7.prototype.ValueTypeName = "quaternion";
// ValueBufferType is inherited
$084574008ccedf86$export$b8043f12b5aafbd7.prototype.DefaultInterpolation = $084574008ccedf86$export$30fac1aace31cf4d;
$084574008ccedf86$export$b8043f12b5aafbd7.prototype.InterpolantFactoryMethodSmooth = undefined;
/**
 * A Track that interpolates Strings
 */ class $084574008ccedf86$export$6ce41d4f3a8df9cd extends $084574008ccedf86$export$b0e479f45b7006d6 {
}
$084574008ccedf86$export$6ce41d4f3a8df9cd.prototype.ValueTypeName = "string";
$084574008ccedf86$export$6ce41d4f3a8df9cd.prototype.ValueBufferType = Array;
$084574008ccedf86$export$6ce41d4f3a8df9cd.prototype.DefaultInterpolation = $084574008ccedf86$export$995b32462a65e855;
$084574008ccedf86$export$6ce41d4f3a8df9cd.prototype.InterpolantFactoryMethodLinear = undefined;
$084574008ccedf86$export$6ce41d4f3a8df9cd.prototype.InterpolantFactoryMethodSmooth = undefined;
/**
 * A Track of vectored keyframe values.
 */ class $084574008ccedf86$export$5ce2dcb4cc9f2bff extends $084574008ccedf86$export$b0e479f45b7006d6 {
}
$084574008ccedf86$export$5ce2dcb4cc9f2bff.prototype.ValueTypeName = "vector";
class $084574008ccedf86$export$d942c706bf23829c {
    constructor(name, duration = -1, tracks, blendMode = $084574008ccedf86$export$bcfbbdcf8de7f8cd){
        this.name = name;
        this.tracks = tracks;
        this.duration = duration;
        this.blendMode = blendMode;
        this.uuid = $084574008ccedf86$var$generateUUID();
        // this means it should figure out its duration by scanning the tracks
        if (this.duration < 0) this.resetDuration();
    }
    static parse(json) {
        const tracks = [], jsonTracks = json.tracks, frameTime = 1.0 / (json.fps || 1.0);
        for(let i288 = 0, n = jsonTracks.length; i288 !== n; ++i288)tracks.push($084574008ccedf86$var$parseKeyframeTrack(jsonTracks[i288]).scale(frameTime));
        const clip = new this(json.name, json.duration, tracks, json.blendMode);
        clip.uuid = json.uuid;
        return clip;
    }
    static toJSON(clip) {
        const tracks = [], clipTracks = clip.tracks;
        const json = {
            "name": clip.name,
            "duration": clip.duration,
            "tracks": tracks,
            "uuid": clip.uuid,
            "blendMode": clip.blendMode
        };
        for(let i289 = 0, n = clipTracks.length; i289 !== n; ++i289)tracks.push($084574008ccedf86$export$b0e479f45b7006d6.toJSON(clipTracks[i289]));
        return json;
    }
    static CreateFromMorphTargetSequence(name, morphTargetSequence, fps, noLoop) {
        const numMorphTargets = morphTargetSequence.length;
        const tracks = [];
        for(let i290 = 0; i290 < numMorphTargets; i290++){
            let times = [];
            let values = [];
            times.push((i290 + numMorphTargets - 1) % numMorphTargets, i290, (i290 + 1) % numMorphTargets);
            values.push(0, 1, 0);
            const order = $084574008ccedf86$export$7ee8caa573e71ad1.getKeyframeOrder(times);
            times = $084574008ccedf86$export$7ee8caa573e71ad1.sortedArray(times, 1, order);
            values = $084574008ccedf86$export$7ee8caa573e71ad1.sortedArray(values, 1, order);
            // if there is a key at the first frame, duplicate it as the
            // last frame as well for perfect loop.
            if (!noLoop && times[0] === 0) {
                times.push(numMorphTargets);
                values.push(values[0]);
            }
            tracks.push(new $084574008ccedf86$export$d45f0d1a4d9a9314(".morphTargetInfluences[" + morphTargetSequence[i290].name + "]", times, values).scale(1.0 / fps));
        }
        return new this(name, -1, tracks);
    }
    static findByName(objectOrClipArray, name) {
        let clipArray = objectOrClipArray;
        if (!Array.isArray(objectOrClipArray)) {
            const o = objectOrClipArray;
            clipArray = o.geometry && o.geometry.animations || o.animations;
        }
        for(let i291 = 0; i291 < clipArray.length; i291++){
            if (clipArray[i291].name === name) return clipArray[i291];
        }
        return null;
    }
    static CreateClipsFromMorphTargetSequences(morphTargets, fps, noLoop) {
        const animationToMorphTargets = {};
        // tested with https://regex101.com/ on trick sequences
        // such flamingo_flyA_003, flamingo_run1_003, crdeath0059
        const pattern = /^([\w-]*?)([\d]+)$/;
        // sort morph target names into animation groups based
        // patterns like Walk_001, Walk_002, Run_001, Run_002
        for(let i292 = 0, il = morphTargets.length; i292 < il; i292++){
            const morphTarget = morphTargets[i292];
            const parts = morphTarget.name.match(pattern);
            if (parts && parts.length > 1) {
                const name = parts[1];
                let animationMorphTargets = animationToMorphTargets[name];
                if (!animationMorphTargets) animationToMorphTargets[name] = animationMorphTargets = [];
                animationMorphTargets.push(morphTarget);
            }
        }
        const clips = [];
        for(const name in animationToMorphTargets)clips.push(this.CreateFromMorphTargetSequence(name, animationToMorphTargets[name], fps, noLoop));
        return clips;
    }
    // parse the animation.hierarchy format
    static parseAnimation(animation, bones) {
        if (!animation) {
            console.error("THREE.AnimationClip: No animation in JSONLoader data.");
            return null;
        }
        const addNonemptyTrack = function(trackType, trackName, animationKeys, propertyName, destTracks) {
            // only return track if there are actually keys.
            if (animationKeys.length !== 0) {
                const times = [];
                const values = [];
                $084574008ccedf86$export$7ee8caa573e71ad1.flattenJSON(animationKeys, times, values, propertyName);
                // empty keys are filtered out, so check again
                if (times.length !== 0) destTracks.push(new trackType(trackName, times, values));
            }
        };
        const tracks = [];
        const clipName = animation.name || "default";
        const fps = animation.fps || 30;
        const blendMode = animation.blendMode;
        // automatic length determination in AnimationClip.
        let duration = animation.length || -1;
        const hierarchyTracks = animation.hierarchy || [];
        for(let h = 0; h < hierarchyTracks.length; h++){
            const animationKeys = hierarchyTracks[h].keys;
            // skip empty tracks
            if (!animationKeys || animationKeys.length === 0) continue;
            // process morph targets
            if (animationKeys[0].morphTargets) {
                // figure out all morph targets used in this track
                const morphTargetNames = {};
                let k;
                for(k = 0; k < animationKeys.length; k++){
                    if (animationKeys[k].morphTargets) for(let m = 0; m < animationKeys[k].morphTargets.length; m++)morphTargetNames[animationKeys[k].morphTargets[m]] = -1;
                }
                // create a track for each morph target with all zero
                // morphTargetInfluences except for the keys in which
                // the morphTarget is named.
                for(const morphTargetName in morphTargetNames){
                    const times = [];
                    const values = [];
                    for(let m = 0; m !== animationKeys[k].morphTargets.length; ++m){
                        const animationKey = animationKeys[k];
                        times.push(animationKey.time);
                        values.push(animationKey.morphTarget === morphTargetName ? 1 : 0);
                    }
                    tracks.push(new $084574008ccedf86$export$d45f0d1a4d9a9314(".morphTargetInfluence[" + morphTargetName + "]", times, values));
                }
                duration = morphTargetNames.length * fps;
            } else {
                // ...assume skeletal animation
                const boneName = ".bones[" + bones[h].name + "]";
                addNonemptyTrack($084574008ccedf86$export$5ce2dcb4cc9f2bff, boneName + ".position", animationKeys, "pos", tracks);
                addNonemptyTrack($084574008ccedf86$export$b8043f12b5aafbd7, boneName + ".quaternion", animationKeys, "rot", tracks);
                addNonemptyTrack($084574008ccedf86$export$5ce2dcb4cc9f2bff, boneName + ".scale", animationKeys, "scl", tracks);
            }
        }
        if (tracks.length === 0) return null;
        const clip = new this(clipName, duration, tracks, blendMode);
        return clip;
    }
    resetDuration() {
        const tracks = this.tracks;
        let duration = 0;
        for(let i293 = 0, n = tracks.length; i293 !== n; ++i293){
            const track = this.tracks[i293];
            duration = Math.max(duration, track.times[track.times.length - 1]);
        }
        this.duration = duration;
        return this;
    }
    trim() {
        for(let i294 = 0; i294 < this.tracks.length; i294++)this.tracks[i294].trim(0, this.duration);
        return this;
    }
    validate() {
        let valid = true;
        for(let i295 = 0; i295 < this.tracks.length; i295++)valid = valid && this.tracks[i295].validate();
        return valid;
    }
    optimize() {
        for(let i296 = 0; i296 < this.tracks.length; i296++)this.tracks[i296].optimize();
        return this;
    }
    clone() {
        const tracks = [];
        for(let i297 = 0; i297 < this.tracks.length; i297++)tracks.push(this.tracks[i297].clone());
        return new this.constructor(this.name, this.duration, tracks, this.blendMode);
    }
    toJSON() {
        return this.constructor.toJSON(this);
    }
}
function $084574008ccedf86$var$getTrackTypeForValueTypeName(typeName) {
    switch(typeName.toLowerCase()){
        case "scalar":
        case "double":
        case "float":
        case "number":
        case "integer":
            return $084574008ccedf86$export$d45f0d1a4d9a9314;
        case "vector":
        case "vector2":
        case "vector3":
        case "vector4":
            return $084574008ccedf86$export$5ce2dcb4cc9f2bff;
        case "color":
            return $084574008ccedf86$export$83444c5d885347d8;
        case "quaternion":
            return $084574008ccedf86$export$b8043f12b5aafbd7;
        case "bool":
        case "boolean":
            return $084574008ccedf86$export$d3a344b98cf0b775;
        case "string":
            return $084574008ccedf86$export$6ce41d4f3a8df9cd;
    }
    throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + typeName);
}
function $084574008ccedf86$var$parseKeyframeTrack(json) {
    if (json.type === undefined) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
    const trackType = $084574008ccedf86$var$getTrackTypeForValueTypeName(json.type);
    if (json.times === undefined) {
        const times = [], values = [];
        $084574008ccedf86$export$7ee8caa573e71ad1.flattenJSON(json.keys, times, values, "value");
        json.times = times;
        json.values = values;
    }
    // derived classes can define a static parse method
    if (trackType.parse !== undefined) return trackType.parse(json);
    else // by default, we assume a constructor compatible with the base
    return new trackType(json.name, json.times, json.values, json.interpolation);
}
const $084574008ccedf86$export$94affb487e701bf2 = {
    enabled: false,
    files: {},
    add: function(key, file) {
        if (this.enabled === false) return;
        // console.log( 'THREE.Cache', 'Adding key:', key );
        this.files[key] = file;
    },
    get: function(key) {
        if (this.enabled === false) return;
        // console.log( 'THREE.Cache', 'Checking key:', key );
        return this.files[key];
    },
    remove: function(key) {
        delete this.files[key];
    },
    clear: function() {
        this.files = {};
    }
};
class $084574008ccedf86$export$99cc795e99919eed {
    constructor(onLoad, onProgress, onError){
        const scope = this;
        let isLoading = false;
        let itemsLoaded = 0;
        let itemsTotal = 0;
        let urlModifier = undefined;
        const handlers = [];
        // Refer to #5689 for the reason why we don't set .onStart
        // in the constructor
        this.onStart = undefined;
        this.onLoad = onLoad;
        this.onProgress = onProgress;
        this.onError = onError;
        this.itemStart = function(url) {
            itemsTotal++;
            if (isLoading === false) {
                if (scope.onStart !== undefined) scope.onStart(url, itemsLoaded, itemsTotal);
            }
            isLoading = true;
        };
        this.itemEnd = function(url) {
            itemsLoaded++;
            if (scope.onProgress !== undefined) scope.onProgress(url, itemsLoaded, itemsTotal);
            if (itemsLoaded === itemsTotal) {
                isLoading = false;
                if (scope.onLoad !== undefined) scope.onLoad();
            }
        };
        this.itemError = function(url) {
            if (scope.onError !== undefined) scope.onError(url);
        };
        this.resolveURL = function(url) {
            if (urlModifier) return urlModifier(url);
            return url;
        };
        this.setURLModifier = function(transform) {
            urlModifier = transform;
            return this;
        };
        this.addHandler = function(regex, loader) {
            handlers.push(regex, loader);
            return this;
        };
        this.removeHandler = function(regex) {
            const index = handlers.indexOf(regex);
            if (index !== -1) handlers.splice(index, 2);
            return this;
        };
        this.getHandler = function(file) {
            for(let i298 = 0, l = handlers.length; i298 < l; i298 += 2){
                const regex = handlers[i298];
                const loader = handlers[i298 + 1];
                if (regex.global) regex.lastIndex = 0; // see #17920
                if (regex.test(file)) return loader;
            }
            return null;
        };
    }
}
const $084574008ccedf86$export$b033c3f9a95c6a16 = new $084574008ccedf86$export$99cc795e99919eed();
class $084574008ccedf86$export$3b0d6d7590275603 {
    constructor(manager){
        this.manager = manager !== undefined ? manager : $084574008ccedf86$export$b033c3f9a95c6a16;
        this.crossOrigin = "anonymous";
        this.withCredentials = false;
        this.path = "";
        this.resourcePath = "";
        this.requestHeader = {};
    }
    load() {}
    loadAsync(url, onProgress) {
        const scope = this;
        return new Promise(function(resolve, reject) {
            scope.load(url, resolve, onProgress, reject);
        });
    }
    parse() {}
    setCrossOrigin(crossOrigin) {
        this.crossOrigin = crossOrigin;
        return this;
    }
    setWithCredentials(value) {
        this.withCredentials = value;
        return this;
    }
    setPath(path) {
        this.path = path;
        return this;
    }
    setResourcePath(resourcePath) {
        this.resourcePath = resourcePath;
        return this;
    }
    setRequestHeader(requestHeader) {
        this.requestHeader = requestHeader;
        return this;
    }
}
const $084574008ccedf86$var$loading = {};
class $084574008ccedf86$export$98435a25b5cf7b2b extends $084574008ccedf86$export$3b0d6d7590275603 {
    constructor(manager){
        super(manager);
    }
    load(url, onLoad, onProgress, onError) {
        if (url === undefined) url = "";
        if (this.path !== undefined) url = this.path + url;
        url = this.manager.resolveURL(url);
        const cached = $084574008ccedf86$export$94affb487e701bf2.get(url);
        if (cached !== undefined) {
            this.manager.itemStart(url);
            setTimeout(()=>{
                if (onLoad) onLoad(cached);
                this.manager.itemEnd(url);
            }, 0);
            return cached;
        }
        // Check if request is duplicate
        if ($084574008ccedf86$var$loading[url] !== undefined) {
            $084574008ccedf86$var$loading[url].push({
                onLoad: onLoad,
                onProgress: onProgress,
                onError: onError
            });
            return;
        }
        // Initialise array for duplicate requests
        $084574008ccedf86$var$loading[url] = [];
        $084574008ccedf86$var$loading[url].push({
            onLoad: onLoad,
            onProgress: onProgress,
            onError: onError
        });
        // create request
        const req = new Request(url, {
            headers: new Headers(this.requestHeader),
            credentials: this.withCredentials ? "include" : "same-origin"
        });
        // record states ( avoid data race )
        const mimeType = this.mimeType;
        const responseType = this.responseType;
        // start the fetch
        fetch(req).then((response)=>{
            if (response.status === 200 || response.status === 0) {
                // Some browsers return HTTP Status 0 when using non-http protocol
                // e.g. 'file://' or 'data://'. Handle as success.
                if (response.status === 0) console.warn("THREE.FileLoader: HTTP Status 0 received.");
                // Workaround: Checking if response.body === undefined for Alipay browser #23548
                if (typeof ReadableStream === "undefined" || response.body === undefined || response.body.getReader === undefined) return response;
                const callbacks = $084574008ccedf86$var$loading[url];
                const reader = response.body.getReader();
                const contentLength = response.headers.get("Content-Length");
                const total = contentLength ? parseInt(contentLength) : 0;
                const lengthComputable = total !== 0;
                let loaded = 0;
                // periodically read data into the new stream tracking while download progress
                const stream = new ReadableStream({
                    start (controller) {
                        readData();
                        function readData() {
                            reader.read().then(({ done: done , value: value  })=>{
                                if (done) controller.close();
                                else {
                                    loaded += value.byteLength;
                                    const event = new ProgressEvent("progress", {
                                        lengthComputable: lengthComputable,
                                        loaded: loaded,
                                        total: total
                                    });
                                    for(let i299 = 0, il = callbacks.length; i299 < il; i299++){
                                        const callback = callbacks[i299];
                                        if (callback.onProgress) callback.onProgress(event);
                                    }
                                    controller.enqueue(value);
                                    readData();
                                }
                            });
                        }
                    }
                });
                return new Response(stream);
            } else throw Error(`fetch for "${response.url}" responded with ${response.status}: ${response.statusText}`);
        }).then((response)=>{
            switch(responseType){
                case "arraybuffer":
                    return response.arrayBuffer();
                case "blob":
                    return response.blob();
                case "document":
                    return response.text().then((text)=>{
                        const parser = new DOMParser();
                        return parser.parseFromString(text, mimeType);
                    });
                case "json":
                    return response.json();
                default:
                    if (mimeType === undefined) return response.text();
                    else {
                        // sniff encoding
                        const re = /charset="?([^;"\s]*)"?/i;
                        const exec = re.exec(mimeType);
                        const label = exec && exec[1] ? exec[1].toLowerCase() : undefined;
                        const decoder = new TextDecoder(label);
                        return response.arrayBuffer().then((ab)=>decoder.decode(ab));
                    }
            }
        }).then((data)=>{
            // Add to cache only on HTTP success, so that we do not cache
            // error response bodies as proper responses to requests.
            $084574008ccedf86$export$94affb487e701bf2.add(url, data);
            const callbacks = $084574008ccedf86$var$loading[url];
            delete $084574008ccedf86$var$loading[url];
            for(let i300 = 0, il = callbacks.length; i300 < il; i300++){
                const callback = callbacks[i300];
                if (callback.onLoad) callback.onLoad(data);
            }
        }).catch((err)=>{
            // Abort errors and other errors are handled the same
            const callbacks = $084574008ccedf86$var$loading[url];
            if (callbacks === undefined) {
                // When onLoad was called and url was deleted in `loading`
                this.manager.itemError(url);
                throw err;
            }
            delete $084574008ccedf86$var$loading[url];
            for(let i301 = 0, il = callbacks.length; i301 < il; i301++){
                const callback = callbacks[i301];
                if (callback.onError) callback.onError(err);
            }
            this.manager.itemError(url);
        }).finally(()=>{
            this.manager.itemEnd(url);
        });
        this.manager.itemStart(url);
    }
    setResponseType(value) {
        this.responseType = value;
        return this;
    }
    setMimeType(value) {
        this.mimeType = value;
        return this;
    }
}
class $084574008ccedf86$export$29711c7e14f61db extends $084574008ccedf86$export$3b0d6d7590275603 {
    constructor(manager){
        super(manager);
    }
    load(url, onLoad, onProgress, onError) {
        const scope = this;
        const loader = new $084574008ccedf86$export$98435a25b5cf7b2b(this.manager);
        loader.setPath(this.path);
        loader.setRequestHeader(this.requestHeader);
        loader.setWithCredentials(this.withCredentials);
        loader.load(url, function(text) {
            try {
                onLoad(scope.parse(JSON.parse(text)));
            } catch (e) {
                if (onError) onError(e);
                else console.error(e);
                scope.manager.itemError(url);
            }
        }, onProgress, onError);
    }
    parse(json) {
        const animations = [];
        for(let i302 = 0; i302 < json.length; i302++){
            const clip = $084574008ccedf86$export$d942c706bf23829c.parse(json[i302]);
            animations.push(clip);
        }
        return animations;
    }
}
/**
 * Abstract Base class to block based textures loader (dds, pvr, ...)
 *
 * Sub classes have to implement the parse() method which will be used in load().
 */ class $084574008ccedf86$export$bd73ce947a280350 extends $084574008ccedf86$export$3b0d6d7590275603 {
    constructor(manager){
        super(manager);
    }
    load(url, onLoad, onProgress, onError) {
        const scope = this;
        const images = [];
        const texture = new $084574008ccedf86$export$3466bac9141a5cc4();
        const loader = new $084574008ccedf86$export$98435a25b5cf7b2b(this.manager);
        loader.setPath(this.path);
        loader.setResponseType("arraybuffer");
        loader.setRequestHeader(this.requestHeader);
        loader.setWithCredentials(scope.withCredentials);
        let loaded = 0;
        function loadTexture(i304) {
            loader.load(url[i304], function(buffer) {
                const texDatas = scope.parse(buffer, true);
                images[i304] = {
                    width: texDatas.width,
                    height: texDatas.height,
                    format: texDatas.format,
                    mipmaps: texDatas.mipmaps
                };
                loaded += 1;
                if (loaded === 6) {
                    if (texDatas.mipmapCount === 1) texture.minFilter = $084574008ccedf86$export$8a72f490b25c56c8;
                    texture.image = images;
                    texture.format = texDatas.format;
                    texture.needsUpdate = true;
                    if (onLoad) onLoad(texture);
                }
            }, onProgress, onError);
        }
        if (Array.isArray(url)) for(let i303 = 0, il = url.length; i303 < il; ++i303)loadTexture(i303);
        else // compressed cubemap texture stored in a single DDS file
        loader.load(url, function(buffer) {
            const texDatas = scope.parse(buffer, true);
            if (texDatas.isCubemap) {
                const faces = texDatas.mipmaps.length / texDatas.mipmapCount;
                for(let f = 0; f < faces; f++){
                    images[f] = {
                        mipmaps: []
                    };
                    for(let i305 = 0; i305 < texDatas.mipmapCount; i305++){
                        images[f].mipmaps.push(texDatas.mipmaps[f * texDatas.mipmapCount + i305]);
                        images[f].format = texDatas.format;
                        images[f].width = texDatas.width;
                        images[f].height = texDatas.height;
                    }
                }
                texture.image = images;
            } else {
                texture.image.width = texDatas.width;
                texture.image.height = texDatas.height;
                texture.mipmaps = texDatas.mipmaps;
            }
            if (texDatas.mipmapCount === 1) texture.minFilter = $084574008ccedf86$export$8a72f490b25c56c8;
            texture.format = texDatas.format;
            texture.needsUpdate = true;
            if (onLoad) onLoad(texture);
        }, onProgress, onError);
        return texture;
    }
}
class $084574008ccedf86$export$8905ce1c7a2464a1 extends $084574008ccedf86$export$3b0d6d7590275603 {
    constructor(manager){
        super(manager);
    }
    load(url, onLoad, onProgress, onError) {
        if (this.path !== undefined) url = this.path + url;
        url = this.manager.resolveURL(url);
        const scope = this;
        const cached = $084574008ccedf86$export$94affb487e701bf2.get(url);
        if (cached !== undefined) {
            scope.manager.itemStart(url);
            setTimeout(function() {
                if (onLoad) onLoad(cached);
                scope.manager.itemEnd(url);
            }, 0);
            return cached;
        }
        const image = $084574008ccedf86$var$createElementNS("img");
        function onImageLoad() {
            removeEventListeners();
            $084574008ccedf86$export$94affb487e701bf2.add(url, this);
            if (onLoad) onLoad(this);
            scope.manager.itemEnd(url);
        }
        function onImageError(event) {
            removeEventListeners();
            if (onError) onError(event);
            scope.manager.itemError(url);
            scope.manager.itemEnd(url);
        }
        function removeEventListeners() {
            image.removeEventListener("load", onImageLoad, false);
            image.removeEventListener("error", onImageError, false);
        }
        image.addEventListener("load", onImageLoad, false);
        image.addEventListener("error", onImageError, false);
        if (url.slice(0, 5) !== "data:") {
            if (this.crossOrigin !== undefined) image.crossOrigin = this.crossOrigin;
        }
        scope.manager.itemStart(url);
        image.src = url;
        return image;
    }
}
class $084574008ccedf86$export$2ec114afc2cf6308 extends $084574008ccedf86$export$3b0d6d7590275603 {
    constructor(manager){
        super(manager);
    }
    load(urls, onLoad, onProgress, onError) {
        const texture = new $084574008ccedf86$export$ee2e5a18258a4049();
        const loader = new $084574008ccedf86$export$8905ce1c7a2464a1(this.manager);
        loader.setCrossOrigin(this.crossOrigin);
        loader.setPath(this.path);
        let loaded = 0;
        function loadTexture(i307) {
            loader.load(urls[i307], function(image) {
                texture.images[i307] = image;
                loaded++;
                if (loaded === 6) {
                    texture.needsUpdate = true;
                    if (onLoad) onLoad(texture);
                }
            }, undefined, onError);
        }
        for(let i306 = 0; i306 < urls.length; ++i306)loadTexture(i306);
        return texture;
    }
}
/**
 * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)
 *
 * Sub classes have to implement the parse() method which will be used in load().
 */ class $084574008ccedf86$export$792d8a18f2c55855 extends $084574008ccedf86$export$3b0d6d7590275603 {
    constructor(manager){
        super(manager);
    }
    load(url, onLoad, onProgress, onError) {
        const scope = this;
        const texture = new $084574008ccedf86$export$b691f601014eabe1();
        const loader = new $084574008ccedf86$export$98435a25b5cf7b2b(this.manager);
        loader.setResponseType("arraybuffer");
        loader.setRequestHeader(this.requestHeader);
        loader.setPath(this.path);
        loader.setWithCredentials(scope.withCredentials);
        loader.load(url, function(buffer) {
            const texData = scope.parse(buffer);
            if (!texData) return;
            if (texData.image !== undefined) texture.image = texData.image;
            else if (texData.data !== undefined) {
                texture.image.width = texData.width;
                texture.image.height = texData.height;
                texture.image.data = texData.data;
            }
            texture.wrapS = texData.wrapS !== undefined ? texData.wrapS : $084574008ccedf86$export$9d9334239a5a5e06;
            texture.wrapT = texData.wrapT !== undefined ? texData.wrapT : $084574008ccedf86$export$9d9334239a5a5e06;
            texture.magFilter = texData.magFilter !== undefined ? texData.magFilter : $084574008ccedf86$export$8a72f490b25c56c8;
            texture.minFilter = texData.minFilter !== undefined ? texData.minFilter : $084574008ccedf86$export$8a72f490b25c56c8;
            texture.anisotropy = texData.anisotropy !== undefined ? texData.anisotropy : 1;
            if (texData.encoding !== undefined) texture.encoding = texData.encoding;
            if (texData.flipY !== undefined) texture.flipY = texData.flipY;
            if (texData.format !== undefined) texture.format = texData.format;
            if (texData.type !== undefined) texture.type = texData.type;
            if (texData.mipmaps !== undefined) {
                texture.mipmaps = texData.mipmaps;
                texture.minFilter = $084574008ccedf86$export$5d8599b6a933fb1b; // presumably...
            }
            if (texData.mipmapCount === 1) texture.minFilter = $084574008ccedf86$export$8a72f490b25c56c8;
            if (texData.generateMipmaps !== undefined) texture.generateMipmaps = texData.generateMipmaps;
            texture.needsUpdate = true;
            if (onLoad) onLoad(texture, texData);
        }, onProgress, onError);
        return texture;
    }
}
class $084574008ccedf86$export$fd1bfc71f64c538c extends $084574008ccedf86$export$3b0d6d7590275603 {
    constructor(manager){
        super(manager);
    }
    load(url, onLoad, onProgress, onError) {
        const texture = new $084574008ccedf86$export$5431306cf43de24a();
        const loader = new $084574008ccedf86$export$8905ce1c7a2464a1(this.manager);
        loader.setCrossOrigin(this.crossOrigin);
        loader.setPath(this.path);
        loader.load(url, function(image) {
            texture.image = image;
            texture.needsUpdate = true;
            if (onLoad !== undefined) onLoad(texture);
        }, onProgress, onError);
        return texture;
    }
}
class $084574008ccedf86$export$6ecadb6ed240d696 extends $084574008ccedf86$export$e4dd07dff30cc924 {
    constructor(color, intensity = 1){
        super();
        this.isLight = true;
        this.type = "Light";
        this.color = new $084574008ccedf86$export$892596cec99bc70e(color);
        this.intensity = intensity;
    }
    dispose() {
    // Empty here in base class; some subclasses override.
    }
    copy(source, recursive) {
        super.copy(source, recursive);
        this.color.copy(source.color);
        this.intensity = source.intensity;
        return this;
    }
    toJSON(meta) {
        const data = super.toJSON(meta);
        data.object.color = this.color.getHex();
        data.object.intensity = this.intensity;
        if (this.groundColor !== undefined) data.object.groundColor = this.groundColor.getHex();
        if (this.distance !== undefined) data.object.distance = this.distance;
        if (this.angle !== undefined) data.object.angle = this.angle;
        if (this.decay !== undefined) data.object.decay = this.decay;
        if (this.penumbra !== undefined) data.object.penumbra = this.penumbra;
        if (this.shadow !== undefined) data.object.shadow = this.shadow.toJSON();
        return data;
    }
}
class $084574008ccedf86$export$8d474f55edbb9624 extends $084574008ccedf86$export$6ecadb6ed240d696 {
    constructor(skyColor, groundColor, intensity){
        super(skyColor, intensity);
        this.isHemisphereLight = true;
        this.type = "HemisphereLight";
        this.position.copy($084574008ccedf86$export$e4dd07dff30cc924.DefaultUp);
        this.updateMatrix();
        this.groundColor = new $084574008ccedf86$export$892596cec99bc70e(groundColor);
    }
    copy(source, recursive) {
        super.copy(source, recursive);
        this.groundColor.copy(source.groundColor);
        return this;
    }
}
const $084574008ccedf86$var$_projScreenMatrix$1 = /*@__PURE__*/ new $084574008ccedf86$export$2ae72fc923e5eb5();
const $084574008ccedf86$var$_lightPositionWorld$1 = /*@__PURE__*/ new $084574008ccedf86$export$64b5c384219d3699();
const $084574008ccedf86$var$_lookTarget$1 = /*@__PURE__*/ new $084574008ccedf86$export$64b5c384219d3699();
class $084574008ccedf86$var$LightShadow {
    constructor(camera){
        this.camera = camera;
        this.bias = 0;
        this.normalBias = 0;
        this.radius = 1;
        this.blurSamples = 8;
        this.mapSize = new $084574008ccedf86$export$c977b3e384af9ae1(512, 512);
        this.map = null;
        this.mapPass = null;
        this.matrix = new $084574008ccedf86$export$2ae72fc923e5eb5();
        this.autoUpdate = true;
        this.needsUpdate = false;
        this._frustum = new $084574008ccedf86$export$35efe6f4c85463d2();
        this._frameExtents = new $084574008ccedf86$export$c977b3e384af9ae1(1, 1);
        this._viewportCount = 1;
        this._viewports = [
            new $084574008ccedf86$export$fa7daccca11cdbe3(0, 0, 1, 1)
        ];
    }
    getViewportCount() {
        return this._viewportCount;
    }
    getFrustum() {
        return this._frustum;
    }
    updateMatrices(light) {
        const shadowCamera = this.camera;
        const shadowMatrix = this.matrix;
        $084574008ccedf86$var$_lightPositionWorld$1.setFromMatrixPosition(light.matrixWorld);
        shadowCamera.position.copy($084574008ccedf86$var$_lightPositionWorld$1);
        $084574008ccedf86$var$_lookTarget$1.setFromMatrixPosition(light.target.matrixWorld);
        shadowCamera.lookAt($084574008ccedf86$var$_lookTarget$1);
        shadowCamera.updateMatrixWorld();
        $084574008ccedf86$var$_projScreenMatrix$1.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);
        this._frustum.setFromProjectionMatrix($084574008ccedf86$var$_projScreenMatrix$1);
        shadowMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);
        shadowMatrix.multiply(shadowCamera.projectionMatrix);
        shadowMatrix.multiply(shadowCamera.matrixWorldInverse);
    }
    getViewport(viewportIndex) {
        return this._viewports[viewportIndex];
    }
    getFrameExtents() {
        return this._frameExtents;
    }
    dispose() {
        if (this.map) this.map.dispose();
        if (this.mapPass) this.mapPass.dispose();
    }
    copy(source) {
        this.camera = source.camera.clone();
        this.bias = source.bias;
        this.radius = source.radius;
        this.mapSize.copy(source.mapSize);
        return this;
    }
    clone() {
        return new this.constructor().copy(this);
    }
    toJSON() {
        const object = {};
        if (this.bias !== 0) object.bias = this.bias;
        if (this.normalBias !== 0) object.normalBias = this.normalBias;
        if (this.radius !== 1) object.radius = this.radius;
        if (this.mapSize.x !== 512 || this.mapSize.y !== 512) object.mapSize = this.mapSize.toArray();
        object.camera = this.camera.toJSON(false).object;
        delete object.camera.matrix;
        return object;
    }
}
class $084574008ccedf86$var$SpotLightShadow extends $084574008ccedf86$var$LightShadow {
    constructor(){
        super(new $084574008ccedf86$export$74e4ae24825f68d7(50, 1, 0.5, 500));
        this.isSpotLightShadow = true;
        this.focus = 1;
    }
    updateMatrices(light) {
        const camera = this.camera;
        const fov3 = $084574008ccedf86$var$RAD2DEG * 2 * light.angle * this.focus;
        const aspect3 = this.mapSize.width / this.mapSize.height;
        const far = light.distance || camera.far;
        if (fov3 !== camera.fov || aspect3 !== camera.aspect || far !== camera.far) {
            camera.fov = fov3;
            camera.aspect = aspect3;
            camera.far = far;
            camera.updateProjectionMatrix();
        }
        super.updateMatrices(light);
    }
    copy(source) {
        super.copy(source);
        this.focus = source.focus;
        return this;
    }
}
class $084574008ccedf86$export$81495cbb73897362 extends $084574008ccedf86$export$6ecadb6ed240d696 {
    constructor(color, intensity, distance = 0, angle = Math.PI / 3, penumbra = 0, decay = 1){
        super(color, intensity);
        this.isSpotLight = true;
        this.type = "SpotLight";
        this.position.copy($084574008ccedf86$export$e4dd07dff30cc924.DefaultUp);
        this.updateMatrix();
        this.target = new $084574008ccedf86$export$e4dd07dff30cc924();
        this.distance = distance;
        this.angle = angle;
        this.penumbra = penumbra;
        this.decay = decay; // for physically correct lights, should be 2.
        this.shadow = new $084574008ccedf86$var$SpotLightShadow();
    }
    get power() {
        // compute the light's luminous power (in lumens) from its intensity (in candela)
        // by convention for a spotlight, luminous power (lm) =  * luminous intensity (cd)
        return this.intensity * Math.PI;
    }
    set power(power) {
        // set the light's intensity (in candela) from the desired luminous power (in lumens)
        this.intensity = power / Math.PI;
    }
    dispose() {
        this.shadow.dispose();
    }
    copy(source, recursive) {
        super.copy(source, recursive);
        this.distance = source.distance;
        this.angle = source.angle;
        this.penumbra = source.penumbra;
        this.decay = source.decay;
        this.target = source.target.clone();
        this.shadow = source.shadow.clone();
        return this;
    }
}
const $084574008ccedf86$var$_projScreenMatrix = /*@__PURE__*/ new $084574008ccedf86$export$2ae72fc923e5eb5();
const $084574008ccedf86$var$_lightPositionWorld = /*@__PURE__*/ new $084574008ccedf86$export$64b5c384219d3699();
const $084574008ccedf86$var$_lookTarget = /*@__PURE__*/ new $084574008ccedf86$export$64b5c384219d3699();
class $084574008ccedf86$var$PointLightShadow extends $084574008ccedf86$var$LightShadow {
    constructor(){
        super(new $084574008ccedf86$export$74e4ae24825f68d7(90, 1, 0.5, 500));
        this.isPointLightShadow = true;
        this._frameExtents = new $084574008ccedf86$export$c977b3e384af9ae1(4, 2);
        this._viewportCount = 6;
        this._viewports = [
            // These viewports map a cube-map onto a 2D texture with the
            // following orientation:
            //
            //  xzXZ
            //   y Y
            //
            // X - Positive x direction
            // x - Negative x direction
            // Y - Positive y direction
            // y - Negative y direction
            // Z - Positive z direction
            // z - Negative z direction
            // positive X
            new $084574008ccedf86$export$fa7daccca11cdbe3(2, 1, 1, 1),
            // negative X
            new $084574008ccedf86$export$fa7daccca11cdbe3(0, 1, 1, 1),
            // positive Z
            new $084574008ccedf86$export$fa7daccca11cdbe3(3, 1, 1, 1),
            // negative Z
            new $084574008ccedf86$export$fa7daccca11cdbe3(1, 1, 1, 1),
            // positive Y
            new $084574008ccedf86$export$fa7daccca11cdbe3(3, 0, 1, 1),
            // negative Y
            new $084574008ccedf86$export$fa7daccca11cdbe3(1, 0, 1, 1)
        ];
        this._cubeDirections = [
            new $084574008ccedf86$export$64b5c384219d3699(1, 0, 0),
            new $084574008ccedf86$export$64b5c384219d3699(-1, 0, 0),
            new $084574008ccedf86$export$64b5c384219d3699(0, 0, 1),
            new $084574008ccedf86$export$64b5c384219d3699(0, 0, -1),
            new $084574008ccedf86$export$64b5c384219d3699(0, 1, 0),
            new $084574008ccedf86$export$64b5c384219d3699(0, -1, 0)
        ];
        this._cubeUps = [
            new $084574008ccedf86$export$64b5c384219d3699(0, 1, 0),
            new $084574008ccedf86$export$64b5c384219d3699(0, 1, 0),
            new $084574008ccedf86$export$64b5c384219d3699(0, 1, 0),
            new $084574008ccedf86$export$64b5c384219d3699(0, 1, 0),
            new $084574008ccedf86$export$64b5c384219d3699(0, 0, 1),
            new $084574008ccedf86$export$64b5c384219d3699(0, 0, -1)
        ];
    }
    updateMatrices(light, viewportIndex = 0) {
        const camera = this.camera;
        const shadowMatrix = this.matrix;
        const far = light.distance || camera.far;
        if (far !== camera.far) {
            camera.far = far;
            camera.updateProjectionMatrix();
        }
        $084574008ccedf86$var$_lightPositionWorld.setFromMatrixPosition(light.matrixWorld);
        camera.position.copy($084574008ccedf86$var$_lightPositionWorld);
        $084574008ccedf86$var$_lookTarget.copy(camera.position);
        $084574008ccedf86$var$_lookTarget.add(this._cubeDirections[viewportIndex]);
        camera.up.copy(this._cubeUps[viewportIndex]);
        camera.lookAt($084574008ccedf86$var$_lookTarget);
        camera.updateMatrixWorld();
        shadowMatrix.makeTranslation(-$084574008ccedf86$var$_lightPositionWorld.x, -$084574008ccedf86$var$_lightPositionWorld.y, -$084574008ccedf86$var$_lightPositionWorld.z);
        $084574008ccedf86$var$_projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
        this._frustum.setFromProjectionMatrix($084574008ccedf86$var$_projScreenMatrix);
    }
}
class $084574008ccedf86$export$4c9c1cb3f0b6f455 extends $084574008ccedf86$export$6ecadb6ed240d696 {
    constructor(color, intensity, distance = 0, decay = 1){
        super(color, intensity);
        this.isPointLight = true;
        this.type = "PointLight";
        this.distance = distance;
        this.decay = decay; // for physically correct lights, should be 2.
        this.shadow = new $084574008ccedf86$var$PointLightShadow();
    }
    get power() {
        // compute the light's luminous power (in lumens) from its intensity (in candela)
        // for an isotropic light source, luminous power (lm) = 4  luminous intensity (cd)
        return this.intensity * 4 * Math.PI;
    }
    set power(power) {
        // set the light's intensity (in candela) from the desired luminous power (in lumens)
        this.intensity = power / (4 * Math.PI);
    }
    dispose() {
        this.shadow.dispose();
    }
    copy(source, recursive) {
        super.copy(source, recursive);
        this.distance = source.distance;
        this.decay = source.decay;
        this.shadow = source.shadow.clone();
        return this;
    }
}
class $084574008ccedf86$var$DirectionalLightShadow extends $084574008ccedf86$var$LightShadow {
    constructor(){
        super(new $084574008ccedf86$export$9ebf355ee4ed261b(-5, 5, 5, -5, 0.5, 500));
        this.isDirectionalLightShadow = true;
    }
}
class $084574008ccedf86$export$3fea33cc9972c868 extends $084574008ccedf86$export$6ecadb6ed240d696 {
    constructor(color, intensity){
        super(color, intensity);
        this.isDirectionalLight = true;
        this.type = "DirectionalLight";
        this.position.copy($084574008ccedf86$export$e4dd07dff30cc924.DefaultUp);
        this.updateMatrix();
        this.target = new $084574008ccedf86$export$e4dd07dff30cc924();
        this.shadow = new $084574008ccedf86$var$DirectionalLightShadow();
    }
    dispose() {
        this.shadow.dispose();
    }
    copy(source) {
        super.copy(source);
        this.target = source.target.clone();
        this.shadow = source.shadow.clone();
        return this;
    }
}
class $084574008ccedf86$export$af279bfef9ec2c96 extends $084574008ccedf86$export$6ecadb6ed240d696 {
    constructor(color, intensity){
        super(color, intensity);
        this.isAmbientLight = true;
        this.type = "AmbientLight";
    }
}
class $084574008ccedf86$export$61db2d908bbd2429 extends $084574008ccedf86$export$6ecadb6ed240d696 {
    constructor(color, intensity, width = 10, height = 10){
        super(color, intensity);
        this.isRectAreaLight = true;
        this.type = "RectAreaLight";
        this.width = width;
        this.height = height;
    }
    get power() {
        // compute the light's luminous power (in lumens) from its intensity (in nits)
        return this.intensity * this.width * this.height * Math.PI;
    }
    set power(power) {
        // set the light's intensity (in nits) from the desired luminous power (in lumens)
        this.intensity = power / (this.width * this.height * Math.PI);
    }
    copy(source) {
        super.copy(source);
        this.width = source.width;
        this.height = source.height;
        return this;
    }
    toJSON(meta) {
        const data = super.toJSON(meta);
        data.object.width = this.width;
        data.object.height = this.height;
        return data;
    }
}
/**
 * Primary reference:
 *   https://graphics.stanford.edu/papers/envmap/envmap.pdf
 *
 * Secondary reference:
 *   https://www.ppsloan.org/publications/StupidSH36.pdf
 */ // 3-band SH defined by 9 coefficients
class $084574008ccedf86$export$ba61ce607e1f405a {
    constructor(){
        this.isSphericalHarmonics3 = true;
        this.coefficients = [];
        for(let i308 = 0; i308 < 9; i308++)this.coefficients.push(new $084574008ccedf86$export$64b5c384219d3699());
    }
    set(coefficients) {
        for(let i309 = 0; i309 < 9; i309++)this.coefficients[i309].copy(coefficients[i309]);
        return this;
    }
    zero() {
        for(let i310 = 0; i310 < 9; i310++)this.coefficients[i310].set(0, 0, 0);
        return this;
    }
    // get the radiance in the direction of the normal
    // target is a Vector3
    getAt(normal, target) {
        // normal is assumed to be unit length
        const x = normal.x, y = normal.y, z = normal.z;
        const coeff = this.coefficients;
        // band 0
        target.copy(coeff[0]).multiplyScalar(0.282095);
        // band 1
        target.addScaledVector(coeff[1], 0.488603 * y);
        target.addScaledVector(coeff[2], 0.488603 * z);
        target.addScaledVector(coeff[3], 0.488603 * x);
        // band 2
        target.addScaledVector(coeff[4], 1.092548 * (x * y));
        target.addScaledVector(coeff[5], 1.092548 * (y * z));
        target.addScaledVector(coeff[6], 0.315392 * (3.0 * z * z - 1.0));
        target.addScaledVector(coeff[7], 1.092548 * (x * z));
        target.addScaledVector(coeff[8], 0.546274 * (x * x - y * y));
        return target;
    }
    // get the irradiance (radiance convolved with cosine lobe) in the direction of the normal
    // target is a Vector3
    // https://graphics.stanford.edu/papers/envmap/envmap.pdf
    getIrradianceAt(normal, target) {
        // normal is assumed to be unit length
        const x = normal.x, y = normal.y, z = normal.z;
        const coeff = this.coefficients;
        // band 0
        target.copy(coeff[0]).multiplyScalar(0.886227); //  * 0.282095
        // band 1
        target.addScaledVector(coeff[1], 1.023328 * y); // ( 2 *  / 3 ) * 0.488603
        target.addScaledVector(coeff[2], 1.023328 * z);
        target.addScaledVector(coeff[3], 1.023328 * x);
        // band 2
        target.addScaledVector(coeff[4], 0.858086 * x * y); // (  / 4 ) * 1.092548
        target.addScaledVector(coeff[5], 0.858086 * y * z);
        target.addScaledVector(coeff[6], 0.743125 * z * z - 0.247708); // (  / 4 ) * 0.315392 * 3
        target.addScaledVector(coeff[7], 0.858086 * x * z);
        target.addScaledVector(coeff[8], 0.429043 * (x * x - y * y)); // (  / 4 ) * 0.546274
        return target;
    }
    add(sh) {
        for(let i311 = 0; i311 < 9; i311++)this.coefficients[i311].add(sh.coefficients[i311]);
        return this;
    }
    addScaledSH(sh, s) {
        for(let i312 = 0; i312 < 9; i312++)this.coefficients[i312].addScaledVector(sh.coefficients[i312], s);
        return this;
    }
    scale(s) {
        for(let i313 = 0; i313 < 9; i313++)this.coefficients[i313].multiplyScalar(s);
        return this;
    }
    lerp(sh, alpha) {
        for(let i314 = 0; i314 < 9; i314++)this.coefficients[i314].lerp(sh.coefficients[i314], alpha);
        return this;
    }
    equals(sh) {
        for(let i315 = 0; i315 < 9; i315++){
            if (!this.coefficients[i315].equals(sh.coefficients[i315])) return false;
        }
        return true;
    }
    copy(sh) {
        return this.set(sh.coefficients);
    }
    clone() {
        return new this.constructor().copy(this);
    }
    fromArray(array, offset = 0) {
        const coefficients = this.coefficients;
        for(let i316 = 0; i316 < 9; i316++)coefficients[i316].fromArray(array, offset + i316 * 3);
        return this;
    }
    toArray(array = [], offset = 0) {
        const coefficients = this.coefficients;
        for(let i317 = 0; i317 < 9; i317++)coefficients[i317].toArray(array, offset + i317 * 3);
        return array;
    }
    // evaluate the basis functions
    // shBasis is an Array[ 9 ]
    static getBasisAt(normal, shBasis) {
        // normal is assumed to be unit length
        const x = normal.x, y = normal.y, z = normal.z;
        // band 0
        shBasis[0] = 0.282095;
        // band 1
        shBasis[1] = 0.488603 * y;
        shBasis[2] = 0.488603 * z;
        shBasis[3] = 0.488603 * x;
        // band 2
        shBasis[4] = 1.092548 * x * y;
        shBasis[5] = 1.092548 * y * z;
        shBasis[6] = 0.315392 * (3 * z * z - 1);
        shBasis[7] = 1.092548 * x * z;
        shBasis[8] = 0.546274 * (x * x - y * y);
    }
}
class $084574008ccedf86$export$e7ef036e309b38d2 extends $084574008ccedf86$export$6ecadb6ed240d696 {
    constructor(sh = new $084574008ccedf86$export$ba61ce607e1f405a(), intensity = 1){
        super(undefined, intensity);
        this.isLightProbe = true;
        this.sh = sh;
    }
    copy(source) {
        super.copy(source);
        this.sh.copy(source.sh);
        return this;
    }
    fromJSON(json) {
        this.intensity = json.intensity; // TODO: Move this bit to Light.fromJSON();
        this.sh.fromArray(json.sh);
        return this;
    }
    toJSON(meta) {
        const data = super.toJSON(meta);
        data.object.sh = this.sh.toArray();
        return data;
    }
}
class $084574008ccedf86$export$3bd6d323353dcf96 extends $084574008ccedf86$export$3b0d6d7590275603 {
    constructor(manager){
        super(manager);
        this.textures = {};
    }
    load(url, onLoad, onProgress, onError) {
        const scope = this;
        const loader = new $084574008ccedf86$export$98435a25b5cf7b2b(scope.manager);
        loader.setPath(scope.path);
        loader.setRequestHeader(scope.requestHeader);
        loader.setWithCredentials(scope.withCredentials);
        loader.load(url, function(text) {
            try {
                onLoad(scope.parse(JSON.parse(text)));
            } catch (e) {
                if (onError) onError(e);
                else console.error(e);
                scope.manager.itemError(url);
            }
        }, onProgress, onError);
    }
    parse(json) {
        const textures = this.textures;
        function getTexture(name) {
            if (textures[name] === undefined) console.warn("THREE.MaterialLoader: Undefined texture", name);
            return textures[name];
        }
        const material = $084574008ccedf86$export$a2d8b23205c25948.fromType(json.type);
        if (json.uuid !== undefined) material.uuid = json.uuid;
        if (json.name !== undefined) material.name = json.name;
        if (json.color !== undefined && material.color !== undefined) material.color.setHex(json.color);
        if (json.roughness !== undefined) material.roughness = json.roughness;
        if (json.metalness !== undefined) material.metalness = json.metalness;
        if (json.sheen !== undefined) material.sheen = json.sheen;
        if (json.sheenColor !== undefined) material.sheenColor = new $084574008ccedf86$export$892596cec99bc70e().setHex(json.sheenColor);
        if (json.sheenRoughness !== undefined) material.sheenRoughness = json.sheenRoughness;
        if (json.emissive !== undefined && material.emissive !== undefined) material.emissive.setHex(json.emissive);
        if (json.specular !== undefined && material.specular !== undefined) material.specular.setHex(json.specular);
        if (json.specularIntensity !== undefined) material.specularIntensity = json.specularIntensity;
        if (json.specularColor !== undefined && material.specularColor !== undefined) material.specularColor.setHex(json.specularColor);
        if (json.shininess !== undefined) material.shininess = json.shininess;
        if (json.clearcoat !== undefined) material.clearcoat = json.clearcoat;
        if (json.clearcoatRoughness !== undefined) material.clearcoatRoughness = json.clearcoatRoughness;
        if (json.iridescence !== undefined) material.iridescence = json.iridescence;
        if (json.iridescenceIOR !== undefined) material.iridescenceIOR = json.iridescenceIOR;
        if (json.iridescenceThicknessRange !== undefined) material.iridescenceThicknessRange = json.iridescenceThicknessRange;
        if (json.transmission !== undefined) material.transmission = json.transmission;
        if (json.thickness !== undefined) material.thickness = json.thickness;
        if (json.attenuationDistance !== undefined) material.attenuationDistance = json.attenuationDistance;
        if (json.attenuationColor !== undefined && material.attenuationColor !== undefined) material.attenuationColor.setHex(json.attenuationColor);
        if (json.fog !== undefined) material.fog = json.fog;
        if (json.flatShading !== undefined) material.flatShading = json.flatShading;
        if (json.blending !== undefined) material.blending = json.blending;
        if (json.combine !== undefined) material.combine = json.combine;
        if (json.side !== undefined) material.side = json.side;
        if (json.shadowSide !== undefined) material.shadowSide = json.shadowSide;
        if (json.opacity !== undefined) material.opacity = json.opacity;
        if (json.transparent !== undefined) material.transparent = json.transparent;
        if (json.alphaTest !== undefined) material.alphaTest = json.alphaTest;
        if (json.depthTest !== undefined) material.depthTest = json.depthTest;
        if (json.depthWrite !== undefined) material.depthWrite = json.depthWrite;
        if (json.colorWrite !== undefined) material.colorWrite = json.colorWrite;
        if (json.stencilWrite !== undefined) material.stencilWrite = json.stencilWrite;
        if (json.stencilWriteMask !== undefined) material.stencilWriteMask = json.stencilWriteMask;
        if (json.stencilFunc !== undefined) material.stencilFunc = json.stencilFunc;
        if (json.stencilRef !== undefined) material.stencilRef = json.stencilRef;
        if (json.stencilFuncMask !== undefined) material.stencilFuncMask = json.stencilFuncMask;
        if (json.stencilFail !== undefined) material.stencilFail = json.stencilFail;
        if (json.stencilZFail !== undefined) material.stencilZFail = json.stencilZFail;
        if (json.stencilZPass !== undefined) material.stencilZPass = json.stencilZPass;
        if (json.wireframe !== undefined) material.wireframe = json.wireframe;
        if (json.wireframeLinewidth !== undefined) material.wireframeLinewidth = json.wireframeLinewidth;
        if (json.wireframeLinecap !== undefined) material.wireframeLinecap = json.wireframeLinecap;
        if (json.wireframeLinejoin !== undefined) material.wireframeLinejoin = json.wireframeLinejoin;
        if (json.rotation !== undefined) material.rotation = json.rotation;
        if (json.linewidth !== 1) material.linewidth = json.linewidth;
        if (json.dashSize !== undefined) material.dashSize = json.dashSize;
        if (json.gapSize !== undefined) material.gapSize = json.gapSize;
        if (json.scale !== undefined) material.scale = json.scale;
        if (json.polygonOffset !== undefined) material.polygonOffset = json.polygonOffset;
        if (json.polygonOffsetFactor !== undefined) material.polygonOffsetFactor = json.polygonOffsetFactor;
        if (json.polygonOffsetUnits !== undefined) material.polygonOffsetUnits = json.polygonOffsetUnits;
        if (json.dithering !== undefined) material.dithering = json.dithering;
        if (json.alphaToCoverage !== undefined) material.alphaToCoverage = json.alphaToCoverage;
        if (json.premultipliedAlpha !== undefined) material.premultipliedAlpha = json.premultipliedAlpha;
        if (json.visible !== undefined) material.visible = json.visible;
        if (json.toneMapped !== undefined) material.toneMapped = json.toneMapped;
        if (json.userData !== undefined) material.userData = json.userData;
        if (json.vertexColors !== undefined) {
            if (typeof json.vertexColors === "number") material.vertexColors = json.vertexColors > 0 ? true : false;
            else material.vertexColors = json.vertexColors;
        }
        // Shader Material
        if (json.uniforms !== undefined) for(const name4 in json.uniforms){
            const uniform = json.uniforms[name4];
            material.uniforms[name4] = {};
            switch(uniform.type){
                case "t":
                    material.uniforms[name4].value = getTexture(uniform.value);
                    break;
                case "c":
                    material.uniforms[name4].value = new $084574008ccedf86$export$892596cec99bc70e().setHex(uniform.value);
                    break;
                case "v2":
                    material.uniforms[name4].value = new $084574008ccedf86$export$c977b3e384af9ae1().fromArray(uniform.value);
                    break;
                case "v3":
                    material.uniforms[name4].value = new $084574008ccedf86$export$64b5c384219d3699().fromArray(uniform.value);
                    break;
                case "v4":
                    material.uniforms[name4].value = new $084574008ccedf86$export$fa7daccca11cdbe3().fromArray(uniform.value);
                    break;
                case "m3":
                    material.uniforms[name4].value = new $084574008ccedf86$export$8ff26dafa08918().fromArray(uniform.value);
                    break;
                case "m4":
                    material.uniforms[name4].value = new $084574008ccedf86$export$2ae72fc923e5eb5().fromArray(uniform.value);
                    break;
                default:
                    material.uniforms[name4].value = uniform.value;
            }
        }
        if (json.defines !== undefined) material.defines = json.defines;
        if (json.vertexShader !== undefined) material.vertexShader = json.vertexShader;
        if (json.fragmentShader !== undefined) material.fragmentShader = json.fragmentShader;
        if (json.extensions !== undefined) for(const key in json.extensions)material.extensions[key] = json.extensions[key];
        // Deprecated
        if (json.shading !== undefined) material.flatShading = json.shading === 1; // THREE.FlatShading
        // for PointsMaterial
        if (json.size !== undefined) material.size = json.size;
        if (json.sizeAttenuation !== undefined) material.sizeAttenuation = json.sizeAttenuation;
        // maps
        if (json.map !== undefined) material.map = getTexture(json.map);
        if (json.matcap !== undefined) material.matcap = getTexture(json.matcap);
        if (json.alphaMap !== undefined) material.alphaMap = getTexture(json.alphaMap);
        if (json.bumpMap !== undefined) material.bumpMap = getTexture(json.bumpMap);
        if (json.bumpScale !== undefined) material.bumpScale = json.bumpScale;
        if (json.normalMap !== undefined) material.normalMap = getTexture(json.normalMap);
        if (json.normalMapType !== undefined) material.normalMapType = json.normalMapType;
        if (json.normalScale !== undefined) {
            let normalScale = json.normalScale;
            if (Array.isArray(normalScale) === false) // Blender exporter used to export a scalar. See #7459
            normalScale = [
                normalScale,
                normalScale
            ];
            material.normalScale = new $084574008ccedf86$export$c977b3e384af9ae1().fromArray(normalScale);
        }
        if (json.displacementMap !== undefined) material.displacementMap = getTexture(json.displacementMap);
        if (json.displacementScale !== undefined) material.displacementScale = json.displacementScale;
        if (json.displacementBias !== undefined) material.displacementBias = json.displacementBias;
        if (json.roughnessMap !== undefined) material.roughnessMap = getTexture(json.roughnessMap);
        if (json.metalnessMap !== undefined) material.metalnessMap = getTexture(json.metalnessMap);
        if (json.emissiveMap !== undefined) material.emissiveMap = getTexture(json.emissiveMap);
        if (json.emissiveIntensity !== undefined) material.emissiveIntensity = json.emissiveIntensity;
        if (json.specularMap !== undefined) material.specularMap = getTexture(json.specularMap);
        if (json.specularIntensityMap !== undefined) material.specularIntensityMap = getTexture(json.specularIntensityMap);
        if (json.specularColorMap !== undefined) material.specularColorMap = getTexture(json.specularColorMap);
        if (json.envMap !== undefined) material.envMap = getTexture(json.envMap);
        if (json.envMapIntensity !== undefined) material.envMapIntensity = json.envMapIntensity;
        if (json.reflectivity !== undefined) material.reflectivity = json.reflectivity;
        if (json.refractionRatio !== undefined) material.refractionRatio = json.refractionRatio;
        if (json.lightMap !== undefined) material.lightMap = getTexture(json.lightMap);
        if (json.lightMapIntensity !== undefined) material.lightMapIntensity = json.lightMapIntensity;
        if (json.aoMap !== undefined) material.aoMap = getTexture(json.aoMap);
        if (json.aoMapIntensity !== undefined) material.aoMapIntensity = json.aoMapIntensity;
        if (json.gradientMap !== undefined) material.gradientMap = getTexture(json.gradientMap);
        if (json.clearcoatMap !== undefined) material.clearcoatMap = getTexture(json.clearcoatMap);
        if (json.clearcoatRoughnessMap !== undefined) material.clearcoatRoughnessMap = getTexture(json.clearcoatRoughnessMap);
        if (json.clearcoatNormalMap !== undefined) material.clearcoatNormalMap = getTexture(json.clearcoatNormalMap);
        if (json.clearcoatNormalScale !== undefined) material.clearcoatNormalScale = new $084574008ccedf86$export$c977b3e384af9ae1().fromArray(json.clearcoatNormalScale);
        if (json.iridescenceMap !== undefined) material.iridescenceMap = getTexture(json.iridescenceMap);
        if (json.iridescenceThicknessMap !== undefined) material.iridescenceThicknessMap = getTexture(json.iridescenceThicknessMap);
        if (json.transmissionMap !== undefined) material.transmissionMap = getTexture(json.transmissionMap);
        if (json.thicknessMap !== undefined) material.thicknessMap = getTexture(json.thicknessMap);
        if (json.sheenColorMap !== undefined) material.sheenColorMap = getTexture(json.sheenColorMap);
        if (json.sheenRoughnessMap !== undefined) material.sheenRoughnessMap = getTexture(json.sheenRoughnessMap);
        return material;
    }
    setTextures(value) {
        this.textures = value;
        return this;
    }
}
class $084574008ccedf86$export$b5d2dc08d867e41a {
    static decodeText(array) {
        if (typeof TextDecoder !== "undefined") return new TextDecoder().decode(array);
        // Avoid the String.fromCharCode.apply(null, array) shortcut, which
        // throws a "maximum call stack size exceeded" error for large arrays.
        let s = "";
        for(let i318 = 0, il = array.length; i318 < il; i318++)// Implicitly assumes little-endian.
        s += String.fromCharCode(array[i318]);
        try {
            // merges multi-byte utf-8 characters.
            return decodeURIComponent(escape(s));
        } catch (e) {
            return s;
        }
    }
    static extractUrlBase(url) {
        const index = url.lastIndexOf("/");
        if (index === -1) return "./";
        return url.slice(0, index + 1);
    }
    static resolveURL(url, path) {
        // Invalid URL
        if (typeof url !== "string" || url === "") return "";
        // Host Relative URL
        if (/^https?:\/\//i.test(path) && /^\//.test(url)) path = path.replace(/(^https?:\/\/[^\/]+).*/i, "$1");
        // Absolute URL http://,https://,//
        if (/^(https?:)?\/\//i.test(url)) return url;
        // Data URI
        if (/^data:.*,.*$/i.test(url)) return url;
        // Blob URL
        if (/^blob:.*$/i.test(url)) return url;
        // Relative URL
        return path + url;
    }
}
class $084574008ccedf86$export$231f009cbe414146 extends $084574008ccedf86$export$b7be63a67df8959 {
    constructor(){
        super();
        this.isInstancedBufferGeometry = true;
        this.type = "InstancedBufferGeometry";
        this.instanceCount = Infinity;
    }
    copy(source) {
        super.copy(source);
        this.instanceCount = source.instanceCount;
        return this;
    }
    clone() {
        return new this.constructor().copy(this);
    }
    toJSON() {
        const data = super.toJSON(this);
        data.instanceCount = this.instanceCount;
        data.isInstancedBufferGeometry = true;
        return data;
    }
}
class $084574008ccedf86$export$dc275bb96327833a extends $084574008ccedf86$export$3b0d6d7590275603 {
    constructor(manager){
        super(manager);
    }
    load(url, onLoad, onProgress, onError) {
        const scope = this;
        const loader = new $084574008ccedf86$export$98435a25b5cf7b2b(scope.manager);
        loader.setPath(scope.path);
        loader.setRequestHeader(scope.requestHeader);
        loader.setWithCredentials(scope.withCredentials);
        loader.load(url, function(text) {
            try {
                onLoad(scope.parse(JSON.parse(text)));
            } catch (e) {
                if (onError) onError(e);
                else console.error(e);
                scope.manager.itemError(url);
            }
        }, onProgress, onError);
    }
    parse(json1) {
        const interleavedBufferMap = {};
        const arrayBufferMap = {};
        function getInterleavedBuffer(json, uuid) {
            if (interleavedBufferMap[uuid] !== undefined) return interleavedBufferMap[uuid];
            const interleavedBuffers = json.interleavedBuffers;
            const interleavedBuffer = interleavedBuffers[uuid];
            const buffer = getArrayBuffer(json, interleavedBuffer.buffer);
            const array = $084574008ccedf86$var$getTypedArray(interleavedBuffer.type, buffer);
            const ib = new $084574008ccedf86$export$3d5cd879f108f53f(array, interleavedBuffer.stride);
            ib.uuid = interleavedBuffer.uuid;
            interleavedBufferMap[uuid] = ib;
            return ib;
        }
        function getArrayBuffer(json, uuid) {
            if (arrayBufferMap[uuid] !== undefined) return arrayBufferMap[uuid];
            const arrayBuffers = json.arrayBuffers;
            const arrayBuffer = arrayBuffers[uuid];
            const ab = new Uint32Array(arrayBuffer).buffer;
            arrayBufferMap[uuid] = ab;
            return ab;
        }
        const geometry = json1.isInstancedBufferGeometry ? new $084574008ccedf86$export$231f009cbe414146() : new $084574008ccedf86$export$b7be63a67df8959();
        const index = json1.data.index;
        if (index !== undefined) {
            const typedArray = $084574008ccedf86$var$getTypedArray(index.type, index.array);
            geometry.setIndex(new $084574008ccedf86$export$8dea267bd6bde117(typedArray, 1));
        }
        const attributes = json1.data.attributes;
        for(const key in attributes){
            const attribute = attributes[key];
            let bufferAttribute;
            if (attribute.isInterleavedBufferAttribute) {
                const interleavedBuffer = getInterleavedBuffer(json1.data, attribute.data);
                bufferAttribute = new $084574008ccedf86$export$920b6d07334599c7(interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized);
            } else {
                const typedArray = $084574008ccedf86$var$getTypedArray(attribute.type, attribute.array);
                const bufferAttributeConstr = attribute.isInstancedBufferAttribute ? $084574008ccedf86$export$32ea87a8b54d744a : $084574008ccedf86$export$8dea267bd6bde117;
                bufferAttribute = new bufferAttributeConstr(typedArray, attribute.itemSize, attribute.normalized);
            }
            if (attribute.name !== undefined) bufferAttribute.name = attribute.name;
            if (attribute.usage !== undefined) bufferAttribute.setUsage(attribute.usage);
            if (attribute.updateRange !== undefined) {
                bufferAttribute.updateRange.offset = attribute.updateRange.offset;
                bufferAttribute.updateRange.count = attribute.updateRange.count;
            }
            geometry.setAttribute(key, bufferAttribute);
        }
        const morphAttributes = json1.data.morphAttributes;
        if (morphAttributes) for(const key2 in morphAttributes){
            const attributeArray = morphAttributes[key2];
            const array = [];
            for(let i319 = 0, il = attributeArray.length; i319 < il; i319++){
                const attribute = attributeArray[i319];
                let bufferAttribute;
                if (attribute.isInterleavedBufferAttribute) {
                    const interleavedBuffer = getInterleavedBuffer(json1.data, attribute.data);
                    bufferAttribute = new $084574008ccedf86$export$920b6d07334599c7(interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized);
                } else {
                    const typedArray = $084574008ccedf86$var$getTypedArray(attribute.type, attribute.array);
                    bufferAttribute = new $084574008ccedf86$export$8dea267bd6bde117(typedArray, attribute.itemSize, attribute.normalized);
                }
                if (attribute.name !== undefined) bufferAttribute.name = attribute.name;
                array.push(bufferAttribute);
            }
            geometry.morphAttributes[key2] = array;
        }
        const morphTargetsRelative = json1.data.morphTargetsRelative;
        if (morphTargetsRelative) geometry.morphTargetsRelative = true;
        const groups = json1.data.groups || json1.data.drawcalls || json1.data.offsets;
        if (groups !== undefined) for(let i320 = 0, n = groups.length; i320 !== n; ++i320){
            const group = groups[i320];
            geometry.addGroup(group.start, group.count, group.materialIndex);
        }
        const boundingSphere = json1.data.boundingSphere;
        if (boundingSphere !== undefined) {
            const center = new $084574008ccedf86$export$64b5c384219d3699();
            if (boundingSphere.center !== undefined) center.fromArray(boundingSphere.center);
            geometry.boundingSphere = new $084574008ccedf86$export$805e8b72413ccaba(center, boundingSphere.radius);
        }
        if (json1.name) geometry.name = json1.name;
        if (json1.userData) geometry.userData = json1.userData;
        return geometry;
    }
}
class $084574008ccedf86$export$40110c8505c5ad19 extends $084574008ccedf86$export$3b0d6d7590275603 {
    constructor(manager){
        super(manager);
    }
    load(url, onLoad, onProgress, onError) {
        const scope = this;
        const path = this.path === "" ? $084574008ccedf86$export$b5d2dc08d867e41a.extractUrlBase(url) : this.path;
        this.resourcePath = this.resourcePath || path;
        const loader = new $084574008ccedf86$export$98435a25b5cf7b2b(this.manager);
        loader.setPath(this.path);
        loader.setRequestHeader(this.requestHeader);
        loader.setWithCredentials(this.withCredentials);
        loader.load(url, function(text) {
            let json = null;
            try {
                json = JSON.parse(text);
            } catch (error) {
                if (onError !== undefined) onError(error);
                console.error("THREE:ObjectLoader: Can't parse " + url + ".", error.message);
                return;
            }
            const metadata = json.metadata;
            if (metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === "geometry") {
                console.error("THREE.ObjectLoader: Can't load " + url);
                return;
            }
            scope.parse(json, onLoad);
        }, onProgress, onError);
    }
    async loadAsync(url, onProgress) {
        const scope = this;
        const path = this.path === "" ? $084574008ccedf86$export$b5d2dc08d867e41a.extractUrlBase(url) : this.path;
        this.resourcePath = this.resourcePath || path;
        const loader = new $084574008ccedf86$export$98435a25b5cf7b2b(this.manager);
        loader.setPath(this.path);
        loader.setRequestHeader(this.requestHeader);
        loader.setWithCredentials(this.withCredentials);
        const text = await loader.loadAsync(url, onProgress);
        const json = JSON.parse(text);
        const metadata = json.metadata;
        if (metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === "geometry") throw new Error("THREE.ObjectLoader: Can't load " + url);
        return await scope.parseAsync(json);
    }
    parse(json, onLoad) {
        const animations = this.parseAnimations(json.animations);
        const shapes = this.parseShapes(json.shapes);
        const geometries = this.parseGeometries(json.geometries, shapes);
        const images = this.parseImages(json.images, function() {
            if (onLoad !== undefined) onLoad(object);
        });
        const textures = this.parseTextures(json.textures, images);
        const materials = this.parseMaterials(json.materials, textures);
        const object = this.parseObject(json.object, geometries, materials, textures, animations);
        const skeletons = this.parseSkeletons(json.skeletons, object);
        this.bindSkeletons(object, skeletons);
        //
        if (onLoad !== undefined) {
            let hasImages = false;
            for(const uuid in images)if (images[uuid].data instanceof HTMLImageElement) {
                hasImages = true;
                break;
            }
            if (hasImages === false) onLoad(object);
        }
        return object;
    }
    async parseAsync(json) {
        const animations = this.parseAnimations(json.animations);
        const shapes = this.parseShapes(json.shapes);
        const geometries = this.parseGeometries(json.geometries, shapes);
        const images = await this.parseImagesAsync(json.images);
        const textures = this.parseTextures(json.textures, images);
        const materials = this.parseMaterials(json.materials, textures);
        const object = this.parseObject(json.object, geometries, materials, textures, animations);
        const skeletons = this.parseSkeletons(json.skeletons, object);
        this.bindSkeletons(object, skeletons);
        return object;
    }
    parseShapes(json) {
        const shapes = {};
        if (json !== undefined) for(let i321 = 0, l = json.length; i321 < l; i321++){
            const shape = new $084574008ccedf86$export$6428a7f2611ef1fa().fromJSON(json[i321]);
            shapes[shape.uuid] = shape;
        }
        return shapes;
    }
    parseSkeletons(json, object) {
        const skeletons = {};
        const bones = {};
        // generate bone lookup table
        object.traverse(function(child) {
            if (child.isBone) bones[child.uuid] = child;
        });
        // create skeletons
        if (json !== undefined) for(let i322 = 0, l = json.length; i322 < l; i322++){
            const skeleton = new $084574008ccedf86$export$8f31e4c4a37b8e9c().fromJSON(json[i322], bones);
            skeletons[skeleton.uuid] = skeleton;
        }
        return skeletons;
    }
    parseGeometries(json, shapes) {
        const geometries = {};
        if (json !== undefined) {
            const bufferGeometryLoader = new $084574008ccedf86$export$dc275bb96327833a();
            for(let i323 = 0, l = json.length; i323 < l; i323++){
                let geometry;
                const data = json[i323];
                switch(data.type){
                    case "BufferGeometry":
                    case "InstancedBufferGeometry":
                        geometry = bufferGeometryLoader.parse(data);
                        break;
                    case "Geometry":
                        console.error("THREE.ObjectLoader: The legacy Geometry type is no longer supported.");
                        break;
                    default:
                        if (data.type in $084574008ccedf86$var$Geometries) geometry = $084574008ccedf86$var$Geometries[data.type].fromJSON(data, shapes);
                        else console.warn(`THREE.ObjectLoader: Unsupported geometry type "${data.type}"`);
                }
                geometry.uuid = data.uuid;
                if (data.name !== undefined) geometry.name = data.name;
                if (geometry.isBufferGeometry === true && data.userData !== undefined) geometry.userData = data.userData;
                geometries[data.uuid] = geometry;
            }
        }
        return geometries;
    }
    parseMaterials(json, textures) {
        const cache = {}; // MultiMaterial
        const materials = {};
        if (json !== undefined) {
            const loader = new $084574008ccedf86$export$3bd6d323353dcf96();
            loader.setTextures(textures);
            for(let i324 = 0, l = json.length; i324 < l; i324++){
                const data = json[i324];
                if (data.type === "MultiMaterial") {
                    // Deprecated
                    const array = [];
                    for(let j = 0; j < data.materials.length; j++){
                        const material = data.materials[j];
                        if (cache[material.uuid] === undefined) cache[material.uuid] = loader.parse(material);
                        array.push(cache[material.uuid]);
                    }
                    materials[data.uuid] = array;
                } else {
                    if (cache[data.uuid] === undefined) cache[data.uuid] = loader.parse(data);
                    materials[data.uuid] = cache[data.uuid];
                }
            }
        }
        return materials;
    }
    parseAnimations(json) {
        const animations = {};
        if (json !== undefined) for(let i325 = 0; i325 < json.length; i325++){
            const data = json[i325];
            const clip = $084574008ccedf86$export$d942c706bf23829c.parse(data);
            animations[clip.uuid] = clip;
        }
        return animations;
    }
    parseImages(json, onLoad) {
        const scope = this;
        const images = {};
        let loader;
        function loadImage(url) {
            scope.manager.itemStart(url);
            return loader.load(url, function() {
                scope.manager.itemEnd(url);
            }, undefined, function() {
                scope.manager.itemError(url);
                scope.manager.itemEnd(url);
            });
        }
        function deserializeImage(image) {
            if (typeof image === "string") {
                const url = image;
                const path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(url) ? url : scope.resourcePath + url;
                return loadImage(path);
            } else {
                if (image.data) return {
                    data: $084574008ccedf86$var$getTypedArray(image.type, image.data),
                    width: image.width,
                    height: image.height
                };
                else return null;
            }
        }
        if (json !== undefined && json.length > 0) {
            const manager = new $084574008ccedf86$export$99cc795e99919eed(onLoad);
            loader = new $084574008ccedf86$export$8905ce1c7a2464a1(manager);
            loader.setCrossOrigin(this.crossOrigin);
            for(let i326 = 0, il = json.length; i326 < il; i326++){
                const image = json[i326];
                const url = image.url;
                if (Array.isArray(url)) {
                    // load array of images e.g CubeTexture
                    const imageArray = [];
                    for(let j = 0, jl = url.length; j < jl; j++){
                        const currentUrl = url[j];
                        const deserializedImage = deserializeImage(currentUrl);
                        if (deserializedImage !== null) {
                            if (deserializedImage instanceof HTMLImageElement) imageArray.push(deserializedImage);
                            else // special case: handle array of data textures for cube textures
                            imageArray.push(new $084574008ccedf86$export$b691f601014eabe1(deserializedImage.data, deserializedImage.width, deserializedImage.height));
                        }
                    }
                    images[image.uuid] = new $084574008ccedf86$export$1d2df86270c81ecb(imageArray);
                } else {
                    // load single image
                    const deserializedImage = deserializeImage(image.url);
                    images[image.uuid] = new $084574008ccedf86$export$1d2df86270c81ecb(deserializedImage);
                }
            }
        }
        return images;
    }
    async parseImagesAsync(json) {
        const scope = this;
        const images = {};
        let loader;
        async function deserializeImage(image) {
            if (typeof image === "string") {
                const url = image;
                const path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(url) ? url : scope.resourcePath + url;
                return await loader.loadAsync(path);
            } else {
                if (image.data) return {
                    data: $084574008ccedf86$var$getTypedArray(image.type, image.data),
                    width: image.width,
                    height: image.height
                };
                else return null;
            }
        }
        if (json !== undefined && json.length > 0) {
            loader = new $084574008ccedf86$export$8905ce1c7a2464a1(this.manager);
            loader.setCrossOrigin(this.crossOrigin);
            for(let i327 = 0, il = json.length; i327 < il; i327++){
                const image = json[i327];
                const url = image.url;
                if (Array.isArray(url)) {
                    // load array of images e.g CubeTexture
                    const imageArray = [];
                    for(let j = 0, jl = url.length; j < jl; j++){
                        const currentUrl = url[j];
                        const deserializedImage = await deserializeImage(currentUrl);
                        if (deserializedImage !== null) {
                            if (deserializedImage instanceof HTMLImageElement) imageArray.push(deserializedImage);
                            else // special case: handle array of data textures for cube textures
                            imageArray.push(new $084574008ccedf86$export$b691f601014eabe1(deserializedImage.data, deserializedImage.width, deserializedImage.height));
                        }
                    }
                    images[image.uuid] = new $084574008ccedf86$export$1d2df86270c81ecb(imageArray);
                } else {
                    // load single image
                    const deserializedImage = await deserializeImage(image.url);
                    images[image.uuid] = new $084574008ccedf86$export$1d2df86270c81ecb(deserializedImage);
                }
            }
        }
        return images;
    }
    parseTextures(json, images) {
        function parseConstant(value, type) {
            if (typeof value === "number") return value;
            console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", value);
            return type[value];
        }
        const textures = {};
        if (json !== undefined) for(let i328 = 0, l = json.length; i328 < l; i328++){
            const data = json[i328];
            if (data.image === undefined) console.warn('THREE.ObjectLoader: No "image" specified for', data.uuid);
            if (images[data.image] === undefined) console.warn("THREE.ObjectLoader: Undefined image", data.image);
            const source = images[data.image];
            const image = source.data;
            let texture;
            if (Array.isArray(image)) {
                texture = new $084574008ccedf86$export$ee2e5a18258a4049();
                if (image.length === 6) texture.needsUpdate = true;
            } else {
                if (image && image.data) texture = new $084574008ccedf86$export$b691f601014eabe1();
                else texture = new $084574008ccedf86$export$5431306cf43de24a();
                if (image) texture.needsUpdate = true; // textures can have undefined image data
            }
            texture.source = source;
            texture.uuid = data.uuid;
            if (data.name !== undefined) texture.name = data.name;
            if (data.mapping !== undefined) texture.mapping = parseConstant(data.mapping, $084574008ccedf86$var$TEXTURE_MAPPING);
            if (data.offset !== undefined) texture.offset.fromArray(data.offset);
            if (data.repeat !== undefined) texture.repeat.fromArray(data.repeat);
            if (data.center !== undefined) texture.center.fromArray(data.center);
            if (data.rotation !== undefined) texture.rotation = data.rotation;
            if (data.wrap !== undefined) {
                texture.wrapS = parseConstant(data.wrap[0], $084574008ccedf86$var$TEXTURE_WRAPPING);
                texture.wrapT = parseConstant(data.wrap[1], $084574008ccedf86$var$TEXTURE_WRAPPING);
            }
            if (data.format !== undefined) texture.format = data.format;
            if (data.type !== undefined) texture.type = data.type;
            if (data.encoding !== undefined) texture.encoding = data.encoding;
            if (data.minFilter !== undefined) texture.minFilter = parseConstant(data.minFilter, $084574008ccedf86$var$TEXTURE_FILTER);
            if (data.magFilter !== undefined) texture.magFilter = parseConstant(data.magFilter, $084574008ccedf86$var$TEXTURE_FILTER);
            if (data.anisotropy !== undefined) texture.anisotropy = data.anisotropy;
            if (data.flipY !== undefined) texture.flipY = data.flipY;
            if (data.premultiplyAlpha !== undefined) texture.premultiplyAlpha = data.premultiplyAlpha;
            if (data.unpackAlignment !== undefined) texture.unpackAlignment = data.unpackAlignment;
            if (data.userData !== undefined) texture.userData = data.userData;
            textures[data.uuid] = texture;
        }
        return textures;
    }
    parseObject(data, geometries, materials, textures, animations) {
        let object;
        function getGeometry(name) {
            if (geometries[name] === undefined) console.warn("THREE.ObjectLoader: Undefined geometry", name);
            return geometries[name];
        }
        function getMaterial(name) {
            if (name === undefined) return undefined;
            if (Array.isArray(name)) {
                const array = [];
                for(let i329 = 0, l = name.length; i329 < l; i329++){
                    const uuid = name[i329];
                    if (materials[uuid] === undefined) console.warn("THREE.ObjectLoader: Undefined material", uuid);
                    array.push(materials[uuid]);
                }
                return array;
            }
            if (materials[name] === undefined) console.warn("THREE.ObjectLoader: Undefined material", name);
            return materials[name];
        }
        function getTexture(uuid) {
            if (textures[uuid] === undefined) console.warn("THREE.ObjectLoader: Undefined texture", uuid);
            return textures[uuid];
        }
        let geometry, material;
        switch(data.type){
            case "Scene":
                object = new $084574008ccedf86$export$38af1803e3442a7f();
                if (data.background !== undefined) {
                    if (Number.isInteger(data.background)) object.background = new $084574008ccedf86$export$892596cec99bc70e(data.background);
                    else object.background = getTexture(data.background);
                }
                if (data.environment !== undefined) object.environment = getTexture(data.environment);
                if (data.fog !== undefined) {
                    if (data.fog.type === "Fog") object.fog = new $084574008ccedf86$export$3c890837b09508d4(data.fog.color, data.fog.near, data.fog.far);
                    else if (data.fog.type === "FogExp2") object.fog = new $084574008ccedf86$export$6f1519f023b8d0f6(data.fog.color, data.fog.density);
                }
                break;
            case "PerspectiveCamera":
                object = new $084574008ccedf86$export$74e4ae24825f68d7(data.fov, data.aspect, data.near, data.far);
                if (data.focus !== undefined) object.focus = data.focus;
                if (data.zoom !== undefined) object.zoom = data.zoom;
                if (data.filmGauge !== undefined) object.filmGauge = data.filmGauge;
                if (data.filmOffset !== undefined) object.filmOffset = data.filmOffset;
                if (data.view !== undefined) object.view = Object.assign({}, data.view);
                break;
            case "OrthographicCamera":
                object = new $084574008ccedf86$export$9ebf355ee4ed261b(data.left, data.right, data.top, data.bottom, data.near, data.far);
                if (data.zoom !== undefined) object.zoom = data.zoom;
                if (data.view !== undefined) object.view = Object.assign({}, data.view);
                break;
            case "AmbientLight":
                object = new $084574008ccedf86$export$af279bfef9ec2c96(data.color, data.intensity);
                break;
            case "DirectionalLight":
                object = new $084574008ccedf86$export$3fea33cc9972c868(data.color, data.intensity);
                break;
            case "PointLight":
                object = new $084574008ccedf86$export$4c9c1cb3f0b6f455(data.color, data.intensity, data.distance, data.decay);
                break;
            case "RectAreaLight":
                object = new $084574008ccedf86$export$61db2d908bbd2429(data.color, data.intensity, data.width, data.height);
                break;
            case "SpotLight":
                object = new $084574008ccedf86$export$81495cbb73897362(data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay);
                break;
            case "HemisphereLight":
                object = new $084574008ccedf86$export$8d474f55edbb9624(data.color, data.groundColor, data.intensity);
                break;
            case "LightProbe":
                object = new $084574008ccedf86$export$e7ef036e309b38d2().fromJSON(data);
                break;
            case "SkinnedMesh":
                geometry = getGeometry(data.geometry);
                material = getMaterial(data.material);
                object = new $084574008ccedf86$export$b303577035157ecf(geometry, material);
                if (data.bindMode !== undefined) object.bindMode = data.bindMode;
                if (data.bindMatrix !== undefined) object.bindMatrix.fromArray(data.bindMatrix);
                if (data.skeleton !== undefined) object.skeleton = data.skeleton;
                break;
            case "Mesh":
                geometry = getGeometry(data.geometry);
                material = getMaterial(data.material);
                object = new $084574008ccedf86$export$e176487c05830cc5(geometry, material);
                break;
            case "InstancedMesh":
                geometry = getGeometry(data.geometry);
                material = getMaterial(data.material);
                const count = data.count;
                const instanceMatrix = data.instanceMatrix;
                const instanceColor = data.instanceColor;
                object = new $084574008ccedf86$export$f3c979c331175ad7(geometry, material, count);
                object.instanceMatrix = new $084574008ccedf86$export$32ea87a8b54d744a(new Float32Array(instanceMatrix.array), 16);
                if (instanceColor !== undefined) object.instanceColor = new $084574008ccedf86$export$32ea87a8b54d744a(new Float32Array(instanceColor.array), instanceColor.itemSize);
                break;
            case "LOD":
                object = new $084574008ccedf86$export$112e7237be0c5f30();
                break;
            case "Line":
                object = new $084574008ccedf86$export$17d680238e50603e(getGeometry(data.geometry), getMaterial(data.material));
                break;
            case "LineLoop":
                object = new $084574008ccedf86$export$f85a24d745e4f17d(getGeometry(data.geometry), getMaterial(data.material));
                break;
            case "LineSegments":
                object = new $084574008ccedf86$export$ff1ed10fedfdd604(getGeometry(data.geometry), getMaterial(data.material));
                break;
            case "PointCloud":
            case "Points":
                object = new $084574008ccedf86$export$1c787534cb11aa3e(getGeometry(data.geometry), getMaterial(data.material));
                break;
            case "Sprite":
                object = new $084574008ccedf86$export$3075603db8e6204c(getMaterial(data.material));
                break;
            case "Group":
                object = new $084574008ccedf86$export$eb2fcfdbd7ba97d4();
                break;
            case "Bone":
                object = new $084574008ccedf86$export$b127726e56765aa4();
                break;
            default:
                object = new $084574008ccedf86$export$e4dd07dff30cc924();
        }
        object.uuid = data.uuid;
        if (data.name !== undefined) object.name = data.name;
        if (data.matrix !== undefined) {
            object.matrix.fromArray(data.matrix);
            if (data.matrixAutoUpdate !== undefined) object.matrixAutoUpdate = data.matrixAutoUpdate;
            if (object.matrixAutoUpdate) object.matrix.decompose(object.position, object.quaternion, object.scale);
        } else {
            if (data.position !== undefined) object.position.fromArray(data.position);
            if (data.rotation !== undefined) object.rotation.fromArray(data.rotation);
            if (data.quaternion !== undefined) object.quaternion.fromArray(data.quaternion);
            if (data.scale !== undefined) object.scale.fromArray(data.scale);
        }
        if (data.castShadow !== undefined) object.castShadow = data.castShadow;
        if (data.receiveShadow !== undefined) object.receiveShadow = data.receiveShadow;
        if (data.shadow) {
            if (data.shadow.bias !== undefined) object.shadow.bias = data.shadow.bias;
            if (data.shadow.normalBias !== undefined) object.shadow.normalBias = data.shadow.normalBias;
            if (data.shadow.radius !== undefined) object.shadow.radius = data.shadow.radius;
            if (data.shadow.mapSize !== undefined) object.shadow.mapSize.fromArray(data.shadow.mapSize);
            if (data.shadow.camera !== undefined) object.shadow.camera = this.parseObject(data.shadow.camera);
        }
        if (data.visible !== undefined) object.visible = data.visible;
        if (data.frustumCulled !== undefined) object.frustumCulled = data.frustumCulled;
        if (data.renderOrder !== undefined) object.renderOrder = data.renderOrder;
        if (data.userData !== undefined) object.userData = data.userData;
        if (data.layers !== undefined) object.layers.mask = data.layers;
        if (data.children !== undefined) {
            const children = data.children;
            for(let i330 = 0; i330 < children.length; i330++)object.add(this.parseObject(children[i330], geometries, materials, textures, animations));
        }
        if (data.animations !== undefined) {
            const objectAnimations = data.animations;
            for(let i331 = 0; i331 < objectAnimations.length; i331++){
                const uuid = objectAnimations[i331];
                object.animations.push(animations[uuid]);
            }
        }
        if (data.type === "LOD") {
            if (data.autoUpdate !== undefined) object.autoUpdate = data.autoUpdate;
            const levels = data.levels;
            for(let l = 0; l < levels.length; l++){
                const level = levels[l];
                const child = object.getObjectByProperty("uuid", level.object);
                if (child !== undefined) object.addLevel(child, level.distance);
            }
        }
        return object;
    }
    bindSkeletons(object, skeletons) {
        if (Object.keys(skeletons).length === 0) return;
        object.traverse(function(child) {
            if (child.isSkinnedMesh === true && child.skeleton !== undefined) {
                const skeleton = skeletons[child.skeleton];
                if (skeleton === undefined) console.warn("THREE.ObjectLoader: No skeleton found with UUID:", child.skeleton);
                else child.bind(skeleton, child.bindMatrix);
            }
        });
    }
    /* DEPRECATED */ setTexturePath(value) {
        console.warn("THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath().");
        return this.setResourcePath(value);
    }
}
const $084574008ccedf86$var$TEXTURE_MAPPING = {
    UVMapping: $084574008ccedf86$export$1beec6768cbb3d2d,
    CubeReflectionMapping: $084574008ccedf86$export$8759762a6477f2c4,
    CubeRefractionMapping: $084574008ccedf86$export$dc59f8aed047f61d,
    EquirectangularReflectionMapping: $084574008ccedf86$export$d64030b316d3b087,
    EquirectangularRefractionMapping: $084574008ccedf86$export$ee99d97d46898098,
    CubeUVReflectionMapping: $084574008ccedf86$export$dbf3e70ff37af79
};
const $084574008ccedf86$var$TEXTURE_WRAPPING = {
    RepeatWrapping: $084574008ccedf86$export$533346c8e8dac0f5,
    ClampToEdgeWrapping: $084574008ccedf86$export$9d9334239a5a5e06,
    MirroredRepeatWrapping: $084574008ccedf86$export$c7e7c00b14f51a4f
};
const $084574008ccedf86$var$TEXTURE_FILTER = {
    NearestFilter: $084574008ccedf86$export$727aa5ec3fe39bf0,
    NearestMipmapNearestFilter: $084574008ccedf86$export$d129e38cf6feaa8c,
    NearestMipmapLinearFilter: $084574008ccedf86$export$d2327c1afe5bfdf2,
    LinearFilter: $084574008ccedf86$export$8a72f490b25c56c8,
    LinearMipmapNearestFilter: $084574008ccedf86$export$19a719f377145a13,
    LinearMipmapLinearFilter: $084574008ccedf86$export$5d8599b6a933fb1b
};
class $084574008ccedf86$export$52286b55c4a9b51f extends $084574008ccedf86$export$3b0d6d7590275603 {
    constructor(manager){
        super(manager);
        this.isImageBitmapLoader = true;
        if (typeof createImageBitmap === "undefined") console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported.");
        if (typeof fetch === "undefined") console.warn("THREE.ImageBitmapLoader: fetch() not supported.");
        this.options = {
            premultiplyAlpha: "none"
        };
    }
    setOptions(options) {
        this.options = options;
        return this;
    }
    load(url, onLoad, onProgress, onError) {
        if (url === undefined) url = "";
        if (this.path !== undefined) url = this.path + url;
        url = this.manager.resolveURL(url);
        const scope = this;
        const cached = $084574008ccedf86$export$94affb487e701bf2.get(url);
        if (cached !== undefined) {
            scope.manager.itemStart(url);
            setTimeout(function() {
                if (onLoad) onLoad(cached);
                scope.manager.itemEnd(url);
            }, 0);
            return cached;
        }
        const fetchOptions = {};
        fetchOptions.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include";
        fetchOptions.headers = this.requestHeader;
        fetch(url, fetchOptions).then(function(res) {
            return res.blob();
        }).then(function(blob) {
            return createImageBitmap(blob, Object.assign(scope.options, {
                colorSpaceConversion: "none"
            }));
        }).then(function(imageBitmap) {
            $084574008ccedf86$export$94affb487e701bf2.add(url, imageBitmap);
            if (onLoad) onLoad(imageBitmap);
            scope.manager.itemEnd(url);
        }).catch(function(e) {
            if (onError) onError(e);
            scope.manager.itemError(url);
            scope.manager.itemEnd(url);
        });
        scope.manager.itemStart(url);
    }
}
let $084574008ccedf86$var$_context;
const $084574008ccedf86$export$fcbc63750ec2a81f = {
    getContext: function() {
        if ($084574008ccedf86$var$_context === undefined) $084574008ccedf86$var$_context = new (window.AudioContext || window.webkitAudioContext)();
        return $084574008ccedf86$var$_context;
    },
    setContext: function(value) {
        $084574008ccedf86$var$_context = value;
    }
};
class $084574008ccedf86$export$d8d5fccfbf47714e extends $084574008ccedf86$export$3b0d6d7590275603 {
    constructor(manager){
        super(manager);
    }
    load(url, onLoad, onProgress, onError) {
        const scope = this;
        const loader = new $084574008ccedf86$export$98435a25b5cf7b2b(this.manager);
        loader.setResponseType("arraybuffer");
        loader.setPath(this.path);
        loader.setRequestHeader(this.requestHeader);
        loader.setWithCredentials(this.withCredentials);
        loader.load(url, function(buffer) {
            try {
                // Create a copy of the buffer. The `decodeAudioData` method
                // detaches the buffer when complete, preventing reuse.
                const bufferCopy = buffer.slice(0);
                const context = $084574008ccedf86$export$fcbc63750ec2a81f.getContext();
                context.decodeAudioData(bufferCopy, function(audioBuffer) {
                    onLoad(audioBuffer);
                });
            } catch (e) {
                if (onError) onError(e);
                else console.error(e);
                scope.manager.itemError(url);
            }
        }, onProgress, onError);
    }
}
class $084574008ccedf86$export$2f22dadc8bc42820 extends $084574008ccedf86$export$e7ef036e309b38d2 {
    constructor(skyColor, groundColor, intensity = 1){
        super(undefined, intensity);
        this.isHemisphereLightProbe = true;
        const color1 = new $084574008ccedf86$export$892596cec99bc70e().set(skyColor);
        const color2 = new $084574008ccedf86$export$892596cec99bc70e().set(groundColor);
        const sky = new $084574008ccedf86$export$64b5c384219d3699(color1.r, color1.g, color1.b);
        const ground = new $084574008ccedf86$export$64b5c384219d3699(color2.r, color2.g, color2.b);
        // without extra factor of PI in the shader, should = 1 / Math.sqrt( Math.PI );
        const c0 = Math.sqrt(Math.PI);
        const c1 = c0 * Math.sqrt(0.75);
        this.sh.coefficients[0].copy(sky).add(ground).multiplyScalar(c0);
        this.sh.coefficients[1].copy(sky).sub(ground).multiplyScalar(c1);
    }
}
class $084574008ccedf86$export$afe310a21c86023d extends $084574008ccedf86$export$e7ef036e309b38d2 {
    constructor(color, intensity = 1){
        super(undefined, intensity);
        this.isAmbientLightProbe = true;
        const color1 = new $084574008ccedf86$export$892596cec99bc70e().set(color);
        // without extra factor of PI in the shader, would be 2 / Math.sqrt( Math.PI );
        this.sh.coefficients[0].set(color1.r, color1.g, color1.b).multiplyScalar(2 * Math.sqrt(Math.PI));
    }
}
const $084574008ccedf86$var$_eyeRight = /*@__PURE__*/ new $084574008ccedf86$export$2ae72fc923e5eb5();
const $084574008ccedf86$var$_eyeLeft = /*@__PURE__*/ new $084574008ccedf86$export$2ae72fc923e5eb5();
const $084574008ccedf86$var$_projectionMatrix = /*@__PURE__*/ new $084574008ccedf86$export$2ae72fc923e5eb5();
class $084574008ccedf86$export$bc7f73a1065bee0c {
    constructor(){
        this.type = "StereoCamera";
        this.aspect = 1;
        this.eyeSep = 0.064;
        this.cameraL = new $084574008ccedf86$export$74e4ae24825f68d7();
        this.cameraL.layers.enable(1);
        this.cameraL.matrixAutoUpdate = false;
        this.cameraR = new $084574008ccedf86$export$74e4ae24825f68d7();
        this.cameraR.layers.enable(2);
        this.cameraR.matrixAutoUpdate = false;
        this._cache = {
            focus: null,
            fov: null,
            aspect: null,
            near: null,
            far: null,
            zoom: null,
            eyeSep: null
        };
    }
    update(camera) {
        const cache = this._cache;
        const needsUpdate = cache.focus !== camera.focus || cache.fov !== camera.fov || cache.aspect !== camera.aspect * this.aspect || cache.near !== camera.near || cache.far !== camera.far || cache.zoom !== camera.zoom || cache.eyeSep !== this.eyeSep;
        if (needsUpdate) {
            cache.focus = camera.focus;
            cache.fov = camera.fov;
            cache.aspect = camera.aspect * this.aspect;
            cache.near = camera.near;
            cache.far = camera.far;
            cache.zoom = camera.zoom;
            cache.eyeSep = this.eyeSep;
            // Off-axis stereoscopic effect based on
            // http://paulbourke.net/stereographics/stereorender/
            $084574008ccedf86$var$_projectionMatrix.copy(camera.projectionMatrix);
            const eyeSepHalf = cache.eyeSep / 2;
            const eyeSepOnProjection = eyeSepHalf * cache.near / cache.focus;
            const ymax = cache.near * Math.tan($084574008ccedf86$var$DEG2RAD * cache.fov * 0.5) / cache.zoom;
            let xmin, xmax;
            // translate xOffset
            $084574008ccedf86$var$_eyeLeft.elements[12] = -eyeSepHalf;
            $084574008ccedf86$var$_eyeRight.elements[12] = eyeSepHalf;
            // for left eye
            xmin = -ymax * cache.aspect + eyeSepOnProjection;
            xmax = ymax * cache.aspect + eyeSepOnProjection;
            $084574008ccedf86$var$_projectionMatrix.elements[0] = 2 * cache.near / (xmax - xmin);
            $084574008ccedf86$var$_projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
            this.cameraL.projectionMatrix.copy($084574008ccedf86$var$_projectionMatrix);
            // for right eye
            xmin = -ymax * cache.aspect - eyeSepOnProjection;
            xmax = ymax * cache.aspect - eyeSepOnProjection;
            $084574008ccedf86$var$_projectionMatrix.elements[0] = 2 * cache.near / (xmax - xmin);
            $084574008ccedf86$var$_projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
            this.cameraR.projectionMatrix.copy($084574008ccedf86$var$_projectionMatrix);
        }
        this.cameraL.matrixWorld.copy(camera.matrixWorld).multiply($084574008ccedf86$var$_eyeLeft);
        this.cameraR.matrixWorld.copy(camera.matrixWorld).multiply($084574008ccedf86$var$_eyeRight);
    }
}
class $084574008ccedf86$export$9735c82c4bae3302 {
    constructor(autoStart = true){
        this.autoStart = autoStart;
        this.startTime = 0;
        this.oldTime = 0;
        this.elapsedTime = 0;
        this.running = false;
    }
    start() {
        this.startTime = $084574008ccedf86$var$now();
        this.oldTime = this.startTime;
        this.elapsedTime = 0;
        this.running = true;
    }
    stop() {
        this.getElapsedTime();
        this.running = false;
        this.autoStart = false;
    }
    getElapsedTime() {
        this.getDelta();
        return this.elapsedTime;
    }
    getDelta() {
        let diff = 0;
        if (this.autoStart && !this.running) {
            this.start();
            return 0;
        }
        if (this.running) {
            const newTime = $084574008ccedf86$var$now();
            diff = (newTime - this.oldTime) / 1000;
            this.oldTime = newTime;
            this.elapsedTime += diff;
        }
        return diff;
    }
}
function $084574008ccedf86$var$now() {
    return (typeof performance === "undefined" ? Date : performance).now(); // see #10732
}
const $084574008ccedf86$var$_position$1 = /*@__PURE__*/ new $084574008ccedf86$export$64b5c384219d3699();
const $084574008ccedf86$var$_quaternion$1 = /*@__PURE__*/ new $084574008ccedf86$export$23d6a54f0bbc85a3();
const $084574008ccedf86$var$_scale$1 = /*@__PURE__*/ new $084574008ccedf86$export$64b5c384219d3699();
const $084574008ccedf86$var$_orientation$1 = /*@__PURE__*/ new $084574008ccedf86$export$64b5c384219d3699();
class $084574008ccedf86$export$8a1b810c6fde8951 extends $084574008ccedf86$export$e4dd07dff30cc924 {
    constructor(){
        super();
        this.type = "AudioListener";
        this.context = $084574008ccedf86$export$fcbc63750ec2a81f.getContext();
        this.gain = this.context.createGain();
        this.gain.connect(this.context.destination);
        this.filter = null;
        this.timeDelta = 0;
        // private
        this._clock = new $084574008ccedf86$export$9735c82c4bae3302();
    }
    getInput() {
        return this.gain;
    }
    removeFilter() {
        if (this.filter !== null) {
            this.gain.disconnect(this.filter);
            this.filter.disconnect(this.context.destination);
            this.gain.connect(this.context.destination);
            this.filter = null;
        }
        return this;
    }
    getFilter() {
        return this.filter;
    }
    setFilter(value) {
        if (this.filter !== null) {
            this.gain.disconnect(this.filter);
            this.filter.disconnect(this.context.destination);
        } else this.gain.disconnect(this.context.destination);
        this.filter = value;
        this.gain.connect(this.filter);
        this.filter.connect(this.context.destination);
        return this;
    }
    getMasterVolume() {
        return this.gain.gain.value;
    }
    setMasterVolume(value) {
        this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
        return this;
    }
    updateMatrixWorld(force) {
        super.updateMatrixWorld(force);
        const listener = this.context.listener;
        const up = this.up;
        this.timeDelta = this._clock.getDelta();
        this.matrixWorld.decompose($084574008ccedf86$var$_position$1, $084574008ccedf86$var$_quaternion$1, $084574008ccedf86$var$_scale$1);
        $084574008ccedf86$var$_orientation$1.set(0, 0, -1).applyQuaternion($084574008ccedf86$var$_quaternion$1);
        if (listener.positionX) {
            // code path for Chrome (see #14393)
            const endTime = this.context.currentTime + this.timeDelta;
            listener.positionX.linearRampToValueAtTime($084574008ccedf86$var$_position$1.x, endTime);
            listener.positionY.linearRampToValueAtTime($084574008ccedf86$var$_position$1.y, endTime);
            listener.positionZ.linearRampToValueAtTime($084574008ccedf86$var$_position$1.z, endTime);
            listener.forwardX.linearRampToValueAtTime($084574008ccedf86$var$_orientation$1.x, endTime);
            listener.forwardY.linearRampToValueAtTime($084574008ccedf86$var$_orientation$1.y, endTime);
            listener.forwardZ.linearRampToValueAtTime($084574008ccedf86$var$_orientation$1.z, endTime);
            listener.upX.linearRampToValueAtTime(up.x, endTime);
            listener.upY.linearRampToValueAtTime(up.y, endTime);
            listener.upZ.linearRampToValueAtTime(up.z, endTime);
        } else {
            listener.setPosition($084574008ccedf86$var$_position$1.x, $084574008ccedf86$var$_position$1.y, $084574008ccedf86$var$_position$1.z);
            listener.setOrientation($084574008ccedf86$var$_orientation$1.x, $084574008ccedf86$var$_orientation$1.y, $084574008ccedf86$var$_orientation$1.z, up.x, up.y, up.z);
        }
    }
}
class $084574008ccedf86$export$153755f98d9861de extends $084574008ccedf86$export$e4dd07dff30cc924 {
    constructor(listener){
        super();
        this.type = "Audio";
        this.listener = listener;
        this.context = listener.context;
        this.gain = this.context.createGain();
        this.gain.connect(listener.getInput());
        this.autoplay = false;
        this.buffer = null;
        this.detune = 0;
        this.loop = false;
        this.loopStart = 0;
        this.loopEnd = 0;
        this.offset = 0;
        this.duration = undefined;
        this.playbackRate = 1;
        this.isPlaying = false;
        this.hasPlaybackControl = true;
        this.source = null;
        this.sourceType = "empty";
        this._startedAt = 0;
        this._progress = 0;
        this._connected = false;
        this.filters = [];
    }
    getOutput() {
        return this.gain;
    }
    setNodeSource(audioNode) {
        this.hasPlaybackControl = false;
        this.sourceType = "audioNode";
        this.source = audioNode;
        this.connect();
        return this;
    }
    setMediaElementSource(mediaElement) {
        this.hasPlaybackControl = false;
        this.sourceType = "mediaNode";
        this.source = this.context.createMediaElementSource(mediaElement);
        this.connect();
        return this;
    }
    setMediaStreamSource(mediaStream) {
        this.hasPlaybackControl = false;
        this.sourceType = "mediaStreamNode";
        this.source = this.context.createMediaStreamSource(mediaStream);
        this.connect();
        return this;
    }
    setBuffer(audioBuffer) {
        this.buffer = audioBuffer;
        this.sourceType = "buffer";
        if (this.autoplay) this.play();
        return this;
    }
    play(delay = 0) {
        if (this.isPlaying === true) {
            console.warn("THREE.Audio: Audio is already playing.");
            return;
        }
        if (this.hasPlaybackControl === false) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return;
        }
        this._startedAt = this.context.currentTime + delay;
        const source = this.context.createBufferSource();
        source.buffer = this.buffer;
        source.loop = this.loop;
        source.loopStart = this.loopStart;
        source.loopEnd = this.loopEnd;
        source.onended = this.onEnded.bind(this);
        source.start(this._startedAt, this._progress + this.offset, this.duration);
        this.isPlaying = true;
        this.source = source;
        this.setDetune(this.detune);
        this.setPlaybackRate(this.playbackRate);
        return this.connect();
    }
    pause() {
        if (this.hasPlaybackControl === false) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return;
        }
        if (this.isPlaying === true) {
            // update current progress
            this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate;
            if (this.loop === true) // ensure _progress does not exceed duration with looped audios
            this._progress = this._progress % (this.duration || this.buffer.duration);
            this.source.stop();
            this.source.onended = null;
            this.isPlaying = false;
        }
        return this;
    }
    stop() {
        if (this.hasPlaybackControl === false) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return;
        }
        this._progress = 0;
        this.source.stop();
        this.source.onended = null;
        this.isPlaying = false;
        return this;
    }
    connect() {
        if (this.filters.length > 0) {
            this.source.connect(this.filters[0]);
            for(let i332 = 1, l = this.filters.length; i332 < l; i332++)this.filters[i332 - 1].connect(this.filters[i332]);
            this.filters[this.filters.length - 1].connect(this.getOutput());
        } else this.source.connect(this.getOutput());
        this._connected = true;
        return this;
    }
    disconnect() {
        if (this.filters.length > 0) {
            this.source.disconnect(this.filters[0]);
            for(let i333 = 1, l = this.filters.length; i333 < l; i333++)this.filters[i333 - 1].disconnect(this.filters[i333]);
            this.filters[this.filters.length - 1].disconnect(this.getOutput());
        } else this.source.disconnect(this.getOutput());
        this._connected = false;
        return this;
    }
    getFilters() {
        return this.filters;
    }
    setFilters(value) {
        if (!value) value = [];
        if (this._connected === true) {
            this.disconnect();
            this.filters = value.slice();
            this.connect();
        } else this.filters = value.slice();
        return this;
    }
    setDetune(value) {
        this.detune = value;
        if (this.source.detune === undefined) return; // only set detune when available
        if (this.isPlaying === true) this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01);
        return this;
    }
    getDetune() {
        return this.detune;
    }
    getFilter() {
        return this.getFilters()[0];
    }
    setFilter(filter) {
        return this.setFilters(filter ? [
            filter
        ] : []);
    }
    setPlaybackRate(value) {
        if (this.hasPlaybackControl === false) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return;
        }
        this.playbackRate = value;
        if (this.isPlaying === true) this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01);
        return this;
    }
    getPlaybackRate() {
        return this.playbackRate;
    }
    onEnded() {
        this.isPlaying = false;
    }
    getLoop() {
        if (this.hasPlaybackControl === false) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return false;
        }
        return this.loop;
    }
    setLoop(value) {
        if (this.hasPlaybackControl === false) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return;
        }
        this.loop = value;
        if (this.isPlaying === true) this.source.loop = this.loop;
        return this;
    }
    setLoopStart(value) {
        this.loopStart = value;
        return this;
    }
    setLoopEnd(value) {
        this.loopEnd = value;
        return this;
    }
    getVolume() {
        return this.gain.gain.value;
    }
    setVolume(value) {
        this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
        return this;
    }
}
const $084574008ccedf86$var$_position = /*@__PURE__*/ new $084574008ccedf86$export$64b5c384219d3699();
const $084574008ccedf86$var$_quaternion = /*@__PURE__*/ new $084574008ccedf86$export$23d6a54f0bbc85a3();
const $084574008ccedf86$var$_scale = /*@__PURE__*/ new $084574008ccedf86$export$64b5c384219d3699();
const $084574008ccedf86$var$_orientation = /*@__PURE__*/ new $084574008ccedf86$export$64b5c384219d3699();
class $084574008ccedf86$export$4b3e397ef1832507 extends $084574008ccedf86$export$153755f98d9861de {
    constructor(listener){
        super(listener);
        this.panner = this.context.createPanner();
        this.panner.panningModel = "HRTF";
        this.panner.connect(this.gain);
    }
    disconnect() {
        super.disconnect();
        this.panner.disconnect(this.gain);
    }
    getOutput() {
        return this.panner;
    }
    getRefDistance() {
        return this.panner.refDistance;
    }
    setRefDistance(value) {
        this.panner.refDistance = value;
        return this;
    }
    getRolloffFactor() {
        return this.panner.rolloffFactor;
    }
    setRolloffFactor(value) {
        this.panner.rolloffFactor = value;
        return this;
    }
    getDistanceModel() {
        return this.panner.distanceModel;
    }
    setDistanceModel(value) {
        this.panner.distanceModel = value;
        return this;
    }
    getMaxDistance() {
        return this.panner.maxDistance;
    }
    setMaxDistance(value) {
        this.panner.maxDistance = value;
        return this;
    }
    setDirectionalCone(coneInnerAngle, coneOuterAngle, coneOuterGain) {
        this.panner.coneInnerAngle = coneInnerAngle;
        this.panner.coneOuterAngle = coneOuterAngle;
        this.panner.coneOuterGain = coneOuterGain;
        return this;
    }
    updateMatrixWorld(force) {
        super.updateMatrixWorld(force);
        if (this.hasPlaybackControl === true && this.isPlaying === false) return;
        this.matrixWorld.decompose($084574008ccedf86$var$_position, $084574008ccedf86$var$_quaternion, $084574008ccedf86$var$_scale);
        $084574008ccedf86$var$_orientation.set(0, 0, 1).applyQuaternion($084574008ccedf86$var$_quaternion);
        const panner = this.panner;
        if (panner.positionX) {
            // code path for Chrome and Firefox (see #14393)
            const endTime = this.context.currentTime + this.listener.timeDelta;
            panner.positionX.linearRampToValueAtTime($084574008ccedf86$var$_position.x, endTime);
            panner.positionY.linearRampToValueAtTime($084574008ccedf86$var$_position.y, endTime);
            panner.positionZ.linearRampToValueAtTime($084574008ccedf86$var$_position.z, endTime);
            panner.orientationX.linearRampToValueAtTime($084574008ccedf86$var$_orientation.x, endTime);
            panner.orientationY.linearRampToValueAtTime($084574008ccedf86$var$_orientation.y, endTime);
            panner.orientationZ.linearRampToValueAtTime($084574008ccedf86$var$_orientation.z, endTime);
        } else {
            panner.setPosition($084574008ccedf86$var$_position.x, $084574008ccedf86$var$_position.y, $084574008ccedf86$var$_position.z);
            panner.setOrientation($084574008ccedf86$var$_orientation.x, $084574008ccedf86$var$_orientation.y, $084574008ccedf86$var$_orientation.z);
        }
    }
}
class $084574008ccedf86$export$d47da1ef3d382827 {
    constructor(audio, fftSize = 2048){
        this.analyser = audio.context.createAnalyser();
        this.analyser.fftSize = fftSize;
        this.data = new Uint8Array(this.analyser.frequencyBinCount);
        audio.getOutput().connect(this.analyser);
    }
    getFrequencyData() {
        this.analyser.getByteFrequencyData(this.data);
        return this.data;
    }
    getAverageFrequency() {
        let value = 0;
        const data = this.getFrequencyData();
        for(let i334 = 0; i334 < data.length; i334++)value += data[i334];
        return value / data.length;
    }
}
class $084574008ccedf86$export$dfe0af1ca1acb78a {
    constructor(binding, typeName, valueSize){
        this.binding = binding;
        this.valueSize = valueSize;
        let mixFunction, mixFunctionAdditive, setIdentity;
        // buffer layout: [ incoming | accu0 | accu1 | orig | addAccu | (optional work) ]
        //
        // interpolators can use .buffer as their .result
        // the data then goes to 'incoming'
        //
        // 'accu0' and 'accu1' are used frame-interleaved for
        // the cumulative result and are compared to detect
        // changes
        //
        // 'orig' stores the original state of the property
        //
        // 'add' is used for additive cumulative results
        //
        // 'work' is optional and is only present for quaternion types. It is used
        // to store intermediate quaternion multiplication results
        switch(typeName){
            case "quaternion":
                mixFunction = this._slerp;
                mixFunctionAdditive = this._slerpAdditive;
                setIdentity = this._setAdditiveIdentityQuaternion;
                this.buffer = new Float64Array(valueSize * 6);
                this._workIndex = 5;
                break;
            case "string":
            case "bool":
                mixFunction = this._select;
                // Use the regular mix function and for additive on these types,
                // additive is not relevant for non-numeric types
                mixFunctionAdditive = this._select;
                setIdentity = this._setAdditiveIdentityOther;
                this.buffer = new Array(valueSize * 5);
                break;
            default:
                mixFunction = this._lerp;
                mixFunctionAdditive = this._lerpAdditive;
                setIdentity = this._setAdditiveIdentityNumeric;
                this.buffer = new Float64Array(valueSize * 5);
        }
        this._mixBufferRegion = mixFunction;
        this._mixBufferRegionAdditive = mixFunctionAdditive;
        this._setIdentity = setIdentity;
        this._origIndex = 3;
        this._addIndex = 4;
        this.cumulativeWeight = 0;
        this.cumulativeWeightAdditive = 0;
        this.useCount = 0;
        this.referenceCount = 0;
    }
    // accumulate data in the 'incoming' region into 'accu<i>'
    accumulate(accuIndex, weight) {
        // note: happily accumulating nothing when weight = 0, the caller knows
        // the weight and shouldn't have made the call in the first place
        const buffer = this.buffer, stride = this.valueSize, offset = accuIndex * stride + stride;
        let currentWeight = this.cumulativeWeight;
        if (currentWeight === 0) {
            // accuN := incoming * weight
            for(let i335 = 0; i335 !== stride; ++i335)buffer[offset + i335] = buffer[i335];
            currentWeight = weight;
        } else {
            // accuN := accuN + incoming * weight
            currentWeight += weight;
            const mix = weight / currentWeight;
            this._mixBufferRegion(buffer, offset, 0, mix, stride);
        }
        this.cumulativeWeight = currentWeight;
    }
    // accumulate data in the 'incoming' region into 'add'
    accumulateAdditive(weight) {
        const buffer = this.buffer, stride = this.valueSize, offset = stride * this._addIndex;
        if (this.cumulativeWeightAdditive === 0) // add = identity
        this._setIdentity();
        // add := add + incoming * weight
        this._mixBufferRegionAdditive(buffer, offset, 0, weight, stride);
        this.cumulativeWeightAdditive += weight;
    }
    // apply the state of 'accu<i>' to the binding when accus differ
    apply(accuIndex) {
        const stride = this.valueSize, buffer = this.buffer, offset = accuIndex * stride + stride, weight = this.cumulativeWeight, weightAdditive = this.cumulativeWeightAdditive, binding = this.binding;
        this.cumulativeWeight = 0;
        this.cumulativeWeightAdditive = 0;
        if (weight < 1) {
            // accuN := accuN + original * ( 1 - cumulativeWeight )
            const originalValueOffset = stride * this._origIndex;
            this._mixBufferRegion(buffer, offset, originalValueOffset, 1 - weight, stride);
        }
        if (weightAdditive > 0) // accuN := accuN + additive accuN
        this._mixBufferRegionAdditive(buffer, offset, this._addIndex * stride, 1, stride);
        for(let i336 = stride, e = stride + stride; i336 !== e; ++i336)if (buffer[i336] !== buffer[i336 + stride]) {
            // value has changed -> update scene graph
            binding.setValue(buffer, offset);
            break;
        }
    }
    // remember the state of the bound property and copy it to both accus
    saveOriginalState() {
        const binding = this.binding;
        const buffer = this.buffer, stride = this.valueSize, originalValueOffset = stride * this._origIndex;
        binding.getValue(buffer, originalValueOffset);
        // accu[0..1] := orig -- initially detect changes against the original
        for(let i337 = stride, e = originalValueOffset; i337 !== e; ++i337)buffer[i337] = buffer[originalValueOffset + i337 % stride];
        // Add to identity for additive
        this._setIdentity();
        this.cumulativeWeight = 0;
        this.cumulativeWeightAdditive = 0;
    }
    // apply the state previously taken via 'saveOriginalState' to the binding
    restoreOriginalState() {
        const originalValueOffset = this.valueSize * 3;
        this.binding.setValue(this.buffer, originalValueOffset);
    }
    _setAdditiveIdentityNumeric() {
        const startIndex = this._addIndex * this.valueSize;
        const endIndex = startIndex + this.valueSize;
        for(let i338 = startIndex; i338 < endIndex; i338++)this.buffer[i338] = 0;
    }
    _setAdditiveIdentityQuaternion() {
        this._setAdditiveIdentityNumeric();
        this.buffer[this._addIndex * this.valueSize + 3] = 1;
    }
    _setAdditiveIdentityOther() {
        const startIndex = this._origIndex * this.valueSize;
        const targetIndex = this._addIndex * this.valueSize;
        for(let i339 = 0; i339 < this.valueSize; i339++)this.buffer[targetIndex + i339] = this.buffer[startIndex + i339];
    }
    // mix functions
    _select(buffer, dstOffset, srcOffset, t, stride) {
        if (t >= 0.5) for(let i340 = 0; i340 !== stride; ++i340)buffer[dstOffset + i340] = buffer[srcOffset + i340];
    }
    _slerp(buffer, dstOffset, srcOffset, t) {
        $084574008ccedf86$export$23d6a54f0bbc85a3.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t);
    }
    _slerpAdditive(buffer, dstOffset, srcOffset, t, stride) {
        const workOffset = this._workIndex * stride;
        // Store result in intermediate buffer offset
        $084574008ccedf86$export$23d6a54f0bbc85a3.multiplyQuaternionsFlat(buffer, workOffset, buffer, dstOffset, buffer, srcOffset);
        // Slerp to the intermediate result
        $084574008ccedf86$export$23d6a54f0bbc85a3.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, workOffset, t);
    }
    _lerp(buffer, dstOffset, srcOffset, t, stride) {
        const s = 1 - t;
        for(let i341 = 0; i341 !== stride; ++i341){
            const j = dstOffset + i341;
            buffer[j] = buffer[j] * s + buffer[srcOffset + i341] * t;
        }
    }
    _lerpAdditive(buffer, dstOffset, srcOffset, t, stride) {
        for(let i342 = 0; i342 !== stride; ++i342){
            const j = dstOffset + i342;
            buffer[j] = buffer[j] + buffer[srcOffset + i342] * t;
        }
    }
}
// Characters [].:/ are reserved for track binding syntax.
const $084574008ccedf86$var$_RESERVED_CHARS_RE = "\\[\\]\\.:\\/";
const $084574008ccedf86$var$_reservedRe = new RegExp("[" + $084574008ccedf86$var$_RESERVED_CHARS_RE + "]", "g");
// Attempts to allow node names from any language. ES5's `\w` regexp matches
// only latin characters, and the unicode \p{L} is not yet supported. So
// instead, we exclude reserved characters and match everything else.
const $084574008ccedf86$var$_wordChar = "[^" + $084574008ccedf86$var$_RESERVED_CHARS_RE + "]";
const $084574008ccedf86$var$_wordCharOrDot = "[^" + $084574008ccedf86$var$_RESERVED_CHARS_RE.replace("\\.", "") + "]";
// Parent directories, delimited by '/' or ':'. Currently unused, but must
// be matched to parse the rest of the track name.
const $084574008ccedf86$var$_directoryRe = /((?:WC+[\/:])*)/.source.replace("WC", $084574008ccedf86$var$_wordChar);
// Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.
const $084574008ccedf86$var$_nodeRe = /(WCOD+)?/.source.replace("WCOD", $084574008ccedf86$var$_wordCharOrDot);
// Object on target node, and accessor. May not contain reserved
// characters. Accessor may contain any character except closing bracket.
const $084574008ccedf86$var$_objectRe = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", $084574008ccedf86$var$_wordChar);
// Property and accessor. May not contain reserved characters. Accessor may
// contain any non-bracket characters.
const $084574008ccedf86$var$_propertyRe = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", $084574008ccedf86$var$_wordChar);
const $084574008ccedf86$var$_trackRe = new RegExp("^" + $084574008ccedf86$var$_directoryRe + $084574008ccedf86$var$_nodeRe + $084574008ccedf86$var$_objectRe + $084574008ccedf86$var$_propertyRe + "$");
const $084574008ccedf86$var$_supportedObjectNames = [
    "material",
    "materials",
    "bones"
];
class $084574008ccedf86$var$Composite {
    constructor(targetGroup, path, optionalParsedPath){
        const parsedPath = optionalParsedPath || $084574008ccedf86$export$7bf70fcf9f891893.parseTrackName(path);
        this._targetGroup = targetGroup;
        this._bindings = targetGroup.subscribe_(path, parsedPath);
    }
    getValue(array, offset) {
        this.bind(); // bind all binding
        const firstValidIndex = this._targetGroup.nCachedObjects_, binding = this._bindings[firstValidIndex];
        // and only call .getValue on the first
        if (binding !== undefined) binding.getValue(array, offset);
    }
    setValue(array, offset) {
        const bindings = this._bindings;
        for(let i343 = this._targetGroup.nCachedObjects_, n = bindings.length; i343 !== n; ++i343)bindings[i343].setValue(array, offset);
    }
    bind() {
        const bindings = this._bindings;
        for(let i344 = this._targetGroup.nCachedObjects_, n = bindings.length; i344 !== n; ++i344)bindings[i344].bind();
    }
    unbind() {
        const bindings = this._bindings;
        for(let i345 = this._targetGroup.nCachedObjects_, n = bindings.length; i345 !== n; ++i345)bindings[i345].unbind();
    }
}
// Note: This class uses a State pattern on a per-method basis:
// 'bind' sets 'this.getValue' / 'setValue' and shadows the
// prototype version of these methods with one that represents
// the bound state. When the property is not found, the methods
// become no-ops.
class $084574008ccedf86$export$7bf70fcf9f891893 {
    constructor(rootNode, path, parsedPath){
        this.path = path;
        this.parsedPath = parsedPath || $084574008ccedf86$export$7bf70fcf9f891893.parseTrackName(path);
        this.node = $084574008ccedf86$export$7bf70fcf9f891893.findNode(rootNode, this.parsedPath.nodeName) || rootNode;
        this.rootNode = rootNode;
        // initial state of these methods that calls 'bind'
        this.getValue = this._getValue_unbound;
        this.setValue = this._setValue_unbound;
    }
    static create(root, path, parsedPath) {
        if (!(root && root.isAnimationObjectGroup)) return new $084574008ccedf86$export$7bf70fcf9f891893(root, path, parsedPath);
        else return new $084574008ccedf86$export$7bf70fcf9f891893.Composite(root, path, parsedPath);
    }
    /**
	 * Replaces spaces with underscores and removes unsupported characters from
	 * node names, to ensure compatibility with parseTrackName().
	 *
	 * @param {string} name Node name to be sanitized.
	 * @return {string}
	 */ static sanitizeNodeName(name) {
        return name.replace(/\s/g, "_").replace($084574008ccedf86$var$_reservedRe, "");
    }
    static parseTrackName(trackName) {
        const matches = $084574008ccedf86$var$_trackRe.exec(trackName);
        if (matches === null) throw new Error("PropertyBinding: Cannot parse trackName: " + trackName);
        const results = {
            // directoryName: matches[ 1 ], // (tschw) currently unused
            nodeName: matches[2],
            objectName: matches[3],
            objectIndex: matches[4],
            propertyName: matches[5],
            propertyIndex: matches[6]
        };
        const lastDot = results.nodeName && results.nodeName.lastIndexOf(".");
        if (lastDot !== undefined && lastDot !== -1) {
            const objectName = results.nodeName.substring(lastDot + 1);
            // Object names must be checked against an allowlist. Otherwise, there
            // is no way to parse 'foo.bar.baz': 'baz' must be a property, but
            // 'bar' could be the objectName, or part of a nodeName (which can
            // include '.' characters).
            if ($084574008ccedf86$var$_supportedObjectNames.indexOf(objectName) !== -1) {
                results.nodeName = results.nodeName.substring(0, lastDot);
                results.objectName = objectName;
            }
        }
        if (results.propertyName === null || results.propertyName.length === 0) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + trackName);
        return results;
    }
    static findNode(root, nodeName) {
        if (nodeName === undefined || nodeName === "" || nodeName === "." || nodeName === -1 || nodeName === root.name || nodeName === root.uuid) return root;
        // search into skeleton bones.
        if (root.skeleton) {
            const bone = root.skeleton.getBoneByName(nodeName);
            if (bone !== undefined) return bone;
        }
        // search into node subtree.
        if (root.children) {
            const searchNodeSubtree = function(children) {
                for(let i346 = 0; i346 < children.length; i346++){
                    const childNode = children[i346];
                    if (childNode.name === nodeName || childNode.uuid === nodeName) return childNode;
                    const result = searchNodeSubtree(childNode.children);
                    if (result) return result;
                }
                return null;
            };
            const subTreeNode = searchNodeSubtree(root.children);
            if (subTreeNode) return subTreeNode;
        }
        return null;
    }
    // these are used to "bind" a nonexistent property
    _getValue_unavailable() {}
    _setValue_unavailable() {}
    // Getters
    _getValue_direct(buffer, offset) {
        buffer[offset] = this.targetObject[this.propertyName];
    }
    _getValue_array(buffer, offset) {
        const source = this.resolvedProperty;
        for(let i347 = 0, n = source.length; i347 !== n; ++i347)buffer[offset++] = source[i347];
    }
    _getValue_arrayElement(buffer, offset) {
        buffer[offset] = this.resolvedProperty[this.propertyIndex];
    }
    _getValue_toArray(buffer, offset) {
        this.resolvedProperty.toArray(buffer, offset);
    }
    // Direct
    _setValue_direct(buffer, offset) {
        this.targetObject[this.propertyName] = buffer[offset];
    }
    _setValue_direct_setNeedsUpdate(buffer, offset) {
        this.targetObject[this.propertyName] = buffer[offset];
        this.targetObject.needsUpdate = true;
    }
    _setValue_direct_setMatrixWorldNeedsUpdate(buffer, offset) {
        this.targetObject[this.propertyName] = buffer[offset];
        this.targetObject.matrixWorldNeedsUpdate = true;
    }
    // EntireArray
    _setValue_array(buffer, offset) {
        const dest = this.resolvedProperty;
        for(let i348 = 0, n = dest.length; i348 !== n; ++i348)dest[i348] = buffer[offset++];
    }
    _setValue_array_setNeedsUpdate(buffer, offset) {
        const dest = this.resolvedProperty;
        for(let i349 = 0, n = dest.length; i349 !== n; ++i349)dest[i349] = buffer[offset++];
        this.targetObject.needsUpdate = true;
    }
    _setValue_array_setMatrixWorldNeedsUpdate(buffer, offset) {
        const dest = this.resolvedProperty;
        for(let i350 = 0, n = dest.length; i350 !== n; ++i350)dest[i350] = buffer[offset++];
        this.targetObject.matrixWorldNeedsUpdate = true;
    }
    // ArrayElement
    _setValue_arrayElement(buffer, offset) {
        this.resolvedProperty[this.propertyIndex] = buffer[offset];
    }
    _setValue_arrayElement_setNeedsUpdate(buffer, offset) {
        this.resolvedProperty[this.propertyIndex] = buffer[offset];
        this.targetObject.needsUpdate = true;
    }
    _setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer, offset) {
        this.resolvedProperty[this.propertyIndex] = buffer[offset];
        this.targetObject.matrixWorldNeedsUpdate = true;
    }
    // HasToFromArray
    _setValue_fromArray(buffer, offset) {
        this.resolvedProperty.fromArray(buffer, offset);
    }
    _setValue_fromArray_setNeedsUpdate(buffer, offset) {
        this.resolvedProperty.fromArray(buffer, offset);
        this.targetObject.needsUpdate = true;
    }
    _setValue_fromArray_setMatrixWorldNeedsUpdate(buffer, offset) {
        this.resolvedProperty.fromArray(buffer, offset);
        this.targetObject.matrixWorldNeedsUpdate = true;
    }
    _getValue_unbound(targetArray, offset) {
        this.bind();
        this.getValue(targetArray, offset);
    }
    _setValue_unbound(sourceArray, offset) {
        this.bind();
        this.setValue(sourceArray, offset);
    }
    // create getter / setter pair for a property in the scene graph
    bind() {
        let targetObject = this.node;
        const parsedPath = this.parsedPath;
        const objectName = parsedPath.objectName;
        const propertyName = parsedPath.propertyName;
        let propertyIndex = parsedPath.propertyIndex;
        if (!targetObject) {
            targetObject = $084574008ccedf86$export$7bf70fcf9f891893.findNode(this.rootNode, parsedPath.nodeName) || this.rootNode;
            this.node = targetObject;
        }
        // set fail state so we can just 'return' on error
        this.getValue = this._getValue_unavailable;
        this.setValue = this._setValue_unavailable;
        // ensure there is a value node
        if (!targetObject) {
            console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
            return;
        }
        if (objectName) {
            let objectIndex = parsedPath.objectIndex;
            // special cases were we need to reach deeper into the hierarchy to get the face materials....
            switch(objectName){
                case "materials":
                    if (!targetObject.material) {
                        console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                        return;
                    }
                    if (!targetObject.material.materials) {
                        console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                        return;
                    }
                    targetObject = targetObject.material.materials;
                    break;
                case "bones":
                    if (!targetObject.skeleton) {
                        console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                        return;
                    }
                    // potential future optimization: skip this if propertyIndex is already an integer
                    // and convert the integer string to a true integer.
                    targetObject = targetObject.skeleton.bones;
                    // support resolving morphTarget names into indices.
                    for(let i351 = 0; i351 < targetObject.length; i351++)if (targetObject[i351].name === objectIndex) {
                        objectIndex = i351;
                        break;
                    }
                    break;
                default:
                    if (targetObject[objectName] === undefined) {
                        console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                        return;
                    }
                    targetObject = targetObject[objectName];
            }
            if (objectIndex !== undefined) {
                if (targetObject[objectIndex] === undefined) {
                    console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, targetObject);
                    return;
                }
                targetObject = targetObject[objectIndex];
            }
        }
        // resolve property
        const nodeProperty = targetObject[propertyName];
        if (nodeProperty === undefined) {
            const nodeName = parsedPath.nodeName;
            console.error("THREE.PropertyBinding: Trying to update property for track: " + nodeName + "." + propertyName + " but it wasn't found.", targetObject);
            return;
        }
        // determine versioning scheme
        let versioning = this.Versioning.None;
        this.targetObject = targetObject;
        if (targetObject.needsUpdate !== undefined) versioning = this.Versioning.NeedsUpdate;
        else if (targetObject.matrixWorldNeedsUpdate !== undefined) versioning = this.Versioning.MatrixWorldNeedsUpdate;
        // determine how the property gets bound
        let bindingType = this.BindingType.Direct;
        if (propertyIndex !== undefined) {
            // access a sub element of the property array (only primitives are supported right now)
            if (propertyName === "morphTargetInfluences") {
                // potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.
                // support resolving morphTarget names into indices.
                if (!targetObject.geometry) {
                    console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                    return;
                }
                if (!targetObject.geometry.morphAttributes) {
                    console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                    return;
                }
                if (targetObject.morphTargetDictionary[propertyIndex] !== undefined) propertyIndex = targetObject.morphTargetDictionary[propertyIndex];
            }
            bindingType = this.BindingType.ArrayElement;
            this.resolvedProperty = nodeProperty;
            this.propertyIndex = propertyIndex;
        } else if (nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined) {
            // must use copy for Object3D.Euler/Quaternion
            bindingType = this.BindingType.HasFromToArray;
            this.resolvedProperty = nodeProperty;
        } else if (Array.isArray(nodeProperty)) {
            bindingType = this.BindingType.EntireArray;
            this.resolvedProperty = nodeProperty;
        } else this.propertyName = propertyName;
        // select getter / setter
        this.getValue = this.GetterByBindingType[bindingType];
        this.setValue = this.SetterByBindingTypeAndVersioning[bindingType][versioning];
    }
    unbind() {
        this.node = null;
        // back to the prototype version of getValue / setValue
        // note: avoiding to mutate the shape of 'this' via 'delete'
        this.getValue = this._getValue_unbound;
        this.setValue = this._setValue_unbound;
    }
}
$084574008ccedf86$export$7bf70fcf9f891893.Composite = $084574008ccedf86$var$Composite;
$084574008ccedf86$export$7bf70fcf9f891893.prototype.BindingType = {
    Direct: 0,
    EntireArray: 1,
    ArrayElement: 2,
    HasFromToArray: 3
};
$084574008ccedf86$export$7bf70fcf9f891893.prototype.Versioning = {
    None: 0,
    NeedsUpdate: 1,
    MatrixWorldNeedsUpdate: 2
};
$084574008ccedf86$export$7bf70fcf9f891893.prototype.GetterByBindingType = [
    $084574008ccedf86$export$7bf70fcf9f891893.prototype._getValue_direct,
    $084574008ccedf86$export$7bf70fcf9f891893.prototype._getValue_array,
    $084574008ccedf86$export$7bf70fcf9f891893.prototype._getValue_arrayElement,
    $084574008ccedf86$export$7bf70fcf9f891893.prototype._getValue_toArray, 
];
$084574008ccedf86$export$7bf70fcf9f891893.prototype.SetterByBindingTypeAndVersioning = [
    [
        // Direct
        $084574008ccedf86$export$7bf70fcf9f891893.prototype._setValue_direct,
        $084574008ccedf86$export$7bf70fcf9f891893.prototype._setValue_direct_setNeedsUpdate,
        $084574008ccedf86$export$7bf70fcf9f891893.prototype._setValue_direct_setMatrixWorldNeedsUpdate, 
    ],
    [
        // EntireArray
        $084574008ccedf86$export$7bf70fcf9f891893.prototype._setValue_array,
        $084574008ccedf86$export$7bf70fcf9f891893.prototype._setValue_array_setNeedsUpdate,
        $084574008ccedf86$export$7bf70fcf9f891893.prototype._setValue_array_setMatrixWorldNeedsUpdate, 
    ],
    [
        // ArrayElement
        $084574008ccedf86$export$7bf70fcf9f891893.prototype._setValue_arrayElement,
        $084574008ccedf86$export$7bf70fcf9f891893.prototype._setValue_arrayElement_setNeedsUpdate,
        $084574008ccedf86$export$7bf70fcf9f891893.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate, 
    ],
    [
        // HasToFromArray
        $084574008ccedf86$export$7bf70fcf9f891893.prototype._setValue_fromArray,
        $084574008ccedf86$export$7bf70fcf9f891893.prototype._setValue_fromArray_setNeedsUpdate,
        $084574008ccedf86$export$7bf70fcf9f891893.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate, 
    ]
];
/**
 *
 * A group of objects that receives a shared animation state.
 *
 * Usage:
 *
 *  - Add objects you would otherwise pass as 'root' to the
 *    constructor or the .clipAction method of AnimationMixer.
 *
 *  - Instead pass this object as 'root'.
 *
 *  - You can also add and remove objects later when the mixer
 *    is running.
 *
 * Note:
 *
 *    Objects of this class appear as one object to the mixer,
 *    so cache control of the individual objects must be done
 *    on the group.
 *
 * Limitation:
 *
 *  - The animated properties must be compatible among the
 *    all objects in the group.
 *
 *  - A single property can either be controlled through a
 *    target group or directly, but not both.
 */ class $084574008ccedf86$export$30619c2afd3f34db {
    constructor(){
        this.isAnimationObjectGroup = true;
        this.uuid = $084574008ccedf86$var$generateUUID();
        // cached objects followed by the active ones
        this._objects = Array.prototype.slice.call(arguments);
        this.nCachedObjects_ = 0; // threshold
        // note: read by PropertyBinding.Composite
        const indices = {};
        this._indicesByUUID = indices; // for bookkeeping
        for(let i352 = 0, n = arguments.length; i352 !== n; ++i352)indices[arguments[i352].uuid] = i352;
        this._paths = []; // inside: string
        this._parsedPaths = []; // inside: { we don't care, here }
        this._bindings = []; // inside: Array< PropertyBinding >
        this._bindingsIndicesByPath = {}; // inside: indices in these arrays
        const scope = this;
        this.stats = {
            objects: {
                get total () {
                    return scope._objects.length;
                },
                get inUse () {
                    return this.total - scope.nCachedObjects_;
                }
            },
            get bindingsPerObject () {
                return scope._bindings.length;
            }
        };
    }
    add() {
        const objects = this._objects, indicesByUUID = this._indicesByUUID, paths = this._paths, parsedPaths = this._parsedPaths, bindings = this._bindings, nBindings = bindings.length;
        let knownObject = undefined, nObjects = objects.length, nCachedObjects = this.nCachedObjects_;
        for(let i353 = 0, n = arguments.length; i353 !== n; ++i353){
            const object = arguments[i353], uuid = object.uuid;
            let index = indicesByUUID[uuid];
            if (index === undefined) {
                // unknown object -> add it to the ACTIVE region
                index = nObjects++;
                indicesByUUID[uuid] = index;
                objects.push(object);
                // accounting is done, now do the same for all bindings
                for(let j = 0, m = nBindings; j !== m; ++j)bindings[j].push(new $084574008ccedf86$export$7bf70fcf9f891893(object, paths[j], parsedPaths[j]));
            } else if (index < nCachedObjects) {
                knownObject = objects[index];
                // move existing object to the ACTIVE region
                const firstActiveIndex = --nCachedObjects, lastCachedObject = objects[firstActiveIndex];
                indicesByUUID[lastCachedObject.uuid] = index;
                objects[index] = lastCachedObject;
                indicesByUUID[uuid] = firstActiveIndex;
                objects[firstActiveIndex] = object;
                // accounting is done, now do the same for all bindings
                for(let j = 0, m = nBindings; j !== m; ++j){
                    const bindingsForPath = bindings[j], lastCached = bindingsForPath[firstActiveIndex];
                    let binding = bindingsForPath[index];
                    bindingsForPath[index] = lastCached;
                    if (binding === undefined) // since we do not bother to create new bindings
                    // for objects that are cached, the binding may
                    // or may not exist
                    binding = new $084574008ccedf86$export$7bf70fcf9f891893(object, paths[j], parsedPaths[j]);
                    bindingsForPath[firstActiveIndex] = binding;
                }
            } else if (objects[index] !== knownObject) console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.");
             // else the object is already where we want it to be
        } // for arguments
        this.nCachedObjects_ = nCachedObjects;
    }
    remove() {
        const objects = this._objects, indicesByUUID = this._indicesByUUID, bindings = this._bindings, nBindings = bindings.length;
        let nCachedObjects = this.nCachedObjects_;
        for(let i354 = 0, n = arguments.length; i354 !== n; ++i354){
            const object = arguments[i354], uuid = object.uuid, index = indicesByUUID[uuid];
            if (index !== undefined && index >= nCachedObjects) {
                // move existing object into the CACHED region
                const lastCachedIndex = nCachedObjects++, firstActiveObject = objects[lastCachedIndex];
                indicesByUUID[firstActiveObject.uuid] = index;
                objects[index] = firstActiveObject;
                indicesByUUID[uuid] = lastCachedIndex;
                objects[lastCachedIndex] = object;
                // accounting is done, now do the same for all bindings
                for(let j = 0, m = nBindings; j !== m; ++j){
                    const bindingsForPath = bindings[j], firstActive = bindingsForPath[lastCachedIndex], binding = bindingsForPath[index];
                    bindingsForPath[index] = firstActive;
                    bindingsForPath[lastCachedIndex] = binding;
                }
            }
        } // for arguments
        this.nCachedObjects_ = nCachedObjects;
    }
    // remove & forget
    uncache() {
        const objects = this._objects, indicesByUUID = this._indicesByUUID, bindings = this._bindings, nBindings = bindings.length;
        let nCachedObjects = this.nCachedObjects_, nObjects = objects.length;
        for(let i355 = 0, n = arguments.length; i355 !== n; ++i355){
            const object = arguments[i355], uuid = object.uuid, index = indicesByUUID[uuid];
            if (index !== undefined) {
                delete indicesByUUID[uuid];
                if (index < nCachedObjects) {
                    // object is cached, shrink the CACHED region
                    const firstActiveIndex = --nCachedObjects, lastCachedObject = objects[firstActiveIndex], lastIndex = --nObjects, lastObject = objects[lastIndex];
                    // last cached object takes this object's place
                    indicesByUUID[lastCachedObject.uuid] = index;
                    objects[index] = lastCachedObject;
                    // last object goes to the activated slot and pop
                    indicesByUUID[lastObject.uuid] = firstActiveIndex;
                    objects[firstActiveIndex] = lastObject;
                    objects.pop();
                    // accounting is done, now do the same for all bindings
                    for(let j = 0, m = nBindings; j !== m; ++j){
                        const bindingsForPath = bindings[j], lastCached = bindingsForPath[firstActiveIndex], last = bindingsForPath[lastIndex];
                        bindingsForPath[index] = lastCached;
                        bindingsForPath[firstActiveIndex] = last;
                        bindingsForPath.pop();
                    }
                } else {
                    // object is active, just swap with the last and pop
                    const lastIndex = --nObjects, lastObject = objects[lastIndex];
                    if (lastIndex > 0) indicesByUUID[lastObject.uuid] = index;
                    objects[index] = lastObject;
                    objects.pop();
                    // accounting is done, now do the same for all bindings
                    for(let j = 0, m = nBindings; j !== m; ++j){
                        const bindingsForPath = bindings[j];
                        bindingsForPath[index] = bindingsForPath[lastIndex];
                        bindingsForPath.pop();
                    }
                } // cached or active
            } // if object is known
        } // for arguments
        this.nCachedObjects_ = nCachedObjects;
    }
    // Internal interface used by befriended PropertyBinding.Composite:
    subscribe_(path, parsedPath) {
        // returns an array of bindings for the given path that is changed
        // according to the contained objects in the group
        const indicesByPath = this._bindingsIndicesByPath;
        let index = indicesByPath[path];
        const bindings = this._bindings;
        if (index !== undefined) return bindings[index];
        const paths = this._paths, parsedPaths = this._parsedPaths, objects = this._objects, nObjects = objects.length, nCachedObjects = this.nCachedObjects_, bindingsForPath = new Array(nObjects);
        index = bindings.length;
        indicesByPath[path] = index;
        paths.push(path);
        parsedPaths.push(parsedPath);
        bindings.push(bindingsForPath);
        for(let i356 = nCachedObjects, n = objects.length; i356 !== n; ++i356){
            const object = objects[i356];
            bindingsForPath[i356] = new $084574008ccedf86$export$7bf70fcf9f891893(object, path, parsedPath);
        }
        return bindingsForPath;
    }
    unsubscribe_(path) {
        // tells the group to forget about a property path and no longer
        // update the array previously obtained with 'subscribe_'
        const indicesByPath = this._bindingsIndicesByPath, index = indicesByPath[path];
        if (index !== undefined) {
            const paths = this._paths, parsedPaths = this._parsedPaths, bindings = this._bindings, lastBindingsIndex = bindings.length - 1, lastBindings = bindings[lastBindingsIndex], lastBindingsPath = path[lastBindingsIndex];
            indicesByPath[lastBindingsPath] = index;
            bindings[index] = lastBindings;
            bindings.pop();
            parsedPaths[index] = parsedPaths[lastBindingsIndex];
            parsedPaths.pop();
            paths[index] = paths[lastBindingsIndex];
            paths.pop();
        }
    }
}
class $084574008ccedf86$var$AnimationAction {
    constructor(mixer, clip, localRoot = null, blendMode = clip.blendMode){
        this._mixer = mixer;
        this._clip = clip;
        this._localRoot = localRoot;
        this.blendMode = blendMode;
        const tracks = clip.tracks, nTracks = tracks.length, interpolants = new Array(nTracks);
        const interpolantSettings = {
            endingStart: $084574008ccedf86$export$7f795934b84ab523,
            endingEnd: $084574008ccedf86$export$7f795934b84ab523
        };
        for(let i357 = 0; i357 !== nTracks; ++i357){
            const interpolant = tracks[i357].createInterpolant(null);
            interpolants[i357] = interpolant;
            interpolant.settings = interpolantSettings;
        }
        this._interpolantSettings = interpolantSettings;
        this._interpolants = interpolants; // bound by the mixer
        // inside: PropertyMixer (managed by the mixer)
        this._propertyBindings = new Array(nTracks);
        this._cacheIndex = null; // for the memory manager
        this._byClipCacheIndex = null; // for the memory manager
        this._timeScaleInterpolant = null;
        this._weightInterpolant = null;
        this.loop = $084574008ccedf86$export$dfaf4422ce096e29;
        this._loopCount = -1;
        // global mixer time when the action is to be started
        // it's set back to 'null' upon start of the action
        this._startTime = null;
        // scaled local time of the action
        // gets clamped or wrapped to 0..clip.duration according to loop
        this.time = 0;
        this.timeScale = 1;
        this._effectiveTimeScale = 1;
        this.weight = 1;
        this._effectiveWeight = 1;
        this.repetitions = Infinity; // no. of repetitions when looping
        this.paused = false; // true -> zero effective time scale
        this.enabled = true; // false -> zero effective weight
        this.clampWhenFinished = false; // keep feeding the last frame?
        this.zeroSlopeAtStart = true; // for smooth interpolation w/o separate
        this.zeroSlopeAtEnd = true; // clips for start, loop and end
    }
    // State & Scheduling
    play() {
        this._mixer._activateAction(this);
        return this;
    }
    stop() {
        this._mixer._deactivateAction(this);
        return this.reset();
    }
    reset() {
        this.paused = false;
        this.enabled = true;
        this.time = 0; // restart clip
        this._loopCount = -1; // forget previous loops
        this._startTime = null; // forget scheduling
        return this.stopFading().stopWarping();
    }
    isRunning() {
        return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
    }
    // return true when play has been called
    isScheduled() {
        return this._mixer._isActiveAction(this);
    }
    startAt(time) {
        this._startTime = time;
        return this;
    }
    setLoop(mode, repetitions) {
        this.loop = mode;
        this.repetitions = repetitions;
        return this;
    }
    // Weight
    // set the weight stopping any scheduled fading
    // although .enabled = false yields an effective weight of zero, this
    // method does *not* change .enabled, because it would be confusing
    setEffectiveWeight(weight) {
        this.weight = weight;
        // note: same logic as when updated at runtime
        this._effectiveWeight = this.enabled ? weight : 0;
        return this.stopFading();
    }
    // return the weight considering fading and .enabled
    getEffectiveWeight() {
        return this._effectiveWeight;
    }
    fadeIn(duration) {
        return this._scheduleFading(duration, 0, 1);
    }
    fadeOut(duration) {
        return this._scheduleFading(duration, 1, 0);
    }
    crossFadeFrom(fadeOutAction, duration, warp) {
        fadeOutAction.fadeOut(duration);
        this.fadeIn(duration);
        if (warp) {
            const fadeInDuration = this._clip.duration, fadeOutDuration = fadeOutAction._clip.duration, startEndRatio = fadeOutDuration / fadeInDuration, endStartRatio = fadeInDuration / fadeOutDuration;
            fadeOutAction.warp(1.0, startEndRatio, duration);
            this.warp(endStartRatio, 1.0, duration);
        }
        return this;
    }
    crossFadeTo(fadeInAction, duration, warp) {
        return fadeInAction.crossFadeFrom(this, duration, warp);
    }
    stopFading() {
        const weightInterpolant = this._weightInterpolant;
        if (weightInterpolant !== null) {
            this._weightInterpolant = null;
            this._mixer._takeBackControlInterpolant(weightInterpolant);
        }
        return this;
    }
    // Time Scale Control
    // set the time scale stopping any scheduled warping
    // although .paused = true yields an effective time scale of zero, this
    // method does *not* change .paused, because it would be confusing
    setEffectiveTimeScale(timeScale) {
        this.timeScale = timeScale;
        this._effectiveTimeScale = this.paused ? 0 : timeScale;
        return this.stopWarping();
    }
    // return the time scale considering warping and .paused
    getEffectiveTimeScale() {
        return this._effectiveTimeScale;
    }
    setDuration(duration) {
        this.timeScale = this._clip.duration / duration;
        return this.stopWarping();
    }
    syncWith(action) {
        this.time = action.time;
        this.timeScale = action.timeScale;
        return this.stopWarping();
    }
    halt(duration) {
        return this.warp(this._effectiveTimeScale, 0, duration);
    }
    warp(startTimeScale, endTimeScale, duration) {
        const mixer = this._mixer, now1 = mixer.time, timeScale = this.timeScale;
        let interpolant = this._timeScaleInterpolant;
        if (interpolant === null) {
            interpolant = mixer._lendControlInterpolant();
            this._timeScaleInterpolant = interpolant;
        }
        const times = interpolant.parameterPositions, values = interpolant.sampleValues;
        times[0] = now1;
        times[1] = now1 + duration;
        values[0] = startTimeScale / timeScale;
        values[1] = endTimeScale / timeScale;
        return this;
    }
    stopWarping() {
        const timeScaleInterpolant = this._timeScaleInterpolant;
        if (timeScaleInterpolant !== null) {
            this._timeScaleInterpolant = null;
            this._mixer._takeBackControlInterpolant(timeScaleInterpolant);
        }
        return this;
    }
    // Object Accessors
    getMixer() {
        return this._mixer;
    }
    getClip() {
        return this._clip;
    }
    getRoot() {
        return this._localRoot || this._mixer._root;
    }
    // Interna
    _update(time, deltaTime, timeDirection, accuIndex) {
        // called by the mixer
        if (!this.enabled) {
            // call ._updateWeight() to update ._effectiveWeight
            this._updateWeight(time);
            return;
        }
        const startTime = this._startTime;
        if (startTime !== null) {
            // check for scheduled start of action
            const timeRunning = (time - startTime) * timeDirection;
            if (timeRunning < 0 || timeDirection === 0) return; // yet to come / don't decide when delta = 0
            // start
            this._startTime = null; // unschedule
            deltaTime = timeDirection * timeRunning;
        }
        // apply time scale and advance time
        deltaTime *= this._updateTimeScale(time);
        const clipTime = this._updateTime(deltaTime);
        // note: _updateTime may disable the action resulting in
        // an effective weight of 0
        const weight = this._updateWeight(time);
        if (weight > 0) {
            const interpolants = this._interpolants;
            const propertyMixers = this._propertyBindings;
            switch(this.blendMode){
                case $084574008ccedf86$export$d875e029ef558d3:
                    for(let j = 0, m = interpolants.length; j !== m; ++j){
                        interpolants[j].evaluate(clipTime);
                        propertyMixers[j].accumulateAdditive(weight);
                    }
                    break;
                case $084574008ccedf86$export$bcfbbdcf8de7f8cd:
                default:
                    for(let j5 = 0, m1 = interpolants.length; j5 !== m1; ++j5){
                        interpolants[j5].evaluate(clipTime);
                        propertyMixers[j5].accumulate(accuIndex, weight);
                    }
            }
        }
    }
    _updateWeight(time) {
        let weight = 0;
        if (this.enabled) {
            weight = this.weight;
            const interpolant = this._weightInterpolant;
            if (interpolant !== null) {
                const interpolantValue = interpolant.evaluate(time)[0];
                weight *= interpolantValue;
                if (time > interpolant.parameterPositions[1]) {
                    this.stopFading();
                    if (interpolantValue === 0) // faded out, disable
                    this.enabled = false;
                }
            }
        }
        this._effectiveWeight = weight;
        return weight;
    }
    _updateTimeScale(time) {
        let timeScale = 0;
        if (!this.paused) {
            timeScale = this.timeScale;
            const interpolant = this._timeScaleInterpolant;
            if (interpolant !== null) {
                const interpolantValue = interpolant.evaluate(time)[0];
                timeScale *= interpolantValue;
                if (time > interpolant.parameterPositions[1]) {
                    this.stopWarping();
                    if (timeScale === 0) // motion has halted, pause
                    this.paused = true;
                    else // warp done - apply final time scale
                    this.timeScale = timeScale;
                }
            }
        }
        this._effectiveTimeScale = timeScale;
        return timeScale;
    }
    _updateTime(deltaTime) {
        const duration = this._clip.duration;
        const loop = this.loop;
        let time = this.time + deltaTime;
        let loopCount = this._loopCount;
        const pingPong = loop === $084574008ccedf86$export$f8f6f2041b78e210;
        if (deltaTime === 0) {
            if (loopCount === -1) return time;
            return pingPong && (loopCount & 1) === 1 ? duration - time : time;
        }
        if (loop === $084574008ccedf86$export$d62fdc9d1b1cccad) {
            if (loopCount === -1) {
                // just started
                this._loopCount = 0;
                this._setEndings(true, true, false);
            }
            handle_stop: {
                if (time >= duration) time = duration;
                else if (time < 0) time = 0;
                else {
                    this.time = time;
                    break handle_stop;
                }
                if (this.clampWhenFinished) this.paused = true;
                else this.enabled = false;
                this.time = time;
                this._mixer.dispatchEvent({
                    type: "finished",
                    action: this,
                    direction: deltaTime < 0 ? -1 : 1
                });
            }
        } else {
            if (loopCount === -1) {
                // just started
                if (deltaTime >= 0) {
                    loopCount = 0;
                    this._setEndings(true, this.repetitions === 0, pingPong);
                } else // when looping in reverse direction, the initial
                // transition through zero counts as a repetition,
                // so leave loopCount at -1
                this._setEndings(this.repetitions === 0, true, pingPong);
            }
            if (time >= duration || time < 0) {
                // wrap around
                const loopDelta = Math.floor(time / duration); // signed
                time -= duration * loopDelta;
                loopCount += Math.abs(loopDelta);
                const pending = this.repetitions - loopCount;
                if (pending <= 0) {
                    // have to stop (switch state, clamp time, fire event)
                    if (this.clampWhenFinished) this.paused = true;
                    else this.enabled = false;
                    time = deltaTime > 0 ? duration : 0;
                    this.time = time;
                    this._mixer.dispatchEvent({
                        type: "finished",
                        action: this,
                        direction: deltaTime > 0 ? 1 : -1
                    });
                } else {
                    // keep running
                    if (pending === 1) {
                        // entering the last round
                        const atStart = deltaTime < 0;
                        this._setEndings(atStart, !atStart, pingPong);
                    } else this._setEndings(false, false, pingPong);
                    this._loopCount = loopCount;
                    this.time = time;
                    this._mixer.dispatchEvent({
                        type: "loop",
                        action: this,
                        loopDelta: loopDelta
                    });
                }
            } else this.time = time;
            if (pingPong && (loopCount & 1) === 1) // invert time for the "pong round"
            return duration - time;
        }
        return time;
    }
    _setEndings(atStart, atEnd, pingPong) {
        const settings = this._interpolantSettings;
        if (pingPong) {
            settings.endingStart = $084574008ccedf86$export$24a4ccb5099273b5;
            settings.endingEnd = $084574008ccedf86$export$24a4ccb5099273b5;
        } else {
            // assuming for LoopOnce atStart == atEnd == true
            if (atStart) settings.endingStart = this.zeroSlopeAtStart ? $084574008ccedf86$export$24a4ccb5099273b5 : $084574008ccedf86$export$7f795934b84ab523;
            else settings.endingStart = $084574008ccedf86$export$8e8c3ecdcd8e1fee;
            if (atEnd) settings.endingEnd = this.zeroSlopeAtEnd ? $084574008ccedf86$export$24a4ccb5099273b5 : $084574008ccedf86$export$7f795934b84ab523;
            else settings.endingEnd = $084574008ccedf86$export$8e8c3ecdcd8e1fee;
        }
    }
    _scheduleFading(duration, weightNow, weightThen) {
        const mixer = this._mixer, now2 = mixer.time;
        let interpolant = this._weightInterpolant;
        if (interpolant === null) {
            interpolant = mixer._lendControlInterpolant();
            this._weightInterpolant = interpolant;
        }
        const times = interpolant.parameterPositions, values = interpolant.sampleValues;
        times[0] = now2;
        values[0] = weightNow;
        times[1] = now2 + duration;
        values[1] = weightThen;
        return this;
    }
}
const $084574008ccedf86$var$_controlInterpolantsResultBuffer = /*@__PURE__*/ new Float32Array(1);
class $084574008ccedf86$export$fbd77e5aefaa0102 extends $084574008ccedf86$export$ec8b666c5fe2c75a {
    constructor(root){
        super();
        this._root = root;
        this._initMemoryManager();
        this._accuIndex = 0;
        this.time = 0;
        this.timeScale = 1.0;
    }
    _bindAction(action, prototypeAction) {
        const root = action._localRoot || this._root, tracks = action._clip.tracks, nTracks = tracks.length, bindings = action._propertyBindings, interpolants = action._interpolants, rootUuid = root.uuid, bindingsByRoot = this._bindingsByRootAndName;
        let bindingsByName = bindingsByRoot[rootUuid];
        if (bindingsByName === undefined) {
            bindingsByName = {};
            bindingsByRoot[rootUuid] = bindingsByName;
        }
        for(let i358 = 0; i358 !== nTracks; ++i358){
            const track = tracks[i358], trackName = track.name;
            let binding = bindingsByName[trackName];
            if (binding !== undefined) {
                ++binding.referenceCount;
                bindings[i358] = binding;
            } else {
                binding = bindings[i358];
                if (binding !== undefined) {
                    // existing binding, make sure the cache knows
                    if (binding._cacheIndex === null) {
                        ++binding.referenceCount;
                        this._addInactiveBinding(binding, rootUuid, trackName);
                    }
                    continue;
                }
                const path = prototypeAction && prototypeAction._propertyBindings[i358].binding.parsedPath;
                binding = new $084574008ccedf86$export$dfe0af1ca1acb78a($084574008ccedf86$export$7bf70fcf9f891893.create(root, trackName, path), track.ValueTypeName, track.getValueSize());
                ++binding.referenceCount;
                this._addInactiveBinding(binding, rootUuid, trackName);
                bindings[i358] = binding;
            }
            interpolants[i358].resultBuffer = binding.buffer;
        }
    }
    _activateAction(action) {
        if (!this._isActiveAction(action)) {
            if (action._cacheIndex === null) {
                // this action has been forgotten by the cache, but the user
                // appears to be still using it -> rebind
                const rootUuid = (action._localRoot || this._root).uuid, clipUuid = action._clip.uuid, actionsForClip = this._actionsByClip[clipUuid];
                this._bindAction(action, actionsForClip && actionsForClip.knownActions[0]);
                this._addInactiveAction(action, clipUuid, rootUuid);
            }
            const bindings = action._propertyBindings;
            // increment reference counts / sort out state
            for(let i359 = 0, n = bindings.length; i359 !== n; ++i359){
                const binding = bindings[i359];
                if ((binding.useCount++) === 0) {
                    this._lendBinding(binding);
                    binding.saveOriginalState();
                }
            }
            this._lendAction(action);
        }
    }
    _deactivateAction(action) {
        if (this._isActiveAction(action)) {
            const bindings = action._propertyBindings;
            // decrement reference counts / sort out state
            for(let i360 = 0, n = bindings.length; i360 !== n; ++i360){
                const binding = bindings[i360];
                if (--binding.useCount === 0) {
                    binding.restoreOriginalState();
                    this._takeBackBinding(binding);
                }
            }
            this._takeBackAction(action);
        }
    }
    // Memory manager
    _initMemoryManager() {
        this._actions = []; // 'nActiveActions' followed by inactive ones
        this._nActiveActions = 0;
        this._actionsByClip = {};
        // inside:
        // {
        // 	knownActions: Array< AnimationAction > - used as prototypes
        // 	actionByRoot: AnimationAction - lookup
        // }
        this._bindings = []; // 'nActiveBindings' followed by inactive ones
        this._nActiveBindings = 0;
        this._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >
        this._controlInterpolants = []; // same game as above
        this._nActiveControlInterpolants = 0;
        const scope = this;
        this.stats = {
            actions: {
                get total () {
                    return scope._actions.length;
                },
                get inUse () {
                    return scope._nActiveActions;
                }
            },
            bindings: {
                get total () {
                    return scope._bindings.length;
                },
                get inUse () {
                    return scope._nActiveBindings;
                }
            },
            controlInterpolants: {
                get total () {
                    return scope._controlInterpolants.length;
                },
                get inUse () {
                    return scope._nActiveControlInterpolants;
                }
            }
        };
    }
    // Memory management for AnimationAction objects
    _isActiveAction(action) {
        const index = action._cacheIndex;
        return index !== null && index < this._nActiveActions;
    }
    _addInactiveAction(action, clipUuid, rootUuid) {
        const actions = this._actions, actionsByClip = this._actionsByClip;
        let actionsForClip = actionsByClip[clipUuid];
        if (actionsForClip === undefined) {
            actionsForClip = {
                knownActions: [
                    action
                ],
                actionByRoot: {}
            };
            action._byClipCacheIndex = 0;
            actionsByClip[clipUuid] = actionsForClip;
        } else {
            const knownActions = actionsForClip.knownActions;
            action._byClipCacheIndex = knownActions.length;
            knownActions.push(action);
        }
        action._cacheIndex = actions.length;
        actions.push(action);
        actionsForClip.actionByRoot[rootUuid] = action;
    }
    _removeInactiveAction(action) {
        const actions = this._actions, lastInactiveAction = actions[actions.length - 1], cacheIndex = action._cacheIndex;
        lastInactiveAction._cacheIndex = cacheIndex;
        actions[cacheIndex] = lastInactiveAction;
        actions.pop();
        action._cacheIndex = null;
        const clipUuid = action._clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid], knownActionsForClip = actionsForClip.knownActions, lastKnownAction = knownActionsForClip[knownActionsForClip.length - 1], byClipCacheIndex = action._byClipCacheIndex;
        lastKnownAction._byClipCacheIndex = byClipCacheIndex;
        knownActionsForClip[byClipCacheIndex] = lastKnownAction;
        knownActionsForClip.pop();
        action._byClipCacheIndex = null;
        const actionByRoot = actionsForClip.actionByRoot, rootUuid = (action._localRoot || this._root).uuid;
        delete actionByRoot[rootUuid];
        if (knownActionsForClip.length === 0) delete actionsByClip[clipUuid];
        this._removeInactiveBindingsForAction(action);
    }
    _removeInactiveBindingsForAction(action) {
        const bindings = action._propertyBindings;
        for(let i361 = 0, n = bindings.length; i361 !== n; ++i361){
            const binding = bindings[i361];
            if (--binding.referenceCount === 0) this._removeInactiveBinding(binding);
        }
    }
    _lendAction(action) {
        // [ active actions |  inactive actions  ]
        // [  active actions >| inactive actions ]
        //                 s        a
        //                  <-swap->
        //                 a        s
        const actions = this._actions, prevIndex = action._cacheIndex, lastActiveIndex = this._nActiveActions++, firstInactiveAction = actions[lastActiveIndex];
        action._cacheIndex = lastActiveIndex;
        actions[lastActiveIndex] = action;
        firstInactiveAction._cacheIndex = prevIndex;
        actions[prevIndex] = firstInactiveAction;
    }
    _takeBackAction(action) {
        // [  active actions  | inactive actions ]
        // [ active actions |< inactive actions  ]
        //        a        s
        //         <-swap->
        //        s        a
        const actions = this._actions, prevIndex = action._cacheIndex, firstInactiveIndex = --this._nActiveActions, lastActiveAction = actions[firstInactiveIndex];
        action._cacheIndex = firstInactiveIndex;
        actions[firstInactiveIndex] = action;
        lastActiveAction._cacheIndex = prevIndex;
        actions[prevIndex] = lastActiveAction;
    }
    // Memory management for PropertyMixer objects
    _addInactiveBinding(binding, rootUuid, trackName) {
        const bindingsByRoot = this._bindingsByRootAndName, bindings = this._bindings;
        let bindingByName = bindingsByRoot[rootUuid];
        if (bindingByName === undefined) {
            bindingByName = {};
            bindingsByRoot[rootUuid] = bindingByName;
        }
        bindingByName[trackName] = binding;
        binding._cacheIndex = bindings.length;
        bindings.push(binding);
    }
    _removeInactiveBinding(binding) {
        const bindings = this._bindings, propBinding = binding.binding, rootUuid = propBinding.rootNode.uuid, trackName = propBinding.path, bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid], lastInactiveBinding = bindings[bindings.length - 1], cacheIndex = binding._cacheIndex;
        lastInactiveBinding._cacheIndex = cacheIndex;
        bindings[cacheIndex] = lastInactiveBinding;
        bindings.pop();
        delete bindingByName[trackName];
        if (Object.keys(bindingByName).length === 0) delete bindingsByRoot[rootUuid];
    }
    _lendBinding(binding) {
        const bindings = this._bindings, prevIndex = binding._cacheIndex, lastActiveIndex = this._nActiveBindings++, firstInactiveBinding = bindings[lastActiveIndex];
        binding._cacheIndex = lastActiveIndex;
        bindings[lastActiveIndex] = binding;
        firstInactiveBinding._cacheIndex = prevIndex;
        bindings[prevIndex] = firstInactiveBinding;
    }
    _takeBackBinding(binding) {
        const bindings = this._bindings, prevIndex = binding._cacheIndex, firstInactiveIndex = --this._nActiveBindings, lastActiveBinding = bindings[firstInactiveIndex];
        binding._cacheIndex = firstInactiveIndex;
        bindings[firstInactiveIndex] = binding;
        lastActiveBinding._cacheIndex = prevIndex;
        bindings[prevIndex] = lastActiveBinding;
    }
    // Memory management of Interpolants for weight and time scale
    _lendControlInterpolant() {
        const interpolants = this._controlInterpolants, lastActiveIndex = this._nActiveControlInterpolants++;
        let interpolant = interpolants[lastActiveIndex];
        if (interpolant === undefined) {
            interpolant = new $084574008ccedf86$export$a8e6009059f51e1a(new Float32Array(2), new Float32Array(2), 1, $084574008ccedf86$var$_controlInterpolantsResultBuffer);
            interpolant.__cacheIndex = lastActiveIndex;
            interpolants[lastActiveIndex] = interpolant;
        }
        return interpolant;
    }
    _takeBackControlInterpolant(interpolant) {
        const interpolants = this._controlInterpolants, prevIndex = interpolant.__cacheIndex, firstInactiveIndex = --this._nActiveControlInterpolants, lastActiveInterpolant = interpolants[firstInactiveIndex];
        interpolant.__cacheIndex = firstInactiveIndex;
        interpolants[firstInactiveIndex] = interpolant;
        lastActiveInterpolant.__cacheIndex = prevIndex;
        interpolants[prevIndex] = lastActiveInterpolant;
    }
    // return an action for a clip optionally using a custom root target
    // object (this method allocates a lot of dynamic memory in case a
    // previously unknown clip/root combination is specified)
    clipAction(clip, optionalRoot, blendMode) {
        const root = optionalRoot || this._root, rootUuid = root.uuid;
        let clipObject = typeof clip === "string" ? $084574008ccedf86$export$d942c706bf23829c.findByName(root, clip) : clip;
        const clipUuid = clipObject !== null ? clipObject.uuid : clip;
        const actionsForClip = this._actionsByClip[clipUuid];
        let prototypeAction = null;
        if (blendMode === undefined) {
            if (clipObject !== null) blendMode = clipObject.blendMode;
            else blendMode = $084574008ccedf86$export$bcfbbdcf8de7f8cd;
        }
        if (actionsForClip !== undefined) {
            const existingAction = actionsForClip.actionByRoot[rootUuid];
            if (existingAction !== undefined && existingAction.blendMode === blendMode) return existingAction;
            // we know the clip, so we don't have to parse all
            // the bindings again but can just copy
            prototypeAction = actionsForClip.knownActions[0];
            // also, take the clip from the prototype action
            if (clipObject === null) clipObject = prototypeAction._clip;
        }
        // clip must be known when specified via string
        if (clipObject === null) return null;
        // allocate all resources required to run it
        const newAction = new $084574008ccedf86$var$AnimationAction(this, clipObject, optionalRoot, blendMode);
        this._bindAction(newAction, prototypeAction);
        // and make the action known to the memory manager
        this._addInactiveAction(newAction, clipUuid, rootUuid);
        return newAction;
    }
    // get an existing action
    existingAction(clip, optionalRoot) {
        const root = optionalRoot || this._root, rootUuid = root.uuid, clipObject = typeof clip === "string" ? $084574008ccedf86$export$d942c706bf23829c.findByName(root, clip) : clip, clipUuid = clipObject ? clipObject.uuid : clip, actionsForClip = this._actionsByClip[clipUuid];
        if (actionsForClip !== undefined) return actionsForClip.actionByRoot[rootUuid] || null;
        return null;
    }
    // deactivates all previously scheduled actions
    stopAllAction() {
        const actions = this._actions, nActions = this._nActiveActions;
        for(let i362 = nActions - 1; i362 >= 0; --i362)actions[i362].stop();
        return this;
    }
    // advance the time and update apply the animation
    update(deltaTime) {
        deltaTime *= this.timeScale;
        const actions = this._actions, nActions = this._nActiveActions, time = this.time += deltaTime, timeDirection = Math.sign(deltaTime), accuIndex = this._accuIndex ^= 1;
        // run active actions
        for(let i364 = 0; i364 !== nActions; ++i364){
            const action = actions[i364];
            action._update(time, deltaTime, timeDirection, accuIndex);
        }
        // update scene graph
        const bindings = this._bindings, nBindings = this._nActiveBindings;
        for(let i363 = 0; i363 !== nBindings; ++i363)bindings[i363].apply(accuIndex);
        return this;
    }
    // Allows you to seek to a specific time in an animation.
    setTime(timeInSeconds) {
        this.time = 0; // Zero out time attribute for AnimationMixer object;
        for(let i365 = 0; i365 < this._actions.length; i365++)this._actions[i365].time = 0; // Zero out time attribute for all associated AnimationAction objects.
        return this.update(timeInSeconds); // Update used to set exact time. Returns "this" AnimationMixer object.
    }
    // return this mixer's root target object
    getRoot() {
        return this._root;
    }
    // free all resources specific to a particular clip
    uncacheClip(clip) {
        const actions = this._actions, clipUuid = clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid];
        if (actionsForClip !== undefined) {
            // note: just calling _removeInactiveAction would mess up the
            // iteration state and also require updating the state we can
            // just throw away
            const actionsToRemove = actionsForClip.knownActions;
            for(let i366 = 0, n = actionsToRemove.length; i366 !== n; ++i366){
                const action = actionsToRemove[i366];
                this._deactivateAction(action);
                const cacheIndex = action._cacheIndex, lastInactiveAction = actions[actions.length - 1];
                action._cacheIndex = null;
                action._byClipCacheIndex = null;
                lastInactiveAction._cacheIndex = cacheIndex;
                actions[cacheIndex] = lastInactiveAction;
                actions.pop();
                this._removeInactiveBindingsForAction(action);
            }
            delete actionsByClip[clipUuid];
        }
    }
    // free all resources specific to a particular root target object
    uncacheRoot(root) {
        const rootUuid = root.uuid, actionsByClip = this._actionsByClip;
        for(const clipUuid in actionsByClip){
            const actionByRoot = actionsByClip[clipUuid].actionByRoot, action = actionByRoot[rootUuid];
            if (action !== undefined) {
                this._deactivateAction(action);
                this._removeInactiveAction(action);
            }
        }
        const bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid];
        if (bindingByName !== undefined) for(const trackName in bindingByName){
            const binding = bindingByName[trackName];
            binding.restoreOriginalState();
            this._removeInactiveBinding(binding);
        }
    }
    // remove a targeted clip from the cache
    uncacheAction(clip, optionalRoot) {
        const action = this.existingAction(clip, optionalRoot);
        if (action !== null) {
            this._deactivateAction(action);
            this._removeInactiveAction(action);
        }
    }
}
class $084574008ccedf86$export$2947cebfe91c02f8 {
    constructor(value){
        if (typeof value === "string") {
            console.warn("THREE.Uniform: Type parameter is no longer needed.");
            value = arguments[1];
        }
        this.value = value;
    }
    clone() {
        return new $084574008ccedf86$export$2947cebfe91c02f8(this.value.clone === undefined ? this.value : this.value.clone());
    }
}
class $084574008ccedf86$export$25ec0e1af1389358 extends $084574008ccedf86$export$3d5cd879f108f53f {
    constructor(array, stride, meshPerAttribute = 1){
        super(array, stride);
        this.isInstancedInterleavedBuffer = true;
        this.meshPerAttribute = meshPerAttribute;
    }
    copy(source) {
        super.copy(source);
        this.meshPerAttribute = source.meshPerAttribute;
        return this;
    }
    clone(data) {
        const ib = super.clone(data);
        ib.meshPerAttribute = this.meshPerAttribute;
        return ib;
    }
    toJSON(data) {
        const json = super.toJSON(data);
        json.isInstancedInterleavedBuffer = true;
        json.meshPerAttribute = this.meshPerAttribute;
        return json;
    }
}
class $084574008ccedf86$export$6b7339ae8dbddf73 {
    constructor(buffer, type, itemSize, elementSize, count){
        this.isGLBufferAttribute = true;
        this.buffer = buffer;
        this.type = type;
        this.itemSize = itemSize;
        this.elementSize = elementSize;
        this.count = count;
        this.version = 0;
    }
    set needsUpdate(value) {
        if (value === true) this.version++;
    }
    setBuffer(buffer) {
        this.buffer = buffer;
        return this;
    }
    setType(type, elementSize) {
        this.type = type;
        this.elementSize = elementSize;
        return this;
    }
    setItemSize(itemSize) {
        this.itemSize = itemSize;
        return this;
    }
    setCount(count) {
        this.count = count;
        return this;
    }
}
class $084574008ccedf86$export$8b7aaceff00bd2f {
    constructor(origin, direction, near = 0, far = Infinity){
        this.ray = new $084574008ccedf86$export$a186db52eed6d40e(origin, direction);
        // direction is assumed to be normalized (for accurate distance calculations)
        this.near = near;
        this.far = far;
        this.camera = null;
        this.layers = new $084574008ccedf86$export$89312ce47c0ca777();
        this.params = {
            Mesh: {},
            Line: {
                threshold: 1
            },
            LOD: {},
            Points: {
                threshold: 1
            },
            Sprite: {}
        };
    }
    set(origin, direction) {
        // direction is assumed to be normalized (for accurate distance calculations)
        this.ray.set(origin, direction);
    }
    setFromCamera(coords, camera) {
        if (camera.isPerspectiveCamera) {
            this.ray.origin.setFromMatrixPosition(camera.matrixWorld);
            this.ray.direction.set(coords.x, coords.y, 0.5).unproject(camera).sub(this.ray.origin).normalize();
            this.camera = camera;
        } else if (camera.isOrthographicCamera) {
            this.ray.origin.set(coords.x, coords.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera); // set origin in plane of camera
            this.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld);
            this.camera = camera;
        } else console.error("THREE.Raycaster: Unsupported camera type: " + camera.type);
    }
    intersectObject(object, recursive = true, intersects8 = []) {
        $084574008ccedf86$var$intersectObject(object, this, intersects8, recursive);
        intersects8.sort($084574008ccedf86$var$ascSort);
        return intersects8;
    }
    intersectObjects(objects, recursive = true, intersects9 = []) {
        for(let i367 = 0, l = objects.length; i367 < l; i367++)$084574008ccedf86$var$intersectObject(objects[i367], this, intersects9, recursive);
        intersects9.sort($084574008ccedf86$var$ascSort);
        return intersects9;
    }
}
function $084574008ccedf86$var$ascSort(a, b) {
    return a.distance - b.distance;
}
function $084574008ccedf86$var$intersectObject(object, raycaster, intersects10, recursive) {
    if (object.layers.test(raycaster.layers)) object.raycast(raycaster, intersects10);
    if (recursive === true) {
        const children = object.children;
        for(let i368 = 0, l = children.length; i368 < l; i368++)$084574008ccedf86$var$intersectObject(children[i368], raycaster, intersects10, true);
    }
}
/**
 * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system
 *
 * The polar angle (phi) is measured from the positive y-axis. The positive y-axis is up.
 * The azimuthal angle (theta) is measured from the positive z-axis.
 */ class $084574008ccedf86$export$d712cd887b4a00f7 {
    constructor(radius = 1, phi = 0, theta = 0){
        this.radius = radius;
        this.phi = phi; // polar angle
        this.theta = theta; // azimuthal angle
        return this;
    }
    set(radius, phi, theta) {
        this.radius = radius;
        this.phi = phi;
        this.theta = theta;
        return this;
    }
    copy(other) {
        this.radius = other.radius;
        this.phi = other.phi;
        this.theta = other.theta;
        return this;
    }
    // restrict phi to be between EPS and PI-EPS
    makeSafe() {
        const EPS = 0.000001;
        this.phi = Math.max(EPS, Math.min(Math.PI - EPS, this.phi));
        return this;
    }
    setFromVector3(v) {
        return this.setFromCartesianCoords(v.x, v.y, v.z);
    }
    setFromCartesianCoords(x, y, z) {
        this.radius = Math.sqrt(x * x + y * y + z * z);
        if (this.radius === 0) {
            this.theta = 0;
            this.phi = 0;
        } else {
            this.theta = Math.atan2(x, z);
            this.phi = Math.acos($084574008ccedf86$var$clamp(y / this.radius, -1, 1));
        }
        return this;
    }
    clone() {
        return new this.constructor().copy(this);
    }
}
/**
 * Ref: https://en.wikipedia.org/wiki/Cylindrical_coordinate_system
 */ class $084574008ccedf86$export$287165bb2177f4fd {
    constructor(radius = 1, theta = 0, y = 0){
        this.radius = radius; // distance from the origin to a point in the x-z plane
        this.theta = theta; // counterclockwise angle in the x-z plane measured in radians from the positive z-axis
        this.y = y; // height above the x-z plane
        return this;
    }
    set(radius, theta, y) {
        this.radius = radius;
        this.theta = theta;
        this.y = y;
        return this;
    }
    copy(other) {
        this.radius = other.radius;
        this.theta = other.theta;
        this.y = other.y;
        return this;
    }
    setFromVector3(v) {
        return this.setFromCartesianCoords(v.x, v.y, v.z);
    }
    setFromCartesianCoords(x, y, z) {
        this.radius = Math.sqrt(x * x + z * z);
        this.theta = Math.atan2(x, z);
        this.y = y;
        return this;
    }
    clone() {
        return new this.constructor().copy(this);
    }
}
const $084574008ccedf86$var$_vector$4 = /*@__PURE__*/ new $084574008ccedf86$export$c977b3e384af9ae1();
class $084574008ccedf86$export$60f553fa130f08b0 {
    constructor(min = new $084574008ccedf86$export$c977b3e384af9ae1(Infinity, Infinity), max = new $084574008ccedf86$export$c977b3e384af9ae1(-Infinity, -Infinity)){
        this.isBox2 = true;
        this.min = min;
        this.max = max;
    }
    set(min, max) {
        this.min.copy(min);
        this.max.copy(max);
        return this;
    }
    setFromPoints(points) {
        this.makeEmpty();
        for(let i369 = 0, il = points.length; i369 < il; i369++)this.expandByPoint(points[i369]);
        return this;
    }
    setFromCenterAndSize(center, size) {
        const halfSize = $084574008ccedf86$var$_vector$4.copy(size).multiplyScalar(0.5);
        this.min.copy(center).sub(halfSize);
        this.max.copy(center).add(halfSize);
        return this;
    }
    clone() {
        return new this.constructor().copy(this);
    }
    copy(box) {
        this.min.copy(box.min);
        this.max.copy(box.max);
        return this;
    }
    makeEmpty() {
        this.min.x = this.min.y = Infinity;
        this.max.x = this.max.y = -Infinity;
        return this;
    }
    isEmpty() {
        // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
        return this.max.x < this.min.x || this.max.y < this.min.y;
    }
    getCenter(target) {
        return this.isEmpty() ? target.set(0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
    }
    getSize(target) {
        return this.isEmpty() ? target.set(0, 0) : target.subVectors(this.max, this.min);
    }
    expandByPoint(point) {
        this.min.min(point);
        this.max.max(point);
        return this;
    }
    expandByVector(vector) {
        this.min.sub(vector);
        this.max.add(vector);
        return this;
    }
    expandByScalar(scalar) {
        this.min.addScalar(-scalar);
        this.max.addScalar(scalar);
        return this;
    }
    containsPoint(point) {
        return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y ? false : true;
    }
    containsBox(box) {
        return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y;
    }
    getParameter(point, target) {
        // This can potentially have a divide by zero if the box
        // has a size dimension of 0.
        return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y));
    }
    intersectsBox(box) {
        // using 4 splitting planes to rule out intersections
        return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y ? false : true;
    }
    clampPoint(point, target) {
        return target.copy(point).clamp(this.min, this.max);
    }
    distanceToPoint(point) {
        const clampedPoint = $084574008ccedf86$var$_vector$4.copy(point).clamp(this.min, this.max);
        return clampedPoint.sub(point).length();
    }
    intersect(box) {
        this.min.max(box.min);
        this.max.min(box.max);
        return this;
    }
    union(box) {
        this.min.min(box.min);
        this.max.max(box.max);
        return this;
    }
    translate(offset) {
        this.min.add(offset);
        this.max.add(offset);
        return this;
    }
    equals(box) {
        return box.min.equals(this.min) && box.max.equals(this.max);
    }
}
const $084574008ccedf86$var$_startP = /*@__PURE__*/ new $084574008ccedf86$export$64b5c384219d3699();
const $084574008ccedf86$var$_startEnd = /*@__PURE__*/ new $084574008ccedf86$export$64b5c384219d3699();
class $084574008ccedf86$export$e0ba6359f1954fd3 {
    constructor(start = new $084574008ccedf86$export$64b5c384219d3699(), end = new $084574008ccedf86$export$64b5c384219d3699()){
        this.start = start;
        this.end = end;
    }
    set(start, end) {
        this.start.copy(start);
        this.end.copy(end);
        return this;
    }
    copy(line) {
        this.start.copy(line.start);
        this.end.copy(line.end);
        return this;
    }
    getCenter(target) {
        return target.addVectors(this.start, this.end).multiplyScalar(0.5);
    }
    delta(target) {
        return target.subVectors(this.end, this.start);
    }
    distanceSq() {
        return this.start.distanceToSquared(this.end);
    }
    distance() {
        return this.start.distanceTo(this.end);
    }
    at(t, target) {
        return this.delta(target).multiplyScalar(t).add(this.start);
    }
    closestPointToPointParameter(point, clampToLine) {
        $084574008ccedf86$var$_startP.subVectors(point, this.start);
        $084574008ccedf86$var$_startEnd.subVectors(this.end, this.start);
        const startEnd2 = $084574008ccedf86$var$_startEnd.dot($084574008ccedf86$var$_startEnd);
        const startEnd_startP = $084574008ccedf86$var$_startEnd.dot($084574008ccedf86$var$_startP);
        let t = startEnd_startP / startEnd2;
        if (clampToLine) t = $084574008ccedf86$var$clamp(t, 0, 1);
        return t;
    }
    closestPointToPoint(point, clampToLine, target) {
        const t = this.closestPointToPointParameter(point, clampToLine);
        return this.delta(target).multiplyScalar(t).add(this.start);
    }
    applyMatrix4(matrix) {
        this.start.applyMatrix4(matrix);
        this.end.applyMatrix4(matrix);
        return this;
    }
    equals(line) {
        return line.start.equals(this.start) && line.end.equals(this.end);
    }
    clone() {
        return new this.constructor().copy(this);
    }
}
const $084574008ccedf86$var$_vector$3 = /*@__PURE__*/ new $084574008ccedf86$export$64b5c384219d3699();
class $084574008ccedf86$export$4b14638ffdd81e68 extends $084574008ccedf86$export$e4dd07dff30cc924 {
    constructor(light, color){
        super();
        this.light = light;
        this.light.updateMatrixWorld();
        this.matrix = light.matrixWorld;
        this.matrixAutoUpdate = false;
        this.color = color;
        const geometry = new $084574008ccedf86$export$b7be63a67df8959();
        const positions = [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            -1,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            -1,
            1
        ];
        for(let i370 = 0, j = 1, l = 32; i370 < l; i370++, j++){
            const p1 = i370 / l * Math.PI * 2;
            const p2 = j / l * Math.PI * 2;
            positions.push(Math.cos(p1), Math.sin(p1), 1, Math.cos(p2), Math.sin(p2), 1);
        }
        geometry.setAttribute("position", new $084574008ccedf86$export$cbe7a62641830ebd(positions, 3));
        const material = new $084574008ccedf86$export$fbaaa33907730a0c({
            fog: false,
            toneMapped: false
        });
        this.cone = new $084574008ccedf86$export$ff1ed10fedfdd604(geometry, material);
        this.add(this.cone);
        this.update();
    }
    dispose() {
        this.cone.geometry.dispose();
        this.cone.material.dispose();
    }
    update() {
        this.light.updateMatrixWorld();
        const coneLength = this.light.distance ? this.light.distance : 1000;
        const coneWidth = coneLength * Math.tan(this.light.angle);
        this.cone.scale.set(coneWidth, coneWidth, coneLength);
        $084574008ccedf86$var$_vector$3.setFromMatrixPosition(this.light.target.matrixWorld);
        this.cone.lookAt($084574008ccedf86$var$_vector$3);
        if (this.color !== undefined) this.cone.material.color.set(this.color);
        else this.cone.material.color.copy(this.light.color);
    }
}
const $084574008ccedf86$var$_vector$2 = /*@__PURE__*/ new $084574008ccedf86$export$64b5c384219d3699();
const $084574008ccedf86$var$_boneMatrix = /*@__PURE__*/ new $084574008ccedf86$export$2ae72fc923e5eb5();
const $084574008ccedf86$var$_matrixWorldInv = /*@__PURE__*/ new $084574008ccedf86$export$2ae72fc923e5eb5();
class $084574008ccedf86$export$5277df3c9e732259 extends $084574008ccedf86$export$ff1ed10fedfdd604 {
    constructor(object){
        const bones = $084574008ccedf86$var$getBoneList(object);
        const geometry = new $084574008ccedf86$export$b7be63a67df8959();
        const vertices = [];
        const colors = [];
        const color1 = new $084574008ccedf86$export$892596cec99bc70e(0, 0, 1);
        const color2 = new $084574008ccedf86$export$892596cec99bc70e(0, 1, 0);
        for(let i371 = 0; i371 < bones.length; i371++){
            const bone = bones[i371];
            if (bone.parent && bone.parent.isBone) {
                vertices.push(0, 0, 0);
                vertices.push(0, 0, 0);
                colors.push(color1.r, color1.g, color1.b);
                colors.push(color2.r, color2.g, color2.b);
            }
        }
        geometry.setAttribute("position", new $084574008ccedf86$export$cbe7a62641830ebd(vertices, 3));
        geometry.setAttribute("color", new $084574008ccedf86$export$cbe7a62641830ebd(colors, 3));
        const material = new $084574008ccedf86$export$fbaaa33907730a0c({
            vertexColors: true,
            depthTest: false,
            depthWrite: false,
            toneMapped: false,
            transparent: true
        });
        super(geometry, material);
        this.isSkeletonHelper = true;
        this.type = "SkeletonHelper";
        this.root = object;
        this.bones = bones;
        this.matrix = object.matrixWorld;
        this.matrixAutoUpdate = false;
    }
    updateMatrixWorld(force) {
        const bones = this.bones;
        const geometry = this.geometry;
        const position = geometry.getAttribute("position");
        $084574008ccedf86$var$_matrixWorldInv.copy(this.root.matrixWorld).invert();
        for(let i372 = 0, j = 0; i372 < bones.length; i372++){
            const bone = bones[i372];
            if (bone.parent && bone.parent.isBone) {
                $084574008ccedf86$var$_boneMatrix.multiplyMatrices($084574008ccedf86$var$_matrixWorldInv, bone.matrixWorld);
                $084574008ccedf86$var$_vector$2.setFromMatrixPosition($084574008ccedf86$var$_boneMatrix);
                position.setXYZ(j, $084574008ccedf86$var$_vector$2.x, $084574008ccedf86$var$_vector$2.y, $084574008ccedf86$var$_vector$2.z);
                $084574008ccedf86$var$_boneMatrix.multiplyMatrices($084574008ccedf86$var$_matrixWorldInv, bone.parent.matrixWorld);
                $084574008ccedf86$var$_vector$2.setFromMatrixPosition($084574008ccedf86$var$_boneMatrix);
                position.setXYZ(j + 1, $084574008ccedf86$var$_vector$2.x, $084574008ccedf86$var$_vector$2.y, $084574008ccedf86$var$_vector$2.z);
                j += 2;
            }
        }
        geometry.getAttribute("position").needsUpdate = true;
        super.updateMatrixWorld(force);
    }
}
function $084574008ccedf86$var$getBoneList(object) {
    const boneList = [];
    if (object.isBone === true) boneList.push(object);
    for(let i373 = 0; i373 < object.children.length; i373++)boneList.push.apply(boneList, $084574008ccedf86$var$getBoneList(object.children[i373]));
    return boneList;
}
class $084574008ccedf86$export$9a9291685b9e4023 extends $084574008ccedf86$export$e176487c05830cc5 {
    constructor(light, sphereSize, color){
        const geometry = new $084574008ccedf86$export$d5d06a966fec4192(sphereSize, 4, 2);
        const material = new $084574008ccedf86$export$55cbcc9b622fe1f5({
            wireframe: true,
            fog: false,
            toneMapped: false
        });
        super(geometry, material);
        this.light = light;
        this.light.updateMatrixWorld();
        this.color = color;
        this.type = "PointLightHelper";
        this.matrix = this.light.matrixWorld;
        this.matrixAutoUpdate = false;
        this.update();
    /*
	// TODO: delete this comment?
	const distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );
	const distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );

	this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
	this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );

	const d = light.distance;

	if ( d === 0.0 ) {

		this.lightDistance.visible = false;

	} else {

		this.lightDistance.scale.set( d, d, d );

	}

	this.add( this.lightDistance );
	*/ }
    dispose() {
        this.geometry.dispose();
        this.material.dispose();
    }
    update() {
        if (this.color !== undefined) this.material.color.set(this.color);
        else this.material.color.copy(this.light.color);
    /*
		const d = this.light.distance;

		if ( d === 0.0 ) {

			this.lightDistance.visible = false;

		} else {

			this.lightDistance.visible = true;
			this.lightDistance.scale.set( d, d, d );

		}
		*/ }
}
const $084574008ccedf86$var$_vector$1 = /*@__PURE__*/ new $084574008ccedf86$export$64b5c384219d3699();
const $084574008ccedf86$var$_color1 = /*@__PURE__*/ new $084574008ccedf86$export$892596cec99bc70e();
const $084574008ccedf86$var$_color2 = /*@__PURE__*/ new $084574008ccedf86$export$892596cec99bc70e();
class $084574008ccedf86$export$8dca15f13f4f8172 extends $084574008ccedf86$export$e4dd07dff30cc924 {
    constructor(light, size, color){
        super();
        this.light = light;
        this.light.updateMatrixWorld();
        this.matrix = light.matrixWorld;
        this.matrixAutoUpdate = false;
        this.color = color;
        const geometry = new $084574008ccedf86$export$8e05fc91596f4752(size);
        geometry.rotateY(Math.PI * 0.5);
        this.material = new $084574008ccedf86$export$55cbcc9b622fe1f5({
            wireframe: true,
            fog: false,
            toneMapped: false
        });
        if (this.color === undefined) this.material.vertexColors = true;
        const position = geometry.getAttribute("position");
        const colors = new Float32Array(position.count * 3);
        geometry.setAttribute("color", new $084574008ccedf86$export$8dea267bd6bde117(colors, 3));
        this.add(new $084574008ccedf86$export$e176487c05830cc5(geometry, this.material));
        this.update();
    }
    dispose() {
        this.children[0].geometry.dispose();
        this.children[0].material.dispose();
    }
    update() {
        const mesh = this.children[0];
        if (this.color !== undefined) this.material.color.set(this.color);
        else {
            const colors = mesh.geometry.getAttribute("color");
            $084574008ccedf86$var$_color1.copy(this.light.color);
            $084574008ccedf86$var$_color2.copy(this.light.groundColor);
            for(let i374 = 0, l = colors.count; i374 < l; i374++){
                const color = i374 < l / 2 ? $084574008ccedf86$var$_color1 : $084574008ccedf86$var$_color2;
                colors.setXYZ(i374, color.r, color.g, color.b);
            }
            colors.needsUpdate = true;
        }
        mesh.lookAt($084574008ccedf86$var$_vector$1.setFromMatrixPosition(this.light.matrixWorld).negate());
    }
}
class $084574008ccedf86$export$3875d39926561055 extends $084574008ccedf86$export$ff1ed10fedfdd604 {
    constructor(size = 10, divisions = 10, color1 = 0x444444, color2 = 0x888888){
        color1 = new $084574008ccedf86$export$892596cec99bc70e(color1);
        color2 = new $084574008ccedf86$export$892596cec99bc70e(color2);
        const center = divisions / 2;
        const step = size / divisions;
        const halfSize = size / 2;
        const vertices = [], colors = [];
        for(let i375 = 0, j = 0, k = -halfSize; i375 <= divisions; i375++, k += step){
            vertices.push(-halfSize, 0, k, halfSize, 0, k);
            vertices.push(k, 0, -halfSize, k, 0, halfSize);
            const color = i375 === center ? color1 : color2;
            color.toArray(colors, j);
            j += 3;
            color.toArray(colors, j);
            j += 3;
            color.toArray(colors, j);
            j += 3;
            color.toArray(colors, j);
            j += 3;
        }
        const geometry = new $084574008ccedf86$export$b7be63a67df8959();
        geometry.setAttribute("position", new $084574008ccedf86$export$cbe7a62641830ebd(vertices, 3));
        geometry.setAttribute("color", new $084574008ccedf86$export$cbe7a62641830ebd(colors, 3));
        const material = new $084574008ccedf86$export$fbaaa33907730a0c({
            vertexColors: true,
            toneMapped: false
        });
        super(geometry, material);
        this.type = "GridHelper";
    }
}
class $084574008ccedf86$export$361430a10f533cd3 extends $084574008ccedf86$export$ff1ed10fedfdd604 {
    constructor(radius = 10, radials = 16, circles = 8, divisions = 64, color1 = 0x444444, color2 = 0x888888){
        color1 = new $084574008ccedf86$export$892596cec99bc70e(color1);
        color2 = new $084574008ccedf86$export$892596cec99bc70e(color2);
        const vertices = [];
        const colors = [];
        // create the radials
        for(let i377 = 0; i377 <= radials; i377++){
            const v = i377 / radials * (Math.PI * 2);
            const x = Math.sin(v) * radius;
            const z = Math.cos(v) * radius;
            vertices.push(0, 0, 0);
            vertices.push(x, 0, z);
            const color = i377 & 1 ? color1 : color2;
            colors.push(color.r, color.g, color.b);
            colors.push(color.r, color.g, color.b);
        }
        // create the circles
        for(let i376 = 0; i376 <= circles; i376++){
            const color = i376 & 1 ? color1 : color2;
            const r = radius - radius / circles * i376;
            for(let j = 0; j < divisions; j++){
                // first vertex
                let v = j / divisions * (Math.PI * 2);
                let x = Math.sin(v) * r;
                let z = Math.cos(v) * r;
                vertices.push(x, 0, z);
                colors.push(color.r, color.g, color.b);
                // second vertex
                v = (j + 1) / divisions * (Math.PI * 2);
                x = Math.sin(v) * r;
                z = Math.cos(v) * r;
                vertices.push(x, 0, z);
                colors.push(color.r, color.g, color.b);
            }
        }
        const geometry = new $084574008ccedf86$export$b7be63a67df8959();
        geometry.setAttribute("position", new $084574008ccedf86$export$cbe7a62641830ebd(vertices, 3));
        geometry.setAttribute("color", new $084574008ccedf86$export$cbe7a62641830ebd(colors, 3));
        const material = new $084574008ccedf86$export$fbaaa33907730a0c({
            vertexColors: true,
            toneMapped: false
        });
        super(geometry, material);
        this.type = "PolarGridHelper";
    }
}
const $084574008ccedf86$var$_v1 = /*@__PURE__*/ new $084574008ccedf86$export$64b5c384219d3699();
const $084574008ccedf86$var$_v2 = /*@__PURE__*/ new $084574008ccedf86$export$64b5c384219d3699();
const $084574008ccedf86$var$_v3 = /*@__PURE__*/ new $084574008ccedf86$export$64b5c384219d3699();
class $084574008ccedf86$export$f8e434dc14203e7d extends $084574008ccedf86$export$e4dd07dff30cc924 {
    constructor(light, size, color){
        super();
        this.light = light;
        this.light.updateMatrixWorld();
        this.matrix = light.matrixWorld;
        this.matrixAutoUpdate = false;
        this.color = color;
        if (size === undefined) size = 1;
        let geometry = new $084574008ccedf86$export$b7be63a67df8959();
        geometry.setAttribute("position", new $084574008ccedf86$export$cbe7a62641830ebd([
            -size,
            size,
            0,
            size,
            size,
            0,
            size,
            -size,
            0,
            -size,
            -size,
            0,
            -size,
            size,
            0
        ], 3));
        const material = new $084574008ccedf86$export$fbaaa33907730a0c({
            fog: false,
            toneMapped: false
        });
        this.lightPlane = new $084574008ccedf86$export$17d680238e50603e(geometry, material);
        this.add(this.lightPlane);
        geometry = new $084574008ccedf86$export$b7be63a67df8959();
        geometry.setAttribute("position", new $084574008ccedf86$export$cbe7a62641830ebd([
            0,
            0,
            0,
            0,
            0,
            1
        ], 3));
        this.targetLine = new $084574008ccedf86$export$17d680238e50603e(geometry, material);
        this.add(this.targetLine);
        this.update();
    }
    dispose() {
        this.lightPlane.geometry.dispose();
        this.lightPlane.material.dispose();
        this.targetLine.geometry.dispose();
        this.targetLine.material.dispose();
    }
    update() {
        $084574008ccedf86$var$_v1.setFromMatrixPosition(this.light.matrixWorld);
        $084574008ccedf86$var$_v2.setFromMatrixPosition(this.light.target.matrixWorld);
        $084574008ccedf86$var$_v3.subVectors($084574008ccedf86$var$_v2, $084574008ccedf86$var$_v1);
        this.lightPlane.lookAt($084574008ccedf86$var$_v2);
        if (this.color !== undefined) {
            this.lightPlane.material.color.set(this.color);
            this.targetLine.material.color.set(this.color);
        } else {
            this.lightPlane.material.color.copy(this.light.color);
            this.targetLine.material.color.copy(this.light.color);
        }
        this.targetLine.lookAt($084574008ccedf86$var$_v2);
        this.targetLine.scale.z = $084574008ccedf86$var$_v3.length();
    }
}
const $084574008ccedf86$var$_vector = /*@__PURE__*/ new $084574008ccedf86$export$64b5c384219d3699();
const $084574008ccedf86$var$_camera = /*@__PURE__*/ new $084574008ccedf86$export$79f141de891a5fed();
/**
 *	- shows frustum, line of sight and up of the camera
 *	- suitable for fast updates
 * 	- based on frustum visualization in lightgl.js shadowmap example
 *		https://github.com/evanw/lightgl.js/blob/master/tests/shadowmap.html
 */ class $084574008ccedf86$export$ed8e93f853cd795 extends $084574008ccedf86$export$ff1ed10fedfdd604 {
    constructor(camera){
        const geometry = new $084574008ccedf86$export$b7be63a67df8959();
        const material = new $084574008ccedf86$export$fbaaa33907730a0c({
            color: 0xffffff,
            vertexColors: true,
            toneMapped: false
        });
        const vertices = [];
        const colors = [];
        const pointMap = {};
        // colors
        const colorFrustum = new $084574008ccedf86$export$892596cec99bc70e(0xffaa00);
        const colorCone = new $084574008ccedf86$export$892596cec99bc70e(0xff0000);
        const colorUp = new $084574008ccedf86$export$892596cec99bc70e(0x00aaff);
        const colorTarget = new $084574008ccedf86$export$892596cec99bc70e(0xffffff);
        const colorCross = new $084574008ccedf86$export$892596cec99bc70e(0x333333);
        // near
        addLine("n1", "n2", colorFrustum);
        addLine("n2", "n4", colorFrustum);
        addLine("n4", "n3", colorFrustum);
        addLine("n3", "n1", colorFrustum);
        // far
        addLine("f1", "f2", colorFrustum);
        addLine("f2", "f4", colorFrustum);
        addLine("f4", "f3", colorFrustum);
        addLine("f3", "f1", colorFrustum);
        // sides
        addLine("n1", "f1", colorFrustum);
        addLine("n2", "f2", colorFrustum);
        addLine("n3", "f3", colorFrustum);
        addLine("n4", "f4", colorFrustum);
        // cone
        addLine("p", "n1", colorCone);
        addLine("p", "n2", colorCone);
        addLine("p", "n3", colorCone);
        addLine("p", "n4", colorCone);
        // up
        addLine("u1", "u2", colorUp);
        addLine("u2", "u3", colorUp);
        addLine("u3", "u1", colorUp);
        // target
        addLine("c", "t", colorTarget);
        addLine("p", "c", colorCross);
        // cross
        addLine("cn1", "cn2", colorCross);
        addLine("cn3", "cn4", colorCross);
        addLine("cf1", "cf2", colorCross);
        addLine("cf3", "cf4", colorCross);
        function addLine(a, b, color) {
            addPoint(a, color);
            addPoint(b, color);
        }
        function addPoint(id, color) {
            vertices.push(0, 0, 0);
            colors.push(color.r, color.g, color.b);
            if (pointMap[id] === undefined) pointMap[id] = [];
            pointMap[id].push(vertices.length / 3 - 1);
        }
        geometry.setAttribute("position", new $084574008ccedf86$export$cbe7a62641830ebd(vertices, 3));
        geometry.setAttribute("color", new $084574008ccedf86$export$cbe7a62641830ebd(colors, 3));
        super(geometry, material);
        this.type = "CameraHelper";
        this.camera = camera;
        if (this.camera.updateProjectionMatrix) this.camera.updateProjectionMatrix();
        this.matrix = camera.matrixWorld;
        this.matrixAutoUpdate = false;
        this.pointMap = pointMap;
        this.update();
    }
    update() {
        const geometry = this.geometry;
        const pointMap = this.pointMap;
        const w = 1, h = 1;
        // we need just camera projection matrix inverse
        // world matrix must be identity
        $084574008ccedf86$var$_camera.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse);
        // center / target
        $084574008ccedf86$var$setPoint("c", pointMap, geometry, $084574008ccedf86$var$_camera, 0, 0, -1);
        $084574008ccedf86$var$setPoint("t", pointMap, geometry, $084574008ccedf86$var$_camera, 0, 0, 1);
        // near
        $084574008ccedf86$var$setPoint("n1", pointMap, geometry, $084574008ccedf86$var$_camera, -w, -h, -1);
        $084574008ccedf86$var$setPoint("n2", pointMap, geometry, $084574008ccedf86$var$_camera, w, -h, -1);
        $084574008ccedf86$var$setPoint("n3", pointMap, geometry, $084574008ccedf86$var$_camera, -w, h, -1);
        $084574008ccedf86$var$setPoint("n4", pointMap, geometry, $084574008ccedf86$var$_camera, w, h, -1);
        // far
        $084574008ccedf86$var$setPoint("f1", pointMap, geometry, $084574008ccedf86$var$_camera, -w, -h, 1);
        $084574008ccedf86$var$setPoint("f2", pointMap, geometry, $084574008ccedf86$var$_camera, w, -h, 1);
        $084574008ccedf86$var$setPoint("f3", pointMap, geometry, $084574008ccedf86$var$_camera, -w, h, 1);
        $084574008ccedf86$var$setPoint("f4", pointMap, geometry, $084574008ccedf86$var$_camera, w, h, 1);
        // up
        $084574008ccedf86$var$setPoint("u1", pointMap, geometry, $084574008ccedf86$var$_camera, w * 0.7, h * 1.1, -1);
        $084574008ccedf86$var$setPoint("u2", pointMap, geometry, $084574008ccedf86$var$_camera, -w * 0.7, h * 1.1, -1);
        $084574008ccedf86$var$setPoint("u3", pointMap, geometry, $084574008ccedf86$var$_camera, 0, h * 2, -1);
        // cross
        $084574008ccedf86$var$setPoint("cf1", pointMap, geometry, $084574008ccedf86$var$_camera, -w, 0, 1);
        $084574008ccedf86$var$setPoint("cf2", pointMap, geometry, $084574008ccedf86$var$_camera, w, 0, 1);
        $084574008ccedf86$var$setPoint("cf3", pointMap, geometry, $084574008ccedf86$var$_camera, 0, -h, 1);
        $084574008ccedf86$var$setPoint("cf4", pointMap, geometry, $084574008ccedf86$var$_camera, 0, h, 1);
        $084574008ccedf86$var$setPoint("cn1", pointMap, geometry, $084574008ccedf86$var$_camera, -w, 0, -1);
        $084574008ccedf86$var$setPoint("cn2", pointMap, geometry, $084574008ccedf86$var$_camera, w, 0, -1);
        $084574008ccedf86$var$setPoint("cn3", pointMap, geometry, $084574008ccedf86$var$_camera, 0, -h, -1);
        $084574008ccedf86$var$setPoint("cn4", pointMap, geometry, $084574008ccedf86$var$_camera, 0, h, -1);
        geometry.getAttribute("position").needsUpdate = true;
    }
    dispose() {
        this.geometry.dispose();
        this.material.dispose();
    }
}
function $084574008ccedf86$var$setPoint(point, pointMap, geometry, camera, x, y, z) {
    $084574008ccedf86$var$_vector.set(x, y, z).unproject(camera);
    const points = pointMap[point];
    if (points !== undefined) {
        const position = geometry.getAttribute("position");
        for(let i378 = 0, l = points.length; i378 < l; i378++)position.setXYZ(points[i378], $084574008ccedf86$var$_vector.x, $084574008ccedf86$var$_vector.y, $084574008ccedf86$var$_vector.z);
    }
}
const $084574008ccedf86$var$_box = /*@__PURE__*/ new $084574008ccedf86$export$6f7d5a9418ab2aa3();
class $084574008ccedf86$export$38a664cc862a6a9d extends $084574008ccedf86$export$ff1ed10fedfdd604 {
    constructor(object, color = 0xffff00){
        const indices = new Uint16Array([
            0,
            1,
            1,
            2,
            2,
            3,
            3,
            0,
            4,
            5,
            5,
            6,
            6,
            7,
            7,
            4,
            0,
            4,
            1,
            5,
            2,
            6,
            3,
            7
        ]);
        const positions = new Float32Array(24);
        const geometry = new $084574008ccedf86$export$b7be63a67df8959();
        geometry.setIndex(new $084574008ccedf86$export$8dea267bd6bde117(indices, 1));
        geometry.setAttribute("position", new $084574008ccedf86$export$8dea267bd6bde117(positions, 3));
        super(geometry, new $084574008ccedf86$export$fbaaa33907730a0c({
            color: color,
            toneMapped: false
        }));
        this.object = object;
        this.type = "BoxHelper";
        this.matrixAutoUpdate = false;
        this.update();
    }
    update(object) {
        if (object !== undefined) console.warn("THREE.BoxHelper: .update() has no longer arguments.");
        if (this.object !== undefined) $084574008ccedf86$var$_box.setFromObject(this.object);
        if ($084574008ccedf86$var$_box.isEmpty()) return;
        const min = $084574008ccedf86$var$_box.min;
        const max = $084574008ccedf86$var$_box.max;
        /*
			5____4
		1/___0/|
		| 6__|_7
		2/___3/

		0: max.x, max.y, max.z
		1: min.x, max.y, max.z
		2: min.x, min.y, max.z
		3: max.x, min.y, max.z
		4: max.x, max.y, min.z
		5: min.x, max.y, min.z
		6: min.x, min.y, min.z
		7: max.x, min.y, min.z
		*/ const position = this.geometry.attributes.position;
        const array = position.array;
        array[0] = max.x;
        array[1] = max.y;
        array[2] = max.z;
        array[3] = min.x;
        array[4] = max.y;
        array[5] = max.z;
        array[6] = min.x;
        array[7] = min.y;
        array[8] = max.z;
        array[9] = max.x;
        array[10] = min.y;
        array[11] = max.z;
        array[12] = max.x;
        array[13] = max.y;
        array[14] = min.z;
        array[15] = min.x;
        array[16] = max.y;
        array[17] = min.z;
        array[18] = min.x;
        array[19] = min.y;
        array[20] = min.z;
        array[21] = max.x;
        array[22] = min.y;
        array[23] = min.z;
        position.needsUpdate = true;
        this.geometry.computeBoundingSphere();
    }
    setFromObject(object) {
        this.object = object;
        this.update();
        return this;
    }
    copy(source, recursive) {
        super.copy(source, recursive);
        this.object = source.object;
        return this;
    }
}
class $084574008ccedf86$export$ce39f4bb96c9a290 extends $084574008ccedf86$export$ff1ed10fedfdd604 {
    constructor(box, color = 0xffff00){
        const indices = new Uint16Array([
            0,
            1,
            1,
            2,
            2,
            3,
            3,
            0,
            4,
            5,
            5,
            6,
            6,
            7,
            7,
            4,
            0,
            4,
            1,
            5,
            2,
            6,
            3,
            7
        ]);
        const positions = [
            1,
            1,
            1,
            -1,
            1,
            1,
            -1,
            -1,
            1,
            1,
            -1,
            1,
            1,
            1,
            -1,
            -1,
            1,
            -1,
            -1,
            -1,
            -1,
            1,
            -1,
            -1
        ];
        const geometry = new $084574008ccedf86$export$b7be63a67df8959();
        geometry.setIndex(new $084574008ccedf86$export$8dea267bd6bde117(indices, 1));
        geometry.setAttribute("position", new $084574008ccedf86$export$cbe7a62641830ebd(positions, 3));
        super(geometry, new $084574008ccedf86$export$fbaaa33907730a0c({
            color: color,
            toneMapped: false
        }));
        this.box = box;
        this.type = "Box3Helper";
        this.geometry.computeBoundingSphere();
    }
    updateMatrixWorld(force) {
        const box = this.box;
        if (box.isEmpty()) return;
        box.getCenter(this.position);
        box.getSize(this.scale);
        this.scale.multiplyScalar(0.5);
        super.updateMatrixWorld(force);
    }
}
class $084574008ccedf86$export$a34fe8156c66e5d7 extends $084574008ccedf86$export$17d680238e50603e {
    constructor(plane, size = 1, hex = 0xffff00){
        const color = hex;
        const positions = [
            1,
            -1,
            1,
            -1,
            1,
            1,
            -1,
            -1,
            1,
            1,
            1,
            1,
            -1,
            1,
            1,
            -1,
            -1,
            1,
            1,
            -1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0
        ];
        const geometry = new $084574008ccedf86$export$b7be63a67df8959();
        geometry.setAttribute("position", new $084574008ccedf86$export$cbe7a62641830ebd(positions, 3));
        geometry.computeBoundingSphere();
        super(geometry, new $084574008ccedf86$export$fbaaa33907730a0c({
            color: color,
            toneMapped: false
        }));
        this.type = "PlaneHelper";
        this.plane = plane;
        this.size = size;
        const positions2 = [
            1,
            1,
            1,
            -1,
            1,
            1,
            -1,
            -1,
            1,
            1,
            1,
            1,
            -1,
            -1,
            1,
            1,
            -1,
            1
        ];
        const geometry2 = new $084574008ccedf86$export$b7be63a67df8959();
        geometry2.setAttribute("position", new $084574008ccedf86$export$cbe7a62641830ebd(positions2, 3));
        geometry2.computeBoundingSphere();
        this.add(new $084574008ccedf86$export$e176487c05830cc5(geometry2, new $084574008ccedf86$export$55cbcc9b622fe1f5({
            color: color,
            opacity: 0.2,
            transparent: true,
            depthWrite: false,
            toneMapped: false
        })));
    }
    updateMatrixWorld(force) {
        let scale = -this.plane.constant;
        if (Math.abs(scale) < 1e-8) scale = 1e-8; // sign does not matter
        this.scale.set(0.5 * this.size, 0.5 * this.size, scale);
        this.children[0].material.side = scale < 0 ? $084574008ccedf86$export$d9f0486e75b5ace : $084574008ccedf86$export$2ede184fc2998901; // renderer flips side when determinant < 0; flipping not wanted here
        this.lookAt(this.plane.normal);
        super.updateMatrixWorld(force);
    }
}
const $084574008ccedf86$var$_axis = /*@__PURE__*/ new $084574008ccedf86$export$64b5c384219d3699();
let $084574008ccedf86$var$_lineGeometry, $084574008ccedf86$var$_coneGeometry;
class $084574008ccedf86$export$a3008e7bd8d2cbe7 extends $084574008ccedf86$export$e4dd07dff30cc924 {
    // dir is assumed to be normalized
    constructor(dir = new $084574008ccedf86$export$64b5c384219d3699(0, 0, 1), origin = new $084574008ccedf86$export$64b5c384219d3699(0, 0, 0), length = 1, color = 0xffff00, headLength = length * 0.2, headWidth = headLength * 0.2){
        super();
        this.type = "ArrowHelper";
        if ($084574008ccedf86$var$_lineGeometry === undefined) {
            $084574008ccedf86$var$_lineGeometry = new $084574008ccedf86$export$b7be63a67df8959();
            $084574008ccedf86$var$_lineGeometry.setAttribute("position", new $084574008ccedf86$export$cbe7a62641830ebd([
                0,
                0,
                0,
                0,
                1,
                0
            ], 3));
            $084574008ccedf86$var$_coneGeometry = new $084574008ccedf86$export$d4345c83207d7c68(0, 0.5, 1, 5, 1);
            $084574008ccedf86$var$_coneGeometry.translate(0, -0.5, 0);
        }
        this.position.copy(origin);
        this.line = new $084574008ccedf86$export$17d680238e50603e($084574008ccedf86$var$_lineGeometry, new $084574008ccedf86$export$fbaaa33907730a0c({
            color: color,
            toneMapped: false
        }));
        this.line.matrixAutoUpdate = false;
        this.add(this.line);
        this.cone = new $084574008ccedf86$export$e176487c05830cc5($084574008ccedf86$var$_coneGeometry, new $084574008ccedf86$export$55cbcc9b622fe1f5({
            color: color,
            toneMapped: false
        }));
        this.cone.matrixAutoUpdate = false;
        this.add(this.cone);
        this.setDirection(dir);
        this.setLength(length, headLength, headWidth);
    }
    setDirection(dir) {
        // dir is assumed to be normalized
        if (dir.y > 0.99999) this.quaternion.set(0, 0, 0, 1);
        else if (dir.y < -0.99999) this.quaternion.set(1, 0, 0, 0);
        else {
            $084574008ccedf86$var$_axis.set(dir.z, 0, -dir.x).normalize();
            const radians = Math.acos(dir.y);
            this.quaternion.setFromAxisAngle($084574008ccedf86$var$_axis, radians);
        }
    }
    setLength(length, headLength = length * 0.2, headWidth = headLength * 0.2) {
        this.line.scale.set(1, Math.max(0.0001, length - headLength), 1); // see #17458
        this.line.updateMatrix();
        this.cone.scale.set(headWidth, headLength, headWidth);
        this.cone.position.y = length;
        this.cone.updateMatrix();
    }
    setColor(color) {
        this.line.material.color.set(color);
        this.cone.material.color.set(color);
    }
    copy(source) {
        super.copy(source, false);
        this.line.copy(source.line);
        this.cone.copy(source.cone);
        return this;
    }
}
class $084574008ccedf86$export$6c8303f35b8578fd extends $084574008ccedf86$export$ff1ed10fedfdd604 {
    constructor(size = 1){
        const vertices = [
            0,
            0,
            0,
            size,
            0,
            0,
            0,
            0,
            0,
            0,
            size,
            0,
            0,
            0,
            0,
            0,
            0,
            size
        ];
        const colors = [
            1,
            0,
            0,
            1,
            0.6,
            0,
            0,
            1,
            0,
            0.6,
            1,
            0,
            0,
            0,
            1,
            0,
            0.6,
            1
        ];
        const geometry = new $084574008ccedf86$export$b7be63a67df8959();
        geometry.setAttribute("position", new $084574008ccedf86$export$cbe7a62641830ebd(vertices, 3));
        geometry.setAttribute("color", new $084574008ccedf86$export$cbe7a62641830ebd(colors, 3));
        const material = new $084574008ccedf86$export$fbaaa33907730a0c({
            vertexColors: true,
            toneMapped: false
        });
        super(geometry, material);
        this.type = "AxesHelper";
    }
    setColors(xAxisColor, yAxisColor, zAxisColor) {
        const color = new $084574008ccedf86$export$892596cec99bc70e();
        const array = this.geometry.attributes.color.array;
        color.set(xAxisColor);
        color.toArray(array, 0);
        color.toArray(array, 3);
        color.set(yAxisColor);
        color.toArray(array, 6);
        color.toArray(array, 9);
        color.set(zAxisColor);
        color.toArray(array, 12);
        color.toArray(array, 15);
        this.geometry.attributes.color.needsUpdate = true;
        return this;
    }
    dispose() {
        this.geometry.dispose();
        this.material.dispose();
    }
}
class $084574008ccedf86$export$148534a3c727230b {
    constructor(){
        this.type = "ShapePath";
        this.color = new $084574008ccedf86$export$892596cec99bc70e();
        this.subPaths = [];
        this.currentPath = null;
    }
    moveTo(x, y) {
        this.currentPath = new $084574008ccedf86$export$4b2950bdac9b6ee9();
        this.subPaths.push(this.currentPath);
        this.currentPath.moveTo(x, y);
        return this;
    }
    lineTo(x, y) {
        this.currentPath.lineTo(x, y);
        return this;
    }
    quadraticCurveTo(aCPx, aCPy, aX, aY) {
        this.currentPath.quadraticCurveTo(aCPx, aCPy, aX, aY);
        return this;
    }
    bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
        this.currentPath.bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY);
        return this;
    }
    splineThru(pts) {
        this.currentPath.splineThru(pts);
        return this;
    }
    toShapes(isCCW, noHoles) {
        function toShapesNoHoles(inSubpaths) {
            const shapes = [];
            for(let i381 = 0, l = inSubpaths.length; i381 < l; i381++){
                const tmpPath = inSubpaths[i381];
                const tmpShape = new $084574008ccedf86$export$6428a7f2611ef1fa();
                tmpShape.curves = tmpPath.curves;
                shapes.push(tmpShape);
            }
            return shapes;
        }
        function isPointInsidePolygon(inPt, inPolygon) {
            const polyLen = inPolygon.length;
            // inPt on polygon contour => immediate success    or
            // toggling of inside/outside at every single! intersection point of an edge
            //  with the horizontal line through inPt, left of inPt
            //  not counting lowerY endpoints of edges and whole edges on that line
            let inside = false;
            for(let p = polyLen - 1, q = 0; q < polyLen; p = q++){
                let edgeLowPt = inPolygon[p];
                let edgeHighPt = inPolygon[q];
                let edgeDx = edgeHighPt.x - edgeLowPt.x;
                let edgeDy = edgeHighPt.y - edgeLowPt.y;
                if (Math.abs(edgeDy) > Number.EPSILON) {
                    // not parallel
                    if (edgeDy < 0) {
                        edgeLowPt = inPolygon[q];
                        edgeDx = -edgeDx;
                        edgeHighPt = inPolygon[p];
                        edgeDy = -edgeDy;
                    }
                    if (inPt.y < edgeLowPt.y || inPt.y > edgeHighPt.y) continue;
                    if (inPt.y === edgeLowPt.y) {
                        if (inPt.x === edgeLowPt.x) return true; // inPt is on contour ?
                    // continue;				// no intersection or edgeLowPt => doesn't count !!!
                    } else {
                        const perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);
                        if (perpEdge === 0) return true; // inPt is on contour ?
                        if (perpEdge < 0) continue;
                        inside = !inside; // true intersection left of inPt
                    }
                } else {
                    // parallel or collinear
                    if (inPt.y !== edgeLowPt.y) continue; // parallel
                    // edge lies on the same horizontal line as inPt
                    if (edgeHighPt.x <= inPt.x && inPt.x <= edgeLowPt.x || edgeLowPt.x <= inPt.x && inPt.x <= edgeHighPt.x) return true; // inPt: Point on contour !
                // continue;
                }
            }
            return inside;
        }
        const isClockWise = $084574008ccedf86$export$96bdf6d9c66d7ba8.isClockWise;
        const subPaths = this.subPaths;
        if (subPaths.length === 0) return [];
        if (noHoles === true) return toShapesNoHoles(subPaths);
        let solid, tmpPath1, tmpShape1;
        const shapes1 = [];
        if (subPaths.length === 1) {
            tmpPath1 = subPaths[0];
            tmpShape1 = new $084574008ccedf86$export$6428a7f2611ef1fa();
            tmpShape1.curves = tmpPath1.curves;
            shapes1.push(tmpShape1);
            return shapes1;
        }
        let holesFirst = !isClockWise(subPaths[0].getPoints());
        holesFirst = isCCW ? !holesFirst : holesFirst;
        // console.log("Holes first", holesFirst);
        const betterShapeHoles = [];
        const newShapes = [];
        let newShapeHoles = [];
        let mainIdx = 0;
        let tmpPoints;
        newShapes[mainIdx] = undefined;
        newShapeHoles[mainIdx] = [];
        for(let i380 = 0, l6 = subPaths.length; i380 < l6; i380++){
            tmpPath1 = subPaths[i380];
            tmpPoints = tmpPath1.getPoints();
            solid = isClockWise(tmpPoints);
            solid = isCCW ? !solid : solid;
            if (solid) {
                if (!holesFirst && newShapes[mainIdx]) mainIdx++;
                newShapes[mainIdx] = {
                    s: new $084574008ccedf86$export$6428a7f2611ef1fa(),
                    p: tmpPoints
                };
                newShapes[mainIdx].s.curves = tmpPath1.curves;
                if (holesFirst) mainIdx++;
                newShapeHoles[mainIdx] = [];
            //console.log('cw', i);
            } else newShapeHoles[mainIdx].push({
                h: tmpPath1,
                p: tmpPoints[0]
            });
        }
        // only Holes? -> probably all Shapes with wrong orientation
        if (!newShapes[0]) return toShapesNoHoles(subPaths);
        if (newShapes.length > 1) {
            let ambiguous = false;
            let toChange = 0;
            for(let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++)betterShapeHoles[sIdx] = [];
            for(let sIdx1 = 0, sLen1 = newShapes.length; sIdx1 < sLen1; sIdx1++){
                const sho = newShapeHoles[sIdx1];
                for(let hIdx = 0; hIdx < sho.length; hIdx++){
                    const ho = sho[hIdx];
                    let hole_unassigned = true;
                    for(let s2Idx = 0; s2Idx < newShapes.length; s2Idx++)if (isPointInsidePolygon(ho.p, newShapes[s2Idx].p)) {
                        if (sIdx1 !== s2Idx) toChange++;
                        if (hole_unassigned) {
                            hole_unassigned = false;
                            betterShapeHoles[s2Idx].push(ho);
                        } else ambiguous = true;
                    }
                    if (hole_unassigned) betterShapeHoles[sIdx1].push(ho);
                }
            }
            if (toChange > 0 && ambiguous === false) newShapeHoles = betterShapeHoles;
        }
        let tmpHoles;
        for(let i379 = 0, il = newShapes.length; i379 < il; i379++){
            tmpShape1 = newShapes[i379].s;
            shapes1.push(tmpShape1);
            tmpHoles = newShapeHoles[i379];
            for(let j = 0, jl = tmpHoles.length; j < jl; j++)tmpShape1.holes.push(tmpHoles[j].h);
        }
        //console.log("shape", shapes);
        return shapes1;
    }
}
// Fast Half Float Conversions, http://www.fox-toolkit.org/ftp/fasthalffloatconversion.pdf
class $084574008ccedf86$export$11ce8b759162cc80 {
    // float32 to float16
    static toHalfFloat(val) {
        if (Math.abs(val) > 65504) console.warn("THREE.DataUtils.toHalfFloat(): Value out of range.");
        val = $084574008ccedf86$var$clamp(val, -65504, 65504);
        $084574008ccedf86$var$_floatView[0] = val;
        const f = $084574008ccedf86$var$_uint32View[0];
        const e = f >> 23 & 0x1ff;
        return $084574008ccedf86$var$_baseTable[e] + ((f & 0x007fffff) >> $084574008ccedf86$var$_shiftTable[e]);
    }
    // float16 to float32
    static fromHalfFloat(val) {
        const m = val >> 10;
        $084574008ccedf86$var$_uint32View[0] = $084574008ccedf86$var$_mantissaTable[$084574008ccedf86$var$_offsetTable[m] + (val & 0x3ff)] + $084574008ccedf86$var$_exponentTable[m];
        return $084574008ccedf86$var$_floatView[0];
    }
}
// float32 to float16 helpers
const $084574008ccedf86$var$_buffer = new ArrayBuffer(4);
const $084574008ccedf86$var$_floatView = new Float32Array($084574008ccedf86$var$_buffer);
const $084574008ccedf86$var$_uint32View = new Uint32Array($084574008ccedf86$var$_buffer);
const $084574008ccedf86$var$_baseTable = new Uint32Array(512);
const $084574008ccedf86$var$_shiftTable = new Uint32Array(512);
for(let i1 = 0; i1 < 256; ++i1){
    const e = i1 - 127;
    // very small number (0, -0)
    if (e < -27) {
        $084574008ccedf86$var$_baseTable[i1] = 0x0000;
        $084574008ccedf86$var$_baseTable[i1 | 0x100] = 0x8000;
        $084574008ccedf86$var$_shiftTable[i1] = 24;
        $084574008ccedf86$var$_shiftTable[i1 | 0x100] = 24;
    // small number (denorm)
    } else if (e < -14) {
        $084574008ccedf86$var$_baseTable[i1] = 0x0400 >> -e - 14;
        $084574008ccedf86$var$_baseTable[i1 | 0x100] = 0x0400 >> -e - 14 | 0x8000;
        $084574008ccedf86$var$_shiftTable[i1] = -e - 1;
        $084574008ccedf86$var$_shiftTable[i1 | 0x100] = -e - 1;
    // normal number
    } else if (e <= 15) {
        $084574008ccedf86$var$_baseTable[i1] = e + 15 << 10;
        $084574008ccedf86$var$_baseTable[i1 | 0x100] = e + 15 << 10 | 0x8000;
        $084574008ccedf86$var$_shiftTable[i1] = 13;
        $084574008ccedf86$var$_shiftTable[i1 | 0x100] = 13;
    // large number (Infinity, -Infinity)
    } else if (e < 128) {
        $084574008ccedf86$var$_baseTable[i1] = 0x7c00;
        $084574008ccedf86$var$_baseTable[i1 | 0x100] = 0xfc00;
        $084574008ccedf86$var$_shiftTable[i1] = 24;
        $084574008ccedf86$var$_shiftTable[i1 | 0x100] = 24;
    // stay (NaN, Infinity, -Infinity)
    } else {
        $084574008ccedf86$var$_baseTable[i1] = 0x7c00;
        $084574008ccedf86$var$_baseTable[i1 | 0x100] = 0xfc00;
        $084574008ccedf86$var$_shiftTable[i1] = 13;
        $084574008ccedf86$var$_shiftTable[i1 | 0x100] = 13;
    }
}
// float16 to float32 helpers
const $084574008ccedf86$var$_mantissaTable = new Uint32Array(2048);
const $084574008ccedf86$var$_exponentTable = new Uint32Array(64);
const $084574008ccedf86$var$_offsetTable = new Uint32Array(64);
for(let i2 = 1; i2 < 1024; ++i2){
    let m = i2 << 13; // zero pad mantissa bits
    let e = 0; // zero exponent
    // normalized
    while((m & 0x00800000) === 0){
        m <<= 1;
        e -= 0x00800000; // decrement exponent
    }
    m &= -8388609; // clear leading 1 bit
    e += 0x38800000; // adjust bias
    $084574008ccedf86$var$_mantissaTable[i2] = m | e;
}
for(let i3 = 1024; i3 < 2048; ++i3)$084574008ccedf86$var$_mantissaTable[i3] = 0x38000000 + (i3 - 1024 << 13);
for(let i4 = 1; i4 < 31; ++i4)$084574008ccedf86$var$_exponentTable[i4] = i4 << 23;
$084574008ccedf86$var$_exponentTable[31] = 0x47800000;
$084574008ccedf86$var$_exponentTable[32] = 0x80000000;
for(let i5 = 33; i5 < 63; ++i5)$084574008ccedf86$var$_exponentTable[i5] = 0x80000000 + (i5 - 32 << 23);
$084574008ccedf86$var$_exponentTable[63] = 0xc7800000;
for(let i6 = 1; i6 < 64; ++i6)if (i6 !== 32) $084574008ccedf86$var$_offsetTable[i6] = 1024;
// r133, c5bb5434555a3c3ddd784944a0a124f996fc721b
class $084574008ccedf86$export$8f6f2b4b16d33f extends $084574008ccedf86$export$b7be63a67df8959 {
    constructor(){
        console.error("THREE.ParametricGeometry has been moved to /examples/jsm/geometries/ParametricGeometry.js");
        super();
    }
}
// r133, eb58ff153119090d3bbb24474ea0ffc40c70dc92
class $084574008ccedf86$export$684b774b4473ba5f extends $084574008ccedf86$export$b7be63a67df8959 {
    constructor(){
        console.error("THREE.TextGeometry has been moved to /examples/jsm/geometries/TextGeometry.js");
        super();
    }
}
// r133, eb58ff153119090d3bbb24474ea0ffc40c70dc92
function $084574008ccedf86$export$812303d6cad736b3() {
    console.error("THREE.FontLoader has been moved to /examples/jsm/loaders/FontLoader.js");
}
// r133, eb58ff153119090d3bbb24474ea0ffc40c70dc92
function $084574008ccedf86$export$89abf52a030e56ee() {
    console.error("THREE.Font has been moved to /examples/jsm/loaders/FontLoader.js");
}
// r134, d65e0af06644fe5a84a6fc0e372f4318f95a04c0
function $084574008ccedf86$export$960665a8431ecff6() {
    console.error("THREE.ImmediateRenderObject has been removed.");
}
// r138, 48b05d3500acc084df50be9b4c90781ad9b8cb17
class $084574008ccedf86$export$cb2022643d3c928d extends $084574008ccedf86$export$3c052beb2e51e23f {
    constructor(width, height, options){
        console.error('THREE.WebGLMultisampleRenderTarget has been removed. Use a normal render target and set the "samples" property to greater 0 to enable multisampling.');
        super(width, height, options);
        this.samples = 4;
    }
}
// r138, f9cd9cab03b7b64244e304900a3a2eeaa3a588ce
class $084574008ccedf86$export$e38bf4541665bbbd extends $084574008ccedf86$export$dfac6c8e811406a3 {
    constructor(data, width, height, depth){
        console.warn("THREE.DataTexture2DArray has been renamed to DataArrayTexture.");
        super(data, width, height, depth);
    }
}
// r138, f9cd9cab03b7b64244e304900a3a2eeaa3a588ce
class $084574008ccedf86$export$ef03cdc98340bab4 extends $084574008ccedf86$export$d7a3086320f856db {
    constructor(data, width, height, depth){
        console.warn("THREE.DataTexture3D has been renamed to Data3DTexture.");
        super(data, width, height, depth);
    }
}
if (typeof __THREE_DEVTOOLS__ !== "undefined") __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {
    detail: {
        revision: $084574008ccedf86$export$3545e07a80636437
    }
}));
if (typeof window !== "undefined") {
    if (window.__THREE__) console.warn("WARNING: Multiple instances of Three.js being imported.");
    else window.__THREE__ = $084574008ccedf86$export$3545e07a80636437;
}




const $fd127f46fc1ba387$var$_box = new (0, $084574008ccedf86$export$6f7d5a9418ab2aa3)();
const $fd127f46fc1ba387$var$_vector = new (0, $084574008ccedf86$export$64b5c384219d3699)();
class $fd127f46fc1ba387$export$5b1256aa5274bf8 extends (0, $084574008ccedf86$export$231f009cbe414146) {
    constructor(){
        super();
        this.isLineSegmentsGeometry = true;
        this.type = "LineSegmentsGeometry";
        const positions = [
            -1,
            2,
            0,
            1,
            2,
            0,
            -1,
            1,
            0,
            1,
            1,
            0,
            -1,
            0,
            0,
            1,
            0,
            0,
            -1,
            -1,
            0,
            1,
            -1,
            0
        ];
        const uvs = [
            -1,
            2,
            1,
            2,
            -1,
            1,
            1,
            1,
            -1,
            -1,
            1,
            -1,
            -1,
            -2,
            1,
            -2
        ];
        const index = [
            0,
            2,
            1,
            2,
            3,
            1,
            2,
            4,
            3,
            4,
            5,
            3,
            4,
            6,
            5,
            6,
            7,
            5
        ];
        this.setIndex(index);
        this.setAttribute("position", new (0, $084574008ccedf86$export$cbe7a62641830ebd)(positions, 3));
        this.setAttribute("uv", new (0, $084574008ccedf86$export$cbe7a62641830ebd)(uvs, 2));
    }
    applyMatrix4(matrix) {
        const start = this.attributes.instanceStart;
        const end = this.attributes.instanceEnd;
        if (start !== undefined) {
            start.applyMatrix4(matrix);
            end.applyMatrix4(matrix);
            start.needsUpdate = true;
        }
        if (this.boundingBox !== null) this.computeBoundingBox();
        if (this.boundingSphere !== null) this.computeBoundingSphere();
        return this;
    }
    setPositions(array) {
        let lineSegments;
        if (array instanceof Float32Array) lineSegments = array;
        else if (Array.isArray(array)) lineSegments = new Float32Array(array);
        const instanceBuffer = new (0, $084574008ccedf86$export$25ec0e1af1389358)(lineSegments, 6, 1); // xyz, xyz
        this.setAttribute("instanceStart", new (0, $084574008ccedf86$export$920b6d07334599c7)(instanceBuffer, 3, 0)); // xyz
        this.setAttribute("instanceEnd", new (0, $084574008ccedf86$export$920b6d07334599c7)(instanceBuffer, 3, 3)); // xyz
        //
        this.computeBoundingBox();
        this.computeBoundingSphere();
        return this;
    }
    setColors(array) {
        let colors;
        if (array instanceof Float32Array) colors = array;
        else if (Array.isArray(array)) colors = new Float32Array(array);
        const instanceColorBuffer = new (0, $084574008ccedf86$export$25ec0e1af1389358)(colors, 6, 1); // rgb, rgb
        this.setAttribute("instanceColorStart", new (0, $084574008ccedf86$export$920b6d07334599c7)(instanceColorBuffer, 3, 0)); // rgb
        this.setAttribute("instanceColorEnd", new (0, $084574008ccedf86$export$920b6d07334599c7)(instanceColorBuffer, 3, 3)); // rgb
        return this;
    }
    fromWireframeGeometry(geometry) {
        this.setPositions(geometry.attributes.position.array);
        return this;
    }
    fromEdgesGeometry(geometry) {
        this.setPositions(geometry.attributes.position.array);
        return this;
    }
    fromMesh(mesh) {
        this.fromWireframeGeometry(new (0, $084574008ccedf86$export$4b739da06d24892b)(mesh.geometry));
        // set colors, maybe
        return this;
    }
    fromLineSegments(lineSegments) {
        const geometry = lineSegments.geometry;
        this.setPositions(geometry.attributes.position.array); // assumes non-indexed
        // set colors, maybe
        return this;
    }
    computeBoundingBox() {
        if (this.boundingBox === null) this.boundingBox = new (0, $084574008ccedf86$export$6f7d5a9418ab2aa3)();
        const start = this.attributes.instanceStart;
        const end = this.attributes.instanceEnd;
        if (start !== undefined && end !== undefined) {
            this.boundingBox.setFromBufferAttribute(start);
            $fd127f46fc1ba387$var$_box.setFromBufferAttribute(end);
            this.boundingBox.union($fd127f46fc1ba387$var$_box);
        }
    }
    computeBoundingSphere() {
        if (this.boundingSphere === null) this.boundingSphere = new (0, $084574008ccedf86$export$805e8b72413ccaba)();
        if (this.boundingBox === null) this.computeBoundingBox();
        const start = this.attributes.instanceStart;
        const end = this.attributes.instanceEnd;
        if (start !== undefined && end !== undefined) {
            const center = this.boundingSphere.center;
            this.boundingBox.getCenter(center);
            let maxRadiusSq = 0;
            for(let i = 0, il = start.count; i < il; i++){
                $fd127f46fc1ba387$var$_vector.fromBufferAttribute(start, i);
                maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared($fd127f46fc1ba387$var$_vector));
                $fd127f46fc1ba387$var$_vector.fromBufferAttribute(end, i);
                maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared($fd127f46fc1ba387$var$_vector));
            }
            this.boundingSphere.radius = Math.sqrt(maxRadiusSq);
            if (isNaN(this.boundingSphere.radius)) console.error("THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.", this);
        }
    }
    toJSON() {
    // todo
    }
    applyMatrix(matrix) {
        console.warn("THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4().");
        return this.applyMatrix4(matrix);
    }
}



(0, $084574008ccedf86$export$6643083551874bf5).line = {
    worldUnits: {
        value: 1
    },
    linewidth: {
        value: 1
    },
    resolution: {
        value: new (0, $084574008ccedf86$export$c977b3e384af9ae1)(1, 1)
    },
    dashOffset: {
        value: 0
    },
    dashScale: {
        value: 1
    },
    dashSize: {
        value: 1
    },
    gapSize: {
        value: 1
    } // todo FIX - maybe change to totalSize
};
(0, $084574008ccedf86$export$bee4a7d47f8f5014)["line"] = {
    uniforms: (0, $084574008ccedf86$export$d8ecdf8615bfea69).merge([
        (0, $084574008ccedf86$export$6643083551874bf5).common,
        (0, $084574008ccedf86$export$6643083551874bf5).fog,
        (0, $084574008ccedf86$export$6643083551874bf5).line
    ]),
    vertexShader: /* glsl */ `
		#include <common>
		#include <color_pars_vertex>
		#include <fog_pars_vertex>
		#include <logdepthbuf_pars_vertex>
		#include <clipping_planes_pars_vertex>

		uniform float linewidth;
		uniform vec2 resolution;

		attribute vec3 instanceStart;
		attribute vec3 instanceEnd;

		attribute vec3 instanceColorStart;
		attribute vec3 instanceColorEnd;

		#ifdef WORLD_UNITS

			varying vec4 worldPos;
			varying vec3 worldStart;
			varying vec3 worldEnd;

			#ifdef USE_DASH

				varying vec2 vUv;

			#endif

		#else

			varying vec2 vUv;

		#endif

		#ifdef USE_DASH

			uniform float dashScale;
			attribute float instanceDistanceStart;
			attribute float instanceDistanceEnd;
			varying float vLineDistance;

		#endif

		void trimSegment( const in vec4 start, inout vec4 end ) {

			// trim end segment so it terminates between the camera plane and the near plane

			// conservative estimate of the near plane
			float a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column
			float b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column
			float nearEstimate = - 0.5 * b / a;

			float alpha = ( nearEstimate - start.z ) / ( end.z - start.z );

			end.xyz = mix( start.xyz, end.xyz, alpha );

		}

		void main() {

			#ifdef USE_COLOR

				vColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;

			#endif

			#ifdef USE_DASH

				vLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;
				vUv = uv;

			#endif

			float aspect = resolution.x / resolution.y;

			// camera space
			vec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );
			vec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );

			#ifdef WORLD_UNITS

				worldStart = start.xyz;
				worldEnd = end.xyz;

			#else

				vUv = uv;

			#endif

			// special case for perspective projection, and segments that terminate either in, or behind, the camera plane
			// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space
			// but we need to perform ndc-space calculations in the shader, so we must address this issue directly
			// perhaps there is a more elegant solution -- WestLangley

			bool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column

			if ( perspective ) {

				if ( start.z < 0.0 && end.z >= 0.0 ) {

					trimSegment( start, end );

				} else if ( end.z < 0.0 && start.z >= 0.0 ) {

					trimSegment( end, start );

				}

			}

			// clip space
			vec4 clipStart = projectionMatrix * start;
			vec4 clipEnd = projectionMatrix * end;

			// ndc space
			vec3 ndcStart = clipStart.xyz / clipStart.w;
			vec3 ndcEnd = clipEnd.xyz / clipEnd.w;

			// direction
			vec2 dir = ndcEnd.xy - ndcStart.xy;

			// account for clip-space aspect ratio
			dir.x *= aspect;
			dir = normalize( dir );

			#ifdef WORLD_UNITS

				// get the offset direction as perpendicular to the view vector
				vec3 worldDir = normalize( end.xyz - start.xyz );
				vec3 offset;
				if ( position.y < 0.5 ) {

					offset = normalize( cross( start.xyz, worldDir ) );

				} else {

					offset = normalize( cross( end.xyz, worldDir ) );

				}

				// sign flip
				if ( position.x < 0.0 ) offset *= - 1.0;

				float forwardOffset = dot( worldDir, vec3( 0.0, 0.0, 1.0 ) );

				// don't extend the line if we're rendering dashes because we
				// won't be rendering the endcaps
				#ifndef USE_DASH

					// extend the line bounds to encompass  endcaps
					start.xyz += - worldDir * linewidth * 0.5;
					end.xyz += worldDir * linewidth * 0.5;

					// shift the position of the quad so it hugs the forward edge of the line
					offset.xy -= dir * forwardOffset;
					offset.z += 0.5;

				#endif

				// endcaps
				if ( position.y > 1.0 || position.y < 0.0 ) {

					offset.xy += dir * 2.0 * forwardOffset;

				}

				// adjust for linewidth
				offset *= linewidth * 0.5;

				// set the world position
				worldPos = ( position.y < 0.5 ) ? start : end;
				worldPos.xyz += offset;

				// project the worldpos
				vec4 clip = projectionMatrix * worldPos;

				// shift the depth of the projected points so the line
				// segments overlap neatly
				vec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;
				clip.z = clipPose.z * clip.w;

			#else

				vec2 offset = vec2( dir.y, - dir.x );
				// undo aspect ratio adjustment
				dir.x /= aspect;
				offset.x /= aspect;

				// sign flip
				if ( position.x < 0.0 ) offset *= - 1.0;

				// endcaps
				if ( position.y < 0.0 ) {

					offset += - dir;

				} else if ( position.y > 1.0 ) {

					offset += dir;

				}

				// adjust for linewidth
				offset *= linewidth;

				// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...
				offset /= resolution.y;

				// select end
				vec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;

				// back to clip space
				offset *= clip.w;

				clip.xy += offset;

			#endif

			gl_Position = clip;

			vec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation

			#include <logdepthbuf_vertex>
			#include <clipping_planes_vertex>
			#include <fog_vertex>

		}
		`,
    fragmentShader: /* glsl */ `
		uniform vec3 diffuse;
		uniform float opacity;
		uniform float linewidth;

		#ifdef USE_DASH

			uniform float dashOffset;
			uniform float dashSize;
			uniform float gapSize;

		#endif

		varying float vLineDistance;

		#ifdef WORLD_UNITS

			varying vec4 worldPos;
			varying vec3 worldStart;
			varying vec3 worldEnd;

			#ifdef USE_DASH

				varying vec2 vUv;

			#endif

		#else

			varying vec2 vUv;

		#endif

		#include <common>
		#include <color_pars_fragment>
		#include <fog_pars_fragment>
		#include <logdepthbuf_pars_fragment>
		#include <clipping_planes_pars_fragment>

		vec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {

			float mua;
			float mub;

			vec3 p13 = p1 - p3;
			vec3 p43 = p4 - p3;

			vec3 p21 = p2 - p1;

			float d1343 = dot( p13, p43 );
			float d4321 = dot( p43, p21 );
			float d1321 = dot( p13, p21 );
			float d4343 = dot( p43, p43 );
			float d2121 = dot( p21, p21 );

			float denom = d2121 * d4343 - d4321 * d4321;

			float numer = d1343 * d4321 - d1321 * d4343;

			mua = numer / denom;
			mua = clamp( mua, 0.0, 1.0 );
			mub = ( d1343 + d4321 * ( mua ) ) / d4343;
			mub = clamp( mub, 0.0, 1.0 );

			return vec2( mua, mub );

		}

		void main() {

			#include <clipping_planes_fragment>

			#ifdef USE_DASH

				if ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps

				if ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX

			#endif

			float alpha = opacity;

			#ifdef WORLD_UNITS

				// Find the closest points on the view ray and the line segment
				vec3 rayEnd = normalize( worldPos.xyz ) * 1e5;
				vec3 lineDir = worldEnd - worldStart;
				vec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );

				vec3 p1 = worldStart + lineDir * params.x;
				vec3 p2 = rayEnd * params.y;
				vec3 delta = p1 - p2;
				float len = length( delta );
				float norm = len / linewidth;

				#ifndef USE_DASH

					#ifdef USE_ALPHA_TO_COVERAGE

						float dnorm = fwidth( norm );
						alpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );

					#else

						if ( norm > 0.5 ) {

							discard;

						}

					#endif

				#endif

			#else

				#ifdef USE_ALPHA_TO_COVERAGE

					// artifacts appear on some hardware if a derivative is taken within a conditional
					float a = vUv.x;
					float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
					float len2 = a * a + b * b;
					float dlen = fwidth( len2 );

					if ( abs( vUv.y ) > 1.0 ) {

						alpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );

					}

				#else

					if ( abs( vUv.y ) > 1.0 ) {

						float a = vUv.x;
						float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
						float len2 = a * a + b * b;

						if ( len2 > 1.0 ) discard;

					}

				#endif

			#endif

			vec4 diffuseColor = vec4( diffuse, alpha );

			#include <logdepthbuf_fragment>
			#include <color_fragment>

			gl_FragColor = vec4( diffuseColor.rgb, alpha );

			#include <tonemapping_fragment>
			#include <encodings_fragment>
			#include <fog_fragment>
			#include <premultiplied_alpha_fragment>

		}
		`
};
class $2841f46819dbdf7d$export$d19cd1378966f3d3 extends (0, $084574008ccedf86$export$83c7d75d550a8b0d) {
    constructor(parameters){
        super({
            type: "LineMaterial",
            uniforms: (0, $084574008ccedf86$export$d8ecdf8615bfea69).clone((0, $084574008ccedf86$export$bee4a7d47f8f5014)["line"].uniforms),
            vertexShader: (0, $084574008ccedf86$export$bee4a7d47f8f5014)["line"].vertexShader,
            fragmentShader: (0, $084574008ccedf86$export$bee4a7d47f8f5014)["line"].fragmentShader,
            clipping: true // required for clipping support
        });
        this.isLineMaterial = true;
        Object.defineProperties(this, {
            color: {
                enumerable: true,
                get: function() {
                    return this.uniforms.diffuse.value;
                },
                set: function(value) {
                    this.uniforms.diffuse.value = value;
                }
            },
            worldUnits: {
                enumerable: true,
                get: function() {
                    return "WORLD_UNITS" in this.defines;
                },
                set: function(value) {
                    if (value === true) this.defines.WORLD_UNITS = "";
                    else delete this.defines.WORLD_UNITS;
                }
            },
            linewidth: {
                enumerable: true,
                get: function() {
                    return this.uniforms.linewidth.value;
                },
                set: function(value) {
                    this.uniforms.linewidth.value = value;
                }
            },
            dashed: {
                enumerable: true,
                get: function() {
                    return Boolean("USE_DASH" in this.defines);
                },
                set (value) {
                    if (Boolean(value) !== Boolean("USE_DASH" in this.defines)) this.needsUpdate = true;
                    if (value === true) this.defines.USE_DASH = "";
                    else delete this.defines.USE_DASH;
                }
            },
            dashScale: {
                enumerable: true,
                get: function() {
                    return this.uniforms.dashScale.value;
                },
                set: function(value) {
                    this.uniforms.dashScale.value = value;
                }
            },
            dashSize: {
                enumerable: true,
                get: function() {
                    return this.uniforms.dashSize.value;
                },
                set: function(value) {
                    this.uniforms.dashSize.value = value;
                }
            },
            dashOffset: {
                enumerable: true,
                get: function() {
                    return this.uniforms.dashOffset.value;
                },
                set: function(value) {
                    this.uniforms.dashOffset.value = value;
                }
            },
            gapSize: {
                enumerable: true,
                get: function() {
                    return this.uniforms.gapSize.value;
                },
                set: function(value) {
                    this.uniforms.gapSize.value = value;
                }
            },
            opacity: {
                enumerable: true,
                get: function() {
                    return this.uniforms.opacity.value;
                },
                set: function(value) {
                    this.uniforms.opacity.value = value;
                }
            },
            resolution: {
                enumerable: true,
                get: function() {
                    return this.uniforms.resolution.value;
                },
                set: function(value) {
                    this.uniforms.resolution.value.copy(value);
                }
            },
            alphaToCoverage: {
                enumerable: true,
                get: function() {
                    return Boolean("USE_ALPHA_TO_COVERAGE" in this.defines);
                },
                set: function(value) {
                    if (Boolean(value) !== Boolean("USE_ALPHA_TO_COVERAGE" in this.defines)) this.needsUpdate = true;
                    if (value === true) {
                        this.defines.USE_ALPHA_TO_COVERAGE = "";
                        this.extensions.derivatives = true;
                    } else {
                        delete this.defines.USE_ALPHA_TO_COVERAGE;
                        this.extensions.derivatives = false;
                    }
                }
            }
        });
        this.setValues(parameters);
    }
}


const $07daaae4e109b37c$var$_start = new (0, $084574008ccedf86$export$64b5c384219d3699)();
const $07daaae4e109b37c$var$_end = new (0, $084574008ccedf86$export$64b5c384219d3699)();
const $07daaae4e109b37c$var$_start4 = new (0, $084574008ccedf86$export$fa7daccca11cdbe3)();
const $07daaae4e109b37c$var$_end4 = new (0, $084574008ccedf86$export$fa7daccca11cdbe3)();
const $07daaae4e109b37c$var$_ssOrigin = new (0, $084574008ccedf86$export$fa7daccca11cdbe3)();
const $07daaae4e109b37c$var$_ssOrigin3 = new (0, $084574008ccedf86$export$64b5c384219d3699)();
const $07daaae4e109b37c$var$_mvMatrix = new (0, $084574008ccedf86$export$2ae72fc923e5eb5)();
const $07daaae4e109b37c$var$_line = new (0, $084574008ccedf86$export$e0ba6359f1954fd3)();
const $07daaae4e109b37c$var$_closestPoint = new (0, $084574008ccedf86$export$64b5c384219d3699)();
const $07daaae4e109b37c$var$_box = new (0, $084574008ccedf86$export$6f7d5a9418ab2aa3)();
const $07daaae4e109b37c$var$_sphere = new (0, $084574008ccedf86$export$805e8b72413ccaba)();
const $07daaae4e109b37c$var$_clipToWorldVector = new (0, $084574008ccedf86$export$fa7daccca11cdbe3)();
let $07daaae4e109b37c$var$_ray, $07daaae4e109b37c$var$_instanceStart, $07daaae4e109b37c$var$_instanceEnd, $07daaae4e109b37c$var$_lineWidth;
// Returns the margin required to expand by in world space given the distance from the camera,
// line width, resolution, and camera projection
function $07daaae4e109b37c$var$getWorldSpaceHalfWidth(camera, distance, resolution) {
    // transform into clip space, adjust the x and y values by the pixel width offset, then
    // transform back into world space to get world offset. Note clip space is [-1, 1] so full
    // width does not need to be halved.
    $07daaae4e109b37c$var$_clipToWorldVector.set(0, 0, -distance, 1.0).applyMatrix4(camera.projectionMatrix);
    $07daaae4e109b37c$var$_clipToWorldVector.multiplyScalar(1.0 / $07daaae4e109b37c$var$_clipToWorldVector.w);
    $07daaae4e109b37c$var$_clipToWorldVector.x = $07daaae4e109b37c$var$_lineWidth / resolution.width;
    $07daaae4e109b37c$var$_clipToWorldVector.y = $07daaae4e109b37c$var$_lineWidth / resolution.height;
    $07daaae4e109b37c$var$_clipToWorldVector.applyMatrix4(camera.projectionMatrixInverse);
    $07daaae4e109b37c$var$_clipToWorldVector.multiplyScalar(1.0 / $07daaae4e109b37c$var$_clipToWorldVector.w);
    return Math.abs(Math.max($07daaae4e109b37c$var$_clipToWorldVector.x, $07daaae4e109b37c$var$_clipToWorldVector.y));
}
function $07daaae4e109b37c$var$raycastWorldUnits(lineSegments, intersects) {
    for(let i = 0, l = $07daaae4e109b37c$var$_instanceStart.count; i < l; i++){
        $07daaae4e109b37c$var$_line.start.fromBufferAttribute($07daaae4e109b37c$var$_instanceStart, i);
        $07daaae4e109b37c$var$_line.end.fromBufferAttribute($07daaae4e109b37c$var$_instanceEnd, i);
        const pointOnLine = new (0, $084574008ccedf86$export$64b5c384219d3699)();
        const point = new (0, $084574008ccedf86$export$64b5c384219d3699)();
        $07daaae4e109b37c$var$_ray.distanceSqToSegment($07daaae4e109b37c$var$_line.start, $07daaae4e109b37c$var$_line.end, point, pointOnLine);
        const isInside = point.distanceTo(pointOnLine) < $07daaae4e109b37c$var$_lineWidth * 0.5;
        if (isInside) intersects.push({
            point: point,
            pointOnLine: pointOnLine,
            distance: $07daaae4e109b37c$var$_ray.origin.distanceTo(point),
            object: lineSegments,
            face: null,
            faceIndex: i,
            uv: null,
            uv2: null
        });
    }
}
function $07daaae4e109b37c$var$raycastScreenSpace(lineSegments, camera, intersects) {
    const projectionMatrix = camera.projectionMatrix;
    const material = lineSegments.material;
    const resolution = material.resolution;
    const matrixWorld = lineSegments.matrixWorld;
    const geometry = lineSegments.geometry;
    const instanceStart = geometry.attributes.instanceStart;
    const instanceEnd = geometry.attributes.instanceEnd;
    const near = -camera.near;
    //
    // pick a point 1 unit out along the ray to avoid the ray origin
    // sitting at the camera origin which will cause "w" to be 0 when
    // applying the projection matrix.
    $07daaae4e109b37c$var$_ray.at(1, $07daaae4e109b37c$var$_ssOrigin);
    // ndc space [ - 1.0, 1.0 ]
    $07daaae4e109b37c$var$_ssOrigin.w = 1;
    $07daaae4e109b37c$var$_ssOrigin.applyMatrix4(camera.matrixWorldInverse);
    $07daaae4e109b37c$var$_ssOrigin.applyMatrix4(projectionMatrix);
    $07daaae4e109b37c$var$_ssOrigin.multiplyScalar(1 / $07daaae4e109b37c$var$_ssOrigin.w);
    // screen space
    $07daaae4e109b37c$var$_ssOrigin.x *= resolution.x / 2;
    $07daaae4e109b37c$var$_ssOrigin.y *= resolution.y / 2;
    $07daaae4e109b37c$var$_ssOrigin.z = 0;
    $07daaae4e109b37c$var$_ssOrigin3.copy($07daaae4e109b37c$var$_ssOrigin);
    $07daaae4e109b37c$var$_mvMatrix.multiplyMatrices(camera.matrixWorldInverse, matrixWorld);
    for(let i = 0, l = instanceStart.count; i < l; i++){
        $07daaae4e109b37c$var$_start4.fromBufferAttribute(instanceStart, i);
        $07daaae4e109b37c$var$_end4.fromBufferAttribute(instanceEnd, i);
        $07daaae4e109b37c$var$_start4.w = 1;
        $07daaae4e109b37c$var$_end4.w = 1;
        // camera space
        $07daaae4e109b37c$var$_start4.applyMatrix4($07daaae4e109b37c$var$_mvMatrix);
        $07daaae4e109b37c$var$_end4.applyMatrix4($07daaae4e109b37c$var$_mvMatrix);
        // skip the segment if it's entirely behind the camera
        const isBehindCameraNear = $07daaae4e109b37c$var$_start4.z > near && $07daaae4e109b37c$var$_end4.z > near;
        if (isBehindCameraNear) continue;
        // trim the segment if it extends behind camera near
        if ($07daaae4e109b37c$var$_start4.z > near) {
            const deltaDist = $07daaae4e109b37c$var$_start4.z - $07daaae4e109b37c$var$_end4.z;
            const t = ($07daaae4e109b37c$var$_start4.z - near) / deltaDist;
            $07daaae4e109b37c$var$_start4.lerp($07daaae4e109b37c$var$_end4, t);
        } else if ($07daaae4e109b37c$var$_end4.z > near) {
            const deltaDist = $07daaae4e109b37c$var$_end4.z - $07daaae4e109b37c$var$_start4.z;
            const t = ($07daaae4e109b37c$var$_end4.z - near) / deltaDist;
            $07daaae4e109b37c$var$_end4.lerp($07daaae4e109b37c$var$_start4, t);
        }
        // clip space
        $07daaae4e109b37c$var$_start4.applyMatrix4(projectionMatrix);
        $07daaae4e109b37c$var$_end4.applyMatrix4(projectionMatrix);
        // ndc space [ - 1.0, 1.0 ]
        $07daaae4e109b37c$var$_start4.multiplyScalar(1 / $07daaae4e109b37c$var$_start4.w);
        $07daaae4e109b37c$var$_end4.multiplyScalar(1 / $07daaae4e109b37c$var$_end4.w);
        // screen space
        $07daaae4e109b37c$var$_start4.x *= resolution.x / 2;
        $07daaae4e109b37c$var$_start4.y *= resolution.y / 2;
        $07daaae4e109b37c$var$_end4.x *= resolution.x / 2;
        $07daaae4e109b37c$var$_end4.y *= resolution.y / 2;
        // create 2d segment
        $07daaae4e109b37c$var$_line.start.copy($07daaae4e109b37c$var$_start4);
        $07daaae4e109b37c$var$_line.start.z = 0;
        $07daaae4e109b37c$var$_line.end.copy($07daaae4e109b37c$var$_end4);
        $07daaae4e109b37c$var$_line.end.z = 0;
        // get closest point on ray to segment
        const param = $07daaae4e109b37c$var$_line.closestPointToPointParameter($07daaae4e109b37c$var$_ssOrigin3, true);
        $07daaae4e109b37c$var$_line.at(param, $07daaae4e109b37c$var$_closestPoint);
        // check if the intersection point is within clip space
        const zPos = (0, $084574008ccedf86$export$6a7ef315a0d1ef07).lerp($07daaae4e109b37c$var$_start4.z, $07daaae4e109b37c$var$_end4.z, param);
        const isInClipSpace = zPos >= -1 && zPos <= 1;
        const isInside = $07daaae4e109b37c$var$_ssOrigin3.distanceTo($07daaae4e109b37c$var$_closestPoint) < $07daaae4e109b37c$var$_lineWidth * 0.5;
        if (isInClipSpace && isInside) {
            $07daaae4e109b37c$var$_line.start.fromBufferAttribute(instanceStart, i);
            $07daaae4e109b37c$var$_line.end.fromBufferAttribute(instanceEnd, i);
            $07daaae4e109b37c$var$_line.start.applyMatrix4(matrixWorld);
            $07daaae4e109b37c$var$_line.end.applyMatrix4(matrixWorld);
            const pointOnLine = new (0, $084574008ccedf86$export$64b5c384219d3699)();
            const point = new (0, $084574008ccedf86$export$64b5c384219d3699)();
            $07daaae4e109b37c$var$_ray.distanceSqToSegment($07daaae4e109b37c$var$_line.start, $07daaae4e109b37c$var$_line.end, point, pointOnLine);
            intersects.push({
                point: point,
                pointOnLine: pointOnLine,
                distance: $07daaae4e109b37c$var$_ray.origin.distanceTo(point),
                object: lineSegments,
                face: null,
                faceIndex: i,
                uv: null,
                uv2: null
            });
        }
    }
}
class $07daaae4e109b37c$export$6eda8f258bdba8c5 extends (0, $084574008ccedf86$export$e176487c05830cc5) {
    constructor(geometry = new (0, $fd127f46fc1ba387$export$5b1256aa5274bf8)(), material = new (0, $2841f46819dbdf7d$export$d19cd1378966f3d3)({
        color: Math.random() * 0xffffff
    })){
        super(geometry, material);
        this.isLineSegments2 = true;
        this.type = "LineSegments2";
    }
    // for backwards-compatibility, but could be a method of LineSegmentsGeometry...
    computeLineDistances() {
        const geometry = this.geometry;
        const instanceStart = geometry.attributes.instanceStart;
        const instanceEnd = geometry.attributes.instanceEnd;
        const lineDistances = new Float32Array(2 * instanceStart.count);
        for(let i = 0, j = 0, l = instanceStart.count; i < l; i++, j += 2){
            $07daaae4e109b37c$var$_start.fromBufferAttribute(instanceStart, i);
            $07daaae4e109b37c$var$_end.fromBufferAttribute(instanceEnd, i);
            lineDistances[j] = j === 0 ? 0 : lineDistances[j - 1];
            lineDistances[j + 1] = lineDistances[j] + $07daaae4e109b37c$var$_start.distanceTo($07daaae4e109b37c$var$_end);
        }
        const instanceDistanceBuffer = new (0, $084574008ccedf86$export$25ec0e1af1389358)(lineDistances, 2, 1); // d0, d1
        geometry.setAttribute("instanceDistanceStart", new (0, $084574008ccedf86$export$920b6d07334599c7)(instanceDistanceBuffer, 1, 0)); // d0
        geometry.setAttribute("instanceDistanceEnd", new (0, $084574008ccedf86$export$920b6d07334599c7)(instanceDistanceBuffer, 1, 1)); // d1
        return this;
    }
    raycast(raycaster, intersects) {
        const worldUnits = this.material.worldUnits;
        const camera = raycaster.camera;
        if (camera === null && !worldUnits) console.error('LineSegments2: "Raycaster.camera" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.');
        const threshold = raycaster.params.Line2 !== undefined ? raycaster.params.Line2.threshold || 0 : 0;
        $07daaae4e109b37c$var$_ray = raycaster.ray;
        const matrixWorld = this.matrixWorld;
        const geometry = this.geometry;
        const material = this.material;
        $07daaae4e109b37c$var$_lineWidth = material.linewidth + threshold;
        $07daaae4e109b37c$var$_instanceStart = geometry.attributes.instanceStart;
        $07daaae4e109b37c$var$_instanceEnd = geometry.attributes.instanceEnd;
        // check if we intersect the sphere bounds
        if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
        $07daaae4e109b37c$var$_sphere.copy(geometry.boundingSphere).applyMatrix4(matrixWorld);
        // increase the sphere bounds by the worst case line screen space width
        let sphereMargin;
        if (worldUnits) sphereMargin = $07daaae4e109b37c$var$_lineWidth * 0.5;
        else {
            const distanceToSphere = Math.max(camera.near, $07daaae4e109b37c$var$_sphere.distanceToPoint($07daaae4e109b37c$var$_ray.origin));
            sphereMargin = $07daaae4e109b37c$var$getWorldSpaceHalfWidth(camera, distanceToSphere, material.resolution);
        }
        $07daaae4e109b37c$var$_sphere.radius += sphereMargin;
        if ($07daaae4e109b37c$var$_ray.intersectsSphere($07daaae4e109b37c$var$_sphere) === false) return;
        // check if we intersect the box bounds
        if (geometry.boundingBox === null) geometry.computeBoundingBox();
        $07daaae4e109b37c$var$_box.copy(geometry.boundingBox).applyMatrix4(matrixWorld);
        // increase the box bounds by the worst case line width
        let boxMargin;
        if (worldUnits) boxMargin = $07daaae4e109b37c$var$_lineWidth * 0.5;
        else {
            const distanceToBox = Math.max(camera.near, $07daaae4e109b37c$var$_box.distanceToPoint($07daaae4e109b37c$var$_ray.origin));
            boxMargin = $07daaae4e109b37c$var$getWorldSpaceHalfWidth(camera, distanceToBox, material.resolution);
        }
        $07daaae4e109b37c$var$_box.expandByScalar(boxMargin);
        if ($07daaae4e109b37c$var$_ray.intersectsBox($07daaae4e109b37c$var$_box) === false) return;
        if (worldUnits) $07daaae4e109b37c$var$raycastWorldUnits(this, intersects);
        else $07daaae4e109b37c$var$raycastScreenSpace(this, camera, intersects);
    }
}



class $b5593040d67e37e6$export$dcc17b59d0a74bb5 extends (0, $fd127f46fc1ba387$export$5b1256aa5274bf8) {
    constructor(){
        super();
        this.isLineGeometry = true;
        this.type = "LineGeometry";
    }
    setPositions(array) {
        // converts [ x1, y1, z1,  x2, y2, z2, ... ] to pairs format
        const length = array.length - 3;
        const points = new Float32Array(2 * length);
        for(let i = 0; i < length; i += 3){
            points[2 * i] = array[i];
            points[2 * i + 1] = array[i + 1];
            points[2 * i + 2] = array[i + 2];
            points[2 * i + 3] = array[i + 3];
            points[2 * i + 4] = array[i + 4];
            points[2 * i + 5] = array[i + 5];
        }
        super.setPositions(points);
        return this;
    }
    setColors(array) {
        // converts [ r1, g1, b1,  r2, g2, b2, ... ] to pairs format
        const length = array.length - 3;
        const colors = new Float32Array(2 * length);
        for(let i = 0; i < length; i += 3){
            colors[2 * i] = array[i];
            colors[2 * i + 1] = array[i + 1];
            colors[2 * i + 2] = array[i + 2];
            colors[2 * i + 3] = array[i + 3];
            colors[2 * i + 4] = array[i + 4];
            colors[2 * i + 5] = array[i + 5];
        }
        super.setColors(colors);
        return this;
    }
    fromLine(line) {
        const geometry = line.geometry;
        this.setPositions(geometry.attributes.position.array); // assumes non-indexed
        // set colors, maybe
        return this;
    }
}



class $bedd24a76a719d5b$export$4e6fcde58d84e955 extends (0, $07daaae4e109b37c$export$6eda8f258bdba8c5) {
    constructor(geometry = new (0, $b5593040d67e37e6$export$dcc17b59d0a74bb5)(), material = new (0, $2841f46819dbdf7d$export$d19cd1378966f3d3)({
        color: Math.random() * 0xffffff
    })){
        super(geometry, material);
        this.isLine2 = true;
        this.type = "Line2";
    }
}




const $fba578f3a3f8835f$export$84657c60382b0f83 = `
attribute float size;
attribute vec3 customColor;

varying vec3 vColor;

void main() {
    vColor = customColor;
    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
    gl_PointSize = size * ( 300.0 / -mvPosition.z );
    gl_Position = projectionMatrix * mvPosition;
}
`;


const $b6abeaa394254db5$export$4391ef72fa03c19 = `
uniform vec3 color;
uniform sampler2D pointTexture;
uniform float alphaTest;

varying vec3 vColor;

void main() {
    gl_FragColor = vec4( color * vColor, 1.0 );
    gl_FragColor = gl_FragColor * texture2D( pointTexture, gl_PointCoord );
    if ( gl_FragColor.a < alphaTest ) discard;
}
`;



var $03PHD = parcelRequire("03PHD");
// Draw the graph out as a bunch of vertices
function $2257d881a60ecbb5$var$DrawTHREEGraphVertices(Graph, bounds) {
    const positionAttribute = [];
    const sizes = [];
    const colors = [];
    const labels = [];
    const color = new $084574008ccedf86$export$892596cec99bc70e();
    // process the data set
    let i = 0;
    for (const node of Graph.nodes.keys()){
        const nodeData = Graph.nodes.get(node);
        positionAttribute.push(nodeData.data.pos.x * bounds, nodeData.data.pos.y * bounds, nodeData.data.pos.z * bounds);
        color.setRGB(255, 255, 255);
        color.toArray(colors, i * 3);
        if (nodeData.data.size != undefined) sizes.push(nodeData.data.size);
        else sizes.push(4);
        labels.push(node);
        i += 1;
    }
    const geometry = new $084574008ccedf86$export$b7be63a67df8959();
    // geometry attribute
    geometry.setAttribute("position", new $084574008ccedf86$export$cbe7a62641830ebd(positionAttribute, 3));
    // color attribute
    geometry.setAttribute("customColor", new $084574008ccedf86$export$cbe7a62641830ebd(colors, 3));
    // size attribute
    geometry.setAttribute("size", new $084574008ccedf86$export$cbe7a62641830ebd(sizes, 1));
    // label attribute
    geometry.setAttribute("label", new $084574008ccedf86$export$46b369aed2968a0a(labels, 1));
    geometry.name = "THIS IS THE VERTEX GROUP";
    // example material
    const PointMaterial = new $084574008ccedf86$export$83c7d75d550a8b0d({
        uniforms: {
            color: {
                value: new $084574008ccedf86$export$892596cec99bc70e(0xffffff)
            },
            pointTexture: {
                value: new $084574008ccedf86$export$fd1bfc71f64c538c().load("./Textures/Square.png")
            },
            alphaTest: {
                value: 0.9
            }
        },
        vertexShader: (0, $fba578f3a3f8835f$export$84657c60382b0f83),
        fragmentShader: (0, $b6abeaa394254db5$export$4391ef72fa03c19)
    });
    const vertices = new $084574008ccedf86$export$1c787534cb11aa3e(geometry, PointMaterial);
    return vertices;
}
// then make a thing which draws out all the edges (THICK)
function $2257d881a60ecbb5$var$DrawTHREEGraphEdgesThick(G, bounds) {
    return $2257d881a60ecbb5$var$DrawThickEdgesFromEdgeMap(G.edges, bounds);
}
// draw a thing to draw out all the edges from the edge map stuff
function $2257d881a60ecbb5$var$DrawThickEdgesFromEdgeMap(emap, bounds) {
    // this is the line thing
    const mat = new (0, $2841f46819dbdf7d$export$d19cd1378966f3d3)({
        color: 0xffffff,
        linewidth: 0.02,
        vertexColors: true,
        //resolution:  // to be set by renderer, eventually
        dashed: false,
        alphaToCoverage: true
    });
    const meshes = new $084574008ccedf86$export$eb2fcfdbd7ba97d4();
    for (const edge of emap.values()){
        const lval = edge.data.ldata;
        const color = new $084574008ccedf86$export$892596cec99bc70e();
        color.setHSL(1.0, 1.0, 1.0);
        const pnts = [];
        const cols = [];
        lval.points.forEach((pnt)=>{
            pnts.push(pnt.x * bounds - bounds / 2, pnt.y * bounds - bounds / 2, pnt.z * bounds - bounds / 2);
            cols.push(color.r, color.g, color.b);
        });
        const geo = new (0, $b5593040d67e37e6$export$dcc17b59d0a74bb5)();
        geo.setPositions(pnts);
        geo.setColors(cols);
        const line = new (0, $bedd24a76a719d5b$export$4e6fcde58d84e955)(geo, mat);
        line.computeLineDistances();
        line.scale.set(1, 1, 1);
        meshes.add(line);
    }
    return meshes;
}
// make a thing that draws out all the lines (Thin)
function $2257d881a60ecbb5$var$DrawTHREEGraphEdgesThin(G, bounds) {
    return $2257d881a60ecbb5$var$DrawThinEdgesFromEdgeMap(G.edges, bounds);
}
// function to draw edges from edge map
function $2257d881a60ecbb5$var$DrawThinEdgesFromEdgeMap(emap, bounds) {
    const material = new $084574008ccedf86$export$fbaaa33907730a0c({
        color: 0x90e0ef
    });
    const lines = new $084574008ccedf86$export$eb2fcfdbd7ba97d4();
    for (const edge of emap.values()){
        const points = [];
        // get the edge data
        const ldata = edge.data.ldata.points;
        ldata.forEach((element)=>{
            points.push(new $084574008ccedf86$export$64b5c384219d3699(element.x * bounds, element.y * bounds, element.z * bounds));
        });
        // then make the line thing
        const geometry = new $084574008ccedf86$export$b7be63a67df8959().setFromPoints(points);
        const line = new $084574008ccedf86$export$17d680238e50603e(geometry, material);
        lines.add(line);
    }
    return lines;
}
// draw the cube box graph here
function $2257d881a60ecbb5$var$AddBoxBasedImaging(vertexMap, bounds) {
    // returns a group
    const group = new $084574008ccedf86$export$eb2fcfdbd7ba97d4();
    const material = new $084574008ccedf86$export$55cbcc9b622fe1f5({
        color: 0x0466c8
    });
    for (const node of vertexMap.keys()){
        const nodeData = vertexMap.get(node);
        const geometry = new $084574008ccedf86$export$ab3456a079aa7d80(nodeData.data.size, nodeData.data.size, nodeData.data.size);
        geometry.name = node;
        const nodeMesh = new $084574008ccedf86$export$e176487c05830cc5(geometry, material);
        nodeMesh.position.set(nodeData.data.pos.x * bounds, nodeData.data.pos.y * bounds, nodeData.data.pos.z * bounds);
        group.add(nodeMesh);
    }
    return group;
}
// Draw BoxBased imaging from a graph
function $2257d881a60ecbb5$var$DrawTHREEBoxBasedVertices(graph, bounds) {
    const Bgroup = $2257d881a60ecbb5$var$AddBoxBasedImaging(graph.nodes, bounds);
    return Bgroup;
}
// draw Cylinder based imaging given a graph
function $2257d881a60ecbb5$var$DrawCylinderBasedVertices(graph, bounds, divisons) {
    const ds = divisons || 1;
    const Cgroup = $2257d881a60ecbb5$var$AddCylinderBasedImaging(graph.nodes, ds, bounds);
    return Cgroup;
}
// draw cylinders where required
function $2257d881a60ecbb5$var$AddCylinderBasedImaging(vertexMap, divisonLength, bounds) {
    // returns a group
    const group = new $084574008ccedf86$export$eb2fcfdbd7ba97d4();
    const material = new $084574008ccedf86$export$55cbcc9b622fe1f5({
        color: 0xffffff
    });
    let radius, circumfurence, segments;
    for (const node of vertexMap.keys()){
        const nodeData = vertexMap.get(node);
        radius = nodeData.data.size;
        circumfurence = 2 * radius * Math.PI;
        segments = Math.ceil(circumfurence / divisonLength);
        const geometry = new $084574008ccedf86$export$d4345c83207d7c68(radius, radius, 10, segments);
        geometry.name = node;
        const nodeMesh = new $084574008ccedf86$export$e176487c05830cc5(geometry, material);
        nodeMesh.position.set(nodeData.data.pos.x * bounds, nodeData.data.pos.y * bounds, nodeData.data.pos.z * bounds);
        group.add(nodeMesh);
    }
    return group;
}
// draw the sparse graph as groups
async function $2257d881a60ecbb5$var$AddInModularityBasedPointGroups(Graph, modularityList) {
    // returns an array of groups
    const groups = new Map();
    const otherNodes = [];
    for (const node of Graph.nodes.keys()){
        const ndata = Graph.nodes.get(node);
        const modularity = ndata.data.modularity;
        if (modularityList.includes(modularity)) {
            if (groups.has(modularity)) groups.get(modularity).push(node);
            else groups.set(modularity, [
                node
            ]);
        } else otherNodes.push(node);
    }
    // then counstruct a bunch of subraphs
    const meshGraphVertices = new Map();
    const meshGraphEdges = new Map();
    // make a seperate group of nodes that have less than 2 neighbours
    console.log("Now started the process of vertex subdivision");
    for (const modularityGroup of groups.keys()){
        const subgraphGroup = groups.get(modularityGroup);
        // returns an array
        const subgraph = await (0, $03PHD.default).SelectSubgraph(Graph, subgraphGroup);
        // then make the vertex thing
        const meshRep = $2257d881a60ecbb5$var$DrawTHREEGraphVertices(subgraph, 1);
        meshGraphVertices.set(modularityGroup, meshRep);
        // make the edges
        const edges = $2257d881a60ecbb5$var$DrawSimplifiedEdges(subgraph, 0.03);
        meshGraphEdges.set(modularityGroup, edges);
    }
    // now for all the vertices in the "other" Nodes map add in the
    // rest of the stuff for us to play around with
    const OtherNodes = await (0, $03PHD.default).SelectSubgraph(Graph, otherNodes);
    const LeafVertices = $2257d881a60ecbb5$var$DrawTHREEGraphVertices(OtherNodes, 1);
    const ROBJ = {
        vertices: meshGraphVertices,
        edges: meshGraphEdges,
        leafs: LeafVertices
    };
    return ROBJ;
}
function $2257d881a60ecbb5$var$DrawSimplifiedEdges(G, amount) {
    const lineGroup = new $084574008ccedf86$export$eb2fcfdbd7ba97d4();
    const material = new $084574008ccedf86$export$fbaaa33907730a0c({
        color: 0x90e0ef
    });
    for (const edge of G.edges.values())if (Math.random() <= amount) {
        const start = G.nodes.get(edge.start).data.pos;
        const end = G.nodes.get(edge.end).data.pos;
        const points = [];
        points.push(new $084574008ccedf86$export$64b5c384219d3699(start.x, start.y, start.z));
        points.push(new $084574008ccedf86$export$64b5c384219d3699(end.x, end.y, end.z));
        const geometry = new $084574008ccedf86$export$b7be63a67df8959().setFromPoints(points);
        const line = new $084574008ccedf86$export$17d680238e50603e(geometry, material);
        lineGroup.add(line);
    }
    return lineGroup;
}
function $2257d881a60ecbb5$var$ChangeTheVertexColours(vertices, indexArray, color) {
    let Attrib = vertices.geometry.attributes;
    let k = 0;
    indexArray.forEach((node)=>{
        k = node * 3;
        Attrib.customColor.array[k] = color.r;
        Attrib.customColor.array[k + 1] = color.g;
        Attrib.customColor.array[k + 2] = color.b;
    });
    Attrib.customColor.needsUpdate = true;
}
function $2257d881a60ecbb5$var$ResetVertexColors(vertices) {
    let Attrib = vertices.geometry.attributes;
    let k = 0;
    for(let i = 0; i < Attrib.customColor.count; i++){
        k = i * 3;
        Attrib.customColor.array[k] = 100;
        Attrib.customColor.array[k + 1] = 237;
        Attrib.customColor.array[k + 2] = 146;
    }
    Attrib.customColor.needsUpdate = true;
}
var $2257d881a60ecbb5$export$2e2bcd8739ae039 = {
    DrawTHREEGraphVertices: $2257d881a60ecbb5$var$DrawTHREEGraphVertices,
    DrawTHREEGraphEdgesThick: $2257d881a60ecbb5$var$DrawTHREEGraphEdgesThick,
    DrawTHREEGraphEdgesThin: $2257d881a60ecbb5$var$DrawTHREEGraphEdgesThin,
    AddBoxBasedImaging: $2257d881a60ecbb5$var$AddBoxBasedImaging,
    AddInModularityBasedPointGroups: $2257d881a60ecbb5$var$AddInModularityBasedPointGroups,
    DrawThinEdgesFromEdgeMap: $2257d881a60ecbb5$var$DrawThinEdgesFromEdgeMap,
    DrawThickEdgesFromEdgeMap: $2257d881a60ecbb5$var$DrawThickEdgesFromEdgeMap,
    AddCylinderBasedImaging: $2257d881a60ecbb5$var$AddCylinderBasedImaging,
    DrawSimplifiedEdges: $2257d881a60ecbb5$var$DrawSimplifiedEdges,
    ChangeTheVertexColours: $2257d881a60ecbb5$var$ChangeTheVertexColours,
    ResetVertexColors: $2257d881a60ecbb5$var$ResetVertexColors,
    DrawTHREEBoxBasedVertices: $2257d881a60ecbb5$var$DrawTHREEBoxBasedVertices,
    DrawCylinderBasedVertices: $2257d881a60ecbb5$var$DrawCylinderBasedVertices
};




// This set of controls performs orbiting, dollying (zooming), and panning.
// Unlike TrackballControls, it maintains the "up" direction object.up (+Y by default).
//
//    Orbit - left mouse / touch: one-finger move
//    Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish
//    Pan - right mouse, or left mouse + ctrl/meta/shiftKey, or arrow keys / touch: two-finger move
const $bbcfa2e1a5161948$var$_changeEvent = {
    type: "change"
};
const $bbcfa2e1a5161948$var$_startEvent = {
    type: "start"
};
const $bbcfa2e1a5161948$var$_endEvent = {
    type: "end"
};
class $bbcfa2e1a5161948$export$8ff7788029dfdf52 extends (0, $084574008ccedf86$export$ec8b666c5fe2c75a) {
    constructor(object, domElement1){
        super();
        if (domElement1 === undefined) console.warn('THREE.OrbitControls: The second parameter "domElement" is now mandatory.');
        if (domElement1 === document) console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.');
        this.object = object;
        this.domElement = domElement1;
        this.domElement.style.touchAction = "none"; // disable touch scroll
        // Set to false to disable this control
        this.enabled = true;
        // "target" sets the location of focus, where the object orbits around
        this.target = new (0, $084574008ccedf86$export$64b5c384219d3699)();
        // How far you can dolly in and out ( PerspectiveCamera only )
        this.minDistance = 0;
        this.maxDistance = Infinity;
        // How far you can zoom in and out ( OrthographicCamera only )
        this.minZoom = 0;
        this.maxZoom = Infinity;
        // How far you can orbit vertically, upper and lower limits.
        // Range is 0 to Math.PI radians.
        this.minPolarAngle = 0; // radians
        this.maxPolarAngle = Math.PI; // radians
        // How far you can orbit horizontally, upper and lower limits.
        // If set, the interval [ min, max ] must be a sub-interval of [ - 2 PI, 2 PI ], with ( max - min < 2 PI )
        this.minAzimuthAngle = -Infinity; // radians
        this.maxAzimuthAngle = Infinity; // radians
        // Set to true to enable damping (inertia)
        // If damping is enabled, you must call controls.update() in your animation loop
        this.enableDamping = false;
        this.dampingFactor = 0.05;
        // This option actually enables dollying in and out; left as "zoom" for backwards compatibility.
        // Set to false to disable zooming
        this.enableZoom = true;
        this.zoomSpeed = 1.0;
        // Set to false to disable rotating
        this.enableRotate = true;
        this.rotateSpeed = 1.0;
        // Set to false to disable panning
        this.enablePan = true;
        this.panSpeed = 1.0;
        this.screenSpacePanning = true; // if false, pan orthogonal to world-space direction camera.up
        this.keyPanSpeed = 7.0; // pixels moved per arrow key push
        // Set to true to automatically rotate around the target
        // If auto-rotate is enabled, you must call controls.update() in your animation loop
        this.autoRotate = false;
        this.autoRotateSpeed = 2.0; // 30 seconds per orbit when fps is 60
        // The four arrow keys
        this.keys = {
            LEFT: "ArrowLeft",
            UP: "ArrowUp",
            RIGHT: "ArrowRight",
            BOTTOM: "ArrowDown"
        };
        // Mouse buttons
        this.mouseButtons = {
            LEFT: (0, $084574008ccedf86$export$7177b3e430c2d7ca).ROTATE,
            MIDDLE: (0, $084574008ccedf86$export$7177b3e430c2d7ca).DOLLY,
            RIGHT: (0, $084574008ccedf86$export$7177b3e430c2d7ca).PAN
        };
        // Touch fingers
        this.touches = {
            ONE: (0, $084574008ccedf86$export$d46bd3ead7cc759b).ROTATE,
            TWO: (0, $084574008ccedf86$export$d46bd3ead7cc759b).DOLLY_PAN
        };
        // for reset
        this.target0 = this.target.clone();
        this.position0 = this.object.position.clone();
        this.zoom0 = this.object.zoom;
        // the target DOM element for key events
        this._domElementKeyEvents = null;
        //
        // public methods
        //
        this.getPolarAngle = function() {
            return spherical.phi;
        };
        this.getAzimuthalAngle = function() {
            return spherical.theta;
        };
        this.getDistance = function() {
            return this.object.position.distanceTo(this.target);
        };
        this.listenToKeyEvents = function(domElement) {
            domElement.addEventListener("keydown", onKeyDown);
            this._domElementKeyEvents = domElement;
        };
        this.saveState = function() {
            scope.target0.copy(scope.target);
            scope.position0.copy(scope.object.position);
            scope.zoom0 = scope.object.zoom;
        };
        this.reset = function() {
            scope.target.copy(scope.target0);
            scope.object.position.copy(scope.position0);
            scope.object.zoom = scope.zoom0;
            scope.object.updateProjectionMatrix();
            scope.dispatchEvent($bbcfa2e1a5161948$var$_changeEvent);
            scope.update();
            state = STATE.NONE;
        };
        // this method is exposed, but perhaps it would be better if we can make it private...
        this.update = function() {
            const offset = new (0, $084574008ccedf86$export$64b5c384219d3699)();
            // so camera.up is the orbit axis
            const quat = new (0, $084574008ccedf86$export$23d6a54f0bbc85a3)().setFromUnitVectors(object.up, new (0, $084574008ccedf86$export$64b5c384219d3699)(0, 1, 0));
            const quatInverse = quat.clone().invert();
            const lastPosition = new (0, $084574008ccedf86$export$64b5c384219d3699)();
            const lastQuaternion = new (0, $084574008ccedf86$export$23d6a54f0bbc85a3)();
            const twoPI = 2 * Math.PI;
            return function update() {
                const position = scope.object.position;
                offset.copy(position).sub(scope.target);
                // rotate offset to "y-axis-is-up" space
                offset.applyQuaternion(quat);
                // angle from z-axis around y-axis
                spherical.setFromVector3(offset);
                if (scope.autoRotate && state === STATE.NONE) rotateLeft(getAutoRotationAngle());
                if (scope.enableDamping) {
                    spherical.theta += sphericalDelta.theta * scope.dampingFactor;
                    spherical.phi += sphericalDelta.phi * scope.dampingFactor;
                } else {
                    spherical.theta += sphericalDelta.theta;
                    spherical.phi += sphericalDelta.phi;
                }
                // restrict theta to be between desired limits
                let min = scope.minAzimuthAngle;
                let max = scope.maxAzimuthAngle;
                if (isFinite(min) && isFinite(max)) {
                    if (min < -Math.PI) min += twoPI;
                    else if (min > Math.PI) min -= twoPI;
                    if (max < -Math.PI) max += twoPI;
                    else if (max > Math.PI) max -= twoPI;
                    if (min <= max) spherical.theta = Math.max(min, Math.min(max, spherical.theta));
                    else spherical.theta = spherical.theta > (min + max) / 2 ? Math.max(min, spherical.theta) : Math.min(max, spherical.theta);
                }
                // restrict phi to be between desired limits
                spherical.phi = Math.max(scope.minPolarAngle, Math.min(scope.maxPolarAngle, spherical.phi));
                spherical.makeSafe();
                spherical.radius *= scale;
                // restrict radius to be between desired limits
                spherical.radius = Math.max(scope.minDistance, Math.min(scope.maxDistance, spherical.radius));
                // move target to panned location
                if (scope.enableDamping === true) scope.target.addScaledVector(panOffset, scope.dampingFactor);
                else scope.target.add(panOffset);
                offset.setFromSpherical(spherical);
                // rotate offset back to "camera-up-vector-is-up" space
                offset.applyQuaternion(quatInverse);
                position.copy(scope.target).add(offset);
                scope.object.lookAt(scope.target);
                if (scope.enableDamping === true) {
                    sphericalDelta.theta *= 1 - scope.dampingFactor;
                    sphericalDelta.phi *= 1 - scope.dampingFactor;
                    panOffset.multiplyScalar(1 - scope.dampingFactor);
                } else {
                    sphericalDelta.set(0, 0, 0);
                    panOffset.set(0, 0, 0);
                }
                scale = 1;
                // update condition is:
                // min(camera displacement, camera rotation in radians)^2 > EPS
                // using small-angle approximation cos(x/2) = 1 - x^2 / 8
                if (zoomChanged || lastPosition.distanceToSquared(scope.object.position) > EPS || 8 * (1 - lastQuaternion.dot(scope.object.quaternion)) > EPS) {
                    scope.dispatchEvent($bbcfa2e1a5161948$var$_changeEvent);
                    lastPosition.copy(scope.object.position);
                    lastQuaternion.copy(scope.object.quaternion);
                    zoomChanged = false;
                    return true;
                }
                return false;
            };
        }();
        this.dispose = function() {
            scope.domElement.removeEventListener("contextmenu", onContextMenu);
            scope.domElement.removeEventListener("pointerdown", onPointerDown);
            scope.domElement.removeEventListener("pointercancel", onPointerCancel);
            scope.domElement.removeEventListener("wheel", onMouseWheel);
            scope.domElement.removeEventListener("pointermove", onPointerMove);
            scope.domElement.removeEventListener("pointerup", onPointerUp);
            if (scope._domElementKeyEvents !== null) scope._domElementKeyEvents.removeEventListener("keydown", onKeyDown);
        //scope.dispatchEvent( { type: 'dispose' } ); // should this be added here?
        };
        //
        // internals
        //
        const scope = this;
        const STATE = {
            NONE: -1,
            ROTATE: 0,
            DOLLY: 1,
            PAN: 2,
            TOUCH_ROTATE: 3,
            TOUCH_PAN: 4,
            TOUCH_DOLLY_PAN: 5,
            TOUCH_DOLLY_ROTATE: 6
        };
        let state = STATE.NONE;
        const EPS = 0.000001;
        // current position in spherical coordinates
        const spherical = new (0, $084574008ccedf86$export$d712cd887b4a00f7)();
        const sphericalDelta = new (0, $084574008ccedf86$export$d712cd887b4a00f7)();
        let scale = 1;
        const panOffset = new (0, $084574008ccedf86$export$64b5c384219d3699)();
        let zoomChanged = false;
        const rotateStart = new (0, $084574008ccedf86$export$c977b3e384af9ae1)();
        const rotateEnd = new (0, $084574008ccedf86$export$c977b3e384af9ae1)();
        const rotateDelta = new (0, $084574008ccedf86$export$c977b3e384af9ae1)();
        const panStart = new (0, $084574008ccedf86$export$c977b3e384af9ae1)();
        const panEnd = new (0, $084574008ccedf86$export$c977b3e384af9ae1)();
        const panDelta = new (0, $084574008ccedf86$export$c977b3e384af9ae1)();
        const dollyStart = new (0, $084574008ccedf86$export$c977b3e384af9ae1)();
        const dollyEnd = new (0, $084574008ccedf86$export$c977b3e384af9ae1)();
        const dollyDelta = new (0, $084574008ccedf86$export$c977b3e384af9ae1)();
        const pointers = [];
        const pointerPositions = {};
        function getAutoRotationAngle() {
            return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;
        }
        function getZoomScale() {
            return Math.pow(0.95, scope.zoomSpeed);
        }
        function rotateLeft(angle) {
            sphericalDelta.theta -= angle;
        }
        function rotateUp(angle) {
            sphericalDelta.phi -= angle;
        }
        const panLeft = function() {
            const v = new (0, $084574008ccedf86$export$64b5c384219d3699)();
            return function panLeft(distance, objectMatrix) {
                v.setFromMatrixColumn(objectMatrix, 0); // get X column of objectMatrix
                v.multiplyScalar(-distance);
                panOffset.add(v);
            };
        }();
        const panUp = function() {
            const v = new (0, $084574008ccedf86$export$64b5c384219d3699)();
            return function panUp(distance, objectMatrix) {
                if (scope.screenSpacePanning === true) v.setFromMatrixColumn(objectMatrix, 1);
                else {
                    v.setFromMatrixColumn(objectMatrix, 0);
                    v.crossVectors(scope.object.up, v);
                }
                v.multiplyScalar(distance);
                panOffset.add(v);
            };
        }();
        // deltaX and deltaY are in pixels; right and down are positive
        const pan = function() {
            const offset = new (0, $084574008ccedf86$export$64b5c384219d3699)();
            return function pan(deltaX, deltaY) {
                const element = scope.domElement;
                if (scope.object.isPerspectiveCamera) {
                    // perspective
                    const position = scope.object.position;
                    offset.copy(position).sub(scope.target);
                    let targetDistance = offset.length();
                    // half of the fov is center to top of screen
                    targetDistance *= Math.tan(scope.object.fov / 2 * Math.PI / 180.0);
                    // we use only clientHeight here so aspect ratio does not distort speed
                    panLeft(2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix);
                    panUp(2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix);
                } else if (scope.object.isOrthographicCamera) {
                    // orthographic
                    panLeft(deltaX * (scope.object.right - scope.object.left) / scope.object.zoom / element.clientWidth, scope.object.matrix);
                    panUp(deltaY * (scope.object.top - scope.object.bottom) / scope.object.zoom / element.clientHeight, scope.object.matrix);
                } else {
                    // camera neither orthographic nor perspective
                    console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.");
                    scope.enablePan = false;
                }
            };
        }();
        function dollyOut(dollyScale) {
            if (scope.object.isPerspectiveCamera) scale /= dollyScale;
            else if (scope.object.isOrthographicCamera) {
                scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom * dollyScale));
                scope.object.updateProjectionMatrix();
                zoomChanged = true;
            } else {
                console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.");
                scope.enableZoom = false;
            }
        }
        function dollyIn(dollyScale) {
            if (scope.object.isPerspectiveCamera) scale *= dollyScale;
            else if (scope.object.isOrthographicCamera) {
                scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom / dollyScale));
                scope.object.updateProjectionMatrix();
                zoomChanged = true;
            } else {
                console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.");
                scope.enableZoom = false;
            }
        }
        //
        // event callbacks - update the object state
        //
        function handleMouseDownRotate(event) {
            rotateStart.set(event.clientX, event.clientY);
        }
        function handleMouseDownDolly(event) {
            dollyStart.set(event.clientX, event.clientY);
        }
        function handleMouseDownPan(event) {
            panStart.set(event.clientX, event.clientY);
        }
        function handleMouseMoveRotate(event) {
            rotateEnd.set(event.clientX, event.clientY);
            rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);
            const element = scope.domElement;
            rotateLeft(2 * Math.PI * rotateDelta.x / element.clientHeight); // yes, height
            rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight);
            rotateStart.copy(rotateEnd);
            scope.update();
        }
        function handleMouseMoveDolly(event) {
            dollyEnd.set(event.clientX, event.clientY);
            dollyDelta.subVectors(dollyEnd, dollyStart);
            if (dollyDelta.y > 0) dollyOut(getZoomScale());
            else if (dollyDelta.y < 0) dollyIn(getZoomScale());
            dollyStart.copy(dollyEnd);
            scope.update();
        }
        function handleMouseMovePan(event) {
            panEnd.set(event.clientX, event.clientY);
            panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);
            pan(panDelta.x, panDelta.y);
            panStart.copy(panEnd);
            scope.update();
        }
        function handleMouseWheel(event) {
            if (event.deltaY < 0) dollyIn(getZoomScale());
            else if (event.deltaY > 0) dollyOut(getZoomScale());
            scope.update();
        }
        function handleKeyDown(event) {
            let needsUpdate = false;
            switch(event.code){
                case scope.keys.UP:
                    pan(0, scope.keyPanSpeed);
                    needsUpdate = true;
                    break;
                case scope.keys.BOTTOM:
                    pan(0, -scope.keyPanSpeed);
                    needsUpdate = true;
                    break;
                case scope.keys.LEFT:
                    pan(scope.keyPanSpeed, 0);
                    needsUpdate = true;
                    break;
                case scope.keys.RIGHT:
                    pan(-scope.keyPanSpeed, 0);
                    needsUpdate = true;
                    break;
            }
            if (needsUpdate) {
                // prevent the browser from scrolling on cursor keys
                event.preventDefault();
                scope.update();
            }
        }
        function handleTouchStartRotate() {
            if (pointers.length === 1) rotateStart.set(pointers[0].pageX, pointers[0].pageY);
            else {
                const x = 0.5 * (pointers[0].pageX + pointers[1].pageX);
                const y = 0.5 * (pointers[0].pageY + pointers[1].pageY);
                rotateStart.set(x, y);
            }
        }
        function handleTouchStartPan() {
            if (pointers.length === 1) panStart.set(pointers[0].pageX, pointers[0].pageY);
            else {
                const x = 0.5 * (pointers[0].pageX + pointers[1].pageX);
                const y = 0.5 * (pointers[0].pageY + pointers[1].pageY);
                panStart.set(x, y);
            }
        }
        function handleTouchStartDolly() {
            const dx = pointers[0].pageX - pointers[1].pageX;
            const dy = pointers[0].pageY - pointers[1].pageY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            dollyStart.set(0, distance);
        }
        function handleTouchStartDollyPan() {
            if (scope.enableZoom) handleTouchStartDolly();
            if (scope.enablePan) handleTouchStartPan();
        }
        function handleTouchStartDollyRotate() {
            if (scope.enableZoom) handleTouchStartDolly();
            if (scope.enableRotate) handleTouchStartRotate();
        }
        function handleTouchMoveRotate(event) {
            if (pointers.length == 1) rotateEnd.set(event.pageX, event.pageY);
            else {
                const position = getSecondPointerPosition(event);
                const x = 0.5 * (event.pageX + position.x);
                const y = 0.5 * (event.pageY + position.y);
                rotateEnd.set(x, y);
            }
            rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);
            const element = scope.domElement;
            rotateLeft(2 * Math.PI * rotateDelta.x / element.clientHeight); // yes, height
            rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight);
            rotateStart.copy(rotateEnd);
        }
        function handleTouchMovePan(event) {
            if (pointers.length === 1) panEnd.set(event.pageX, event.pageY);
            else {
                const position = getSecondPointerPosition(event);
                const x = 0.5 * (event.pageX + position.x);
                const y = 0.5 * (event.pageY + position.y);
                panEnd.set(x, y);
            }
            panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);
            pan(panDelta.x, panDelta.y);
            panStart.copy(panEnd);
        }
        function handleTouchMoveDolly(event) {
            const position = getSecondPointerPosition(event);
            const dx = event.pageX - position.x;
            const dy = event.pageY - position.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            dollyEnd.set(0, distance);
            dollyDelta.set(0, Math.pow(dollyEnd.y / dollyStart.y, scope.zoomSpeed));
            dollyOut(dollyDelta.y);
            dollyStart.copy(dollyEnd);
        }
        function handleTouchMoveDollyPan(event) {
            if (scope.enableZoom) handleTouchMoveDolly(event);
            if (scope.enablePan) handleTouchMovePan(event);
        }
        function handleTouchMoveDollyRotate(event) {
            if (scope.enableZoom) handleTouchMoveDolly(event);
            if (scope.enableRotate) handleTouchMoveRotate(event);
        }
        //
        // event handlers - FSM: listen for events and reset state
        //
        function onPointerDown(event) {
            if (scope.enabled === false) return;
            if (pointers.length === 0) {
                scope.domElement.setPointerCapture(event.pointerId);
                scope.domElement.addEventListener("pointermove", onPointerMove);
                scope.domElement.addEventListener("pointerup", onPointerUp);
            }
            //
            addPointer(event);
            if (event.pointerType === "touch") onTouchStart(event);
            else onMouseDown(event);
        }
        function onPointerMove(event) {
            if (scope.enabled === false) return;
            if (event.pointerType === "touch") onTouchMove(event);
            else onMouseMove(event);
        }
        function onPointerUp(event) {
            removePointer(event);
            if (pointers.length === 0) {
                scope.domElement.releasePointerCapture(event.pointerId);
                scope.domElement.removeEventListener("pointermove", onPointerMove);
                scope.domElement.removeEventListener("pointerup", onPointerUp);
            }
            scope.dispatchEvent($bbcfa2e1a5161948$var$_endEvent);
            state = STATE.NONE;
        }
        function onPointerCancel(event) {
            removePointer(event);
        }
        function onMouseDown(event) {
            let mouseAction;
            switch(event.button){
                case 0:
                    mouseAction = scope.mouseButtons.LEFT;
                    break;
                case 1:
                    mouseAction = scope.mouseButtons.MIDDLE;
                    break;
                case 2:
                    mouseAction = scope.mouseButtons.RIGHT;
                    break;
                default:
                    mouseAction = -1;
            }
            switch(mouseAction){
                case (0, $084574008ccedf86$export$7177b3e430c2d7ca).DOLLY:
                    if (scope.enableZoom === false) return;
                    handleMouseDownDolly(event);
                    state = STATE.DOLLY;
                    break;
                case (0, $084574008ccedf86$export$7177b3e430c2d7ca).ROTATE:
                    if (event.ctrlKey || event.metaKey || event.shiftKey) {
                        if (scope.enablePan === false) return;
                        handleMouseDownPan(event);
                        state = STATE.PAN;
                    } else {
                        if (scope.enableRotate === false) return;
                        handleMouseDownRotate(event);
                        state = STATE.ROTATE;
                    }
                    break;
                case (0, $084574008ccedf86$export$7177b3e430c2d7ca).PAN:
                    if (event.ctrlKey || event.metaKey || event.shiftKey) {
                        if (scope.enableRotate === false) return;
                        handleMouseDownRotate(event);
                        state = STATE.ROTATE;
                    } else {
                        if (scope.enablePan === false) return;
                        handleMouseDownPan(event);
                        state = STATE.PAN;
                    }
                    break;
                default:
                    state = STATE.NONE;
            }
            if (state !== STATE.NONE) scope.dispatchEvent($bbcfa2e1a5161948$var$_startEvent);
        }
        function onMouseMove(event) {
            if (scope.enabled === false) return;
            switch(state){
                case STATE.ROTATE:
                    if (scope.enableRotate === false) return;
                    handleMouseMoveRotate(event);
                    break;
                case STATE.DOLLY:
                    if (scope.enableZoom === false) return;
                    handleMouseMoveDolly(event);
                    break;
                case STATE.PAN:
                    if (scope.enablePan === false) return;
                    handleMouseMovePan(event);
                    break;
            }
        }
        function onMouseWheel(event) {
            if (scope.enabled === false || scope.enableZoom === false || state !== STATE.NONE) return;
            event.preventDefault();
            scope.dispatchEvent($bbcfa2e1a5161948$var$_startEvent);
            handleMouseWheel(event);
            scope.dispatchEvent($bbcfa2e1a5161948$var$_endEvent);
        }
        function onKeyDown(event) {
            if (scope.enabled === false || scope.enablePan === false) return;
            handleKeyDown(event);
        }
        function onTouchStart(event) {
            trackPointer(event);
            switch(pointers.length){
                case 1:
                    switch(scope.touches.ONE){
                        case (0, $084574008ccedf86$export$d46bd3ead7cc759b).ROTATE:
                            if (scope.enableRotate === false) return;
                            handleTouchStartRotate();
                            state = STATE.TOUCH_ROTATE;
                            break;
                        case (0, $084574008ccedf86$export$d46bd3ead7cc759b).PAN:
                            if (scope.enablePan === false) return;
                            handleTouchStartPan();
                            state = STATE.TOUCH_PAN;
                            break;
                        default:
                            state = STATE.NONE;
                    }
                    break;
                case 2:
                    switch(scope.touches.TWO){
                        case (0, $084574008ccedf86$export$d46bd3ead7cc759b).DOLLY_PAN:
                            if (scope.enableZoom === false && scope.enablePan === false) return;
                            handleTouchStartDollyPan();
                            state = STATE.TOUCH_DOLLY_PAN;
                            break;
                        case (0, $084574008ccedf86$export$d46bd3ead7cc759b).DOLLY_ROTATE:
                            if (scope.enableZoom === false && scope.enableRotate === false) return;
                            handleTouchStartDollyRotate();
                            state = STATE.TOUCH_DOLLY_ROTATE;
                            break;
                        default:
                            state = STATE.NONE;
                    }
                    break;
                default:
                    state = STATE.NONE;
            }
            if (state !== STATE.NONE) scope.dispatchEvent($bbcfa2e1a5161948$var$_startEvent);
        }
        function onTouchMove(event) {
            trackPointer(event);
            switch(state){
                case STATE.TOUCH_ROTATE:
                    if (scope.enableRotate === false) return;
                    handleTouchMoveRotate(event);
                    scope.update();
                    break;
                case STATE.TOUCH_PAN:
                    if (scope.enablePan === false) return;
                    handleTouchMovePan(event);
                    scope.update();
                    break;
                case STATE.TOUCH_DOLLY_PAN:
                    if (scope.enableZoom === false && scope.enablePan === false) return;
                    handleTouchMoveDollyPan(event);
                    scope.update();
                    break;
                case STATE.TOUCH_DOLLY_ROTATE:
                    if (scope.enableZoom === false && scope.enableRotate === false) return;
                    handleTouchMoveDollyRotate(event);
                    scope.update();
                    break;
                default:
                    state = STATE.NONE;
            }
        }
        function onContextMenu(event) {
            if (scope.enabled === false) return;
            event.preventDefault();
        }
        function addPointer(event) {
            pointers.push(event);
        }
        function removePointer(event) {
            delete pointerPositions[event.pointerId];
            for(let i = 0; i < pointers.length; i++)if (pointers[i].pointerId == event.pointerId) {
                pointers.splice(i, 1);
                return;
            }
        }
        function trackPointer(event) {
            let position = pointerPositions[event.pointerId];
            if (position === undefined) {
                position = new (0, $084574008ccedf86$export$c977b3e384af9ae1)();
                pointerPositions[event.pointerId] = position;
            }
            position.set(event.pageX, event.pageY);
        }
        function getSecondPointerPosition(event) {
            const pointer = event.pointerId === pointers[0].pointerId ? pointers[1] : pointers[0];
            return pointerPositions[pointer.pointerId];
        }
        //
        scope.domElement.addEventListener("contextmenu", onContextMenu);
        scope.domElement.addEventListener("pointerdown", onPointerDown);
        scope.domElement.addEventListener("pointercancel", onPointerCancel);
        scope.domElement.addEventListener("wheel", onMouseWheel, {
            passive: false
        });
        // force an update at start
        this.update();
    }
}
// This set of controls performs orbiting, dollying (zooming), and panning.
// Unlike TrackballControls, it maintains the "up" direction object.up (+Y by default).
// This is very similar to OrbitControls, another set of touch behavior
//
//    Orbit - right mouse, or left mouse + ctrl/meta/shiftKey / touch: two-finger rotate
//    Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish
//    Pan - left mouse, or arrow keys / touch: one-finger move
class $bbcfa2e1a5161948$export$7628ccdac312035f extends $bbcfa2e1a5161948$export$8ff7788029dfdf52 {
    constructor(object, domElement){
        super(object, domElement);
        this.screenSpacePanning = false; // pan orthogonal to world-space direction camera.up
        this.mouseButtons.LEFT = (0, $084574008ccedf86$export$7177b3e430c2d7ca).PAN;
        this.mouseButtons.RIGHT = (0, $084574008ccedf86$export$7177b3e430c2d7ca).ROTATE;
        this.touches.ONE = (0, $084574008ccedf86$export$d46bd3ead7cc759b).PAN;
        this.touches.TWO = (0, $084574008ccedf86$export$d46bd3ead7cc759b).DOLLY_ROTATE;
    }
}



// this is the 3d graph drawing class with three js
class $1560099bec86dda1$export$4aefcc8a99cfbd66 {
    constructor(GraphDrawerOptions3d, graphs){
        this.canvas = GraphDrawerOptions3d.canvas;
        this.width = GraphDrawerOptions3d.width;
        this.height = GraphDrawerOptions3d.height;
        this.nodeStyle = GraphDrawerOptions3d.nodeStyle || "POINT";
        this.edgeStyle = GraphDrawerOptions3d.edgeStyle || "THIN";
        this.geometryMap = new Map();
        this.materialMap = new Map();
        this.meshMap = new Map();
        this.controls;
        this.renderer;
        this.camera;
        this.scene;
        // bounds is a global parameter that we change (think about this as scale)
        this.bound = GraphDrawerOptions3d.bounds;
        // graph map is the hash map that holds all the
        // graphs that we are working with together
        this.graphs = new Map();
        // add the default graph to the graph map
        for(let i = 0; i < graphs.length; i++){
            const g = graphs[i];
            this.graphs.set(i, g);
        }
    }
    async init() {
        const t1 = performance.now();
        this.camera = new $084574008ccedf86$export$74e4ae24825f68d7();
        // start up a new scene
        this.scene = new $084574008ccedf86$export$38af1803e3442a7f();
        // set up a renderer
        this.renderer = new $084574008ccedf86$export$f6cc00ef28d7cf97({
            canvas: this.canvas,
            antialias: true
        });
        this.renderer.setSize(this.width, this.height);
        this.renderer.setClearColor(0xff00ff, 0);
        // add in a light
        this.scene.add(new $084574008ccedf86$export$af279bfef9ec2c96(0xffffff));
        // add a spotlight 
        const DirectionalLight = new $084574008ccedf86$export$3fea33cc9972c868(0xffffff, 1);
        DirectionalLight.position.set(0, 10, 0);
        this.scene.add(DirectionalLight);
        // set up the control system
        this.controls = new (0, $bbcfa2e1a5161948$export$8ff7788029dfdf52)(this.camera, this.renderer.domElement);
        this.camera.position.set(0, 100, 100);
        this.controls.autoRotate = true;
        this.controls.maxPolarAngle = Math.PI * 0.5;
        this.camera.enableDamping = true;
        this.controls.maxDistance = 1000;
        this.controls.minDistance = 10;
        this.controls.update();
        // add in the graph that we wanted this.graphs.get('ProvidedGraph')
        for (const graph of this.graphs.keys()){
            // first add in the correct type of nodes 
            if (this.nodeStyle == "BOX") {
                const GeoGraph = (0, $2257d881a60ecbb5$export$2e2bcd8739ae039).DrawTHREEBoxBasedVertices(this.graphs.get(graph), this.bound);
                this.scene.add(GeoGraph);
            } else if (this.nodeStyle == "CYLINDER") {
                const GeoGraph = (0, $2257d881a60ecbb5$export$2e2bcd8739ae039).DrawCylinderBasedVertices(this.graphs.get(graph), this.bound);
                this.scene.add(GeoGraph);
            } else if (this.nodeStyle == "POINT") {
                const GeoGraph = (0, $2257d881a60ecbb5$export$2e2bcd8739ae039).DrawTHREEGraphVertices(this.graphs.get(graph), this.bound);
                this.scene.add(GeoGraph);
            }
            // then add in the correct type of edges
            if (this.edgeStyle == "THICK") {
                const ThickEdges = (0, $2257d881a60ecbb5$export$2e2bcd8739ae039).DrawTHREEGraphEdgesThick(this.graphs.get(graph), this.bound);
                this.scene.add(ThickEdges);
            } else if (this.edgeStyle == "THIN") {
                const ThinLines = (0, $2257d881a60ecbb5$export$2e2bcd8739ae039).DrawTHREEGraphEdgesThin(this.graphs.get(graph), this.bound);
                this.scene.add(ThinLines);
            }
        }
        // finally print out that the initialization has finished
        const t2 = performance.now();
        console.log("initialization has finished");
        console.log(`Time to initialize ${t2 - t1} milliseconds`);
    }
    // this stuff renders out one specific instances
    rendercall() {
        // this is the render draw call
        this.renderer.render(this.scene, this.camera);
        this.controls.update();
    }
}


function $037483d1fb5deac8$export$2e2bcd8739ae039(obj, key, value) {
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}



function $97fc0da493e153d5$export$2e2bcd8739ae039(mockUserAgent) {
    if (typeof window !== "undefined" && typeof window.process === "object" && window.process.type === "renderer") return true;
    if (typeof $7jljs$process !== "undefined" && typeof $7jljs$process.versions === "object" && Boolean($7jljs$process.versions.electron)) return true;
    const realUserAgent = typeof navigator === "object" && typeof navigator.userAgent === "string" && navigator.userAgent;
    const userAgent = mockUserAgent || realUserAgent;
    if (userAgent && userAgent.indexOf("Electron") >= 0) return true;
    return false;
}



function $58cc8c917413a7dc$export$2e2bcd8739ae039() {
    const isNode = typeof $7jljs$process === "object" && String($7jljs$process) === "[object process]" && false;
    return !isNode || (0, $97fc0da493e153d5$export$2e2bcd8739ae039)();
}
function $58cc8c917413a7dc$export$fb09d24fafba666a() {
    return $58cc8c917413a7dc$export$2e2bcd8739ae039() && typeof document !== "undefined";
}



const $3b0c2dd0bdd7037d$export$a4ad2735b021c132 = typeof __VERSION__ !== "undefined" ? __VERSION__ : "untranspiled source";
const $3b0c2dd0bdd7037d$export$4e09c449d6c407f7 = (0, $58cc8c917413a7dc$export$2e2bcd8739ae039)();


const $72a0e31c3f6d6aed$var$globals = {
    self: typeof self !== "undefined" && self,
    window: typeof window !== "undefined" && window,
    global: typeof $parcel$global !== "undefined" && $parcel$global,
    document: typeof document !== "undefined" && document,
    process: typeof $7jljs$process === "object" && $7jljs$process
};
const $72a0e31c3f6d6aed$export$90b4d2ff6acb88af = globalThis;
const $72a0e31c3f6d6aed$export$82c2e460fb230c2a = $72a0e31c3f6d6aed$var$globals.self || $72a0e31c3f6d6aed$var$globals.window || $72a0e31c3f6d6aed$var$globals.global;
const $72a0e31c3f6d6aed$export$8291e5b88f90ce4 = $72a0e31c3f6d6aed$var$globals.window || $72a0e31c3f6d6aed$var$globals.self || $72a0e31c3f6d6aed$var$globals.global;
const $72a0e31c3f6d6aed$export$5a7bfc01df82fcd1 = $72a0e31c3f6d6aed$var$globals.document || {};
const $72a0e31c3f6d6aed$export$e54fe5b0f43758f7 = $72a0e31c3f6d6aed$var$globals.process || {};
const $72a0e31c3f6d6aed$export$e896d9a1b4631fa1 = console;



const $ef7c7b0387e72f27$var$window = globalThis;
function $ef7c7b0387e72f27$export$d0a8044dce8ff2fc() {
    return typeof $ef7c7b0387e72f27$var$window.orientation !== "undefined";
}
function $ef7c7b0387e72f27$export$2e2bcd8739ae039(mockUserAgent) {
    if (!mockUserAgent && !(0, $58cc8c917413a7dc$export$2e2bcd8739ae039)()) return "Node";
    if ((0, $97fc0da493e153d5$export$2e2bcd8739ae039)(mockUserAgent)) return "Electron";
    const navigator_ = typeof navigator !== "undefined" ? navigator : {};
    const userAgent = mockUserAgent || navigator_.userAgent || "";
    if (userAgent.indexOf("Edge") > -1) return "Edge";
    const isMSIE = userAgent.indexOf("MSIE ") !== -1;
    const isTrident = userAgent.indexOf("Trident/") !== -1;
    if (isMSIE || isTrident) return "IE";
    if ($ef7c7b0387e72f27$var$window.chrome) return "Chrome";
    if ($ef7c7b0387e72f27$var$window.safari) return "Safari";
    if ($ef7c7b0387e72f27$var$window.mozInnerScreenX) return "Firefox";
    return "Unknown";
}




function $c1f669f220866fe9$var$getStorage(type) {
    try {
        const storage = window[type];
        const x = "__storage_test__";
        storage.setItem(x, x);
        storage.removeItem(x);
        return storage;
    } catch (e) {
        return null;
    }
}
class $c1f669f220866fe9$export$2e2bcd8739ae039 {
    constructor(id){
        let defaultSettings = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        let type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "sessionStorage";
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "storage", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "id", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "config", {});
        this.storage = $c1f669f220866fe9$var$getStorage(type);
        this.id = id;
        this.config = {};
        Object.assign(this.config, defaultSettings);
        this._loadConfiguration();
    }
    getConfiguration() {
        return this.config;
    }
    setConfiguration(configuration) {
        this.config = {};
        return this.updateConfiguration(configuration);
    }
    updateConfiguration(configuration) {
        Object.assign(this.config, configuration);
        if (this.storage) {
            const serialized = JSON.stringify(this.config);
            this.storage.setItem(this.id, serialized);
        }
        return this;
    }
    _loadConfiguration() {
        let configuration = {};
        if (this.storage) {
            const serializedConfiguration = this.storage.getItem(this.id);
            configuration = serializedConfiguration ? JSON.parse(serializedConfiguration) : {};
        }
        Object.assign(this.config, configuration);
        return this;
    }
}


function $3857e0fef6b33c0d$export$3203edd9e5edd663(ms) {
    let formatted;
    if (ms < 10) formatted = "".concat(ms.toFixed(2), "ms");
    else if (ms < 100) formatted = "".concat(ms.toFixed(1), "ms");
    else if (ms < 1000) formatted = "".concat(ms.toFixed(0), "ms");
    else formatted = "".concat((ms / 1000).toFixed(2), "s");
    return formatted;
}
function $3857e0fef6b33c0d$export$cbb503201166aab7(string) {
    let length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 8;
    const padLength = Math.max(length - string.length, 0);
    return "".concat(" ".repeat(padLength)).concat(string);
}
function $3857e0fef6b33c0d$export$390245bab32fb60f(string) {
    let length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 8;
    const padLength = Math.max(length - string.length, 0);
    return "".concat(string).concat(" ".repeat(padLength));
}
function $3857e0fef6b33c0d$export$7c4d25c0c3217d8c(v) {
    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    const EPSILON = 1e-16;
    const { isInteger: isInteger = false  } = opts;
    if (Array.isArray(v) || ArrayBuffer.isView(v)) return $3857e0fef6b33c0d$var$formatArrayValue(v, opts);
    if (!Number.isFinite(v)) return String(v);
    if (Math.abs(v) < EPSILON) return isInteger ? "0" : "0.";
    if (isInteger) return v.toFixed(0);
    if (Math.abs(v) > 100 && Math.abs(v) < 10000) return v.toFixed(0);
    const string = v.toPrecision(2);
    const decimal = string.indexOf(".0");
    return decimal === string.length - 2 ? string.slice(0, -1) : string;
}
function $3857e0fef6b33c0d$var$formatArrayValue(v, opts) {
    const { maxElts: maxElts = 16 , size: size = 1  } = opts;
    let string = "[";
    for(let i = 0; i < v.length && i < maxElts; ++i){
        if (i > 0) string += ",".concat(i % size === 0 ? " " : "");
        string += $3857e0fef6b33c0d$export$7c4d25c0c3217d8c(v[i], opts);
    }
    const terminator = v.length > maxElts ? "..." : "]";
    return "".concat(string).concat(terminator);
}
function $3857e0fef6b33c0d$export$9171d83acafa047c(image, message, scale) {
    let maxWidth = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 600;
    const imageUrl = image.src.replace(/\(/g, "%28").replace(/\)/g, "%29");
    if (image.width > maxWidth) scale = Math.min(scale, maxWidth / image.width);
    const width = image.width * scale;
    const height = image.height * scale;
    const style = [
        "font-size:1px;",
        "padding:".concat(Math.floor(height / 2), "px ").concat(Math.floor(width / 2), "px;"),
        "line-height:".concat(height, "px;"),
        "background:url(".concat(imageUrl, ");"),
        "background-size:".concat(width, "px ").concat(height, "px;"),
        "color:transparent;"
    ].join("");
    return [
        "".concat(message, " %c+"),
        style
    ];
}



let $d107ad8121232cc1$export$9b982809044276a6;
(function(COLOR1) {
    COLOR1[COLOR1["BLACK"] = 30] = "BLACK";
    COLOR1[COLOR1["RED"] = 31] = "RED";
    COLOR1[COLOR1["GREEN"] = 32] = "GREEN";
    COLOR1[COLOR1["YELLOW"] = 33] = "YELLOW";
    COLOR1[COLOR1["BLUE"] = 34] = "BLUE";
    COLOR1[COLOR1["MAGENTA"] = 35] = "MAGENTA";
    COLOR1[COLOR1["CYAN"] = 36] = "CYAN";
    COLOR1[COLOR1["WHITE"] = 37] = "WHITE";
    COLOR1[COLOR1["BRIGHT_BLACK"] = 90] = "BRIGHT_BLACK";
    COLOR1[COLOR1["BRIGHT_RED"] = 91] = "BRIGHT_RED";
    COLOR1[COLOR1["BRIGHT_GREEN"] = 92] = "BRIGHT_GREEN";
    COLOR1[COLOR1["BRIGHT_YELLOW"] = 93] = "BRIGHT_YELLOW";
    COLOR1[COLOR1["BRIGHT_BLUE"] = 94] = "BRIGHT_BLUE";
    COLOR1[COLOR1["BRIGHT_MAGENTA"] = 95] = "BRIGHT_MAGENTA";
    COLOR1[COLOR1["BRIGHT_CYAN"] = 96] = "BRIGHT_CYAN";
    COLOR1[COLOR1["BRIGHT_WHITE"] = 97] = "BRIGHT_WHITE";
})($d107ad8121232cc1$export$9b982809044276a6 || ($d107ad8121232cc1$export$9b982809044276a6 = {}));
function $d107ad8121232cc1$var$getColor(color) {
    return typeof color === "string" ? $d107ad8121232cc1$export$9b982809044276a6[color.toUpperCase()] || $d107ad8121232cc1$export$9b982809044276a6.WHITE : color;
}
function $d107ad8121232cc1$export$4c4d9288a45f1fb3(string, color, background) {
    if (!(0, $58cc8c917413a7dc$export$2e2bcd8739ae039) && typeof string === "string") {
        if (color) {
            color = $d107ad8121232cc1$var$getColor(color);
            string = "\x1b[".concat(color, "m").concat(string, "\x1b[39m");
        }
        if (background) {
            color = $d107ad8121232cc1$var$getColor(background);
            string = "\x1b[".concat(background + 10, "m").concat(string, "\x1b[49m");
        }
    }
    return string;
}


function $3d686a00c9f13fdf$export$f648f36420f83db(obj) {
    let predefined = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [
        "constructor"
    ];
    const proto = Object.getPrototypeOf(obj);
    const propNames = Object.getOwnPropertyNames(proto);
    for (const key of propNames){
        if (typeof obj[key] === "function") {
            if (!predefined.find((name)=>key === name)) obj[key] = obj[key].bind(obj);
        }
    }
}


function $c06a07b3f6443903$export$2e2bcd8739ae039(condition, message) {
    if (!condition) throw new Error(message || "Assertion failed");
}



function $9c44cc46ef7deaf1$export$19cd34ab73b4c7a7() {
    let timestamp;
    if ((0, $58cc8c917413a7dc$export$2e2bcd8739ae039) && "performance" in (0, $72a0e31c3f6d6aed$export$8291e5b88f90ce4)) {
        var _window$performance, _window$performance$n;
        timestamp = (0, $72a0e31c3f6d6aed$export$8291e5b88f90ce4) === null || (0, $72a0e31c3f6d6aed$export$8291e5b88f90ce4) === void 0 ? void 0 : (_window$performance = (0, $72a0e31c3f6d6aed$export$8291e5b88f90ce4).performance) === null || _window$performance === void 0 ? void 0 : (_window$performance$n = _window$performance.now) === null || _window$performance$n === void 0 ? void 0 : _window$performance$n.call(_window$performance);
    } else if ("hrtime" in (0, $72a0e31c3f6d6aed$export$e54fe5b0f43758f7)) {
        var _process$hrtime;
        const timeParts = (0, $72a0e31c3f6d6aed$export$e54fe5b0f43758f7) === null || (0, $72a0e31c3f6d6aed$export$e54fe5b0f43758f7) === void 0 ? void 0 : (_process$hrtime = (0, $72a0e31c3f6d6aed$export$e54fe5b0f43758f7).hrtime) === null || _process$hrtime === void 0 ? void 0 : _process$hrtime.call((0, $72a0e31c3f6d6aed$export$e54fe5b0f43758f7));
        timestamp = timeParts[0] * 1000 + timeParts[1] / 1e6;
    } else timestamp = Date.now();
    return timestamp;
}


const $88fdfccabe5e323d$var$originalConsole = {
    debug: (0, $58cc8c917413a7dc$export$2e2bcd8739ae039) ? console.debug || console.log : console.log,
    log: console.log,
    info: console.info,
    warn: console.warn,
    error: console.error
};
const $88fdfccabe5e323d$var$DEFAULT_SETTINGS = {
    enabled: true,
    level: 0
};
function $88fdfccabe5e323d$var$noop() {}
const $88fdfccabe5e323d$var$cache = {};
const $88fdfccabe5e323d$var$ONCE = {
    once: true
};
class $88fdfccabe5e323d$export$2e2bcd8739ae039 {
    constructor(){
        let { id: id  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
            id: ""
        };
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "id", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "VERSION", (0, $3b0c2dd0bdd7037d$export$a4ad2735b021c132));
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_startTs", (0, $9c44cc46ef7deaf1$export$19cd34ab73b4c7a7)());
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_deltaTs", (0, $9c44cc46ef7deaf1$export$19cd34ab73b4c7a7)());
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_storage", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "userData", {});
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "LOG_THROTTLE_TIMEOUT", 0);
        this.id = id;
        this._storage = new (0, $c1f669f220866fe9$export$2e2bcd8739ae039)("__probe-".concat(this.id, "__"), $88fdfccabe5e323d$var$DEFAULT_SETTINGS);
        this.userData = {};
        this.timeStamp("".concat(this.id, " started"));
        (0, $3d686a00c9f13fdf$export$f648f36420f83db)(this);
        Object.seal(this);
    }
    set level(newLevel) {
        this.setLevel(newLevel);
    }
    get level() {
        return this.getLevel();
    }
    isEnabled() {
        return this._storage.config.enabled;
    }
    getLevel() {
        return this._storage.config.level;
    }
    getTotal() {
        return Number(((0, $9c44cc46ef7deaf1$export$19cd34ab73b4c7a7)() - this._startTs).toPrecision(10));
    }
    getDelta() {
        return Number(((0, $9c44cc46ef7deaf1$export$19cd34ab73b4c7a7)() - this._deltaTs).toPrecision(10));
    }
    set priority(newPriority) {
        this.level = newPriority;
    }
    get priority() {
        return this.level;
    }
    getPriority() {
        return this.level;
    }
    enable() {
        let enabled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
        this._storage.updateConfiguration({
            enabled: enabled
        });
        return this;
    }
    setLevel(level) {
        this._storage.updateConfiguration({
            level: level
        });
        return this;
    }
    get(setting) {
        return this._storage.config[setting];
    }
    set(setting, value) {
        this._storage.updateConfiguration({
            [setting]: value
        });
    }
    settings() {
        if (console.table) console.table(this._storage.config);
        else console.log(this._storage.config);
    }
    assert(condition, message) {
        (0, $c06a07b3f6443903$export$2e2bcd8739ae039)(condition, message);
    }
    warn(message) {
        return this._getLogFunction(0, message, $88fdfccabe5e323d$var$originalConsole.warn, arguments, $88fdfccabe5e323d$var$ONCE);
    }
    error(message) {
        return this._getLogFunction(0, message, $88fdfccabe5e323d$var$originalConsole.error, arguments);
    }
    deprecated(oldUsage, newUsage) {
        return this.warn("`".concat(oldUsage, "` is deprecated and will be removed in a later version. Use `").concat(newUsage, "` instead"));
    }
    removed(oldUsage, newUsage) {
        return this.error("`".concat(oldUsage, "` has been removed. Use `").concat(newUsage, "` instead"));
    }
    probe(logLevel, message) {
        return this._getLogFunction(logLevel, message, $88fdfccabe5e323d$var$originalConsole.log, arguments, {
            time: true,
            once: true
        });
    }
    log(logLevel, message) {
        return this._getLogFunction(logLevel, message, $88fdfccabe5e323d$var$originalConsole.debug, arguments);
    }
    info(logLevel, message) {
        return this._getLogFunction(logLevel, message, console.info, arguments);
    }
    once(logLevel, message) {
        for(var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++)args[_key - 2] = arguments[_key];
        return this._getLogFunction(logLevel, message, $88fdfccabe5e323d$var$originalConsole.debug || $88fdfccabe5e323d$var$originalConsole.info, arguments, $88fdfccabe5e323d$var$ONCE);
    }
    table(logLevel, table, columns) {
        if (table) return this._getLogFunction(logLevel, table, console.table || $88fdfccabe5e323d$var$noop, columns && [
            columns
        ], {
            tag: $88fdfccabe5e323d$var$getTableHeader(table)
        });
        return $88fdfccabe5e323d$var$noop;
    }
    image(_ref) {
        let { logLevel: logLevel , priority: priority , image: image , message: message = "" , scale: scale = 1  } = _ref;
        if (!this._shouldLog(logLevel || priority)) return $88fdfccabe5e323d$var$noop;
        return (0, $58cc8c917413a7dc$export$2e2bcd8739ae039) ? $88fdfccabe5e323d$var$logImageInBrowser({
            image: image,
            message: message,
            scale: scale
        }) : $88fdfccabe5e323d$var$logImageInNode({
            image: image,
            message: message,
            scale: scale
        });
    }
    time(logLevel, message) {
        return this._getLogFunction(logLevel, message, console.time ? console.time : console.info);
    }
    timeEnd(logLevel, message) {
        return this._getLogFunction(logLevel, message, console.timeEnd ? console.timeEnd : console.info);
    }
    timeStamp(logLevel, message) {
        return this._getLogFunction(logLevel, message, console.timeStamp || $88fdfccabe5e323d$var$noop);
    }
    group(logLevel, message) {
        let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
            collapsed: false
        };
        const options = $88fdfccabe5e323d$export$abc60e668512edf9({
            logLevel: logLevel,
            message: message,
            opts: opts
        });
        const { collapsed: collapsed  } = opts;
        options.method = (collapsed ? console.groupCollapsed : console.group) || console.info;
        return this._getLogFunction(options);
    }
    groupCollapsed(logLevel, message) {
        let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        return this.group(logLevel, message, Object.assign({}, opts, {
            collapsed: true
        }));
    }
    groupEnd(logLevel) {
        return this._getLogFunction(logLevel, "", console.groupEnd || $88fdfccabe5e323d$var$noop);
    }
    withGroup(logLevel, message, func) {
        this.group(logLevel, message)();
        try {
            func();
        } finally{
            this.groupEnd(logLevel)();
        }
    }
    trace() {
        if (console.trace) console.trace();
    }
    _shouldLog(logLevel) {
        return this.isEnabled() && this.getLevel() >= $88fdfccabe5e323d$var$normalizeLogLevel(logLevel);
    }
    _getLogFunction(logLevel, message, method, args, opts) {
        if (this._shouldLog(logLevel)) {
            opts = $88fdfccabe5e323d$export$abc60e668512edf9({
                logLevel: logLevel,
                message: message,
                args: args,
                opts: opts
            });
            method = method || opts.method;
            (0, $c06a07b3f6443903$export$2e2bcd8739ae039)(method);
            opts.total = this.getTotal();
            opts.delta = this.getDelta();
            this._deltaTs = (0, $9c44cc46ef7deaf1$export$19cd34ab73b4c7a7)();
            const tag = opts.tag || opts.message;
            if (opts.once) {
                if (!$88fdfccabe5e323d$var$cache[tag]) $88fdfccabe5e323d$var$cache[tag] = (0, $9c44cc46ef7deaf1$export$19cd34ab73b4c7a7)();
                else return $88fdfccabe5e323d$var$noop;
            }
            message = $88fdfccabe5e323d$var$decorateMessage(this.id, opts.message, opts);
            return method.bind(console, message, ...opts.args);
        }
        return $88fdfccabe5e323d$var$noop;
    }
}
(0, $037483d1fb5deac8$export$2e2bcd8739ae039)($88fdfccabe5e323d$export$2e2bcd8739ae039, "VERSION", (0, $3b0c2dd0bdd7037d$export$a4ad2735b021c132));
function $88fdfccabe5e323d$var$normalizeLogLevel(logLevel) {
    if (!logLevel) return 0;
    let resolvedLevel;
    switch(typeof logLevel){
        case "number":
            resolvedLevel = logLevel;
            break;
        case "object":
            resolvedLevel = logLevel.logLevel || logLevel.priority || 0;
            break;
        default:
            return 0;
    }
    (0, $c06a07b3f6443903$export$2e2bcd8739ae039)(Number.isFinite(resolvedLevel) && resolvedLevel >= 0);
    return resolvedLevel;
}
function $88fdfccabe5e323d$export$abc60e668512edf9(opts) {
    const { logLevel: logLevel , message: message  } = opts;
    opts.logLevel = $88fdfccabe5e323d$var$normalizeLogLevel(logLevel);
    const args = opts.args ? Array.from(opts.args) : [];
    while(args.length && args.shift() !== message);
    switch(typeof logLevel){
        case "string":
        case "function":
            if (message !== undefined) args.unshift(message);
            opts.message = logLevel;
            break;
        case "object":
            Object.assign(opts, logLevel);
            break;
        default:
    }
    if (typeof opts.message === "function") opts.message = opts.message();
    const messageType = typeof opts.message;
    (0, $c06a07b3f6443903$export$2e2bcd8739ae039)(messageType === "string" || messageType === "object");
    return Object.assign(opts, {
        args: args
    }, opts.opts);
}
function $88fdfccabe5e323d$var$decorateMessage(id, message, opts) {
    if (typeof message === "string") {
        const time = opts.time ? (0, $3857e0fef6b33c0d$export$cbb503201166aab7)((0, $3857e0fef6b33c0d$export$3203edd9e5edd663)(opts.total)) : "";
        message = opts.time ? "".concat(id, ": ").concat(time, "  ").concat(message) : "".concat(id, ": ").concat(message);
        message = (0, $d107ad8121232cc1$export$4c4d9288a45f1fb3)(message, opts.color, opts.background);
    }
    return message;
}

function $88fdfccabe5e323d$var$logImageInNode(_ref2) {
    let { image: image , message: message = "" , scale: scale = 1  } = _ref2;
    let asciify = null;
    try {
        asciify = (parcelRequire("9aLFZ"));
    } catch (error) {}
    if (asciify) return ()=>asciify(image, {
            fit: "box",
            width: "".concat(Math.round(80 * scale), "%")
        }).then((data)=>console.log(data));
    return $88fdfccabe5e323d$var$noop;
}
function $88fdfccabe5e323d$var$logImageInBrowser(_ref3) {
    let { image: image , message: message = "" , scale: scale = 1  } = _ref3;
    if (typeof image === "string") {
        const img = new Image();
        img.onload = ()=>{
            const args = (0, $3857e0fef6b33c0d$export$9171d83acafa047c)(img, message, scale);
            console.log(...args);
        };
        img.src = image;
        return $88fdfccabe5e323d$var$noop;
    }
    const element = image.nodeName || "";
    if (element.toLowerCase() === "img") {
        console.log(...(0, $3857e0fef6b33c0d$export$9171d83acafa047c)(image, message, scale));
        return $88fdfccabe5e323d$var$noop;
    }
    if (element.toLowerCase() === "canvas") {
        const img = new Image();
        img.onload = ()=>console.log(...(0, $3857e0fef6b33c0d$export$9171d83acafa047c)(img, message, scale));
        img.src = image.toDataURL();
        return $88fdfccabe5e323d$var$noop;
    }
    return $88fdfccabe5e323d$var$noop;
}
function $88fdfccabe5e323d$var$getTableHeader(table) {
    for(const key in table){
        for(const title in table[key])return title || "untitled";
    }
    return "empty";
}










var $3c64196f3b0487f1$export$2e2bcd8739ae039 = new (0, $88fdfccabe5e323d$export$2e2bcd8739ae039)({
    id: "@probe.gl/log"
});


const $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3 = new (0, $88fdfccabe5e323d$export$2e2bcd8739ae039)({
    id: "luma.gl"
});


function $611f47f49512a05f$export$a7a9523472993e97(condition, message) {
    if (!condition) throw new Error(message || "luma.gl: assertion failed.");
}


const $325e733792a03f4e$var$ERR_CONTEXT = "Invalid WebGLRenderingContext";
const $325e733792a03f4e$export$48f7473fb8287ec0 = $325e733792a03f4e$var$ERR_CONTEXT;
const $325e733792a03f4e$export$f882315798580146 = "Requires WebGL2";
function $325e733792a03f4e$export$3a471d0dd6792be6(gl) {
    if (typeof WebGLRenderingContext !== "undefined" && gl instanceof WebGLRenderingContext) return true;
    if (typeof WebGL2RenderingContext !== "undefined" && gl instanceof WebGL2RenderingContext) return true;
    return Boolean(gl && Number.isFinite(gl._version));
}
function $325e733792a03f4e$export$e3518b1ac7891039(gl) {
    if (typeof WebGL2RenderingContext !== "undefined" && gl instanceof WebGL2RenderingContext) return true;
    return Boolean(gl && gl._version === 2);
}
function $325e733792a03f4e$export$89dcfcb9130f2c28(gl) {
    return $325e733792a03f4e$export$e3518b1ac7891039(gl) ? gl : null;
}
function $325e733792a03f4e$export$9b0605fd3c935712(gl) {
    (0, $611f47f49512a05f$export$a7a9523472993e97)($325e733792a03f4e$export$3a471d0dd6792be6(gl), $325e733792a03f4e$var$ERR_CONTEXT);
    return gl;
}
function $325e733792a03f4e$export$22897d77b4bb5316(gl) {
    (0, $611f47f49512a05f$export$a7a9523472993e97)($325e733792a03f4e$export$e3518b1ac7891039(gl), $325e733792a03f4e$export$f882315798580146);
    return gl;
}


const $44909f389943f36e$var$glErrorShadow = {};
function $44909f389943f36e$var$error(msg) {
    if (globalThis.console && globalThis.console.error) globalThis.console.error(msg);
}
function $44909f389943f36e$var$log(msg) {
    if (globalThis.console && globalThis.console.log) globalThis.console.log(msg);
}
function $44909f389943f36e$var$synthesizeGLError(err, opt_msg) {
    $44909f389943f36e$var$glErrorShadow[err] = true;
    if (opt_msg !== undefined) $44909f389943f36e$var$error(opt_msg);
}
function $44909f389943f36e$var$wrapGLError(gl) {
    const f = gl.getError;
    gl.getError = function getError() {
        let err;
        do {
            err = f.apply(gl);
            if (err !== 0) $44909f389943f36e$var$glErrorShadow[err] = true;
        }while (err !== 0);
        for(err in $44909f389943f36e$var$glErrorShadow)if ($44909f389943f36e$var$glErrorShadow[err]) {
            delete $44909f389943f36e$var$glErrorShadow[err];
            return parseInt(err, 10);
        }
        return 0;
    };
}
const $44909f389943f36e$var$WebGLVertexArrayObjectOES = function WebGLVertexArrayObjectOES1(ext) {
    const gl = ext.gl;
    this.ext = ext;
    this.isAlive = true;
    this.hasBeenBound = false;
    this.elementArrayBuffer = null;
    this.attribs = new Array(ext.maxVertexAttribs);
    for(let n = 0; n < this.attribs.length; n++){
        const attrib = new WebGLVertexArrayObjectOES1.VertexAttrib(gl);
        this.attribs[n] = attrib;
    }
    this.maxAttrib = 0;
};
$44909f389943f36e$var$WebGLVertexArrayObjectOES.VertexAttrib = function VertexAttrib(gl) {
    this.enabled = false;
    this.buffer = null;
    this.size = 4;
    this.type = 5126;
    this.normalized = false;
    this.stride = 16;
    this.offset = 0;
    this.cached = "";
    this.recache();
};
$44909f389943f36e$var$WebGLVertexArrayObjectOES.VertexAttrib.prototype.recache = function recache() {
    this.cached = [
        this.size,
        this.type,
        this.normalized,
        this.stride,
        this.offset
    ].join(":");
};
const $44909f389943f36e$var$OESVertexArrayObject = function OESVertexArrayObject(gl) {
    const self = this;
    this.gl = gl;
    $44909f389943f36e$var$wrapGLError(gl);
    const original = this.original = {
        getParameter: gl.getParameter,
        enableVertexAttribArray: gl.enableVertexAttribArray,
        disableVertexAttribArray: gl.disableVertexAttribArray,
        bindBuffer: gl.bindBuffer,
        getVertexAttrib: gl.getVertexAttrib,
        vertexAttribPointer: gl.vertexAttribPointer
    };
    gl.getParameter = function getParameter(pname) {
        if (pname === self.VERTEX_ARRAY_BINDING_OES) {
            if (self.currentVertexArrayObject === self.defaultVertexArrayObject) return null;
            return self.currentVertexArrayObject;
        }
        return original.getParameter.apply(this, arguments);
    };
    gl.enableVertexAttribArray = function enableVertexAttribArray(index) {
        const vao = self.currentVertexArrayObject;
        vao.maxAttrib = Math.max(vao.maxAttrib, index);
        const attrib = vao.attribs[index];
        attrib.enabled = true;
        return original.enableVertexAttribArray.apply(this, arguments);
    };
    gl.disableVertexAttribArray = function disableVertexAttribArray(index) {
        const vao = self.currentVertexArrayObject;
        vao.maxAttrib = Math.max(vao.maxAttrib, index);
        const attrib = vao.attribs[index];
        attrib.enabled = false;
        return original.disableVertexAttribArray.apply(this, arguments);
    };
    gl.bindBuffer = function bindBuffer(target, buffer) {
        switch(target){
            case 34962:
                self.currentArrayBuffer = buffer;
                break;
            case 34963:
                self.currentVertexArrayObject.elementArrayBuffer = buffer;
                break;
            default:
        }
        return original.bindBuffer.apply(this, arguments);
    };
    gl.getVertexAttrib = function getVertexAttrib(index, pname) {
        const vao = self.currentVertexArrayObject;
        const attrib = vao.attribs[index];
        switch(pname){
            case 34975:
                return attrib.buffer;
            case 34338:
                return attrib.enabled;
            case 34339:
                return attrib.size;
            case 34340:
                return attrib.stride;
            case 34341:
                return attrib.type;
            case 34922:
                return attrib.normalized;
            default:
                return original.getVertexAttrib.apply(this, arguments);
        }
    };
    gl.vertexAttribPointer = function vertexAttribPointer(indx, size, type, normalized, stride, offset) {
        const vao = self.currentVertexArrayObject;
        vao.maxAttrib = Math.max(vao.maxAttrib, indx);
        const attrib = vao.attribs[indx];
        attrib.buffer = self.currentArrayBuffer;
        attrib.size = size;
        attrib.type = type;
        attrib.normalized = normalized;
        attrib.stride = stride;
        attrib.offset = offset;
        attrib.recache();
        return original.vertexAttribPointer.apply(this, arguments);
    };
    if (gl.instrumentExtension) gl.instrumentExtension(this, "OES_vertex_array_object");
    if (gl.canvas) gl.canvas.addEventListener("webglcontextrestored", ()=>{
        $44909f389943f36e$var$log("OESVertexArrayObject emulation library context restored");
        self.reset_();
    }, true);
    this.reset_();
};
$44909f389943f36e$var$OESVertexArrayObject.prototype.VERTEX_ARRAY_BINDING_OES = 0x85b5;
$44909f389943f36e$var$OESVertexArrayObject.prototype.reset_ = function reset_() {
    const contextWasLost = this.vertexArrayObjects !== undefined;
    if (contextWasLost) for(let ii = 0; ii < this.vertexArrayObjects.length; ++ii)this.vertexArrayObjects.isAlive = false;
    const gl = this.gl;
    this.maxVertexAttribs = gl.getParameter(34921);
    this.defaultVertexArrayObject = new $44909f389943f36e$var$WebGLVertexArrayObjectOES(this);
    this.currentVertexArrayObject = null;
    this.currentArrayBuffer = null;
    this.vertexArrayObjects = [
        this.defaultVertexArrayObject
    ];
    this.bindVertexArrayOES(null);
};
$44909f389943f36e$var$OESVertexArrayObject.prototype.createVertexArrayOES = function createVertexArrayOES() {
    const arrayObject = new $44909f389943f36e$var$WebGLVertexArrayObjectOES(this);
    this.vertexArrayObjects.push(arrayObject);
    return arrayObject;
};
$44909f389943f36e$var$OESVertexArrayObject.prototype.deleteVertexArrayOES = function deleteVertexArrayOES(arrayObject) {
    arrayObject.isAlive = false;
    this.vertexArrayObjects.splice(this.vertexArrayObjects.indexOf(arrayObject), 1);
    if (this.currentVertexArrayObject === arrayObject) this.bindVertexArrayOES(null);
};
$44909f389943f36e$var$OESVertexArrayObject.prototype.isVertexArrayOES = function isVertexArrayOES(arrayObject) {
    if (arrayObject && arrayObject instanceof $44909f389943f36e$var$WebGLVertexArrayObjectOES) {
        if (arrayObject.hasBeenBound && arrayObject.ext === this) return true;
    }
    return false;
};
$44909f389943f36e$var$OESVertexArrayObject.prototype.bindVertexArrayOES = function bindVertexArrayOES(arrayObject) {
    const gl = this.gl;
    if (arrayObject && !arrayObject.isAlive) {
        $44909f389943f36e$var$synthesizeGLError(1282, "bindVertexArrayOES: attempt to bind deleted arrayObject");
        return;
    }
    const original = this.original;
    const oldVAO = this.currentVertexArrayObject;
    this.currentVertexArrayObject = arrayObject || this.defaultVertexArrayObject;
    this.currentVertexArrayObject.hasBeenBound = true;
    const newVAO = this.currentVertexArrayObject;
    if (oldVAO === newVAO) return;
    if (!oldVAO || newVAO.elementArrayBuffer !== oldVAO.elementArrayBuffer) original.bindBuffer.call(gl, 34963, newVAO.elementArrayBuffer);
    let currentBinding = this.currentArrayBuffer;
    const maxAttrib = Math.max(oldVAO ? oldVAO.maxAttrib : 0, newVAO.maxAttrib);
    for(let n = 0; n <= maxAttrib; n++){
        const attrib = newVAO.attribs[n];
        const oldAttrib = oldVAO ? oldVAO.attribs[n] : null;
        if (!oldVAO || attrib.enabled !== oldAttrib.enabled) {
            if (attrib.enabled) original.enableVertexAttribArray.call(gl, n);
            else original.disableVertexAttribArray.call(gl, n);
        }
        if (attrib.enabled) {
            let bufferChanged = false;
            if (!oldVAO || attrib.buffer !== oldAttrib.buffer) {
                if (currentBinding !== attrib.buffer) {
                    original.bindBuffer.call(gl, 34962, attrib.buffer);
                    currentBinding = attrib.buffer;
                }
                bufferChanged = true;
            }
            if (bufferChanged || attrib.cached !== oldAttrib.cached) original.vertexAttribPointer.call(gl, n, attrib.size, attrib.type, attrib.normalized, attrib.stride, attrib.offset);
        }
    }
    if (this.currentArrayBuffer !== currentBinding) original.bindBuffer.call(gl, 34962, this.currentArrayBuffer);
};
function $44909f389943f36e$export$a14b3889aebee3e2(gl) {
    if (typeof gl.createVertexArray === "function") return;
    const original_getSupportedExtensions = gl.getSupportedExtensions;
    gl.getSupportedExtensions = function getSupportedExtensions() {
        const list = original_getSupportedExtensions.call(this) || [];
        if (list.indexOf("OES_vertex_array_object") < 0) list.push("OES_vertex_array_object");
        return list;
    };
    const original_getExtension = gl.getExtension;
    gl.getExtension = function getExtension(name) {
        const ext = original_getExtension.call(this, name);
        if (ext) return ext;
        if (name !== "OES_vertex_array_object") return null;
        if (!gl.__OESVertexArrayObject) this.__OESVertexArrayObject = new $44909f389943f36e$var$OESVertexArrayObject(this);
        return this.__OESVertexArrayObject;
    };
}






const $621a69577d3810ee$var$OES_element_index = "OES_element_index";
const $621a69577d3810ee$var$WEBGL_draw_buffers = "WEBGL_draw_buffers";
const $621a69577d3810ee$var$EXT_disjoint_timer_query = "EXT_disjoint_timer_query";
const $621a69577d3810ee$var$EXT_disjoint_timer_query_webgl2 = "EXT_disjoint_timer_query_webgl2";
const $621a69577d3810ee$var$EXT_texture_filter_anisotropic = "EXT_texture_filter_anisotropic";
const $621a69577d3810ee$var$WEBGL_debug_renderer_info = "WEBGL_debug_renderer_info";
const $621a69577d3810ee$var$GL_FRAGMENT_SHADER_DERIVATIVE_HINT = 0x8b8b;
const $621a69577d3810ee$var$GL_DONT_CARE = 0x1100;
const $621a69577d3810ee$var$GL_GPU_DISJOINT_EXT = 0x8fbb;
const $621a69577d3810ee$var$GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT = 0x84ff;
const $621a69577d3810ee$var$GL_UNMASKED_VENDOR_WEBGL = 0x9245;
const $621a69577d3810ee$var$GL_UNMASKED_RENDERER_WEBGL = 0x9246;
const $621a69577d3810ee$var$getWebGL2ValueOrZero = (gl)=>!(0, $325e733792a03f4e$export$e3518b1ac7891039)(gl) ? 0 : undefined;
const $621a69577d3810ee$var$WEBGL_PARAMETERS = {
    [3074]: (gl)=>!(0, $325e733792a03f4e$export$e3518b1ac7891039)(gl) ? 36064 : undefined,
    [$621a69577d3810ee$var$GL_FRAGMENT_SHADER_DERIVATIVE_HINT]: (gl)=>!(0, $325e733792a03f4e$export$e3518b1ac7891039)(gl) ? $621a69577d3810ee$var$GL_DONT_CARE : undefined,
    [35977]: $621a69577d3810ee$var$getWebGL2ValueOrZero,
    [32937]: $621a69577d3810ee$var$getWebGL2ValueOrZero,
    [$621a69577d3810ee$var$GL_GPU_DISJOINT_EXT]: (gl, getParameter)=>{
        const ext = (0, $325e733792a03f4e$export$e3518b1ac7891039)(gl) ? gl.getExtension($621a69577d3810ee$var$EXT_disjoint_timer_query_webgl2) : gl.getExtension($621a69577d3810ee$var$EXT_disjoint_timer_query);
        return ext && ext.GPU_DISJOINT_EXT ? getParameter(ext.GPU_DISJOINT_EXT) : 0;
    },
    [$621a69577d3810ee$var$GL_UNMASKED_VENDOR_WEBGL]: (gl, getParameter)=>{
        const ext = gl.getExtension($621a69577d3810ee$var$WEBGL_debug_renderer_info);
        return getParameter(ext && ext.UNMASKED_VENDOR_WEBGL || 7936);
    },
    [$621a69577d3810ee$var$GL_UNMASKED_RENDERER_WEBGL]: (gl, getParameter)=>{
        const ext = gl.getExtension($621a69577d3810ee$var$WEBGL_debug_renderer_info);
        return getParameter(ext && ext.UNMASKED_RENDERER_WEBGL || 7937);
    },
    [$621a69577d3810ee$var$GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT]: (gl, getParameter)=>{
        const ext = gl.luma.extensions[$621a69577d3810ee$var$EXT_texture_filter_anisotropic];
        return ext ? getParameter(ext.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 1.0;
    },
    [32883]: $621a69577d3810ee$var$getWebGL2ValueOrZero,
    [35071]: $621a69577d3810ee$var$getWebGL2ValueOrZero,
    [37447]: $621a69577d3810ee$var$getWebGL2ValueOrZero,
    [36063]: (gl, getParameter)=>{
        if (!(0, $325e733792a03f4e$export$e3518b1ac7891039)(gl)) {
            const ext = gl.getExtension($621a69577d3810ee$var$WEBGL_draw_buffers);
            return ext ? getParameter(ext.MAX_COLOR_ATTACHMENTS_WEBGL) : 0;
        }
        return undefined;
    },
    [35379]: $621a69577d3810ee$var$getWebGL2ValueOrZero,
    [35374]: $621a69577d3810ee$var$getWebGL2ValueOrZero,
    [35377]: $621a69577d3810ee$var$getWebGL2ValueOrZero,
    [34852]: (gl)=>{
        if (!(0, $325e733792a03f4e$export$e3518b1ac7891039)(gl)) {
            const ext = gl.getExtension($621a69577d3810ee$var$WEBGL_draw_buffers);
            return ext ? ext.MAX_DRAW_BUFFERS_WEBGL : 0;
        }
        return undefined;
    },
    [36203]: (gl)=>gl.getExtension($621a69577d3810ee$var$OES_element_index) ? 2147483647 : 65535,
    [33001]: (gl)=>gl.getExtension($621a69577d3810ee$var$OES_element_index) ? 16777216 : 65535,
    [33000]: (gl)=>16777216,
    [37157]: $621a69577d3810ee$var$getWebGL2ValueOrZero,
    [35373]: $621a69577d3810ee$var$getWebGL2ValueOrZero,
    [35657]: $621a69577d3810ee$var$getWebGL2ValueOrZero,
    [36183]: $621a69577d3810ee$var$getWebGL2ValueOrZero,
    [37137]: $621a69577d3810ee$var$getWebGL2ValueOrZero,
    [34045]: $621a69577d3810ee$var$getWebGL2ValueOrZero,
    [35978]: $621a69577d3810ee$var$getWebGL2ValueOrZero,
    [35979]: $621a69577d3810ee$var$getWebGL2ValueOrZero,
    [35968]: $621a69577d3810ee$var$getWebGL2ValueOrZero,
    [35376]: $621a69577d3810ee$var$getWebGL2ValueOrZero,
    [35375]: $621a69577d3810ee$var$getWebGL2ValueOrZero,
    [35659]: $621a69577d3810ee$var$getWebGL2ValueOrZero,
    [37154]: $621a69577d3810ee$var$getWebGL2ValueOrZero,
    [35371]: $621a69577d3810ee$var$getWebGL2ValueOrZero,
    [35658]: $621a69577d3810ee$var$getWebGL2ValueOrZero,
    [35076]: $621a69577d3810ee$var$getWebGL2ValueOrZero,
    [35077]: $621a69577d3810ee$var$getWebGL2ValueOrZero,
    [35380]: $621a69577d3810ee$var$getWebGL2ValueOrZero
};
function $621a69577d3810ee$export$76e91f2080178ba1(gl, originalGetParameter, pname) {
    const limit = $621a69577d3810ee$var$WEBGL_PARAMETERS[pname];
    const value = typeof limit === "function" ? limit(gl, originalGetParameter, pname) : limit;
    const result = value !== undefined ? value : originalGetParameter(pname);
    return result;
}


const $71b2d93ff8e47bee$var$OES_vertex_array_object = "OES_vertex_array_object";
const $71b2d93ff8e47bee$var$ANGLE_instanced_arrays = "ANGLE_instanced_arrays";
const $71b2d93ff8e47bee$var$WEBGL_draw_buffers = "WEBGL_draw_buffers";
const $71b2d93ff8e47bee$var$EXT_disjoint_timer_query = "EXT_disjoint_timer_query";
const $71b2d93ff8e47bee$var$EXT_texture_filter_anisotropic = "EXT_texture_filter_anisotropic";
const $71b2d93ff8e47bee$var$ERR_VAO_NOT_SUPPORTED = "VertexArray requires WebGL2 or OES_vertex_array_object extension";
function $71b2d93ff8e47bee$var$getExtensionData(gl, extension) {
    return {
        webgl2: (0, $325e733792a03f4e$export$e3518b1ac7891039)(gl),
        ext: gl.getExtension(extension)
    };
}
const $71b2d93ff8e47bee$export$55b4f9cc9ea3ebcb = {
    [$71b2d93ff8e47bee$var$OES_vertex_array_object]: {
        meta: {
            suffix: "OES"
        },
        createVertexArray: ()=>{
            (0, $611f47f49512a05f$export$a7a9523472993e97)(false, $71b2d93ff8e47bee$var$ERR_VAO_NOT_SUPPORTED);
        },
        deleteVertexArray: ()=>{},
        bindVertexArray: ()=>{},
        isVertexArray: ()=>false
    },
    [$71b2d93ff8e47bee$var$ANGLE_instanced_arrays]: {
        meta: {
            suffix: "ANGLE"
        },
        vertexAttribDivisor (location, divisor) {
            (0, $611f47f49512a05f$export$a7a9523472993e97)(divisor === 0, "WebGL instanced rendering not supported");
        },
        drawElementsInstanced: ()=>{},
        drawArraysInstanced: ()=>{}
    },
    [$71b2d93ff8e47bee$var$WEBGL_draw_buffers]: {
        meta: {
            suffix: "WEBGL"
        },
        drawBuffers: ()=>{
            (0, $611f47f49512a05f$export$a7a9523472993e97)(false);
        }
    },
    [$71b2d93ff8e47bee$var$EXT_disjoint_timer_query]: {
        meta: {
            suffix: "EXT"
        },
        createQuery: ()=>{
            (0, $611f47f49512a05f$export$a7a9523472993e97)(false);
        },
        deleteQuery: ()=>{
            (0, $611f47f49512a05f$export$a7a9523472993e97)(false);
        },
        beginQuery: ()=>{
            (0, $611f47f49512a05f$export$a7a9523472993e97)(false);
        },
        endQuery: ()=>{},
        getQuery (handle, pname) {
            return this.getQueryObject(handle, pname);
        },
        getQueryParameter (handle, pname) {
            return this.getQueryObject(handle, pname);
        },
        getQueryObject: ()=>{}
    }
};
const $71b2d93ff8e47bee$export$16cadaab146130da = {
    readBuffer: (gl, originalFunc, attachment)=>{
        if ((0, $325e733792a03f4e$export$e3518b1ac7891039)(gl)) originalFunc(attachment);
    },
    getVertexAttrib: (gl, originalFunc, location, pname)=>{
        const { webgl2: webgl2 , ext: ext  } = $71b2d93ff8e47bee$var$getExtensionData(gl, $71b2d93ff8e47bee$var$ANGLE_instanced_arrays);
        let result;
        switch(pname){
            case 35069:
                result = !webgl2 ? false : undefined;
                break;
            case 35070:
                result = !webgl2 && !ext ? 0 : undefined;
                break;
            default:
        }
        return result !== undefined ? result : originalFunc(location, pname);
    },
    getProgramParameter: (gl, originalFunc, program, pname)=>{
        if (!(0, $325e733792a03f4e$export$e3518b1ac7891039)(gl)) switch(pname){
            case 35967:
                return 35981;
            case 35971:
                return 0;
            case 35382:
                return 0;
            default:
        }
        return originalFunc(program, pname);
    },
    getInternalformatParameter: (gl, originalFunc, target, format, pname)=>{
        if (!(0, $325e733792a03f4e$export$e3518b1ac7891039)(gl)) switch(pname){
            case 32937:
                return new Int32Array([
                    0
                ]);
            default:
        }
        return gl.getInternalformatParameter(target, format, pname);
    },
    getTexParameter (gl, originalFunc, target, pname) {
        switch(pname){
            case 34046:
                const { extensions: extensions  } = gl.luma;
                const ext = extensions[$71b2d93ff8e47bee$var$EXT_texture_filter_anisotropic];
                pname = ext && ext.TEXTURE_MAX_ANISOTROPY_EXT || 34046;
                break;
            default:
        }
        return originalFunc(target, pname);
    },
    getParameter: (0, $621a69577d3810ee$export$76e91f2080178ba1),
    hint (gl, originalFunc, pname, value) {
        return originalFunc(pname, value);
    }
};


function $1f185b328a16f979$export$2546a51f55104d54(gl) {
    gl.luma = gl.luma || {};
    const { luma: luma  } = gl;
    if (!luma.polyfilled) {
        (0, $44909f389943f36e$export$a14b3889aebee3e2)(gl);
        $1f185b328a16f979$var$initializeExtensions(gl);
        $1f185b328a16f979$var$installPolyfills(gl, (0, $71b2d93ff8e47bee$export$55b4f9cc9ea3ebcb));
        $1f185b328a16f979$var$installOverrides(gl, {
            target: luma,
            target2: gl
        });
        luma.polyfilled = true;
    }
    return gl;
}
globalThis.polyfillContext = $1f185b328a16f979$export$2546a51f55104d54;
function $1f185b328a16f979$var$initializeExtensions(gl) {
    gl.luma.extensions = {};
    const EXTENSIONS = gl.getSupportedExtensions() || [];
    for (const extension of EXTENSIONS)gl.luma[extension] = gl.getExtension(extension);
}
function $1f185b328a16f979$var$installOverrides(gl, _ref) {
    let { target: target , target2: target2  } = _ref;
    Object.keys((0, $71b2d93ff8e47bee$export$16cadaab146130da)).forEach((key)=>{
        if (typeof (0, $71b2d93ff8e47bee$export$16cadaab146130da)[key] === "function") {
            const originalFunc = gl[key] ? gl[key].bind(gl) : ()=>{};
            const polyfill = (0, $71b2d93ff8e47bee$export$16cadaab146130da)[key].bind(null, gl, originalFunc);
            target[key] = polyfill;
            target2[key] = polyfill;
        }
    });
}
function $1f185b328a16f979$var$installPolyfills(gl, polyfills) {
    for (const extension of Object.getOwnPropertyNames(polyfills))if (extension !== "overrides") $1f185b328a16f979$var$polyfillExtension(gl, {
        extension: extension,
        target: gl.luma,
        target2: gl
    });
}
function $1f185b328a16f979$var$polyfillExtension(gl, _ref2) {
    let { extension: extension , target: target , target2: target2  } = _ref2;
    const defaults = (0, $71b2d93ff8e47bee$export$55b4f9cc9ea3ebcb)[extension];
    (0, $611f47f49512a05f$export$a7a9523472993e97)(defaults);
    const { meta: meta = {}  } = defaults;
    const { suffix: suffix = ""  } = meta;
    const ext = gl.getExtension(extension);
    for (const key of Object.keys(defaults)){
        const extKey = "".concat(key).concat(suffix);
        let polyfill = null;
        if (key === "meta") ;
        else if (typeof gl[key] === "function") ;
        else if (ext && typeof ext[extKey] === "function") polyfill = function() {
            return ext[extKey](...arguments);
        };
        else if (typeof defaults[key] === "function") polyfill = defaults[key].bind(target);
        if (polyfill) {
            target[key] = polyfill;
            target2[key] = polyfill;
        }
    }
}



const $2cabdcb30df9ebb5$export$baa06478962d475e = {
    [3042]: false,
    [32773]: new Float32Array([
        0,
        0,
        0,
        0
    ]),
    [32777]: 32774,
    [34877]: 32774,
    [32969]: 1,
    [32968]: 0,
    [32971]: 1,
    [32970]: 0,
    [3106]: new Float32Array([
        0,
        0,
        0,
        0
    ]),
    [3107]: [
        true,
        true,
        true,
        true
    ],
    [2884]: false,
    [2885]: 1029,
    [2929]: false,
    [2931]: 1,
    [2932]: 513,
    [2928]: new Float32Array([
        0,
        1
    ]),
    [2930]: true,
    [3024]: true,
    [36006]: null,
    [2886]: 2305,
    [33170]: 4352,
    [2849]: 1,
    [32823]: false,
    [32824]: 0,
    [10752]: 0,
    [32938]: 1.0,
    [32939]: false,
    [3089]: false,
    [3088]: new Int32Array([
        0,
        0,
        1024,
        1024
    ]),
    [2960]: false,
    [2961]: 0,
    [2968]: 0xffffffff,
    [36005]: 0xffffffff,
    [2962]: 519,
    [2967]: 0,
    [2963]: 0xffffffff,
    [34816]: 519,
    [36003]: 0,
    [36004]: 0xffffffff,
    [2964]: 7680,
    [2965]: 7680,
    [2966]: 7680,
    [34817]: 7680,
    [34818]: 7680,
    [34819]: 7680,
    [2978]: [
        0,
        0,
        1024,
        1024
    ],
    [3333]: 4,
    [3317]: 4,
    [37440]: false,
    [37441]: false,
    [37443]: 37444,
    [35723]: 4352,
    [36010]: null,
    [35977]: false,
    [3330]: 0,
    [3332]: 0,
    [3331]: 0,
    [3314]: 0,
    [32878]: 0,
    [3316]: 0,
    [3315]: 0,
    [32877]: 0
};
const $2cabdcb30df9ebb5$var$enable = (gl, value, key)=>value ? gl.enable(key) : gl.disable(key);
const $2cabdcb30df9ebb5$var$hint = (gl, value, key)=>gl.hint(key, value);
const $2cabdcb30df9ebb5$var$pixelStorei = (gl, value, key)=>gl.pixelStorei(key, value);
const $2cabdcb30df9ebb5$var$drawFramebuffer = (gl, value)=>{
    const target = (0, $325e733792a03f4e$export$e3518b1ac7891039)(gl) ? 36009 : 36160;
    return gl.bindFramebuffer(target, value);
};
const $2cabdcb30df9ebb5$var$readFramebuffer = (gl, value)=>{
    return gl.bindFramebuffer(36008, value);
};
function $2cabdcb30df9ebb5$var$isArray(array) {
    return Array.isArray(array) || ArrayBuffer.isView(array);
}
const $2cabdcb30df9ebb5$export$f29b03183ed64cfb = {
    [3042]: $2cabdcb30df9ebb5$var$enable,
    [32773]: (gl, value)=>gl.blendColor(...value),
    [32777]: "blendEquation",
    [34877]: "blendEquation",
    [32969]: "blendFunc",
    [32968]: "blendFunc",
    [32971]: "blendFunc",
    [32970]: "blendFunc",
    [3106]: (gl, value)=>gl.clearColor(...value),
    [3107]: (gl, value)=>gl.colorMask(...value),
    [2884]: $2cabdcb30df9ebb5$var$enable,
    [2885]: (gl, value)=>gl.cullFace(value),
    [2929]: $2cabdcb30df9ebb5$var$enable,
    [2931]: (gl, value)=>gl.clearDepth(value),
    [2932]: (gl, value)=>gl.depthFunc(value),
    [2928]: (gl, value)=>gl.depthRange(...value),
    [2930]: (gl, value)=>gl.depthMask(value),
    [3024]: $2cabdcb30df9ebb5$var$enable,
    [35723]: $2cabdcb30df9ebb5$var$hint,
    [36006]: $2cabdcb30df9ebb5$var$drawFramebuffer,
    [2886]: (gl, value)=>gl.frontFace(value),
    [33170]: $2cabdcb30df9ebb5$var$hint,
    [2849]: (gl, value)=>gl.lineWidth(value),
    [32823]: $2cabdcb30df9ebb5$var$enable,
    [32824]: "polygonOffset",
    [10752]: "polygonOffset",
    [35977]: $2cabdcb30df9ebb5$var$enable,
    [32938]: "sampleCoverage",
    [32939]: "sampleCoverage",
    [3089]: $2cabdcb30df9ebb5$var$enable,
    [3088]: (gl, value)=>gl.scissor(...value),
    [2960]: $2cabdcb30df9ebb5$var$enable,
    [2961]: (gl, value)=>gl.clearStencil(value),
    [2968]: (gl, value)=>gl.stencilMaskSeparate(1028, value),
    [36005]: (gl, value)=>gl.stencilMaskSeparate(1029, value),
    [2962]: "stencilFuncFront",
    [2967]: "stencilFuncFront",
    [2963]: "stencilFuncFront",
    [34816]: "stencilFuncBack",
    [36003]: "stencilFuncBack",
    [36004]: "stencilFuncBack",
    [2964]: "stencilOpFront",
    [2965]: "stencilOpFront",
    [2966]: "stencilOpFront",
    [34817]: "stencilOpBack",
    [34818]: "stencilOpBack",
    [34819]: "stencilOpBack",
    [2978]: (gl, value)=>gl.viewport(...value),
    [3333]: $2cabdcb30df9ebb5$var$pixelStorei,
    [3317]: $2cabdcb30df9ebb5$var$pixelStorei,
    [37440]: $2cabdcb30df9ebb5$var$pixelStorei,
    [37441]: $2cabdcb30df9ebb5$var$pixelStorei,
    [37443]: $2cabdcb30df9ebb5$var$pixelStorei,
    [3330]: $2cabdcb30df9ebb5$var$pixelStorei,
    [3332]: $2cabdcb30df9ebb5$var$pixelStorei,
    [3331]: $2cabdcb30df9ebb5$var$pixelStorei,
    [36010]: $2cabdcb30df9ebb5$var$readFramebuffer,
    [3314]: $2cabdcb30df9ebb5$var$pixelStorei,
    [32878]: $2cabdcb30df9ebb5$var$pixelStorei,
    [3316]: $2cabdcb30df9ebb5$var$pixelStorei,
    [3315]: $2cabdcb30df9ebb5$var$pixelStorei,
    [32877]: $2cabdcb30df9ebb5$var$pixelStorei,
    framebuffer: (gl, framebuffer)=>{
        const handle = framebuffer && "handle" in framebuffer ? framebuffer.handle : framebuffer;
        return gl.bindFramebuffer(36160, handle);
    },
    blend: (gl, value)=>value ? gl.enable(3042) : gl.disable(3042),
    blendColor: (gl, value)=>gl.blendColor(...value),
    blendEquation: (gl, args)=>{
        args = $2cabdcb30df9ebb5$var$isArray(args) ? args : [
            args,
            args
        ];
        gl.blendEquationSeparate(...args);
    },
    blendFunc: (gl, args)=>{
        args = $2cabdcb30df9ebb5$var$isArray(args) && args.length === 2 ? [
            ...args,
            ...args
        ] : args;
        gl.blendFuncSeparate(...args);
    },
    clearColor: (gl, value)=>gl.clearColor(...value),
    clearDepth: (gl, value)=>gl.clearDepth(value),
    clearStencil: (gl, value)=>gl.clearStencil(value),
    colorMask: (gl, value)=>gl.colorMask(...value),
    cull: (gl, value)=>value ? gl.enable(2884) : gl.disable(2884),
    cullFace: (gl, value)=>gl.cullFace(value),
    depthTest: (gl, value)=>value ? gl.enable(2929) : gl.disable(2929),
    depthFunc: (gl, value)=>gl.depthFunc(value),
    depthMask: (gl, value)=>gl.depthMask(value),
    depthRange: (gl, value)=>gl.depthRange(...value),
    dither: (gl, value)=>value ? gl.enable(3024) : gl.disable(3024),
    derivativeHint: (gl, value)=>{
        gl.hint(35723, value);
    },
    frontFace: (gl, value)=>gl.frontFace(value),
    mipmapHint: (gl, value)=>gl.hint(33170, value),
    lineWidth: (gl, value)=>gl.lineWidth(value),
    polygonOffsetFill: (gl, value)=>value ? gl.enable(32823) : gl.disable(32823),
    polygonOffset: (gl, value)=>gl.polygonOffset(...value),
    sampleCoverage: (gl, value)=>gl.sampleCoverage(...value),
    scissorTest: (gl, value)=>value ? gl.enable(3089) : gl.disable(3089),
    scissor: (gl, value)=>gl.scissor(...value),
    stencilTest: (gl, value)=>value ? gl.enable(2960) : gl.disable(2960),
    stencilMask: (gl, value)=>{
        value = $2cabdcb30df9ebb5$var$isArray(value) ? value : [
            value,
            value
        ];
        const [mask, backMask] = value;
        gl.stencilMaskSeparate(1028, mask);
        gl.stencilMaskSeparate(1029, backMask);
    },
    stencilFunc: (gl, args)=>{
        args = $2cabdcb30df9ebb5$var$isArray(args) && args.length === 3 ? [
            ...args,
            ...args
        ] : args;
        const [func, ref, mask, backFunc, backRef, backMask] = args;
        gl.stencilFuncSeparate(1028, func, ref, mask);
        gl.stencilFuncSeparate(1029, backFunc, backRef, backMask);
    },
    stencilOp: (gl, args)=>{
        args = $2cabdcb30df9ebb5$var$isArray(args) && args.length === 3 ? [
            ...args,
            ...args
        ] : args;
        const [sfail, dpfail, dppass, backSfail, backDpfail, backDppass] = args;
        gl.stencilOpSeparate(1028, sfail, dpfail, dppass);
        gl.stencilOpSeparate(1029, backSfail, backDpfail, backDppass);
    },
    viewport: (gl, value)=>gl.viewport(...value)
};
function $2cabdcb30df9ebb5$var$getValue(glEnum, values, cache) {
    return values[glEnum] !== undefined ? values[glEnum] : cache[glEnum];
}
const $2cabdcb30df9ebb5$export$ff5443824a4dc32 = {
    blendEquation: (gl, values, cache)=>gl.blendEquationSeparate($2cabdcb30df9ebb5$var$getValue(32777, values, cache), $2cabdcb30df9ebb5$var$getValue(34877, values, cache)),
    blendFunc: (gl, values, cache)=>gl.blendFuncSeparate($2cabdcb30df9ebb5$var$getValue(32969, values, cache), $2cabdcb30df9ebb5$var$getValue(32968, values, cache), $2cabdcb30df9ebb5$var$getValue(32971, values, cache), $2cabdcb30df9ebb5$var$getValue(32970, values, cache)),
    polygonOffset: (gl, values, cache)=>gl.polygonOffset($2cabdcb30df9ebb5$var$getValue(32824, values, cache), $2cabdcb30df9ebb5$var$getValue(10752, values, cache)),
    sampleCoverage: (gl, values, cache)=>gl.sampleCoverage($2cabdcb30df9ebb5$var$getValue(32938, values, cache), $2cabdcb30df9ebb5$var$getValue(32939, values, cache)),
    stencilFuncFront: (gl, values, cache)=>gl.stencilFuncSeparate(1028, $2cabdcb30df9ebb5$var$getValue(2962, values, cache), $2cabdcb30df9ebb5$var$getValue(2967, values, cache), $2cabdcb30df9ebb5$var$getValue(2963, values, cache)),
    stencilFuncBack: (gl, values, cache)=>gl.stencilFuncSeparate(1029, $2cabdcb30df9ebb5$var$getValue(34816, values, cache), $2cabdcb30df9ebb5$var$getValue(36003, values, cache), $2cabdcb30df9ebb5$var$getValue(36004, values, cache)),
    stencilOpFront: (gl, values, cache)=>gl.stencilOpSeparate(1028, $2cabdcb30df9ebb5$var$getValue(2964, values, cache), $2cabdcb30df9ebb5$var$getValue(2965, values, cache), $2cabdcb30df9ebb5$var$getValue(2966, values, cache)),
    stencilOpBack: (gl, values, cache)=>gl.stencilOpSeparate(1029, $2cabdcb30df9ebb5$var$getValue(34817, values, cache), $2cabdcb30df9ebb5$var$getValue(34818, values, cache), $2cabdcb30df9ebb5$var$getValue(34819, values, cache))
};
const $2cabdcb30df9ebb5$export$21a690e042a82719 = {
    enable: (update, capability)=>update({
            [capability]: true
        }),
    disable: (update, capability)=>update({
            [capability]: false
        }),
    pixelStorei: (update, pname, value)=>update({
            [pname]: value
        }),
    hint: (update, pname, hint1)=>update({
            [pname]: hint1
        }),
    bindFramebuffer: (update, target, framebuffer)=>{
        switch(target){
            case 36160:
                return update({
                    [36006]: framebuffer,
                    [36010]: framebuffer
                });
            case 36009:
                return update({
                    [36006]: framebuffer
                });
            case 36008:
                return update({
                    [36010]: framebuffer
                });
            default:
                return null;
        }
    },
    blendColor: (update, r, g, b, a)=>update({
            [32773]: new Float32Array([
                r,
                g,
                b,
                a
            ])
        }),
    blendEquation: (update, mode)=>update({
            [32777]: mode,
            [34877]: mode
        }),
    blendEquationSeparate: (update, modeRGB, modeAlpha)=>update({
            [32777]: modeRGB,
            [34877]: modeAlpha
        }),
    blendFunc: (update, src, dst)=>update({
            [32969]: src,
            [32968]: dst,
            [32971]: src,
            [32970]: dst
        }),
    blendFuncSeparate: (update, srcRGB, dstRGB, srcAlpha, dstAlpha)=>update({
            [32969]: srcRGB,
            [32968]: dstRGB,
            [32971]: srcAlpha,
            [32970]: dstAlpha
        }),
    clearColor: (update, r, g, b, a)=>update({
            [3106]: new Float32Array([
                r,
                g,
                b,
                a
            ])
        }),
    clearDepth: (update, depth)=>update({
            [2931]: depth
        }),
    clearStencil: (update, s)=>update({
            [2961]: s
        }),
    colorMask: (update, r, g, b, a)=>update({
            [3107]: [
                r,
                g,
                b,
                a
            ]
        }),
    cullFace: (update, mode)=>update({
            [2885]: mode
        }),
    depthFunc: (update, func)=>update({
            [2932]: func
        }),
    depthRange: (update, zNear, zFar)=>update({
            [2928]: new Float32Array([
                zNear,
                zFar
            ])
        }),
    depthMask: (update, mask)=>update({
            [2930]: mask
        }),
    frontFace: (update, face)=>update({
            [2886]: face
        }),
    lineWidth: (update, width)=>update({
            [2849]: width
        }),
    polygonOffset: (update, factor, units)=>update({
            [32824]: factor,
            [10752]: units
        }),
    sampleCoverage: (update, value, invert)=>update({
            [32938]: value,
            [32939]: invert
        }),
    scissor: (update, x, y, width, height)=>update({
            [3088]: new Int32Array([
                x,
                y,
                width,
                height
            ])
        }),
    stencilMask: (update, mask)=>update({
            [2968]: mask,
            [36005]: mask
        }),
    stencilMaskSeparate: (update, face, mask)=>update({
            [face === 1028 ? 2968 : 36005]: mask
        }),
    stencilFunc: (update, func, ref, mask)=>update({
            [2962]: func,
            [2967]: ref,
            [2963]: mask,
            [34816]: func,
            [36003]: ref,
            [36004]: mask
        }),
    stencilFuncSeparate: (update, face, func, ref, mask)=>update({
            [face === 1028 ? 2962 : 34816]: func,
            [face === 1028 ? 2967 : 36003]: ref,
            [face === 1028 ? 2963 : 36004]: mask
        }),
    stencilOp: (update, fail, zfail, zpass)=>update({
            [2964]: fail,
            [2965]: zfail,
            [2966]: zpass,
            [34817]: fail,
            [34818]: zfail,
            [34819]: zpass
        }),
    stencilOpSeparate: (update, face, fail, zfail, zpass)=>update({
            [face === 1028 ? 2964 : 34817]: fail,
            [face === 1028 ? 2965 : 34818]: zfail,
            [face === 1028 ? 2966 : 34819]: zpass
        }),
    viewport: (update, x, y, width, height)=>update({
            [2978]: [
                x,
                y,
                width,
                height
            ]
        })
};
const $2cabdcb30df9ebb5$var$isEnabled = (gl, key)=>gl.isEnabled(key);
const $2cabdcb30df9ebb5$export$f7e7f6f928a85334 = {
    [3042]: $2cabdcb30df9ebb5$var$isEnabled,
    [2884]: $2cabdcb30df9ebb5$var$isEnabled,
    [2929]: $2cabdcb30df9ebb5$var$isEnabled,
    [3024]: $2cabdcb30df9ebb5$var$isEnabled,
    [32823]: $2cabdcb30df9ebb5$var$isEnabled,
    [32926]: $2cabdcb30df9ebb5$var$isEnabled,
    [32928]: $2cabdcb30df9ebb5$var$isEnabled,
    [3089]: $2cabdcb30df9ebb5$var$isEnabled,
    [2960]: $2cabdcb30df9ebb5$var$isEnabled,
    [35977]: $2cabdcb30df9ebb5$var$isEnabled
};





function $40e068f0e4b7a959$export$23cfe696632d10f4(object) {
    for(const key in object)return false;
    return true;
}
function $40e068f0e4b7a959$export$9b55716ca87eded(x, y) {
    if (x === y) return true;
    const isArrayX = Array.isArray(x) || ArrayBuffer.isView(x);
    const isArrayY = Array.isArray(y) || ArrayBuffer.isView(y);
    if (isArrayX && isArrayY && x.length === y.length) {
        for(let i = 0; i < x.length; ++i){
            if (x[i] !== y[i]) return false;
        }
        return true;
    }
    return false;
}


function $0aaaa72a803ca01a$var$installGetterOverride(gl, functionName) {
    const originalGetterFunc = gl[functionName].bind(gl);
    gl[functionName] = function get() {
        const pname = arguments.length <= 0 ? undefined : arguments[0];
        if (!(pname in gl.state.cache)) return originalGetterFunc(...arguments);
        return gl.state.enable ? gl.state.cache[pname] : originalGetterFunc(...arguments);
    };
    Object.defineProperty(gl[functionName], "name", {
        value: "".concat(functionName, "-from-cache"),
        configurable: false
    });
}
function $0aaaa72a803ca01a$var$installSetterSpy(gl, functionName, setter) {
    const originalSetterFunc = gl[functionName].bind(gl);
    gl[functionName] = function set() {
        for(var _len = arguments.length, params = new Array(_len), _key = 0; _key < _len; _key++)params[_key] = arguments[_key];
        const { valueChanged: valueChanged , oldValue: oldValue  } = setter(gl.state._updateCache, ...params);
        if (valueChanged) originalSetterFunc(...params);
        return oldValue;
    };
    Object.defineProperty(gl[functionName], "name", {
        value: "".concat(functionName, "-to-cache"),
        configurable: false
    });
}
function $0aaaa72a803ca01a$var$installProgramSpy(gl) {
    const originalUseProgram = gl.useProgram.bind(gl);
    gl.useProgram = function useProgramLuma(handle) {
        if (gl.state.program !== handle) {
            originalUseProgram(handle);
            gl.state.program = handle;
        }
    };
}
class $0aaaa72a803ca01a$var$GLState {
    constructor(gl){
        let { copyState: copyState = false , log: log = ()=>{}  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        this.gl = gl;
        this.program = null;
        this.stateStack = [];
        this.enable = true;
        this.cache = copyState ? (0, $54220aa8b6471f1a$export$1d5e65f36fbcdb49)(gl) : Object.assign({}, (0, $2cabdcb30df9ebb5$export$baa06478962d475e));
        this.log = log;
        this._updateCache = this._updateCache.bind(this);
        Object.seal(this);
    }
    push() {
        let values = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        this.stateStack.push({});
    }
    pop() {
        (0, $611f47f49512a05f$export$a7a9523472993e97)(this.stateStack.length > 0);
        const oldValues = this.stateStack[this.stateStack.length - 1];
        (0, $54220aa8b6471f1a$export$60752c4a8a24d484)(this.gl, oldValues);
        this.stateStack.pop();
    }
    _updateCache(values) {
        let valueChanged = false;
        let oldValue;
        const oldValues = this.stateStack.length > 0 && this.stateStack[this.stateStack.length - 1];
        for(const key in values){
            (0, $611f47f49512a05f$export$a7a9523472993e97)(key !== undefined);
            const value = values[key];
            const cached = this.cache[key];
            if (!(0, $40e068f0e4b7a959$export$9b55716ca87eded)(value, cached)) {
                valueChanged = true;
                oldValue = cached;
                if (oldValues && !(key in oldValues)) oldValues[key] = cached;
                this.cache[key] = value;
            }
        }
        return {
            valueChanged: valueChanged,
            oldValue: oldValue
        };
    }
}
function $0aaaa72a803ca01a$export$eda55831a64d5931(gl) {
    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    const { enable: enable = true , copyState: copyState  } = options;
    (0, $611f47f49512a05f$export$a7a9523472993e97)(copyState !== undefined);
    if (!gl.state) {
        const { polyfillContext: polyfillContext  } = globalThis;
        if (polyfillContext) polyfillContext(gl);
        gl.state = new $0aaaa72a803ca01a$var$GLState(gl, {
            copyState: copyState
        });
        $0aaaa72a803ca01a$var$installProgramSpy(gl);
        for(const key in 0, $2cabdcb30df9ebb5$export$21a690e042a82719){
            const setter = (0, $2cabdcb30df9ebb5$export$21a690e042a82719)[key];
            $0aaaa72a803ca01a$var$installSetterSpy(gl, key, setter);
        }
        $0aaaa72a803ca01a$var$installGetterOverride(gl, "getParameter");
        $0aaaa72a803ca01a$var$installGetterOverride(gl, "isEnabled");
    }
    gl.state.enable = enable;
    return gl;
}
function $0aaaa72a803ca01a$export$529f9c1c84156b45(gl) {
    if (!gl.state) $0aaaa72a803ca01a$export$eda55831a64d5931(gl, {
        copyState: false
    });
    gl.state.push();
}
function $0aaaa72a803ca01a$export$30ca4f2cb45c903e(gl) {
    (0, $611f47f49512a05f$export$a7a9523472993e97)(gl.state);
    gl.state.pop();
}





function $54220aa8b6471f1a$export$60752c4a8a24d484(gl, values) {
    (0, $611f47f49512a05f$export$a7a9523472993e97)((0, $325e733792a03f4e$export$3a471d0dd6792be6)(gl), "setParameters requires a WebGL context");
    if ((0, $40e068f0e4b7a959$export$23cfe696632d10f4)(values)) return;
    const compositeSetters = {};
    for(const key in values){
        const glConstant = Number(key);
        const setter = (0, $2cabdcb30df9ebb5$export$f29b03183ed64cfb)[key];
        if (setter) {
            if (typeof setter === "string") compositeSetters[setter] = true;
            else setter(gl, values[key], glConstant);
        }
    }
    const cache = gl.state && gl.state.cache;
    if (cache) for(const key1 in compositeSetters){
        const compositeSetter = (0, $2cabdcb30df9ebb5$export$ff5443824a4dc32)[key1];
        compositeSetter(gl, values, cache);
    }
}
function $54220aa8b6471f1a$export$1d5e65f36fbcdb49(gl, parameters) {
    parameters = parameters || (0, $2cabdcb30df9ebb5$export$baa06478962d475e);
    if (typeof parameters === "number") {
        const key = parameters;
        const getter = (0, $2cabdcb30df9ebb5$export$f7e7f6f928a85334)[key];
        return getter ? getter(gl, key) : gl.getParameter(key);
    }
    const parameterKeys = Array.isArray(parameters) ? parameters : Object.keys(parameters);
    const state = {};
    for (const key of parameterKeys){
        const getter = (0, $2cabdcb30df9ebb5$export$f7e7f6f928a85334)[key];
        state[key] = getter ? getter(gl, Number(key)) : gl.getParameter(Number(key));
    }
    return state;
}
function $54220aa8b6471f1a$export$2ee1427ea70eaaab(gl) {
    $54220aa8b6471f1a$export$60752c4a8a24d484(gl, (0, $2cabdcb30df9ebb5$export$baa06478962d475e));
}
function $54220aa8b6471f1a$export$b1e7058a2936b651(gl, parameters, func) {
    if ((0, $40e068f0e4b7a959$export$23cfe696632d10f4)(parameters)) return func(gl);
    const { nocatch: nocatch = true  } = parameters;
    (0, $0aaaa72a803ca01a$export$529f9c1c84156b45)(gl);
    $54220aa8b6471f1a$export$60752c4a8a24d484(gl, parameters);
    let value;
    if (nocatch) {
        value = func(gl);
        (0, $0aaaa72a803ca01a$export$30ca4f2cb45c903e)(gl);
    } else try {
        value = func(gl);
    } finally{
        (0, $0aaaa72a803ca01a$export$30ca4f2cb45c903e)(gl);
    }
    return value;
}







function $294e503c6396a3ff$export$df40057290e74703(gl) {
    const { luma: luma  } = gl;
    if (gl.canvas && luma) {
        const { clientWidth: clientWidth  } = luma.canvasSizeInfo;
        return clientWidth ? gl.drawingBufferWidth / clientWidth : 1;
    }
    return 1;
}
function $294e503c6396a3ff$export$af080a4e21b7825c(gl, cssPixel) {
    let yInvert = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
    const ratio = $294e503c6396a3ff$export$df40057290e74703(gl);
    const width = gl.drawingBufferWidth;
    const height = gl.drawingBufferHeight;
    return $294e503c6396a3ff$var$scalePixels(cssPixel, ratio, width, height, yInvert);
}
function $294e503c6396a3ff$export$cf4a949e5ad681d(useDevicePixels) {
    const windowRatio = typeof window === "undefined" ? 1 : window.devicePixelRatio || 1;
    if (Number.isFinite(useDevicePixels)) return useDevicePixels <= 0 ? 1 : useDevicePixels;
    return useDevicePixels ? windowRatio : 1;
}
function $294e503c6396a3ff$var$scalePixels(pixel, ratio, width, height, yInvert) {
    const x = $294e503c6396a3ff$var$scaleX(pixel[0], ratio, width);
    let y = $294e503c6396a3ff$var$scaleY(pixel[1], ratio, height, yInvert);
    let t = $294e503c6396a3ff$var$scaleX(pixel[0] + 1, ratio, width);
    const xHigh = t === width - 1 ? t : t - 1;
    t = $294e503c6396a3ff$var$scaleY(pixel[1] + 1, ratio, height, yInvert);
    let yHigh;
    if (yInvert) {
        t = t === 0 ? t : t + 1;
        yHigh = y;
        y = t;
    } else yHigh = t === height - 1 ? t : t - 1;
    return {
        x: x,
        y: y,
        width: Math.max(xHigh - x + 1, 1),
        height: Math.max(yHigh - y + 1, 1)
    };
}
function $294e503c6396a3ff$var$scaleX(x, ratio, width) {
    const r = Math.min(Math.round(x * ratio), width - 1);
    return r;
}
function $294e503c6396a3ff$var$scaleY(y, ratio, height, yInvert) {
    return yInvert ? Math.max(0, height - 1 - Math.round(y * ratio)) : Math.min(Math.round(y * ratio), height - 1);
}



const $f89b67ad8c6f5746$var$isBrowser = (0, $58cc8c917413a7dc$export$2e2bcd8739ae039)();
const $f89b67ad8c6f5746$var$isPage = $f89b67ad8c6f5746$var$isBrowser && typeof document !== "undefined";
const $f89b67ad8c6f5746$var$CONTEXT_DEFAULTS = {
    webgl2: true,
    webgl1: true,
    throwOnError: true,
    manageState: true,
    canvas: null,
    debug: false,
    width: 800,
    height: 600
};
function $f89b67ad8c6f5746$export$a32ea65c51ffebe7() {
    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, $611f47f49512a05f$export$a7a9523472993e97)($f89b67ad8c6f5746$var$isBrowser, "createGLContext only available in the browser.\nCreate your own headless context or use 'createHeadlessContext' from @luma.gl/test-utils");
    options = Object.assign({}, $f89b67ad8c6f5746$var$CONTEXT_DEFAULTS, options);
    const { width: width , height: height  } = options;
    function onError(message) {
        if (options.throwOnError) throw new Error(message);
        console.error(message);
        return null;
    }
    options.onError = onError;
    let gl;
    const { canvas: canvas  } = options;
    const targetCanvas = $f89b67ad8c6f5746$var$getCanvas({
        canvas: canvas,
        width: width,
        height: height,
        onError: onError
    });
    gl = $f89b67ad8c6f5746$var$createBrowserContext(targetCanvas, options);
    if (!gl) return null;
    gl = $f89b67ad8c6f5746$export$6b6cef073fe6a207(gl, options);
    $f89b67ad8c6f5746$var$logInfo(gl);
    return gl;
}
function $f89b67ad8c6f5746$export$6b6cef073fe6a207(gl) {
    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    if (!gl || gl._instrumented) return gl;
    gl._version = gl._version || $f89b67ad8c6f5746$var$getVersion(gl);
    gl.luma = gl.luma || {};
    gl.luma.canvasSizeInfo = gl.luma.canvasSizeInfo || {};
    options = Object.assign({}, $f89b67ad8c6f5746$var$CONTEXT_DEFAULTS, options);
    const { manageState: manageState , debug: debug  } = options;
    if (manageState) (0, $0aaaa72a803ca01a$export$eda55831a64d5931)(gl, {
        copyState: false,
        log: function() {
            for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)args[_key] = arguments[_key];
            return (0, $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3).log(1, ...args)();
        }
    });
    if ($f89b67ad8c6f5746$var$isBrowser && debug) {
        if (!globalThis.makeDebugContext) (0, $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3).warn('WebGL debug mode not activated. import "@luma.gl/debug" to enable.')();
        else {
            gl = globalThis.makeDebugContext(gl, options);
            (0, $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3).level = Math.max((0, $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3).level, 1);
        }
    }
    gl._instrumented = true;
    return gl;
}
function $f89b67ad8c6f5746$export$6f15ab3b829c3189(gl) {
    const vendorMasked = gl.getParameter(7936);
    const rendererMasked = gl.getParameter(7937);
    const ext = gl.getExtension("WEBGL_debug_renderer_info");
    const vendorUnmasked = ext && gl.getParameter(ext.UNMASKED_VENDOR_WEBGL || 7936);
    const rendererUnmasked = ext && gl.getParameter(ext.UNMASKED_RENDERER_WEBGL || 7937);
    return {
        vendor: vendorUnmasked || vendorMasked,
        renderer: rendererUnmasked || rendererMasked,
        vendorMasked: vendorMasked,
        rendererMasked: rendererMasked,
        version: gl.getParameter(7938),
        shadingLanguageVersion: gl.getParameter(35724)
    };
}
function $f89b67ad8c6f5746$export$4ed444b69b8944fd(gl) {
    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    if (gl.canvas) {
        const devicePixelRatio = (0, $294e503c6396a3ff$export$cf4a949e5ad681d)(options.useDevicePixels);
        $f89b67ad8c6f5746$var$setDevicePixelRatio(gl, devicePixelRatio, options);
        return;
    }
    const ext = gl.getExtension("STACKGL_resize_drawingbuffer");
    if (ext && "width" in options && "height" in options) ext.resize(options.width, options.height);
}
function $f89b67ad8c6f5746$var$createBrowserContext(canvas, options) {
    const { onError: onError  } = options;
    let errorMessage = null;
    const onCreateError = (error)=>errorMessage = error.statusMessage || errorMessage;
    canvas.addEventListener("webglcontextcreationerror", onCreateError, false);
    const { webgl1: webgl1 = true , webgl2: webgl2 = true  } = options;
    let gl = null;
    if (webgl2) {
        gl = gl || canvas.getContext("webgl2", options);
        gl = gl || canvas.getContext("experimental-webgl2", options);
    }
    if (webgl1) {
        gl = gl || canvas.getContext("webgl", options);
        gl = gl || canvas.getContext("experimental-webgl", options);
    }
    canvas.removeEventListener("webglcontextcreationerror", onCreateError, false);
    if (!gl) return onError("Failed to create ".concat(webgl2 && !webgl1 ? "WebGL2" : "WebGL", " context: ").concat(errorMessage || "Unknown error"));
    if (options.onContextLost) canvas.addEventListener("webglcontextlost", options.onContextLost, false);
    if (options.onContextRestored) canvas.addEventListener("webglcontextrestored", options.onContextRestored, false);
    return gl;
}
function $f89b67ad8c6f5746$var$getCanvas(_ref) {
    let { canvas: canvas , width: width = 800 , height: height = 600 , onError: onError  } = _ref;
    let targetCanvas;
    if (typeof canvas === "string") {
        const isPageLoaded = $f89b67ad8c6f5746$var$isPage && document.readyState === "complete";
        if (!isPageLoaded) onError("createGLContext called on canvas '".concat(canvas, "' before page was loaded"));
        targetCanvas = document.getElementById(canvas);
    } else if (canvas) targetCanvas = canvas;
    else {
        targetCanvas = document.createElement("canvas");
        targetCanvas.id = "lumagl-canvas";
        targetCanvas.style.width = Number.isFinite(width) ? "".concat(width, "px") : "100%";
        targetCanvas.style.height = Number.isFinite(height) ? "".concat(height, "px") : "100%";
        document.body.insertBefore(targetCanvas, document.body.firstChild);
    }
    return targetCanvas;
}
function $f89b67ad8c6f5746$var$logInfo(gl) {
    const webGL = (0, $325e733792a03f4e$export$e3518b1ac7891039)(gl) ? "WebGL2" : "WebGL1";
    const info = $f89b67ad8c6f5746$export$6f15ab3b829c3189(gl);
    const driver = info ? "(".concat(info.vendor, ",").concat(info.renderer, ")") : "";
    const debug = gl.debug ? " debug" : "";
    (0, $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3).info(1, "".concat(webGL).concat(debug, " context ").concat(driver))();
}
function $f89b67ad8c6f5746$var$getVersion(gl) {
    if (typeof WebGL2RenderingContext !== "undefined" && gl instanceof WebGL2RenderingContext) return 2;
    return 1;
}
function $f89b67ad8c6f5746$var$setDevicePixelRatio(gl, devicePixelRatio, options) {
    let clientWidth = "width" in options ? options.width : gl.canvas.clientWidth;
    let clientHeight = "height" in options ? options.height : gl.canvas.clientHeight;
    if (!clientWidth || !clientHeight) {
        (0, $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3).log(1, "Canvas clientWidth/clientHeight is 0")();
        devicePixelRatio = 1;
        clientWidth = gl.canvas.width || 1;
        clientHeight = gl.canvas.height || 1;
    }
    gl.luma = gl.luma || {};
    gl.luma.canvasSizeInfo = gl.luma.canvasSizeInfo || {};
    const cachedSize = gl.luma.canvasSizeInfo;
    if (cachedSize.clientWidth !== clientWidth || cachedSize.clientHeight !== clientHeight || cachedSize.devicePixelRatio !== devicePixelRatio) {
        let clampedPixelRatio = devicePixelRatio;
        const canvasWidth = Math.floor(clientWidth * clampedPixelRatio);
        const canvasHeight = Math.floor(clientHeight * clampedPixelRatio);
        gl.canvas.width = canvasWidth;
        gl.canvas.height = canvasHeight;
        if (gl.drawingBufferWidth !== canvasWidth || gl.drawingBufferHeight !== canvasHeight) {
            (0, $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3).warn("Device pixel ratio clamped")();
            clampedPixelRatio = Math.min(gl.drawingBufferWidth / clientWidth, gl.drawingBufferHeight / clientHeight);
            gl.canvas.width = Math.floor(clientWidth * clampedPixelRatio);
            gl.canvas.height = Math.floor(clientHeight * clampedPixelRatio);
        }
        Object.assign(gl.luma.canvasSizeInfo, {
            clientWidth: clientWidth,
            clientHeight: clientHeight,
            devicePixelRatio: devicePixelRatio
        });
    }
}








function $bf567bf995a1ec07$export$2e2bcd8739ae039() {
    let timestamp;
    if (typeof window !== "undefined" && window.performance) timestamp = window.performance.now();
    else if (typeof $7jljs$process !== "undefined" && $7jljs$process.hrtime) {
        const timeParts = $7jljs$process.hrtime();
        timestamp = timeParts[0] * 1000 + timeParts[1] / 1e6;
    } else timestamp = Date.now();
    return timestamp;
}


class $c4430e0424ce29bf$export$2e2bcd8739ae039 {
    constructor(name, type){
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "name", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "type", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "sampleSize", 1);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "time", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "count", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "samples", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "lastTiming", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "lastSampleTime", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "lastSampleCount", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_count", 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_time", 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_samples", 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_startTime", 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_timerPending", false);
        this.name = name;
        this.type = type;
        this.reset();
    }
    setSampleSize(samples) {
        this.sampleSize = samples;
        return this;
    }
    incrementCount() {
        this.addCount(1);
        return this;
    }
    decrementCount() {
        this.subtractCount(1);
        return this;
    }
    addCount(value) {
        this._count += value;
        this._samples++;
        this._checkSampling();
        return this;
    }
    subtractCount(value) {
        this._count -= value;
        this._samples++;
        this._checkSampling();
        return this;
    }
    addTime(time) {
        this._time += time;
        this.lastTiming = time;
        this._samples++;
        this._checkSampling();
        return this;
    }
    timeStart() {
        this._startTime = (0, $bf567bf995a1ec07$export$2e2bcd8739ae039)();
        this._timerPending = true;
        return this;
    }
    timeEnd() {
        if (!this._timerPending) return this;
        this.addTime((0, $bf567bf995a1ec07$export$2e2bcd8739ae039)() - this._startTime);
        this._timerPending = false;
        this._checkSampling();
        return this;
    }
    getSampleAverageCount() {
        return this.sampleSize > 0 ? this.lastSampleCount / this.sampleSize : 0;
    }
    getSampleAverageTime() {
        return this.sampleSize > 0 ? this.lastSampleTime / this.sampleSize : 0;
    }
    getSampleHz() {
        return this.lastSampleTime > 0 ? this.sampleSize / (this.lastSampleTime / 1000) : 0;
    }
    getAverageCount() {
        return this.samples > 0 ? this.count / this.samples : 0;
    }
    getAverageTime() {
        return this.samples > 0 ? this.time / this.samples : 0;
    }
    getHz() {
        return this.time > 0 ? this.samples / (this.time / 1000) : 0;
    }
    reset() {
        this.time = 0;
        this.count = 0;
        this.samples = 0;
        this.lastTiming = 0;
        this.lastSampleTime = 0;
        this.lastSampleCount = 0;
        this._count = 0;
        this._time = 0;
        this._samples = 0;
        this._startTime = 0;
        this._timerPending = false;
        return this;
    }
    _checkSampling() {
        if (this._samples === this.sampleSize) {
            this.lastSampleTime = this._time;
            this.lastSampleCount = this._count;
            this.count += this._count;
            this.time += this._time;
            this.samples += this._samples;
            this._time = 0;
            this._count = 0;
            this._samples = 0;
        }
    }
}


class $2fb061cfbc5cb32d$export$2e2bcd8739ae039 {
    constructor(options){
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "id", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "stats", {});
        this.id = options.id;
        this.stats = {};
        this._initializeStats(options.stats);
        Object.seal(this);
    }
    get(name) {
        let type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "count";
        return this._getOrCreate({
            name: name,
            type: type
        });
    }
    get size() {
        return Object.keys(this.stats).length;
    }
    reset() {
        for(const key in this.stats)this.stats[key].reset();
        return this;
    }
    forEach(fn) {
        for(const key in this.stats)fn(this.stats[key]);
    }
    getTable() {
        const table = {};
        this.forEach((stat)=>{
            table[stat.name] = {
                time: stat.time || 0,
                count: stat.count || 0,
                average: stat.getAverageTime() || 0,
                hz: stat.getHz() || 0
            };
        });
        return table;
    }
    _initializeStats() {
        let stats = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
        stats.forEach((stat)=>this._getOrCreate(stat));
    }
    _getOrCreate(stat) {
        if (!stat || !stat.name) return null;
        const { name: name , type: type  } = stat;
        if (!this.stats[name]) {
            if (stat instanceof (0, $c4430e0424ce29bf$export$2e2bcd8739ae039)) this.stats[name] = stat;
            else this.stats[name] = new (0, $c4430e0424ce29bf$export$2e2bcd8739ae039)(name, type);
        }
        return this.stats[name];
    }
}







const $0a3fbec7776af5cb$var$VERSION = "8.5.16";
const $0a3fbec7776af5cb$var$STARTUP_MESSAGE = "set luma.log.level=1 (or higher) to trace rendering";
class $0a3fbec7776af5cb$export$a763db1752b80c33 {
    constructor(){
        this.stats = new Map();
    }
    get(name) {
        if (!this.stats.has(name)) this.stats.set(name, new (0, $2fb061cfbc5cb32d$export$2e2bcd8739ae039)({
            id: name
        }));
        return this.stats.get(name);
    }
}
const $0a3fbec7776af5cb$export$fb95d6e12d0fb414 = new $0a3fbec7776af5cb$export$a763db1752b80c33();
if (globalThis.luma && globalThis.luma.VERSION !== $0a3fbec7776af5cb$var$VERSION) throw new Error("luma.gl - multiple VERSIONs detected: ".concat(globalThis.luma.VERSION, " vs ").concat($0a3fbec7776af5cb$var$VERSION));
if (!globalThis.luma) {
    if ((0, $58cc8c917413a7dc$export$2e2bcd8739ae039)()) (0, $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3).log(1, "luma.gl ".concat($0a3fbec7776af5cb$var$VERSION, " - ").concat($0a3fbec7776af5cb$var$STARTUP_MESSAGE))();
    globalThis.luma = globalThis.luma || {
        VERSION: $0a3fbec7776af5cb$var$VERSION,
        version: $0a3fbec7776af5cb$var$VERSION,
        log: $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3,
        stats: $0a3fbec7776af5cb$export$fb95d6e12d0fb414,
        globals: {
            modules: {},
            nodeIO: {}
        }
    };
}
var $0a3fbec7776af5cb$export$2e2bcd8739ae039 = globalThis.luma;

function $cb3c1c602b31e96d$export$6cb2c4c0a22909c0(callback) {
    return typeof window !== "undefined" && window.requestAnimationFrame ? window.requestAnimationFrame(callback) : setTimeout(callback, 1000 / 60);
}
function $cb3c1c602b31e96d$export$e00521de187a817a(timerId) {
    return typeof window !== "undefined" && window.cancelAnimationFrame ? window.cancelAnimationFrame(timerId) : clearTimeout(timerId);
}





function $fc8ccbf4aa55ce20$export$a7a9523472993e97(condition, message) {
    if (!condition) throw new Error(message || "luma.gl: assertion failed.");
}


function $d2f1571231f3f4d0$export$38eb86f225c9e34c(gl, name) {
    if (typeof name !== "string") return name;
    const number = Number(name);
    if (!isNaN(number)) return number;
    name = name.replace(/^.*\./, "");
    const value = gl[name];
    (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(value !== undefined, "Accessing undefined constant GL.".concat(name));
    return value;
}
function $d2f1571231f3f4d0$export$a47fb462a08de82f(gl, value) {
    value = Number(value);
    for(const key in gl){
        if (gl[key] === value) return "GL.".concat(key);
    }
    return String(value);
}
function $d2f1571231f3f4d0$export$7869d83d4284f7ff(gl, value) {
    (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(value !== undefined, "undefined key");
    value = Number(value);
    for(const key in gl){
        if (gl[key] === value) return "GL.".concat(key);
    }
    return String(value);
}




const $757dc76705f498e6$var$uidCounters = {};
function $757dc76705f498e6$export$e2a22331486dcca0() {
    let id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "id";
    $757dc76705f498e6$var$uidCounters[id] = $757dc76705f498e6$var$uidCounters[id] || 1;
    const count = $757dc76705f498e6$var$uidCounters[id]++;
    return "".concat(id, "-").concat(count);
}
function $757dc76705f498e6$export$b9e43d1765415474(n) {
    (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(typeof n === "number", "Input must be a number");
    return n && (n & n - 1) === 0;
}
function $757dc76705f498e6$export$23cfe696632d10f4(obj) {
    let isEmpty = true;
    for(const key in obj){
        isEmpty = false;
        break;
    }
    return isEmpty;
}



function $cd105bc7922a3ca2$export$5c9302507afeb7af(instance, className, version, methodNames) {
    const upgradeMessage = "See luma.gl ".concat(version, " Upgrade Guide at https://luma.gl/docs/upgrade-guide");
    const prototype = Object.getPrototypeOf(instance);
    methodNames.forEach((methodName)=>{
        if (prototype.methodName) return;
        prototype[methodName] = ()=>{
            (0, $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3).removed("Calling removed method ".concat(className, ".").concat(methodName, ": "), upgradeMessage)();
            throw new Error(methodName);
        };
    });
}


const $dabe379caebdf3da$var$ERR_RESOURCE_METHOD_UNDEFINED = "Resource subclass must define virtual methods";
class $dabe379caebdf3da$export$2e2bcd8739ae039 {
    get [Symbol.toStringTag]() {
        return "Resource";
    }
    constructor(gl){
        let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        (0, $325e733792a03f4e$export$9b0605fd3c935712)(gl);
        const { id: id , userData: userData = {}  } = opts;
        this.gl = gl;
        this.gl2 = gl;
        this.id = id || (0, $757dc76705f498e6$export$e2a22331486dcca0)(this[Symbol.toStringTag]);
        this.userData = userData;
        this._bound = false;
        this._handle = opts.handle;
        if (this._handle === undefined) this._handle = this._createHandle();
        this.byteLength = 0;
        this._initStats();
        this._addStats();
    }
    toString() {
        return "".concat(this[Symbol.toStringTag] || this.constructor.name, "(").concat(this.id, ")");
    }
    get handle() {
        return this._handle;
    }
    delete() {
        let { deleteChildren: deleteChildren = false  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        const children = this._handle && this._deleteHandle(this._handle);
        if (this._handle) this._removeStats();
        this._handle = null;
        if (children && deleteChildren) children.filter(Boolean).forEach((child)=>child.delete());
        return this;
    }
    bind() {
        let funcOrHandle = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.handle;
        if (typeof funcOrHandle !== "function") {
            this._bindHandle(funcOrHandle);
            return this;
        }
        let value;
        if (!this._bound) {
            this._bindHandle(this.handle);
            this._bound = true;
            value = funcOrHandle();
            this._bound = false;
            this._bindHandle(null);
        } else value = funcOrHandle();
        return value;
    }
    unbind() {
        this.bind(null);
    }
    getParameter(pname) {
        let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        pname = (0, $d2f1571231f3f4d0$export$38eb86f225c9e34c)(this.gl, pname);
        (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(pname);
        const parameters = this.constructor.PARAMETERS || {};
        const parameter = parameters[pname];
        if (parameter) {
            const isWebgl2 = (0, $325e733792a03f4e$export$e3518b1ac7891039)(this.gl);
            const parameterAvailable = (!("webgl2" in parameter) || isWebgl2) && (!("extension" in parameter) || this.gl.getExtension(parameter.extension));
            if (!parameterAvailable) {
                const webgl1Default = parameter.webgl1;
                const webgl2Default = "webgl2" in parameter ? parameter.webgl2 : parameter.webgl1;
                const defaultValue = isWebgl2 ? webgl2Default : webgl1Default;
                return defaultValue;
            }
        }
        return this._getParameter(pname, opts);
    }
    getParameters() {
        let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        const { parameters: parameters , keys: keys  } = options;
        const PARAMETERS = this.constructor.PARAMETERS || {};
        const isWebgl2 = (0, $325e733792a03f4e$export$e3518b1ac7891039)(this.gl);
        const values = {};
        const parameterKeys = parameters || Object.keys(PARAMETERS);
        for (const pname of parameterKeys){
            const parameter = PARAMETERS[pname];
            const parameterAvailable = parameter && (!("webgl2" in parameter) || isWebgl2) && (!("extension" in parameter) || this.gl.getExtension(parameter.extension));
            if (parameterAvailable) {
                const key = keys ? (0, $d2f1571231f3f4d0$export$a47fb462a08de82f)(this.gl, pname) : pname;
                values[key] = this.getParameter(pname, options);
                if (keys && parameter.type === "GLenum") values[key] = (0, $d2f1571231f3f4d0$export$a47fb462a08de82f)(this.gl, values[key]);
            }
        }
        return values;
    }
    setParameter(pname, value) {
        pname = (0, $d2f1571231f3f4d0$export$38eb86f225c9e34c)(this.gl, pname);
        (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(pname);
        const parameters = this.constructor.PARAMETERS || {};
        const parameter = parameters[pname];
        if (parameter) {
            const isWebgl2 = (0, $325e733792a03f4e$export$e3518b1ac7891039)(this.gl);
            const parameterAvailable = (!("webgl2" in parameter) || isWebgl2) && (!("extension" in parameter) || this.gl.getExtension(parameter.extension));
            if (!parameterAvailable) throw new Error("Parameter not available on this platform");
            if (parameter.type === "GLenum") value = (0, $d2f1571231f3f4d0$export$38eb86f225c9e34c)(value);
        }
        this._setParameter(pname, value);
        return this;
    }
    setParameters(parameters) {
        for(const pname in parameters)this.setParameter(pname, parameters[pname]);
        return this;
    }
    stubRemovedMethods(className, version, methodNames) {
        return (0, $cd105bc7922a3ca2$export$5c9302507afeb7af)(this, className, version, methodNames);
    }
    initialize(opts) {}
    _createHandle() {
        throw new Error($dabe379caebdf3da$var$ERR_RESOURCE_METHOD_UNDEFINED);
    }
    _deleteHandle() {
        throw new Error($dabe379caebdf3da$var$ERR_RESOURCE_METHOD_UNDEFINED);
    }
    _bindHandle(handle) {
        throw new Error($dabe379caebdf3da$var$ERR_RESOURCE_METHOD_UNDEFINED);
    }
    _getOptsFromHandle() {
        throw new Error($dabe379caebdf3da$var$ERR_RESOURCE_METHOD_UNDEFINED);
    }
    _getParameter(pname, opts) {
        throw new Error($dabe379caebdf3da$var$ERR_RESOURCE_METHOD_UNDEFINED);
    }
    _setParameter(pname, value) {
        throw new Error($dabe379caebdf3da$var$ERR_RESOURCE_METHOD_UNDEFINED);
    }
    _context() {
        this.gl.luma = this.gl.luma || {};
        return this.gl.luma;
    }
    _initStats() {
        this.gl.stats = this.gl.stats || new (0, $0a3fbec7776af5cb$export$a763db1752b80c33)();
    }
    _addStats() {
        const name = this[Symbol.toStringTag];
        const stats = (0, $0a3fbec7776af5cb$export$fb95d6e12d0fb414).get("Resource Counts");
        stats.get("Resources Created").incrementCount();
        stats.get("".concat(name, "s Created")).incrementCount();
        stats.get("".concat(name, "s Active")).incrementCount();
    }
    _removeStats() {
        const name = this[Symbol.toStringTag];
        const stats = (0, $0a3fbec7776af5cb$export$fb95d6e12d0fb414).get("Resource Counts");
        stats.get("".concat(name, "s Active")).decrementCount();
    }
    _trackAllocatedMemory(bytes) {
        let name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this[Symbol.toStringTag];
        this._doTrackAllocatedMemory(bytes, name);
        this._doTrackAllocatedMemory(bytes, name, this.gl.stats.get("Memory Usage"));
    }
    _doTrackAllocatedMemory(bytes) {
        let name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this[Symbol.toStringTag];
        let stats = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : (0, $0a3fbec7776af5cb$export$fb95d6e12d0fb414).get("Memory Usage");
        stats.get("GPU Memory").addCount(bytes);
        stats.get("".concat(name, " Memory")).addCount(bytes);
        this.byteLength = bytes;
    }
    _trackDeallocatedMemory() {
        let name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this[Symbol.toStringTag];
        this._doTrackDeallocatedMemory(name);
        this._doTrackDeallocatedMemory(name, this.gl.stats.get("Memory Usage"));
    }
    _doTrackDeallocatedMemory() {
        let name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this[Symbol.toStringTag];
        let stats = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : (0, $0a3fbec7776af5cb$export$fb95d6e12d0fb414).get("Memory Usage");
        stats.get("GPU Memory").subtractCount(this.byteLength);
        stats.get("".concat(name, " Memory")).subtractCount(this.byteLength);
        this.byteLength = 0;
    }
}



const $eee37e63e18ddcdf$var$ERR_TYPE_DEDUCTION = "Failed to deduce GL constant from typed array";
function $eee37e63e18ddcdf$export$127239b7f8a5750f(arrayOrType) {
    const type = ArrayBuffer.isView(arrayOrType) ? arrayOrType.constructor : arrayOrType;
    switch(type){
        case Float32Array:
            return 5126;
        case Uint16Array:
            return 5123;
        case Uint32Array:
            return 5125;
        case Uint8Array:
            return 5121;
        case Uint8ClampedArray:
            return 5121;
        case Int8Array:
            return 5120;
        case Int16Array:
            return 5122;
        case Int32Array:
            return 5124;
        default:
            throw new Error($eee37e63e18ddcdf$var$ERR_TYPE_DEDUCTION);
    }
}
function $eee37e63e18ddcdf$export$9619a05b47814a85(glType) {
    let { clamped: clamped = true  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    switch(glType){
        case 5126:
            return Float32Array;
        case 5123:
        case 33635:
        case 32819:
        case 32820:
            return Uint16Array;
        case 5125:
            return Uint32Array;
        case 5121:
            return clamped ? Uint8ClampedArray : Uint8Array;
        case 5120:
            return Int8Array;
        case 5122:
            return Int16Array;
        case 5124:
            return Int32Array;
        default:
            throw new Error("Failed to deduce typed array type from GL constant");
    }
}
function $eee37e63e18ddcdf$export$2478197380c2212f(_ref) {
    let { data: data , width: width , height: height , bytesPerPixel: bytesPerPixel = 4 , temp: temp  } = _ref;
    const bytesPerRow = width * bytesPerPixel;
    temp = temp || new Uint8Array(bytesPerRow);
    for(let y = 0; y < height / 2; ++y){
        const topOffset = y * bytesPerRow;
        const bottomOffset = (height - y - 1) * bytesPerRow;
        temp.set(data.subarray(topOffset, topOffset + bytesPerRow));
        data.copyWithin(topOffset, bottomOffset, bottomOffset + bytesPerRow);
        data.set(temp, bottomOffset);
    }
}
function $eee37e63e18ddcdf$export$b405024b493a473f(_ref2) {
    let { data: data , width: width , height: height  } = _ref2;
    const newWidth = Math.round(width / 2);
    const newHeight = Math.round(height / 2);
    const newData = new Uint8Array(newWidth * newHeight * 4);
    for(let y = 0; y < newHeight; y++){
        for(let x = 0; x < newWidth; x++)for(let c = 0; c < 4; c++)newData[(y * newWidth + x) * 4 + c] = data[(y * 2 * width + x * 2) * 4 + c];
    }
    return {
        data: newData,
        width: newWidth,
        height: newHeight
    };
}




function $91dad1923f57789f$export$aac163a490409890(className, props, propChecks) {
    const { removedProps: removedProps = {} , deprecatedProps: deprecatedProps = {} , replacedProps: replacedProps = {}  } = propChecks;
    for(const propName in removedProps)if (propName in props) {
        const replacementProp = removedProps[propName];
        const replacement = replacementProp ? "".concat(className, ".").concat(removedProps[propName]) : "N/A";
        (0, $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3).removed("".concat(className, ".").concat(propName), replacement)();
    }
    for(const propName1 in deprecatedProps)if (propName1 in props) {
        const replacementProp = deprecatedProps[propName1];
        (0, $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3).deprecated("".concat(className, ".").concat(propName1), "".concat(className, ".").concat(replacementProp))();
    }
    let newProps = null;
    for(const propName2 in replacedProps)if (propName2 in props) {
        const replacementProp = replacedProps[propName2];
        (0, $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3).deprecated("".concat(className, ".").concat(propName2), "".concat(className, ".").concat(replacementProp))();
        newProps = newProps || Object.assign({}, props);
        newProps[replacementProp] = props[propName2];
        delete newProps[propName2];
    }
    return newProps || props;
}


const $905df3b590d61c61$export$e62d85e07017bac6 = {
    offset: 0,
    stride: 0,
    type: 5126,
    size: 1,
    divisor: 0,
    normalized: false,
    integer: false
};
const $905df3b590d61c61$var$PROP_CHECKS = {
    deprecatedProps: {
        instanced: "divisor",
        isInstanced: "divisor"
    }
};
class $905df3b590d61c61$export$2e2bcd8739ae039 {
    static getBytesPerElement(accessor) {
        const ArrayType = (0, $eee37e63e18ddcdf$export$9619a05b47814a85)(accessor.type || 5126);
        return ArrayType.BYTES_PER_ELEMENT;
    }
    static getBytesPerVertex(accessor) {
        (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(accessor.size);
        const ArrayType = (0, $eee37e63e18ddcdf$export$9619a05b47814a85)(accessor.type || 5126);
        return ArrayType.BYTES_PER_ELEMENT * accessor.size;
    }
    static resolve() {
        for(var _len = arguments.length, accessors = new Array(_len), _key = 0; _key < _len; _key++)accessors[_key] = arguments[_key];
        return new $905df3b590d61c61$export$2e2bcd8739ae039(...[
            $905df3b590d61c61$export$e62d85e07017bac6,
            ...accessors
        ]);
    }
    constructor(){
        for(var _len2 = arguments.length, accessors = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++)accessors[_key2] = arguments[_key2];
        accessors.forEach((accessor)=>this._assign(accessor));
        Object.freeze(this);
    }
    toString() {
        return JSON.stringify(this);
    }
    get BYTES_PER_ELEMENT() {
        return $905df3b590d61c61$export$2e2bcd8739ae039.getBytesPerElement(this);
    }
    get BYTES_PER_VERTEX() {
        return $905df3b590d61c61$export$2e2bcd8739ae039.getBytesPerVertex(this);
    }
    _assign() {
        let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        props = (0, $91dad1923f57789f$export$aac163a490409890)("Accessor", props, $905df3b590d61c61$var$PROP_CHECKS);
        if (props.type !== undefined) {
            this.type = props.type;
            if (props.type === 5124 || props.type === 5125) this.integer = true;
        }
        if (props.size !== undefined) this.size = props.size;
        if (props.offset !== undefined) this.offset = props.offset;
        if (props.stride !== undefined) this.stride = props.stride;
        if (props.normalized !== undefined) this.normalized = props.normalized;
        if (props.integer !== undefined) this.integer = props.integer;
        if (props.divisor !== undefined) this.divisor = props.divisor;
        if (props.buffer !== undefined) this.buffer = props.buffer;
        if (props.index !== undefined) {
            if (typeof props.index === "boolean") this.index = props.index ? 1 : 0;
            else this.index = props.index;
        }
        if (props.instanced !== undefined) this.divisor = props.instanced ? 1 : 0;
        if (props.isInstanced !== undefined) this.divisor = props.isInstanced ? 1 : 0;
        return this;
    }
}






const $28a69bf6d03705d1$var$DEBUG_DATA_LENGTH = 10;
const $28a69bf6d03705d1$var$DEPRECATED_PROPS = {
    offset: "accessor.offset",
    stride: "accessor.stride",
    type: "accessor.type",
    size: "accessor.size",
    divisor: "accessor.divisor",
    normalized: "accessor.normalized",
    integer: "accessor.integer",
    instanced: "accessor.divisor",
    isInstanced: "accessor.divisor"
};
const $28a69bf6d03705d1$var$PROP_CHECKS_INITIALIZE = {
    removedProps: {},
    replacedProps: {
        bytes: "byteLength"
    },
    deprecatedProps: $28a69bf6d03705d1$var$DEPRECATED_PROPS
};
const $28a69bf6d03705d1$var$PROP_CHECKS_SET_PROPS = {
    removedProps: $28a69bf6d03705d1$var$DEPRECATED_PROPS
};
class $28a69bf6d03705d1$export$2e2bcd8739ae039 extends (0, $dabe379caebdf3da$export$2e2bcd8739ae039) {
    get [Symbol.toStringTag]() {
        return "Buffer";
    }
    constructor(gl){
        let props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        super(gl, props);
        this.stubRemovedMethods("Buffer", "v6.0", [
            "layout",
            "setLayout",
            "getIndexedParameter"
        ]);
        this.target = props.target || (this.gl.webgl2 ? 36662 : 34962);
        this.initialize(props);
        Object.seal(this);
    }
    getElementCount() {
        let accessor = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.accessor;
        return Math.round(this.byteLength / (0, $905df3b590d61c61$export$2e2bcd8739ae039).getBytesPerElement(accessor));
    }
    getVertexCount() {
        let accessor = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.accessor;
        return Math.round(this.byteLength / (0, $905df3b590d61c61$export$2e2bcd8739ae039).getBytesPerVertex(accessor));
    }
    initialize() {
        let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        if (ArrayBuffer.isView(props)) props = {
            data: props
        };
        if (Number.isFinite(props)) props = {
            byteLength: props
        };
        props = (0, $91dad1923f57789f$export$aac163a490409890)("Buffer", props, $28a69bf6d03705d1$var$PROP_CHECKS_INITIALIZE);
        this.usage = props.usage || 35044;
        this.debugData = null;
        this.setAccessor(Object.assign({}, props, props.accessor));
        if (props.data) this._setData(props.data, props.offset, props.byteLength);
        else this._setByteLength(props.byteLength || 0);
        return this;
    }
    setProps(props) {
        props = (0, $91dad1923f57789f$export$aac163a490409890)("Buffer", props, $28a69bf6d03705d1$var$PROP_CHECKS_SET_PROPS);
        if ("accessor" in props) this.setAccessor(props.accessor);
        return this;
    }
    setAccessor(accessor) {
        accessor = Object.assign({}, accessor);
        delete accessor.buffer;
        this.accessor = new (0, $905df3b590d61c61$export$2e2bcd8739ae039)(accessor);
        return this;
    }
    reallocate(byteLength) {
        if (byteLength > this.byteLength) {
            this._setByteLength(byteLength);
            return true;
        }
        this.bytesUsed = byteLength;
        return false;
    }
    setData(props) {
        return this.initialize(props);
    }
    subData(props) {
        if (ArrayBuffer.isView(props)) props = {
            data: props
        };
        const { data: data , offset: offset = 0 , srcOffset: srcOffset = 0  } = props;
        const byteLength = props.byteLength || props.length;
        (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(data);
        const target = this.gl.webgl2 ? 36663 : this.target;
        this.gl.bindBuffer(target, this.handle);
        if (srcOffset !== 0 || byteLength !== undefined) {
            (0, $325e733792a03f4e$export$22897d77b4bb5316)(this.gl);
            this.gl.bufferSubData(this.target, offset, data, srcOffset, byteLength);
        } else this.gl.bufferSubData(target, offset, data);
        this.gl.bindBuffer(target, null);
        this.debugData = null;
        this._inferType(data);
        return this;
    }
    copyData(_ref) {
        let { sourceBuffer: sourceBuffer , readOffset: readOffset = 0 , writeOffset: writeOffset = 0 , size: size  } = _ref;
        const { gl: gl  } = this;
        (0, $325e733792a03f4e$export$22897d77b4bb5316)(gl);
        gl.bindBuffer(36662, sourceBuffer.handle);
        gl.bindBuffer(36663, this.handle);
        gl.copyBufferSubData(36662, 36663, readOffset, writeOffset, size);
        gl.bindBuffer(36662, null);
        gl.bindBuffer(36663, null);
        this.debugData = null;
        return this;
    }
    getData() {
        let { dstData: dstData = null , srcByteOffset: srcByteOffset = 0 , dstOffset: dstOffset = 0 , length: length = 0  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        (0, $325e733792a03f4e$export$22897d77b4bb5316)(this.gl);
        const ArrayType = (0, $eee37e63e18ddcdf$export$9619a05b47814a85)(this.accessor.type || 5126, {
            clamped: false
        });
        const sourceAvailableElementCount = this._getAvailableElementCount(srcByteOffset);
        const dstElementOffset = dstOffset;
        let dstAvailableElementCount;
        let dstElementCount;
        if (dstData) {
            dstElementCount = dstData.length;
            dstAvailableElementCount = dstElementCount - dstElementOffset;
        } else {
            dstAvailableElementCount = Math.min(sourceAvailableElementCount, length || sourceAvailableElementCount);
            dstElementCount = dstElementOffset + dstAvailableElementCount;
        }
        const copyElementCount = Math.min(sourceAvailableElementCount, dstAvailableElementCount);
        length = length || copyElementCount;
        (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(length <= copyElementCount);
        dstData = dstData || new ArrayType(dstElementCount);
        this.gl.bindBuffer(36662, this.handle);
        this.gl.getBufferSubData(36662, srcByteOffset, dstData, dstOffset, length);
        this.gl.bindBuffer(36662, null);
        return dstData;
    }
    bind() {
        let { target: target = this.target , index: index = this.accessor && this.accessor.index , offset: offset = 0 , size: size  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        if (target === 35345 || target === 35982) {
            if (size !== undefined) this.gl.bindBufferRange(target, index, this.handle, offset, size);
            else {
                (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(offset === 0);
                this.gl.bindBufferBase(target, index, this.handle);
            }
        } else this.gl.bindBuffer(target, this.handle);
        return this;
    }
    unbind() {
        let { target: target = this.target , index: index = this.accessor && this.accessor.index  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        const isIndexedBuffer = target === 35345 || target === 35982;
        if (isIndexedBuffer) this.gl.bindBufferBase(target, index, null);
        else this.gl.bindBuffer(target, null);
        return this;
    }
    getDebugData() {
        if (!this.debugData) {
            this.debugData = this.getData({
                length: Math.min($28a69bf6d03705d1$var$DEBUG_DATA_LENGTH, this.byteLength)
            });
            return {
                data: this.debugData,
                changed: true
            };
        }
        return {
            data: this.debugData,
            changed: false
        };
    }
    invalidateDebugData() {
        this.debugData = null;
    }
    _setData(data) {
        let offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        let byteLength = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : data.byteLength + offset;
        (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(ArrayBuffer.isView(data));
        this._trackDeallocatedMemory();
        const target = this._getTarget();
        this.gl.bindBuffer(target, this.handle);
        this.gl.bufferData(target, byteLength, this.usage);
        this.gl.bufferSubData(target, offset, data);
        this.gl.bindBuffer(target, null);
        this.debugData = data.slice(0, $28a69bf6d03705d1$var$DEBUG_DATA_LENGTH);
        this.bytesUsed = byteLength;
        this._trackAllocatedMemory(byteLength);
        const type = (0, $eee37e63e18ddcdf$export$127239b7f8a5750f)(data);
        (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(type);
        this.setAccessor(new (0, $905df3b590d61c61$export$2e2bcd8739ae039)(this.accessor, {
            type: type
        }));
        return this;
    }
    _setByteLength(byteLength) {
        let usage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.usage;
        (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(byteLength >= 0);
        this._trackDeallocatedMemory();
        let data = byteLength;
        if (byteLength === 0) data = new Float32Array(0);
        const target = this._getTarget();
        this.gl.bindBuffer(target, this.handle);
        this.gl.bufferData(target, data, usage);
        this.gl.bindBuffer(target, null);
        this.usage = usage;
        this.debugData = null;
        this.bytesUsed = byteLength;
        this._trackAllocatedMemory(byteLength);
        return this;
    }
    _getTarget() {
        return this.gl.webgl2 ? 36663 : this.target;
    }
    _getAvailableElementCount(srcByteOffset) {
        const ArrayType = (0, $eee37e63e18ddcdf$export$9619a05b47814a85)(this.accessor.type || 5126, {
            clamped: false
        });
        const sourceElementOffset = srcByteOffset / ArrayType.BYTES_PER_ELEMENT;
        return this.getElementCount() - sourceElementOffset;
    }
    _inferType(data) {
        if (!this.accessor.type) this.setAccessor(new (0, $905df3b590d61c61$export$2e2bcd8739ae039)(this.accessor, {
            type: (0, $eee37e63e18ddcdf$export$127239b7f8a5750f)(data)
        }));
    }
    _createHandle() {
        return this.gl.createBuffer();
    }
    _deleteHandle() {
        this.gl.deleteBuffer(this.handle);
        this._trackDeallocatedMemory();
    }
    _getParameter(pname) {
        this.gl.bindBuffer(this.target, this.handle);
        const value = this.gl.getBufferParameter(this.target, pname);
        this.gl.bindBuffer(this.target, null);
        return value;
    }
    get type() {
        (0, $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3).deprecated("Buffer.type", "Buffer.accessor.type")();
        return this.accessor.type;
    }
    get bytes() {
        (0, $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3).deprecated("Buffer.bytes", "Buffer.byteLength")();
        return this.byteLength;
    }
    setByteLength(byteLength) {
        (0, $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3).deprecated("setByteLength", "reallocate")();
        return this.reallocate(byteLength);
    }
    updateAccessor(opts) {
        (0, $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3).deprecated("updateAccessor(...)", "setAccessor(new Accessor(buffer.accessor, ...)")();
        this.accessor = new (0, $905df3b590d61c61$export$2e2bcd8739ae039)(this.accessor, opts);
        return this;
    }
}



const $7e79c6e30bc6943f$export$ff6ccd50a74e6c72 = {
    [6407]: {
        dataFormat: 6407,
        types: [
            5121,
            33635
        ]
    },
    [6408]: {
        dataFormat: 6408,
        types: [
            5121,
            32819,
            32820
        ]
    },
    [6406]: {
        dataFormat: 6406,
        types: [
            5121
        ]
    },
    [6409]: {
        dataFormat: 6409,
        types: [
            5121
        ]
    },
    [6410]: {
        dataFormat: 6410,
        types: [
            5121
        ]
    },
    [33326]: {
        dataFormat: 6403,
        types: [
            5126
        ],
        gl2: true
    },
    [33328]: {
        dataFormat: 33319,
        types: [
            5126
        ],
        gl2: true
    },
    [34837]: {
        dataFormat: 6407,
        types: [
            5126
        ],
        gl2: true
    },
    [34836]: {
        dataFormat: 6408,
        types: [
            5126
        ],
        gl2: true
    }
};
const $7e79c6e30bc6943f$export$1b400e62d2e54950 = {
    [6403]: 1,
    [36244]: 1,
    [33319]: 2,
    [33320]: 2,
    [6407]: 3,
    [36248]: 3,
    [6408]: 4,
    [36249]: 4,
    [6402]: 1,
    [34041]: 1,
    [6406]: 1,
    [6409]: 1,
    [6410]: 2
};
const $7e79c6e30bc6943f$export$9acf869cba30dad8 = {
    [5126]: 4,
    [5125]: 4,
    [5124]: 4,
    [5123]: 2,
    [5122]: 2,
    [5131]: 2,
    [5120]: 1,
    [5121]: 1
};
function $7e79c6e30bc6943f$export$a3bf67278d0a9114(gl, format) {
    const info = $7e79c6e30bc6943f$export$ff6ccd50a74e6c72[format];
    if (!info) return false;
    if (info.gl1 === undefined && info.gl2 === undefined) return true;
    const value = (0, $325e733792a03f4e$export$e3518b1ac7891039)(gl) ? info.gl2 || info.gl1 : info.gl1;
    return typeof value === "string" ? gl.getExtension(value) : value;
}
function $7e79c6e30bc6943f$export$769628e6c078fe4c(gl, format) {
    const info = $7e79c6e30bc6943f$export$ff6ccd50a74e6c72[format];
    switch(info && info.types[0]){
        case 5126:
            return gl.getExtension("OES_texture_float_linear");
        case 5131:
            return gl.getExtension("OES_texture_half_float_linear");
        default:
            return true;
    }
}




const $541c007d64b391ad$var$NPOT_MIN_FILTERS = [
    9729,
    9728
];
const $541c007d64b391ad$var$WebGLBuffer = globalThis.WebGLBuffer || function WebGLBuffer() {};
class $541c007d64b391ad$export$2e2bcd8739ae039 extends (0, $dabe379caebdf3da$export$2e2bcd8739ae039) {
    get [Symbol.toStringTag]() {
        return "Texture";
    }
    static isSupported(gl) {
        let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        const { format: format , linearFiltering: linearFiltering  } = opts;
        let supported = true;
        if (format) {
            supported = supported && (0, $7e79c6e30bc6943f$export$a3bf67278d0a9114)(gl, format);
            supported = supported && (!linearFiltering || (0, $7e79c6e30bc6943f$export$769628e6c078fe4c)(gl, format));
        }
        return supported;
    }
    constructor(gl, props){
        const { id: id = (0, $757dc76705f498e6$export$e2a22331486dcca0)("texture") , handle: handle , target: target  } = props;
        super(gl, {
            id: id,
            handle: handle
        });
        this.target = target;
        this.textureUnit = undefined;
        this.loaded = false;
        this.width = undefined;
        this.height = undefined;
        this.depth = undefined;
        this.format = undefined;
        this.type = undefined;
        this.dataFormat = undefined;
        this.border = undefined;
        this.textureUnit = undefined;
        this.mipmaps = undefined;
    }
    toString() {
        return "Texture(".concat(this.id, ",").concat(this.width, "x").concat(this.height, ")");
    }
    initialize() {
        let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        let data = props.data;
        if (data instanceof Promise) {
            data.then((resolvedImageData)=>this.initialize(Object.assign({}, props, {
                    pixels: resolvedImageData,
                    data: resolvedImageData
                })));
            return this;
        }
        const isVideo = typeof HTMLVideoElement !== "undefined" && data instanceof HTMLVideoElement;
        if (isVideo && data.readyState < HTMLVideoElement.HAVE_METADATA) {
            this._video = null;
            data.addEventListener("loadeddata", ()=>this.initialize(props));
            return this;
        }
        const { pixels: pixels = null , format: format = 6408 , border: border = 0 , recreate: recreate = false , parameters: parameters = {} , pixelStore: pixelStore = {} , textureUnit: textureUnit  } = props;
        if (!data) data = pixels;
        let { width: width , height: height , dataFormat: dataFormat , type: type , compressed: compressed = false , mipmaps: mipmaps = true  } = props;
        const { depth: depth = 0  } = props;
        ({ width: width , height: height , compressed: compressed , dataFormat: dataFormat , type: type  } = this._deduceParameters({
            format: format,
            type: type,
            dataFormat: dataFormat,
            compressed: compressed,
            data: data,
            width: width,
            height: height
        }));
        this.width = width;
        this.height = height;
        this.depth = depth;
        this.format = format;
        this.type = type;
        this.dataFormat = dataFormat;
        this.border = border;
        this.textureUnit = textureUnit;
        if (Number.isFinite(this.textureUnit)) {
            this.gl.activeTexture(33984 + this.textureUnit);
            this.gl.bindTexture(this.target, this.handle);
        }
        if (mipmaps && this._isNPOT()) {
            (0, $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3).warn("texture: ".concat(this, " is Non-Power-Of-Two, disabling mipmaping"))();
            mipmaps = false;
            this._updateForNPOT(parameters);
        }
        this.mipmaps = mipmaps;
        this.setImageData({
            data: data,
            width: width,
            height: height,
            depth: depth,
            format: format,
            type: type,
            dataFormat: dataFormat,
            border: border,
            mipmaps: mipmaps,
            parameters: pixelStore,
            compressed: compressed
        });
        if (mipmaps) this.generateMipmap();
        this.setParameters(parameters);
        if (recreate) this.data = data;
        if (isVideo) this._video = {
            video: data,
            parameters: parameters,
            lastTime: data.readyState >= HTMLVideoElement.HAVE_CURRENT_DATA ? data.currentTime : -1
        };
        return this;
    }
    update() {
        if (this._video) {
            const { video: video , parameters: parameters , lastTime: lastTime  } = this._video;
            if (lastTime === video.currentTime || video.readyState < HTMLVideoElement.HAVE_CURRENT_DATA) return;
            this.setSubImageData({
                data: video,
                parameters: parameters
            });
            if (this.mipmaps) this.generateMipmap();
            this._video.lastTime = video.currentTime;
        }
    }
    resize(_ref) {
        let { height: height , width: width , mipmaps: mipmaps = false  } = _ref;
        if (width !== this.width || height !== this.height) return this.initialize({
            width: width,
            height: height,
            format: this.format,
            type: this.type,
            dataFormat: this.dataFormat,
            border: this.border,
            mipmaps: mipmaps
        });
        return this;
    }
    generateMipmap() {
        let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        if (this._isNPOT()) {
            (0, $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3).warn("texture: ".concat(this, " is Non-Power-Of-Two, disabling mipmaping"))();
            return this;
        }
        this.mipmaps = true;
        this.gl.bindTexture(this.target, this.handle);
        (0, $54220aa8b6471f1a$export$b1e7058a2936b651)(this.gl, params, ()=>{
            this.gl.generateMipmap(this.target);
        });
        this.gl.bindTexture(this.target, null);
        return this;
    }
    setImageData(options) {
        this._trackDeallocatedMemory("Texture");
        const { target: target = this.target , pixels: pixels = null , level: level = 0 , format: format = this.format , border: border = this.border , offset: offset = 0 , parameters: parameters = {}  } = options;
        let { data: data = null , type: type = this.type , width: width = this.width , height: height = this.height , dataFormat: dataFormat = this.dataFormat , compressed: compressed = false  } = options;
        if (!data) data = pixels;
        ({ type: type , dataFormat: dataFormat , compressed: compressed , width: width , height: height  } = this._deduceParameters({
            format: format,
            type: type,
            dataFormat: dataFormat,
            compressed: compressed,
            data: data,
            width: width,
            height: height
        }));
        const { gl: gl  } = this;
        gl.bindTexture(this.target, this.handle);
        let dataType = null;
        ({ data: data , dataType: dataType  } = this._getDataType({
            data: data,
            compressed: compressed
        }));
        let gl2;
        let compressedTextureSize = 0;
        (0, $54220aa8b6471f1a$export$b1e7058a2936b651)(this.gl, parameters, ()=>{
            switch(dataType){
                case "null":
                    gl.texImage2D(target, level, format, width, height, border, dataFormat, type, data);
                    break;
                case "typed-array":
                    gl.texImage2D(target, level, format, width, height, border, dataFormat, type, data, offset);
                    break;
                case "buffer":
                    gl2 = (0, $325e733792a03f4e$export$22897d77b4bb5316)(gl);
                    gl2.bindBuffer(35052, data.handle || data);
                    gl2.texImage2D(target, level, format, width, height, border, dataFormat, type, offset);
                    gl2.bindBuffer(35052, null);
                    break;
                case "browser-object":
                    if ((0, $325e733792a03f4e$export$e3518b1ac7891039)(gl)) gl.texImage2D(target, level, format, width, height, border, dataFormat, type, data);
                    else gl.texImage2D(target, level, format, dataFormat, type, data);
                    break;
                case "compressed":
                    for (const [levelIndex, levelData] of data.entries()){
                        gl.compressedTexImage2D(target, levelIndex, levelData.format, levelData.width, levelData.height, border, levelData.data);
                        compressedTextureSize += levelData.levelSize;
                    }
                    break;
                default:
                    (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(false, "Unknown image data type");
            }
        });
        if (dataType === "compressed") this._trackAllocatedMemory(compressedTextureSize, "Texture");
        else if (data && data.byteLength) this._trackAllocatedMemory(data.byteLength, "Texture");
        else {
            const channels = (0, $7e79c6e30bc6943f$export$1b400e62d2e54950)[this.dataFormat] || 4;
            const channelSize = (0, $7e79c6e30bc6943f$export$9acf869cba30dad8)[this.type] || 1;
            this._trackAllocatedMemory(this.width * this.height * channels * channelSize, "Texture");
        }
        this.loaded = true;
        return this;
    }
    setSubImageData(_ref2) {
        let { target: target = this.target , pixels: pixels = null , data: data = null , x: x = 0 , y: y = 0 , width: width = this.width , height: height = this.height , level: level = 0 , format: format = this.format , type: type = this.type , dataFormat: dataFormat = this.dataFormat , compressed: compressed = false , offset: offset = 0 , border: border = this.border , parameters: parameters = {}  } = _ref2;
        ({ type: type , dataFormat: dataFormat , compressed: compressed , width: width , height: height  } = this._deduceParameters({
            format: format,
            type: type,
            dataFormat: dataFormat,
            compressed: compressed,
            data: data,
            width: width,
            height: height
        }));
        (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(this.depth === 0, "texSubImage not supported for 3D textures");
        if (!data) data = pixels;
        if (data && data.data) {
            const ndarray = data;
            data = ndarray.data;
            width = ndarray.shape[0];
            height = ndarray.shape[1];
        }
        if (data instanceof (0, $28a69bf6d03705d1$export$2e2bcd8739ae039)) data = data.handle;
        this.gl.bindTexture(this.target, this.handle);
        (0, $54220aa8b6471f1a$export$b1e7058a2936b651)(this.gl, parameters, ()=>{
            if (compressed) this.gl.compressedTexSubImage2D(target, level, x, y, width, height, format, data);
            else if (data === null) this.gl.texSubImage2D(target, level, x, y, width, height, dataFormat, type, null);
            else if (ArrayBuffer.isView(data)) this.gl.texSubImage2D(target, level, x, y, width, height, dataFormat, type, data, offset);
            else if (data instanceof $541c007d64b391ad$var$WebGLBuffer) {
                const gl2 = (0, $325e733792a03f4e$export$22897d77b4bb5316)(this.gl);
                gl2.bindBuffer(35052, data);
                gl2.texSubImage2D(target, level, x, y, width, height, dataFormat, type, offset);
                gl2.bindBuffer(35052, null);
            } else if ((0, $325e733792a03f4e$export$e3518b1ac7891039)(this.gl)) {
                const gl2 = (0, $325e733792a03f4e$export$22897d77b4bb5316)(this.gl);
                gl2.texSubImage2D(target, level, x, y, width, height, dataFormat, type, data);
            } else this.gl.texSubImage2D(target, level, x, y, dataFormat, type, data);
        });
        this.gl.bindTexture(this.target, null);
    }
    copyFramebuffer() {
        let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        (0, $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3).error("Texture.copyFramebuffer({...}) is no logner supported, use copyToTexture(source, target, opts})")();
        return null;
    }
    getActiveUnit() {
        return this.gl.getParameter(34016) - 33984;
    }
    bind() {
        let textureUnit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.textureUnit;
        const { gl: gl  } = this;
        if (textureUnit !== undefined) {
            this.textureUnit = textureUnit;
            gl.activeTexture(33984 + textureUnit);
        }
        gl.bindTexture(this.target, this.handle);
        return textureUnit;
    }
    unbind() {
        let textureUnit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.textureUnit;
        const { gl: gl  } = this;
        if (textureUnit !== undefined) {
            this.textureUnit = textureUnit;
            gl.activeTexture(33984 + textureUnit);
        }
        gl.bindTexture(this.target, null);
        return textureUnit;
    }
    _getDataType(_ref3) {
        let { data: data , compressed: compressed = false  } = _ref3;
        if (compressed) return {
            data: data,
            dataType: "compressed"
        };
        if (data === null) return {
            data: data,
            dataType: "null"
        };
        if (ArrayBuffer.isView(data)) return {
            data: data,
            dataType: "typed-array"
        };
        if (data instanceof (0, $28a69bf6d03705d1$export$2e2bcd8739ae039)) return {
            data: data.handle,
            dataType: "buffer"
        };
        if (data instanceof $541c007d64b391ad$var$WebGLBuffer) return {
            data: data,
            dataType: "buffer"
        };
        return {
            data: data,
            dataType: "browser-object"
        };
    }
    _deduceParameters(opts) {
        const { format: format , data: data  } = opts;
        let { width: width , height: height , dataFormat: dataFormat , type: type , compressed: compressed  } = opts;
        const textureFormat = (0, $7e79c6e30bc6943f$export$ff6ccd50a74e6c72)[format];
        dataFormat = dataFormat || textureFormat && textureFormat.dataFormat;
        type = type || textureFormat && textureFormat.types[0];
        compressed = compressed || textureFormat && textureFormat.compressed;
        ({ width: width , height: height  } = this._deduceImageSize(data, width, height));
        return {
            dataFormat: dataFormat,
            type: type,
            compressed: compressed,
            width: width,
            height: height,
            format: format,
            data: data
        };
    }
    _deduceImageSize(data, width, height) {
        let size;
        if (typeof ImageData !== "undefined" && data instanceof ImageData) size = {
            width: data.width,
            height: data.height
        };
        else if (typeof HTMLImageElement !== "undefined" && data instanceof HTMLImageElement) size = {
            width: data.naturalWidth,
            height: data.naturalHeight
        };
        else if (typeof HTMLCanvasElement !== "undefined" && data instanceof HTMLCanvasElement) size = {
            width: data.width,
            height: data.height
        };
        else if (typeof ImageBitmap !== "undefined" && data instanceof ImageBitmap) size = {
            width: data.width,
            height: data.height
        };
        else if (typeof HTMLVideoElement !== "undefined" && data instanceof HTMLVideoElement) size = {
            width: data.videoWidth,
            height: data.videoHeight
        };
        else if (!data) size = {
            width: width >= 0 ? width : 1,
            height: height >= 0 ? height : 1
        };
        else size = {
            width: width,
            height: height
        };
        (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(size, "Could not deduced texture size");
        (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(width === undefined || size.width === width, "Deduced texture width does not match supplied width");
        (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(height === undefined || size.height === height, "Deduced texture height does not match supplied height");
        return size;
    }
    _createHandle() {
        return this.gl.createTexture();
    }
    _deleteHandle() {
        this.gl.deleteTexture(this.handle);
        this._trackDeallocatedMemory("Texture");
    }
    _getParameter(pname) {
        switch(pname){
            case 4096:
                return this.width;
            case 4097:
                return this.height;
            default:
                this.gl.bindTexture(this.target, this.handle);
                const value = this.gl.getTexParameter(this.target, pname);
                this.gl.bindTexture(this.target, null);
                return value;
        }
    }
    _setParameter(pname, param) {
        this.gl.bindTexture(this.target, this.handle);
        param = this._getNPOTParam(pname, param);
        switch(pname){
            case 33082:
            case 33083:
                this.gl.texParameterf(this.handle, pname, param);
                break;
            case 4096:
            case 4097:
                (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(false);
                break;
            default:
                this.gl.texParameteri(this.target, pname, param);
                break;
        }
        this.gl.bindTexture(this.target, null);
        return this;
    }
    _isNPOT() {
        if ((0, $325e733792a03f4e$export$e3518b1ac7891039)(this.gl)) return false;
        if (!this.width || !this.height) return false;
        return !(0, $757dc76705f498e6$export$b9e43d1765415474)(this.width) || !(0, $757dc76705f498e6$export$b9e43d1765415474)(this.height);
    }
    _updateForNPOT(parameters) {
        if (parameters[this.gl.TEXTURE_MIN_FILTER] === undefined) parameters[this.gl.TEXTURE_MIN_FILTER] = this.gl.LINEAR;
        if (parameters[this.gl.TEXTURE_WRAP_S] === undefined) parameters[this.gl.TEXTURE_WRAP_S] = this.gl.CLAMP_TO_EDGE;
        if (parameters[this.gl.TEXTURE_WRAP_T] === undefined) parameters[this.gl.TEXTURE_WRAP_T] = this.gl.CLAMP_TO_EDGE;
    }
    _getNPOTParam(pname, param) {
        if (this._isNPOT()) switch(pname){
            case 10241:
                if ($541c007d64b391ad$var$NPOT_MIN_FILTERS.indexOf(param) === -1) param = 9729;
                break;
            case 10242:
            case 10243:
                if (param !== 33071) param = 33071;
                break;
            default:
                break;
        }
        return param;
    }
}



let $5874bd7c18e6bc05$var$pathPrefix = "";
function $5874bd7c18e6bc05$export$fa7cbeea6a0f8cd3(prefix) {
    $5874bd7c18e6bc05$var$pathPrefix = prefix;
}
function $5874bd7c18e6bc05$export$3ae43cdaeb063d33(url) {
    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(typeof url === "string");
    url = $5874bd7c18e6bc05$var$pathPrefix + url;
    const dataType = options.dataType || "text";
    return fetch(url, options).then((res)=>res[dataType]());
}
function $5874bd7c18e6bc05$export$fe58198efe02b173(url, opts) {
    (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(typeof url === "string");
    url = $5874bd7c18e6bc05$var$pathPrefix + url;
    return new Promise((resolve, reject)=>{
        try {
            const image = new Image();
            image.onload = ()=>resolve(image);
            image.onerror = ()=>reject(new Error("Could not load image ".concat(url, ".")));
            image.crossOrigin = opts && opts.crossOrigin || "anonymous";
            image.src = url;
        } catch (error) {
            reject(error);
        }
    });
}


class $df31c887249e3faa$export$2e2bcd8739ae039 extends (0, $541c007d64b391ad$export$2e2bcd8739ae039) {
    get [Symbol.toStringTag]() {
        return "Texture2D";
    }
    static isSupported(gl, opts) {
        return (0, $541c007d64b391ad$export$2e2bcd8739ae039).isSupported(gl, opts);
    }
    constructor(gl){
        let props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        (0, $325e733792a03f4e$export$9b0605fd3c935712)(gl);
        if (props instanceof Promise || typeof props === "string") props = {
            data: props
        };
        if (typeof props.data === "string") props = Object.assign({}, props, {
            data: (0, $5874bd7c18e6bc05$export$fe58198efe02b173)(props.data)
        });
        super(gl, Object.assign({}, props, {
            target: 3553
        }));
        this.initialize(props);
        Object.seal(this);
    }
}




const $499b8d3cccd7f89c$var$FACES = [
    34069,
    34070,
    34071,
    34072,
    34073,
    34074
];
class $499b8d3cccd7f89c$export$2e2bcd8739ae039 extends (0, $541c007d64b391ad$export$2e2bcd8739ae039) {
    get [Symbol.toStringTag]() {
        return "TextureCube";
    }
    constructor(gl){
        let props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        (0, $325e733792a03f4e$export$9b0605fd3c935712)(gl);
        super(gl, Object.assign({}, props, {
            target: 34067
        }));
        this.initialize(props);
        Object.seal(this);
    }
    initialize() {
        let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        const { mipmaps: mipmaps = true , parameters: parameters = {}  } = props;
        this.opts = props;
        this.setCubeMapImageData(props).then(()=>{
            this.loaded = true;
            if (mipmaps) this.generateMipmap(props);
            this.setParameters(parameters);
        });
        return this;
    }
    subImage(_ref) {
        let { face: face , data: data , x: x = 0 , y: y = 0 , mipmapLevel: mipmapLevel = 0  } = _ref;
        return this._subImage({
            target: face,
            data: data,
            x: x,
            y: y,
            mipmapLevel: mipmapLevel
        });
    }
    async setCubeMapImageData(_ref2) {
        let { width: width , height: height , pixels: pixels , data: data , border: border = 0 , format: format = 6408 , type: type = 5121  } = _ref2;
        const { gl: gl  } = this;
        const imageDataMap = pixels || data;
        const resolvedFaces = await Promise.all($499b8d3cccd7f89c$var$FACES.map((face)=>{
            const facePixels = imageDataMap[face];
            return Promise.all(Array.isArray(facePixels) ? facePixels : [
                facePixels
            ]);
        }));
        this.bind();
        $499b8d3cccd7f89c$var$FACES.forEach((face, index)=>{
            if (resolvedFaces[index].length > 1 && this.opts.mipmaps !== false) (0, $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3).warn("".concat(this.id, " has mipmap and multiple LODs."))();
            resolvedFaces[index].forEach((image, lodLevel)=>{
                if (width && height) gl.texImage2D(face, lodLevel, format, width, height, border, format, type, image);
                else gl.texImage2D(face, lodLevel, format, format, type, image);
            });
        });
        this.unbind();
    }
    setImageDataForFace(options) {
        const { face: face , width: width , height: height , pixels: pixels , data: data , border: border = 0 , format: format = 6408 , type: type = 5121  } = options;
        const { gl: gl  } = this;
        const imageData = pixels || data;
        this.bind();
        if (imageData instanceof Promise) imageData.then((resolvedImageData)=>this.setImageDataForFace(Object.assign({}, options, {
                face: face,
                data: resolvedImageData,
                pixels: resolvedImageData
            })));
        else if (this.width || this.height) gl.texImage2D(face, 0, format, width, height, border, format, type, imageData);
        else gl.texImage2D(face, 0, format, format, type, imageData);
        return this;
    }
}
$499b8d3cccd7f89c$export$2e2bcd8739ae039.FACES = $499b8d3cccd7f89c$var$FACES;






class $4aa833ce3ed7a225$export$2e2bcd8739ae039 extends (0, $541c007d64b391ad$export$2e2bcd8739ae039) {
    get [Symbol.toStringTag]() {
        return "Texture3D";
    }
    static isSupported(gl) {
        return (0, $325e733792a03f4e$export$e3518b1ac7891039)(gl);
    }
    constructor(gl){
        let props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        (0, $325e733792a03f4e$export$22897d77b4bb5316)(gl);
        props = Object.assign({
            depth: 1
        }, props, {
            target: 32879,
            unpackFlipY: false
        });
        super(gl, props);
        this.initialize(props);
        Object.seal(this);
    }
    setImageData(_ref) {
        let { level: level = 0 , dataFormat: dataFormat = 6408 , width: width , height: height , depth: depth = 1 , border: border = 0 , format: format , type: type = 5121 , offset: offset = 0 , data: data , parameters: parameters = {}  } = _ref;
        this._trackDeallocatedMemory("Texture");
        this.gl.bindTexture(this.target, this.handle);
        (0, $54220aa8b6471f1a$export$b1e7058a2936b651)(this.gl, parameters, ()=>{
            if (ArrayBuffer.isView(data)) this.gl.texImage3D(this.target, level, dataFormat, width, height, depth, border, format, type, data);
            if (data instanceof (0, $28a69bf6d03705d1$export$2e2bcd8739ae039)) {
                this.gl.bindBuffer(35052, data.handle);
                this.gl.texImage3D(this.target, level, dataFormat, width, height, depth, border, format, type, offset);
            }
        });
        if (data && data.byteLength) this._trackAllocatedMemory(data.byteLength, "Texture");
        else {
            const channels = (0, $7e79c6e30bc6943f$export$1b400e62d2e54950)[this.dataFormat] || 4;
            const channelSize = (0, $7e79c6e30bc6943f$export$9acf869cba30dad8)[this.type] || 1;
            this._trackAllocatedMemory(this.width * this.height * this.depth * channels * channelSize, "Texture");
        }
        this.loaded = true;
        return this;
    }
}






const $7d33c99dc7978aa3$var$EXT_FLOAT_WEBGL2 = "EXT_color_buffer_float";
var $7d33c99dc7978aa3$export$2e2bcd8739ae039 = {
    [33189]: {
        bpp: 2
    },
    [33190]: {
        gl2: true,
        bpp: 3
    },
    [36012]: {
        gl2: true,
        bpp: 4
    },
    [36168]: {
        bpp: 1
    },
    [34041]: {
        bpp: 4
    },
    [35056]: {
        gl2: true,
        bpp: 4
    },
    [36013]: {
        gl2: true,
        bpp: 5
    },
    [32854]: {
        bpp: 2
    },
    [36194]: {
        bpp: 2
    },
    [32855]: {
        bpp: 2
    },
    [33321]: {
        gl2: true,
        bpp: 1
    },
    [33330]: {
        gl2: true,
        bpp: 1
    },
    [33329]: {
        gl2: true,
        bpp: 1
    },
    [33332]: {
        gl2: true,
        bpp: 2
    },
    [33331]: {
        gl2: true,
        bpp: 2
    },
    [33334]: {
        gl2: true,
        bpp: 4
    },
    [33333]: {
        gl2: true,
        bpp: 4
    },
    [33323]: {
        gl2: true,
        bpp: 2
    },
    [33336]: {
        gl2: true,
        bpp: 2
    },
    [33335]: {
        gl2: true,
        bpp: 2
    },
    [33338]: {
        gl2: true,
        bpp: 4
    },
    [33337]: {
        gl2: true,
        bpp: 4
    },
    [33340]: {
        gl2: true,
        bpp: 8
    },
    [33339]: {
        gl2: true,
        bpp: 8
    },
    [32849]: {
        gl2: true,
        bpp: 3
    },
    [32856]: {
        gl2: true,
        bpp: 4
    },
    [32857]: {
        gl2: true,
        bpp: 4
    },
    [36220]: {
        gl2: true,
        bpp: 4
    },
    [36238]: {
        gl2: true,
        bpp: 4
    },
    [36975]: {
        gl2: true,
        bpp: 4
    },
    [36214]: {
        gl2: true,
        bpp: 8
    },
    [36232]: {
        gl2: true,
        bpp: 8
    },
    [36226]: {
        gl2: true,
        bpp: 16
    },
    [36208]: {
        gl2: true,
        bpp: 16
    },
    [33325]: {
        gl2: $7d33c99dc7978aa3$var$EXT_FLOAT_WEBGL2,
        bpp: 2
    },
    [33327]: {
        gl2: $7d33c99dc7978aa3$var$EXT_FLOAT_WEBGL2,
        bpp: 4
    },
    [34842]: {
        gl2: $7d33c99dc7978aa3$var$EXT_FLOAT_WEBGL2,
        bpp: 8
    },
    [33326]: {
        gl2: $7d33c99dc7978aa3$var$EXT_FLOAT_WEBGL2,
        bpp: 4
    },
    [33328]: {
        gl2: $7d33c99dc7978aa3$var$EXT_FLOAT_WEBGL2,
        bpp: 8
    },
    [34836]: {
        gl2: $7d33c99dc7978aa3$var$EXT_FLOAT_WEBGL2,
        bpp: 16
    },
    [35898]: {
        gl2: $7d33c99dc7978aa3$var$EXT_FLOAT_WEBGL2,
        bpp: 4
    }
};




function $0082476f18a250b0$var$isFormatSupported(gl, format, formats) {
    const info = formats[format];
    if (!info) return false;
    const value = (0, $325e733792a03f4e$export$e3518b1ac7891039)(gl) ? info.gl2 || info.gl1 : info.gl1;
    if (typeof value === "string") return gl.getExtension(value);
    return value;
}
class $0082476f18a250b0$export$2e2bcd8739ae039 extends (0, $dabe379caebdf3da$export$2e2bcd8739ae039) {
    get [Symbol.toStringTag]() {
        return "Renderbuffer";
    }
    static isSupported(gl) {
        let { format: format  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
            format: null
        };
        return !format || $0082476f18a250b0$var$isFormatSupported(gl, format, (0, $7d33c99dc7978aa3$export$2e2bcd8739ae039));
    }
    static getSamplesForFormat(gl, _ref) {
        let { format: format  } = _ref;
        return gl.getInternalformatParameter(36161, format, 32937);
    }
    constructor(gl){
        let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        super(gl, opts);
        this.initialize(opts);
        Object.seal(this);
    }
    initialize(_ref2) {
        let { format: format , width: width = 1 , height: height = 1 , samples: samples = 0  } = _ref2;
        (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(format, "Needs format");
        this._trackDeallocatedMemory();
        this.gl.bindRenderbuffer(36161, this.handle);
        if (samples !== 0 && (0, $325e733792a03f4e$export$e3518b1ac7891039)(this.gl)) this.gl.renderbufferStorageMultisample(36161, samples, format, width, height);
        else this.gl.renderbufferStorage(36161, format, width, height);
        this.format = format;
        this.width = width;
        this.height = height;
        this.samples = samples;
        this._trackAllocatedMemory(this.width * this.height * (this.samples || 1) * (0, $7d33c99dc7978aa3$export$2e2bcd8739ae039)[this.format].bpp);
        return this;
    }
    resize(_ref3) {
        let { width: width , height: height  } = _ref3;
        if (width !== this.width || height !== this.height) return this.initialize({
            width: width,
            height: height,
            format: this.format,
            samples: this.samples
        });
        return this;
    }
    _createHandle() {
        return this.gl.createRenderbuffer();
    }
    _deleteHandle() {
        this.gl.deleteRenderbuffer(this.handle);
        this._trackDeallocatedMemory();
    }
    _bindHandle(handle) {
        this.gl.bindRenderbuffer(36161, handle);
    }
    _syncHandle(handle) {
        this.format = this.getParameter(36164);
        this.width = this.getParameter(36162);
        this.height = this.getParameter(36163);
        this.samples = this.getParameter(36011);
    }
    _getParameter(pname) {
        this.gl.bindRenderbuffer(36161, this.handle);
        const value = this.gl.getRenderbufferParameter(36161, pname);
        return value;
    }
}




const $9d2da77370080708$var$GL_DEPTH_BUFFER_BIT = 0x00000100;
const $9d2da77370080708$var$GL_STENCIL_BUFFER_BIT = 0x00000400;
const $9d2da77370080708$var$GL_COLOR_BUFFER_BIT = 0x00004000;
const $9d2da77370080708$var$GL_COLOR = 0x1800;
const $9d2da77370080708$var$GL_DEPTH = 0x1801;
const $9d2da77370080708$var$GL_STENCIL = 0x1802;
const $9d2da77370080708$var$GL_DEPTH_STENCIL = 0x84f9;
const $9d2da77370080708$var$ERR_ARGUMENTS = "clear: bad arguments";
function $9d2da77370080708$export$42ffd38884aecdac(gl) {
    let { framebuffer: framebuffer = null , color: color = null , depth: depth = null , stencil: stencil = null  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    const parameters = {};
    if (framebuffer) parameters.framebuffer = framebuffer;
    let clearFlags = 0;
    if (color) {
        clearFlags |= $9d2da77370080708$var$GL_COLOR_BUFFER_BIT;
        if (color !== true) parameters.clearColor = color;
    }
    if (depth) {
        clearFlags |= $9d2da77370080708$var$GL_DEPTH_BUFFER_BIT;
        if (depth !== true) parameters.clearDepth = depth;
    }
    if (stencil) {
        clearFlags |= $9d2da77370080708$var$GL_STENCIL_BUFFER_BIT;
        if (depth !== true) parameters.clearStencil = depth;
    }
    (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(clearFlags !== 0, $9d2da77370080708$var$ERR_ARGUMENTS);
    (0, $54220aa8b6471f1a$export$b1e7058a2936b651)(gl, parameters, ()=>{
        gl.clear(clearFlags);
    });
}
function $9d2da77370080708$export$abb0b37bc9255c0e(gl) {
    let { framebuffer: framebuffer = null , buffer: buffer = $9d2da77370080708$var$GL_COLOR , drawBuffer: drawBuffer = 0 , value: value = [
        0,
        0,
        0,
        0
    ]  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, $325e733792a03f4e$export$22897d77b4bb5316)(gl);
    (0, $54220aa8b6471f1a$export$b1e7058a2936b651)(gl, {
        framebuffer: framebuffer
    }, ()=>{
        switch(buffer){
            case $9d2da77370080708$var$GL_COLOR:
                switch(value.constructor){
                    case Int32Array:
                        gl.clearBufferiv(buffer, drawBuffer, value);
                        break;
                    case Uint32Array:
                        gl.clearBufferuiv(buffer, drawBuffer, value);
                        break;
                    case Float32Array:
                    default:
                        gl.clearBufferfv(buffer, drawBuffer, value);
                }
                break;
            case $9d2da77370080708$var$GL_DEPTH:
                gl.clearBufferfv($9d2da77370080708$var$GL_DEPTH, 0, [
                    value
                ]);
                break;
            case $9d2da77370080708$var$GL_STENCIL:
                gl.clearBufferiv($9d2da77370080708$var$GL_STENCIL, 0, [
                    value
                ]);
                break;
            case $9d2da77370080708$var$GL_DEPTH_STENCIL:
                const [depth, stencil] = value;
                gl.clearBufferfi($9d2da77370080708$var$GL_DEPTH_STENCIL, 0, depth, stencil);
                break;
            default:
                (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(false, $9d2da77370080708$var$ERR_ARGUMENTS);
        }
    });
}









function $6f98a3202da2e321$export$211a621476a5328b(format) {
    switch(format){
        case 6406:
        case 33326:
        case 6403:
            return 1;
        case 33328:
        case 33319:
            return 2;
        case 6407:
        case 34837:
            return 3;
        case 6408:
        case 34836:
            return 4;
        default:
            (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(false);
            return 0;
    }
}
function $6f98a3202da2e321$export$25c250e029e88433(type) {
    switch(type){
        case 5121:
            return 1;
        case 33635:
        case 32819:
        case 32820:
            return 2;
        case 5126:
            return 4;
        default:
            (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(false);
            return 0;
    }
}




function $c192e756436d1779$export$f9f2f48e7f9faaa5(source) {
    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    const { sourceX: sourceX = 0 , sourceY: sourceY = 0 , sourceFormat: sourceFormat = 6408  } = options;
    let { sourceAttachment: sourceAttachment = 36064 , target: target = null , sourceWidth: sourceWidth , sourceHeight: sourceHeight , sourceType: sourceType  } = options;
    const { framebuffer: framebuffer , deleteFramebuffer: deleteFramebuffer  } = $c192e756436d1779$var$getFramebuffer(source);
    (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(framebuffer);
    const { gl: gl , handle: handle , attachments: attachments  } = framebuffer;
    sourceWidth = sourceWidth || framebuffer.width;
    sourceHeight = sourceHeight || framebuffer.height;
    if (sourceAttachment === 36064 && handle === null) sourceAttachment = 1028;
    (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(attachments[sourceAttachment]);
    sourceType = sourceType || attachments[sourceAttachment].type;
    target = $c192e756436d1779$var$getPixelArray(target, sourceType, sourceFormat, sourceWidth, sourceHeight);
    sourceType = sourceType || (0, $eee37e63e18ddcdf$export$127239b7f8a5750f)(target);
    const prevHandle = gl.bindFramebuffer(36160, handle);
    gl.readPixels(sourceX, sourceY, sourceWidth, sourceHeight, sourceFormat, sourceType, target);
    gl.bindFramebuffer(36160, prevHandle || null);
    if (deleteFramebuffer) framebuffer.delete();
    return target;
}
function $c192e756436d1779$export$c063f9191f0d5b03(source, _ref) {
    let { sourceX: sourceX = 0 , sourceY: sourceY = 0 , sourceFormat: sourceFormat = 6408 , target: target = null , targetByteOffset: targetByteOffset = 0 , sourceWidth: sourceWidth , sourceHeight: sourceHeight , sourceType: sourceType  } = _ref;
    const { framebuffer: framebuffer , deleteFramebuffer: deleteFramebuffer  } = $c192e756436d1779$var$getFramebuffer(source);
    (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(framebuffer);
    sourceWidth = sourceWidth || framebuffer.width;
    sourceHeight = sourceHeight || framebuffer.height;
    const gl2 = (0, $325e733792a03f4e$export$22897d77b4bb5316)(framebuffer.gl);
    sourceType = sourceType || (target ? target.type : 5121);
    if (!target) {
        const components = (0, $6f98a3202da2e321$export$211a621476a5328b)(sourceFormat);
        const byteCount = (0, $6f98a3202da2e321$export$25c250e029e88433)(sourceType);
        const byteLength = targetByteOffset + sourceWidth * sourceHeight * components * byteCount;
        target = new (0, $28a69bf6d03705d1$export$2e2bcd8739ae039)(gl2, {
            byteLength: byteLength,
            accessor: {
                type: sourceType,
                size: components
            }
        });
    }
    target.bind({
        target: 35051
    });
    (0, $54220aa8b6471f1a$export$b1e7058a2936b651)(gl2, {
        framebuffer: framebuffer
    }, ()=>{
        gl2.readPixels(sourceX, sourceY, sourceWidth, sourceHeight, sourceFormat, sourceType, targetByteOffset);
    });
    target.unbind({
        target: 35051
    });
    if (deleteFramebuffer) framebuffer.delete();
    return target;
}
function $c192e756436d1779$export$310e97e05f1c81cc(source) {
    let { sourceAttachment: sourceAttachment = 36064 , targetMaxHeight: targetMaxHeight = Number.MAX_SAFE_INTEGER  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    let data = $c192e756436d1779$export$f9f2f48e7f9faaa5(source, {
        sourceAttachment: sourceAttachment
    });
    let { width: width , height: height  } = source;
    while(height > targetMaxHeight)({ data: data , width: width , height: height  } = (0, $eee37e63e18ddcdf$export$b405024b493a473f)({
        data: data,
        width: width,
        height: height
    }));
    (0, $eee37e63e18ddcdf$export$2478197380c2212f)({
        data: data,
        width: width,
        height: height
    });
    const canvas = document.createElement("canvas");
    canvas.width = width;
    canvas.height = height;
    const context = canvas.getContext("2d");
    const imageData = context.createImageData(width, height);
    imageData.data.set(data);
    context.putImageData(imageData, 0, 0);
    return canvas.toDataURL();
}
function $c192e756436d1779$export$d848cd44c7a9b314(source) {
    let { sourceAttachment: sourceAttachment = 36064 , targetImage: targetImage = null  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    const dataUrl = $c192e756436d1779$export$310e97e05f1c81cc(source, {
        sourceAttachment: sourceAttachment
    });
    targetImage = targetImage || new Image();
    targetImage.src = dataUrl;
    return targetImage;
}
function $c192e756436d1779$export$45ef68203138b6b0(source, target) {
    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    const { sourceX: sourceX = 0 , sourceY: sourceY = 0 , targetMipmaplevel: targetMipmaplevel = 0 , targetInternalFormat: targetInternalFormat = 6408  } = options;
    let { targetX: targetX , targetY: targetY , targetZ: targetZ , width: width , height: height  } = options;
    const { framebuffer: framebuffer , deleteFramebuffer: deleteFramebuffer  } = $c192e756436d1779$var$getFramebuffer(source);
    (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(framebuffer);
    const { gl: gl , handle: handle  } = framebuffer;
    const isSubCopy = typeof targetX !== "undefined" || typeof targetY !== "undefined" || typeof targetZ !== "undefined";
    targetX = targetX || 0;
    targetY = targetY || 0;
    targetZ = targetZ || 0;
    const prevHandle = gl.bindFramebuffer(36160, handle);
    (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(target);
    let texture = null;
    if (target instanceof (0, $541c007d64b391ad$export$2e2bcd8739ae039)) {
        texture = target;
        width = Number.isFinite(width) ? width : texture.width;
        height = Number.isFinite(height) ? height : texture.height;
        texture.bind(0);
        target = texture.target;
    }
    if (!isSubCopy) gl.copyTexImage2D(target, targetMipmaplevel, targetInternalFormat, sourceX, sourceY, width, height, 0);
    else switch(target){
        case 3553:
        case 34067:
            gl.copyTexSubImage2D(target, targetMipmaplevel, targetX, targetY, sourceX, sourceY, width, height);
            break;
        case 35866:
        case 32879:
            const gl2 = (0, $325e733792a03f4e$export$22897d77b4bb5316)(gl);
            gl2.copyTexSubImage3D(target, targetMipmaplevel, targetX, targetY, targetZ, sourceX, sourceY, width, height);
            break;
        default:
    }
    if (texture) texture.unbind();
    gl.bindFramebuffer(36160, prevHandle || null);
    if (deleteFramebuffer) framebuffer.delete();
    return texture;
}
function $c192e756436d1779$export$1b8713e12f56ba52(source, target) {
    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    const { sourceX0: sourceX0 = 0 , sourceY0: sourceY0 = 0 , targetX0: targetX0 = 0 , targetY0: targetY0 = 0 , color: color = true , depth: depth = false , stencil: stencil = false , filter: filter = 9728  } = options;
    let { sourceX1: sourceX1 , sourceY1: sourceY1 , targetX1: targetX1 , targetY1: targetY1 , sourceAttachment: sourceAttachment = 36064 , mask: mask = 0  } = options;
    const { framebuffer: srcFramebuffer , deleteFramebuffer: deleteSrcFramebuffer  } = $c192e756436d1779$var$getFramebuffer(source);
    const { framebuffer: dstFramebuffer , deleteFramebuffer: deleteDstFramebuffer  } = $c192e756436d1779$var$getFramebuffer(target);
    (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(srcFramebuffer);
    (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(dstFramebuffer);
    const { gl: gl , handle: handle , width: width , height: height , readBuffer: readBuffer  } = dstFramebuffer;
    const gl2 = (0, $325e733792a03f4e$export$22897d77b4bb5316)(gl);
    if (!srcFramebuffer.handle && sourceAttachment === 36064) sourceAttachment = 1028;
    if (color) mask |= 16384;
    if (depth) mask |= 256;
    if (stencil) mask |= 1024;
    if (deleteSrcFramebuffer || deleteDstFramebuffer) {
        if (mask & 1280) {
            mask = 16384;
            (0, $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3).warn("Blitting from or into a Texture object, forcing mask to GL.COLOR_BUFFER_BIT")();
        }
    }
    (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(mask);
    sourceX1 = sourceX1 === undefined ? srcFramebuffer.width : sourceX1;
    sourceY1 = sourceY1 === undefined ? srcFramebuffer.height : sourceY1;
    targetX1 = targetX1 === undefined ? width : targetX1;
    targetY1 = targetY1 === undefined ? height : targetY1;
    const prevDrawHandle = gl.bindFramebuffer(36009, handle);
    const prevReadHandle = gl.bindFramebuffer(36008, srcFramebuffer.handle);
    gl2.readBuffer(sourceAttachment);
    gl2.blitFramebuffer(sourceX0, sourceY0, sourceX1, sourceY1, targetX0, targetY0, targetX1, targetY1, mask, filter);
    gl2.readBuffer(readBuffer);
    gl2.bindFramebuffer(36008, prevReadHandle || null);
    gl2.bindFramebuffer(36009, prevDrawHandle || null);
    if (deleteSrcFramebuffer) srcFramebuffer.delete();
    if (deleteDstFramebuffer) dstFramebuffer.delete();
    return dstFramebuffer;
}
function $c192e756436d1779$var$getFramebuffer(source) {
    if (!(source instanceof (0, $a0e9e15bc57c4882$export$2e2bcd8739ae039))) return {
        framebuffer: (0, $379077f7c038ee76$export$37e0e55400e095ba)(source),
        deleteFramebuffer: true
    };
    return {
        framebuffer: source,
        deleteFramebuffer: false
    };
}
function $c192e756436d1779$var$getPixelArray(pixelArray, type, format, width, height) {
    if (pixelArray) return pixelArray;
    type = type || 5121;
    const ArrayType = (0, $eee37e63e18ddcdf$export$9619a05b47814a85)(type, {
        clamped: false
    });
    const components = (0, $6f98a3202da2e321$export$211a621476a5328b)(format);
    return new ArrayType(width * height * components);
}




const $8cba87f65ded858b$export$d6a5c11f04f75862 = {
    WEBGL2: "WEBGL2",
    VERTEX_ARRAY_OBJECT: "VERTEX_ARRAY_OBJECT",
    TIMER_QUERY: "TIMER_QUERY",
    INSTANCED_RENDERING: "INSTANCED_RENDERING",
    MULTIPLE_RENDER_TARGETS: "MULTIPLE_RENDER_TARGETS",
    ELEMENT_INDEX_UINT32: "ELEMENT_INDEX_UINT32",
    BLEND_EQUATION_MINMAX: "BLEND_EQUATION_MINMAX",
    FLOAT_BLEND: "FLOAT_BLEND",
    COLOR_ENCODING_SRGB: "COLOR_ENCODING_SRGB",
    TEXTURE_DEPTH: "TEXTURE_DEPTH",
    TEXTURE_FLOAT: "TEXTURE_FLOAT",
    TEXTURE_HALF_FLOAT: "TEXTURE_HALF_FLOAT",
    TEXTURE_FILTER_LINEAR_FLOAT: "TEXTURE_FILTER_LINEAR_FLOAT",
    TEXTURE_FILTER_LINEAR_HALF_FLOAT: "TEXTURE_FILTER_LINEAR_HALF_FLOAT",
    TEXTURE_FILTER_ANISOTROPIC: "TEXTURE_FILTER_ANISOTROPIC",
    COLOR_ATTACHMENT_RGBA32F: "COLOR_ATTACHMENT_RGBA32F",
    COLOR_ATTACHMENT_FLOAT: "COLOR_ATTACHMENT_FLOAT",
    COLOR_ATTACHMENT_HALF_FLOAT: "COLOR_ATTACHMENT_HALF_FLOAT",
    GLSL_FRAG_DATA: "GLSL_FRAG_DATA",
    GLSL_FRAG_DEPTH: "GLSL_FRAG_DEPTH",
    GLSL_DERIVATIVES: "GLSL_DERIVATIVES",
    GLSL_TEXTURE_LOD: "GLSL_TEXTURE_LOD"
};
function $8cba87f65ded858b$var$checkFloat32ColorAttachment(gl) {
    const testTexture = new (0, $df31c887249e3faa$export$2e2bcd8739ae039)(gl, {
        format: 6408,
        type: 5126,
        dataFormat: 6408
    });
    const testFb = new (0, $a0e9e15bc57c4882$export$2e2bcd8739ae039)(gl, {
        id: "test-framebuffer",
        check: false,
        attachments: {
            [36064]: testTexture
        }
    });
    const status = testFb.getStatus();
    testTexture.delete();
    testFb.delete();
    return status === 36053;
}
var $8cba87f65ded858b$export$2e2bcd8739ae039 = {
    [$8cba87f65ded858b$export$d6a5c11f04f75862.WEBGL2]: [
        false,
        true
    ],
    [$8cba87f65ded858b$export$d6a5c11f04f75862.VERTEX_ARRAY_OBJECT]: [
        "OES_vertex_array_object",
        true
    ],
    [$8cba87f65ded858b$export$d6a5c11f04f75862.TIMER_QUERY]: [
        "EXT_disjoint_timer_query",
        "EXT_disjoint_timer_query_webgl2"
    ],
    [$8cba87f65ded858b$export$d6a5c11f04f75862.INSTANCED_RENDERING]: [
        "ANGLE_instanced_arrays",
        true
    ],
    [$8cba87f65ded858b$export$d6a5c11f04f75862.MULTIPLE_RENDER_TARGETS]: [
        "WEBGL_draw_buffers",
        true
    ],
    [$8cba87f65ded858b$export$d6a5c11f04f75862.ELEMENT_INDEX_UINT32]: [
        "OES_element_index_uint",
        true
    ],
    [$8cba87f65ded858b$export$d6a5c11f04f75862.BLEND_EQUATION_MINMAX]: [
        "EXT_blend_minmax",
        true
    ],
    [$8cba87f65ded858b$export$d6a5c11f04f75862.FLOAT_BLEND]: [
        "EXT_float_blend"
    ],
    [$8cba87f65ded858b$export$d6a5c11f04f75862.COLOR_ENCODING_SRGB]: [
        "EXT_sRGB",
        true
    ],
    [$8cba87f65ded858b$export$d6a5c11f04f75862.TEXTURE_DEPTH]: [
        "WEBGL_depth_texture",
        true
    ],
    [$8cba87f65ded858b$export$d6a5c11f04f75862.TEXTURE_FLOAT]: [
        "OES_texture_float",
        true
    ],
    [$8cba87f65ded858b$export$d6a5c11f04f75862.TEXTURE_HALF_FLOAT]: [
        "OES_texture_half_float",
        true
    ],
    [$8cba87f65ded858b$export$d6a5c11f04f75862.TEXTURE_FILTER_LINEAR_FLOAT]: [
        "OES_texture_float_linear"
    ],
    [$8cba87f65ded858b$export$d6a5c11f04f75862.TEXTURE_FILTER_LINEAR_HALF_FLOAT]: [
        "OES_texture_half_float_linear"
    ],
    [$8cba87f65ded858b$export$d6a5c11f04f75862.TEXTURE_FILTER_ANISOTROPIC]: [
        "EXT_texture_filter_anisotropic"
    ],
    [$8cba87f65ded858b$export$d6a5c11f04f75862.COLOR_ATTACHMENT_RGBA32F]: [
        $8cba87f65ded858b$var$checkFloat32ColorAttachment,
        "EXT_color_buffer_float"
    ],
    [$8cba87f65ded858b$export$d6a5c11f04f75862.COLOR_ATTACHMENT_FLOAT]: [
        false,
        "EXT_color_buffer_float"
    ],
    [$8cba87f65ded858b$export$d6a5c11f04f75862.COLOR_ATTACHMENT_HALF_FLOAT]: [
        "EXT_color_buffer_half_float"
    ],
    [$8cba87f65ded858b$export$d6a5c11f04f75862.GLSL_FRAG_DATA]: [
        "WEBGL_draw_buffers",
        true
    ],
    [$8cba87f65ded858b$export$d6a5c11f04f75862.GLSL_FRAG_DEPTH]: [
        "EXT_frag_depth",
        true
    ],
    [$8cba87f65ded858b$export$d6a5c11f04f75862.GLSL_DERIVATIVES]: [
        "OES_standard_derivatives",
        true
    ],
    [$8cba87f65ded858b$export$d6a5c11f04f75862.GLSL_TEXTURE_LOD]: [
        "EXT_shader_texture_lod",
        true
    ]
};




const $75ff6bc03ebbcaf6$var$LOG_UNSUPPORTED_FEATURE = 2;
function $75ff6bc03ebbcaf6$export$805ddaeeece0413e(gl, feature) {
    return $75ff6bc03ebbcaf6$export$990fdf4f5aca9ddb(gl, feature);
}
function $75ff6bc03ebbcaf6$export$990fdf4f5aca9ddb(gl, features) {
    features = Array.isArray(features) ? features : [
        features
    ];
    return features.every((feature)=>{
        return $75ff6bc03ebbcaf6$var$isFeatureSupported(gl, feature);
    });
}
function $75ff6bc03ebbcaf6$export$c5c8eb9e425b0de0(gl) {
    gl.luma = gl.luma || {};
    gl.luma.caps = gl.luma.caps || {};
    for(const cap in 0, $8cba87f65ded858b$export$2e2bcd8739ae039)if (gl.luma.caps[cap] === undefined) gl.luma.caps[cap] = $75ff6bc03ebbcaf6$var$isFeatureSupported(gl, cap);
    return gl.luma.caps;
}
function $75ff6bc03ebbcaf6$var$isFeatureSupported(gl, cap) {
    gl.luma = gl.luma || {};
    gl.luma.caps = gl.luma.caps || {};
    if (gl.luma.caps[cap] === undefined) gl.luma.caps[cap] = $75ff6bc03ebbcaf6$var$queryFeature(gl, cap);
    if (!gl.luma.caps[cap]) (0, $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3).log($75ff6bc03ebbcaf6$var$LOG_UNSUPPORTED_FEATURE, "Feature: ".concat(cap, " not supported"))();
    return gl.luma.caps[cap];
}
function $75ff6bc03ebbcaf6$var$queryFeature(gl, cap) {
    const feature = (0, $8cba87f65ded858b$export$2e2bcd8739ae039)[cap];
    (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(feature, cap);
    let isSupported;
    const featureDefinition = (0, $325e733792a03f4e$export$e3518b1ac7891039)(gl) ? feature[1] || feature[0] : feature[0];
    if (typeof featureDefinition === "function") isSupported = featureDefinition(gl);
    else if (Array.isArray(featureDefinition)) {
        isSupported = true;
        for (const extension of featureDefinition)isSupported = isSupported && Boolean(gl.getExtension(extension));
    } else if (typeof featureDefinition === "string") isSupported = Boolean(gl.getExtension(featureDefinition));
    else if (typeof featureDefinition === "boolean") isSupported = featureDefinition;
    else (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(false);
    return isSupported;
}





const $a0e9e15bc57c4882$var$ERR_MULTIPLE_RENDERTARGETS = "Multiple render targets not supported";
class $a0e9e15bc57c4882$export$2e2bcd8739ae039 extends (0, $dabe379caebdf3da$export$2e2bcd8739ae039) {
    get [Symbol.toStringTag]() {
        return "Framebuffer";
    }
    static isSupported(gl) {
        let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        const { colorBufferFloat: colorBufferFloat , colorBufferHalfFloat: colorBufferHalfFloat  } = options;
        let supported = true;
        if (colorBufferFloat) supported = Boolean(gl.getExtension("EXT_color_buffer_float") || gl.getExtension("WEBGL_color_buffer_float") || gl.getExtension("OES_texture_float"));
        if (colorBufferHalfFloat) supported = supported && Boolean(gl.getExtension("EXT_color_buffer_float") || gl.getExtension("EXT_color_buffer_half_float"));
        return supported;
    }
    static getDefaultFramebuffer(gl) {
        gl.luma = gl.luma || {};
        gl.luma.defaultFramebuffer = gl.luma.defaultFramebuffer || new $a0e9e15bc57c4882$export$2e2bcd8739ae039(gl, {
            id: "default-framebuffer",
            handle: null,
            attachments: {}
        });
        return gl.luma.defaultFramebuffer;
    }
    get MAX_COLOR_ATTACHMENTS() {
        const gl2 = (0, $325e733792a03f4e$export$22897d77b4bb5316)(this.gl);
        return gl2.getParameter(gl2.MAX_COLOR_ATTACHMENTS);
    }
    get MAX_DRAW_BUFFERS() {
        const gl2 = (0, $325e733792a03f4e$export$22897d77b4bb5316)(this.gl);
        return gl2.getParameter(gl2.MAX_DRAW_BUFFERS);
    }
    constructor(gl){
        let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        super(gl, opts);
        this.width = null;
        this.height = null;
        this.attachments = {};
        this.readBuffer = 36064;
        this.drawBuffers = [
            36064
        ];
        this.ownResources = [];
        this.initialize(opts);
        Object.seal(this);
    }
    get color() {
        return this.attachments[36064] || null;
    }
    get texture() {
        return this.attachments[36064] || null;
    }
    get depth() {
        return this.attachments[36096] || this.attachments[33306] || null;
    }
    get stencil() {
        return this.attachments[36128] || this.attachments[33306] || null;
    }
    initialize(_ref) {
        let { width: width = 1 , height: height = 1 , attachments: attachments = null , color: color = true , depth: depth = true , stencil: stencil = false , check: check = true , readBuffer: readBuffer , drawBuffers: drawBuffers  } = _ref;
        (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(width >= 0 && height >= 0, "Width and height need to be integers");
        this.width = width;
        this.height = height;
        if (attachments) for(const attachment in attachments){
            const target = attachments[attachment];
            const object = Array.isArray(target) ? target[0] : target;
            object.resize({
                width: width,
                height: height
            });
        }
        else attachments = this._createDefaultAttachments(color, depth, stencil, width, height);
        this.update({
            clearAttachments: true,
            attachments: attachments,
            readBuffer: readBuffer,
            drawBuffers: drawBuffers
        });
        if (attachments && check) this.checkStatus();
    }
    delete() {
        for (const resource of this.ownResources)resource.delete();
        super.delete();
        return this;
    }
    update(_ref2) {
        let { attachments: attachments = {} , readBuffer: readBuffer , drawBuffers: drawBuffers , clearAttachments: clearAttachments = false , resizeAttachments: resizeAttachments = true  } = _ref2;
        this.attach(attachments, {
            clearAttachments: clearAttachments,
            resizeAttachments: resizeAttachments
        });
        const { gl: gl  } = this;
        const prevHandle = gl.bindFramebuffer(36160, this.handle);
        if (readBuffer) this._setReadBuffer(readBuffer);
        if (drawBuffers) this._setDrawBuffers(drawBuffers);
        gl.bindFramebuffer(36160, prevHandle || null);
        return this;
    }
    resize() {
        let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        let { width: width , height: height  } = options;
        if (this.handle === null) {
            (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(width === undefined && height === undefined);
            this.width = this.gl.drawingBufferWidth;
            this.height = this.gl.drawingBufferHeight;
            return this;
        }
        if (width === undefined) width = this.gl.drawingBufferWidth;
        if (height === undefined) height = this.gl.drawingBufferHeight;
        if (width !== this.width && height !== this.height) (0, $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3).log(2, "Resizing framebuffer ".concat(this.id, " to ").concat(width, "x").concat(height))();
        for(const attachmentPoint in this.attachments)this.attachments[attachmentPoint].resize({
            width: width,
            height: height
        });
        this.width = width;
        this.height = height;
        return this;
    }
    attach(attachments) {
        let { clearAttachments: clearAttachments = false , resizeAttachments: resizeAttachments = true  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        const newAttachments = {};
        if (clearAttachments) Object.keys(this.attachments).forEach((key)=>{
            newAttachments[key] = null;
        });
        Object.assign(newAttachments, attachments);
        const prevHandle = this.gl.bindFramebuffer(36160, this.handle);
        for(const key1 in newAttachments){
            (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(key1 !== undefined, "Misspelled framebuffer binding point?");
            const attachment = Number(key1);
            const descriptor = newAttachments[attachment];
            let object = descriptor;
            if (!object) this._unattach(attachment);
            else if (object instanceof (0, $0082476f18a250b0$export$2e2bcd8739ae039)) this._attachRenderbuffer({
                attachment: attachment,
                renderbuffer: object
            });
            else if (Array.isArray(descriptor)) {
                const [texture, layer = 0, level = 0] = descriptor;
                object = texture;
                this._attachTexture({
                    attachment: attachment,
                    texture: texture,
                    layer: layer,
                    level: level
                });
            } else this._attachTexture({
                attachment: attachment,
                texture: object,
                layer: 0,
                level: 0
            });
            if (resizeAttachments && object) object.resize({
                width: this.width,
                height: this.height
            });
        }
        this.gl.bindFramebuffer(36160, prevHandle || null);
        Object.assign(this.attachments, attachments);
        Object.keys(this.attachments).filter((key)=>!this.attachments[key]).forEach((key)=>{
            delete this.attachments[key];
        });
    }
    checkStatus() {
        const { gl: gl  } = this;
        const status = this.getStatus();
        if (status !== 36053) throw new Error($a0e9e15bc57c4882$var$_getFrameBufferStatus(status));
        return this;
    }
    getStatus() {
        const { gl: gl  } = this;
        const prevHandle = gl.bindFramebuffer(36160, this.handle);
        const status = gl.checkFramebufferStatus(36160);
        gl.bindFramebuffer(36160, prevHandle || null);
        return status;
    }
    clear() {
        let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        const { color: color , depth: depth , stencil: stencil , drawBuffers: drawBuffers = []  } = options;
        const prevHandle = this.gl.bindFramebuffer(36160, this.handle);
        if (color || depth || stencil) (0, $9d2da77370080708$export$42ffd38884aecdac)(this.gl, {
            color: color,
            depth: depth,
            stencil: stencil
        });
        drawBuffers.forEach((value, drawBuffer)=>{
            (0, $9d2da77370080708$export$abb0b37bc9255c0e)(this.gl, {
                drawBuffer: drawBuffer,
                value: value
            });
        });
        this.gl.bindFramebuffer(36160, prevHandle || null);
        return this;
    }
    readPixels() {
        let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        (0, $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3).error("Framebuffer.readPixels() is no logner supported, use readPixelsToArray(framebuffer)")();
        return null;
    }
    readPixelsToBuffer() {
        let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        (0, $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3).error("Framebuffer.readPixelsToBuffer()is no logner supported, use readPixelsToBuffer(framebuffer)")();
        return null;
    }
    copyToDataUrl() {
        let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        (0, $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3).error("Framebuffer.copyToDataUrl() is no logner supported, use copyToDataUrl(framebuffer)")();
        return null;
    }
    copyToImage() {
        let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        (0, $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3).error("Framebuffer.copyToImage() is no logner supported, use copyToImage(framebuffer)")();
        return null;
    }
    copyToTexture() {
        let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        (0, $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3).error("Framebuffer.copyToTexture({...}) is no logner supported, use copyToTexture(source, target, opts})")();
        return null;
    }
    blit() {
        let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        (0, $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3).error("Framebuffer.blit({...}) is no logner supported, use blit(source, target, opts)")();
        return null;
    }
    invalidate(_ref3) {
        let { attachments: attachments = [] , x: x = 0 , y: y = 0 , width: width , height: height  } = _ref3;
        const gl2 = (0, $325e733792a03f4e$export$22897d77b4bb5316)(this.gl);
        const prevHandle = gl2.bindFramebuffer(36008, this.handle);
        const invalidateAll = x === 0 && y === 0 && width === undefined && height === undefined;
        if (invalidateAll) gl2.invalidateFramebuffer(36008, attachments);
        else gl2.invalidateFramebuffer(36008, attachments, x, y, width, height);
        gl2.bindFramebuffer(36008, prevHandle);
        return this;
    }
    getAttachmentParameter(attachment, pname, keys) {
        let value = this._getAttachmentParameterFallback(pname);
        if (value === null) {
            this.gl.bindFramebuffer(36160, this.handle);
            value = this.gl.getFramebufferAttachmentParameter(36160, attachment, pname);
            this.gl.bindFramebuffer(36160, null);
        }
        if (keys && value > 1000) value = (0, $d2f1571231f3f4d0$export$a47fb462a08de82f)(this.gl, value);
        return value;
    }
    getAttachmentParameters() {
        let attachment = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 36064;
        let keys = arguments.length > 1 ? arguments[1] : undefined;
        let parameters = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.constructor.ATTACHMENT_PARAMETERS || [];
        const values = {};
        for (const pname of parameters){
            const key = keys ? (0, $d2f1571231f3f4d0$export$a47fb462a08de82f)(this.gl, pname) : pname;
            values[key] = this.getAttachmentParameter(attachment, pname, keys);
        }
        return values;
    }
    getParameters() {
        let keys = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
        const attachments = Object.keys(this.attachments);
        const parameters = {};
        for (const attachmentName of attachments){
            const attachment = Number(attachmentName);
            const key = keys ? (0, $d2f1571231f3f4d0$export$a47fb462a08de82f)(this.gl, attachment) : attachment;
            parameters[key] = this.getAttachmentParameters(attachment, keys);
        }
        return parameters;
    }
    show() {
        if (typeof window !== "undefined") window.open((0, $c192e756436d1779$export$310e97e05f1c81cc)(this), "luma-debug-texture");
        return this;
    }
    log() {
        let logLevel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        let message = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
        if (logLevel > (0, $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3).level || typeof window === "undefined") return this;
        message = message || "Framebuffer ".concat(this.id);
        const image = (0, $c192e756436d1779$export$310e97e05f1c81cc)(this, {
            targetMaxHeight: 100
        });
        (0, $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3).image({
            logLevel: logLevel,
            message: message,
            image: image
        }, message)();
        return this;
    }
    bind() {
        let { target: target = 36160  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        this.gl.bindFramebuffer(target, this.handle);
        return this;
    }
    unbind() {
        let { target: target = 36160  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        this.gl.bindFramebuffer(target, null);
        return this;
    }
    _createDefaultAttachments(color, depth, stencil, width, height) {
        let defaultAttachments = null;
        if (color) {
            defaultAttachments = defaultAttachments || {};
            defaultAttachments[36064] = new (0, $df31c887249e3faa$export$2e2bcd8739ae039)(this.gl, {
                id: "".concat(this.id, "-color0"),
                pixels: null,
                format: 6408,
                type: 5121,
                width: width,
                height: height,
                mipmaps: false,
                parameters: {
                    [10241]: 9729,
                    [10240]: 9729,
                    [10242]: 33071,
                    [10243]: 33071
                }
            });
            this.ownResources.push(defaultAttachments[36064]);
        }
        if (depth && stencil) {
            defaultAttachments = defaultAttachments || {};
            defaultAttachments[33306] = new (0, $0082476f18a250b0$export$2e2bcd8739ae039)(this.gl, {
                id: "".concat(this.id, "-depth-stencil"),
                format: 35056,
                width: width,
                height: 111
            });
            this.ownResources.push(defaultAttachments[33306]);
        } else if (depth) {
            defaultAttachments = defaultAttachments || {};
            defaultAttachments[36096] = new (0, $0082476f18a250b0$export$2e2bcd8739ae039)(this.gl, {
                id: "".concat(this.id, "-depth"),
                format: 33189,
                width: width,
                height: height
            });
            this.ownResources.push(defaultAttachments[36096]);
        } else if (stencil) (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(false);
        return defaultAttachments;
    }
    _unattach(attachment) {
        const oldAttachment = this.attachments[attachment];
        if (!oldAttachment) return;
        if (oldAttachment instanceof (0, $0082476f18a250b0$export$2e2bcd8739ae039)) this.gl.framebufferRenderbuffer(36160, attachment, 36161, null);
        else this.gl.framebufferTexture2D(36160, attachment, 3553, null, 0);
        delete this.attachments[attachment];
    }
    _attachRenderbuffer(_ref4) {
        let { attachment: attachment = 36064 , renderbuffer: renderbuffer  } = _ref4;
        const { gl: gl  } = this;
        gl.framebufferRenderbuffer(36160, attachment, 36161, renderbuffer.handle);
        this.attachments[attachment] = renderbuffer;
    }
    _attachTexture(_ref5) {
        let { attachment: attachment = 36064 , texture: texture , layer: layer , level: level  } = _ref5;
        const { gl: gl  } = this;
        gl.bindTexture(texture.target, texture.handle);
        switch(texture.target){
            case 35866:
            case 32879:
                const gl2 = (0, $325e733792a03f4e$export$22897d77b4bb5316)(gl);
                gl2.framebufferTextureLayer(36160, attachment, texture.target, level, layer);
                break;
            case 34067:
                const face = $a0e9e15bc57c4882$var$mapIndexToCubeMapFace(layer);
                gl.framebufferTexture2D(36160, attachment, face, texture.handle, level);
                break;
            case 3553:
                gl.framebufferTexture2D(36160, attachment, 3553, texture.handle, level);
                break;
            default:
                (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(false, "Illegal texture type");
        }
        gl.bindTexture(texture.target, null);
        this.attachments[attachment] = texture;
    }
    _setReadBuffer(readBuffer) {
        const gl2 = (0, $325e733792a03f4e$export$89dcfcb9130f2c28)(this.gl);
        if (gl2) gl2.readBuffer(readBuffer);
        else (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(readBuffer === 36064 || readBuffer === 1029, $a0e9e15bc57c4882$var$ERR_MULTIPLE_RENDERTARGETS);
        this.readBuffer = readBuffer;
    }
    _setDrawBuffers(drawBuffers) {
        const { gl: gl  } = this;
        const gl2 = (0, $325e733792a03f4e$export$22897d77b4bb5316)(gl);
        if (gl2) gl2.drawBuffers(drawBuffers);
        else {
            const ext = gl.getExtension("WEBGL_draw_buffers");
            if (ext) ext.drawBuffersWEBGL(drawBuffers);
            else (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(drawBuffers.length === 1 && (drawBuffers[0] === 36064 || drawBuffers[0] === 1029), $a0e9e15bc57c4882$var$ERR_MULTIPLE_RENDERTARGETS);
        }
        this.drawBuffers = drawBuffers;
    }
    _getAttachmentParameterFallback(pname) {
        const caps = (0, $75ff6bc03ebbcaf6$export$c5c8eb9e425b0de0)(this.gl);
        switch(pname){
            case 36052:
                return !caps.WEBGL2 ? 0 : null;
            case 33298:
            case 33299:
            case 33300:
            case 33301:
            case 33302:
            case 33303:
                return !caps.WEBGL2 ? 8 : null;
            case 33297:
                return !caps.WEBGL2 ? 5125 : null;
            case 33296:
                return !caps.WEBGL2 && !caps.EXT_sRGB ? 9729 : null;
            default:
                return null;
        }
    }
    _createHandle() {
        return this.gl.createFramebuffer();
    }
    _deleteHandle() {
        this.gl.deleteFramebuffer(this.handle);
    }
    _bindHandle(handle) {
        return this.gl.bindFramebuffer(36160, handle);
    }
}
function $a0e9e15bc57c4882$var$mapIndexToCubeMapFace(layer) {
    return layer < 34069 ? layer + 34069 : layer;
}
function $a0e9e15bc57c4882$var$_getFrameBufferStatus(status) {
    const STATUS = $a0e9e15bc57c4882$export$2e2bcd8739ae039.STATUS || {};
    return STATUS[status] || "Framebuffer error ".concat(status);
}
const $a0e9e15bc57c4882$export$9bc39e54f49ae5f4 = [
    36049,
    36048,
    33296,
    33298,
    33299,
    33300,
    33301,
    33302,
    33303
];
$a0e9e15bc57c4882$export$2e2bcd8739ae039.ATTACHMENT_PARAMETERS = $a0e9e15bc57c4882$export$9bc39e54f49ae5f4;



function $379077f7c038ee76$export$a502ec217e00cfb1(refTexture, overrides) {
    (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(refTexture instanceof (0, $df31c887249e3faa$export$2e2bcd8739ae039) || refTexture instanceof (0, $499b8d3cccd7f89c$export$2e2bcd8739ae039) || refTexture instanceof (0, $4aa833ce3ed7a225$export$2e2bcd8739ae039));
    const TextureType = refTexture.constructor;
    const { gl: gl , width: width , height: height , format: format , type: type , dataFormat: dataFormat , border: border , mipmaps: mipmaps  } = refTexture;
    const textureOptions = Object.assign({
        width: width,
        height: height,
        format: format,
        type: type,
        dataFormat: dataFormat,
        border: border,
        mipmaps: mipmaps
    }, overrides);
    return new TextureType(gl, textureOptions);
}
function $379077f7c038ee76$export$37e0e55400e095ba(texture, opts) {
    const { gl: gl , width: width , height: height , id: id  } = texture;
    const framebuffer = new (0, $a0e9e15bc57c4882$export$2e2bcd8739ae039)(gl, Object.assign({}, opts, {
        id: "framebuffer-for-".concat(id),
        width: width,
        height: height,
        attachments: {
            [36064]: texture
        }
    }));
    return framebuffer;
}









const $b100fa53b681ec78$var$UNIFORM_SETTERS = {
    [5126]: $b100fa53b681ec78$var$getArraySetter.bind(null, "uniform1fv", $b100fa53b681ec78$var$toFloatArray, 1, $b100fa53b681ec78$var$setVectorUniform),
    [35664]: $b100fa53b681ec78$var$getArraySetter.bind(null, "uniform2fv", $b100fa53b681ec78$var$toFloatArray, 2, $b100fa53b681ec78$var$setVectorUniform),
    [35665]: $b100fa53b681ec78$var$getArraySetter.bind(null, "uniform3fv", $b100fa53b681ec78$var$toFloatArray, 3, $b100fa53b681ec78$var$setVectorUniform),
    [35666]: $b100fa53b681ec78$var$getArraySetter.bind(null, "uniform4fv", $b100fa53b681ec78$var$toFloatArray, 4, $b100fa53b681ec78$var$setVectorUniform),
    [5124]: $b100fa53b681ec78$var$getArraySetter.bind(null, "uniform1iv", $b100fa53b681ec78$var$toIntArray, 1, $b100fa53b681ec78$var$setVectorUniform),
    [35667]: $b100fa53b681ec78$var$getArraySetter.bind(null, "uniform2iv", $b100fa53b681ec78$var$toIntArray, 2, $b100fa53b681ec78$var$setVectorUniform),
    [35668]: $b100fa53b681ec78$var$getArraySetter.bind(null, "uniform3iv", $b100fa53b681ec78$var$toIntArray, 3, $b100fa53b681ec78$var$setVectorUniform),
    [35669]: $b100fa53b681ec78$var$getArraySetter.bind(null, "uniform4iv", $b100fa53b681ec78$var$toIntArray, 4, $b100fa53b681ec78$var$setVectorUniform),
    [35670]: $b100fa53b681ec78$var$getArraySetter.bind(null, "uniform1iv", $b100fa53b681ec78$var$toIntArray, 1, $b100fa53b681ec78$var$setVectorUniform),
    [35671]: $b100fa53b681ec78$var$getArraySetter.bind(null, "uniform2iv", $b100fa53b681ec78$var$toIntArray, 2, $b100fa53b681ec78$var$setVectorUniform),
    [35672]: $b100fa53b681ec78$var$getArraySetter.bind(null, "uniform3iv", $b100fa53b681ec78$var$toIntArray, 3, $b100fa53b681ec78$var$setVectorUniform),
    [35673]: $b100fa53b681ec78$var$getArraySetter.bind(null, "uniform4iv", $b100fa53b681ec78$var$toIntArray, 4, $b100fa53b681ec78$var$setVectorUniform),
    [35674]: $b100fa53b681ec78$var$getArraySetter.bind(null, "uniformMatrix2fv", $b100fa53b681ec78$var$toFloatArray, 4, $b100fa53b681ec78$var$setMatrixUniform),
    [35675]: $b100fa53b681ec78$var$getArraySetter.bind(null, "uniformMatrix3fv", $b100fa53b681ec78$var$toFloatArray, 9, $b100fa53b681ec78$var$setMatrixUniform),
    [35676]: $b100fa53b681ec78$var$getArraySetter.bind(null, "uniformMatrix4fv", $b100fa53b681ec78$var$toFloatArray, 16, $b100fa53b681ec78$var$setMatrixUniform),
    [35678]: $b100fa53b681ec78$var$getSamplerSetter,
    [35680]: $b100fa53b681ec78$var$getSamplerSetter,
    [5125]: $b100fa53b681ec78$var$getArraySetter.bind(null, "uniform1uiv", $b100fa53b681ec78$var$toUIntArray, 1, $b100fa53b681ec78$var$setVectorUniform),
    [36294]: $b100fa53b681ec78$var$getArraySetter.bind(null, "uniform2uiv", $b100fa53b681ec78$var$toUIntArray, 2, $b100fa53b681ec78$var$setVectorUniform),
    [36295]: $b100fa53b681ec78$var$getArraySetter.bind(null, "uniform3uiv", $b100fa53b681ec78$var$toUIntArray, 3, $b100fa53b681ec78$var$setVectorUniform),
    [36296]: $b100fa53b681ec78$var$getArraySetter.bind(null, "uniform4uiv", $b100fa53b681ec78$var$toUIntArray, 4, $b100fa53b681ec78$var$setVectorUniform),
    [35685]: $b100fa53b681ec78$var$getArraySetter.bind(null, "uniformMatrix2x3fv", $b100fa53b681ec78$var$toFloatArray, 6, $b100fa53b681ec78$var$setMatrixUniform),
    [35686]: $b100fa53b681ec78$var$getArraySetter.bind(null, "uniformMatrix2x4fv", $b100fa53b681ec78$var$toFloatArray, 8, $b100fa53b681ec78$var$setMatrixUniform),
    [35687]: $b100fa53b681ec78$var$getArraySetter.bind(null, "uniformMatrix3x2fv", $b100fa53b681ec78$var$toFloatArray, 6, $b100fa53b681ec78$var$setMatrixUniform),
    [35688]: $b100fa53b681ec78$var$getArraySetter.bind(null, "uniformMatrix3x4fv", $b100fa53b681ec78$var$toFloatArray, 12, $b100fa53b681ec78$var$setMatrixUniform),
    [35689]: $b100fa53b681ec78$var$getArraySetter.bind(null, "uniformMatrix4x2fv", $b100fa53b681ec78$var$toFloatArray, 8, $b100fa53b681ec78$var$setMatrixUniform),
    [35690]: $b100fa53b681ec78$var$getArraySetter.bind(null, "uniformMatrix4x3fv", $b100fa53b681ec78$var$toFloatArray, 12, $b100fa53b681ec78$var$setMatrixUniform),
    [35678]: $b100fa53b681ec78$var$getSamplerSetter,
    [35680]: $b100fa53b681ec78$var$getSamplerSetter,
    [35679]: $b100fa53b681ec78$var$getSamplerSetter,
    [35682]: $b100fa53b681ec78$var$getSamplerSetter,
    [36289]: $b100fa53b681ec78$var$getSamplerSetter,
    [36292]: $b100fa53b681ec78$var$getSamplerSetter,
    [36293]: $b100fa53b681ec78$var$getSamplerSetter,
    [36298]: $b100fa53b681ec78$var$getSamplerSetter,
    [36299]: $b100fa53b681ec78$var$getSamplerSetter,
    [36300]: $b100fa53b681ec78$var$getSamplerSetter,
    [36303]: $b100fa53b681ec78$var$getSamplerSetter,
    [36306]: $b100fa53b681ec78$var$getSamplerSetter,
    [36307]: $b100fa53b681ec78$var$getSamplerSetter,
    [36308]: $b100fa53b681ec78$var$getSamplerSetter,
    [36311]: $b100fa53b681ec78$var$getSamplerSetter
};
const $b100fa53b681ec78$var$FLOAT_ARRAY = {};
const $b100fa53b681ec78$var$INT_ARRAY = {};
const $b100fa53b681ec78$var$UINT_ARRAY = {};
const $b100fa53b681ec78$var$array1 = [
    0
];
function $b100fa53b681ec78$var$toTypedArray(value, uniformLength, Type, cache) {
    if (uniformLength === 1 && typeof value === "boolean") value = value ? 1 : 0;
    if (Number.isFinite(value)) {
        $b100fa53b681ec78$var$array1[0] = value;
        value = $b100fa53b681ec78$var$array1;
    }
    const length = value.length;
    if (length % uniformLength) (0, $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3).warn("Uniform size should be multiples of ".concat(uniformLength), value)();
    if (value instanceof Type) return value;
    let result = cache[length];
    if (!result) {
        result = new Type(length);
        cache[length] = result;
    }
    for(let i = 0; i < length; i++)result[i] = value[i];
    return result;
}
function $b100fa53b681ec78$var$toFloatArray(value, uniformLength) {
    return $b100fa53b681ec78$var$toTypedArray(value, uniformLength, Float32Array, $b100fa53b681ec78$var$FLOAT_ARRAY);
}
function $b100fa53b681ec78$var$toIntArray(value, uniformLength) {
    return $b100fa53b681ec78$var$toTypedArray(value, uniformLength, Int32Array, $b100fa53b681ec78$var$INT_ARRAY);
}
function $b100fa53b681ec78$var$toUIntArray(value, uniformLength) {
    return $b100fa53b681ec78$var$toTypedArray(value, uniformLength, Uint32Array, $b100fa53b681ec78$var$UINT_ARRAY);
}
function $b100fa53b681ec78$export$c2b5b6d0be3c2cf0(gl, location, info) {
    const setter = $b100fa53b681ec78$var$UNIFORM_SETTERS[info.type];
    if (!setter) throw new Error("Unknown GLSL uniform type ".concat(info.type));
    return setter().bind(null, gl, location);
}
function $b100fa53b681ec78$export$ae5f39dc6a50a1c7(name) {
    if (name[name.length - 1] !== "]") return {
        name: name,
        length: 1,
        isArray: false
    };
    const UNIFORM_NAME_REGEXP = /([^[]*)(\[[0-9]+\])?/;
    const matches = name.match(UNIFORM_NAME_REGEXP);
    if (!matches || matches.length < 2) throw new Error("Failed to parse GLSL uniform name ".concat(name));
    return {
        name: matches[1],
        length: matches[2] || 1,
        isArray: Boolean(matches[2])
    };
}
function $b100fa53b681ec78$export$c83bcc63b305493(uniforms, source, uniformMap) {
    for(const uniformName in uniforms){
        const value = uniforms[uniformName];
        const shouldCheck = !uniformMap || Boolean(uniformMap[uniformName]);
        if (shouldCheck && !$b100fa53b681ec78$var$checkUniformValue(value)) {
            source = source ? "".concat(source, " ") : "";
            console.error("".concat(source, " Bad uniform ").concat(uniformName), value);
            throw new Error("".concat(source, " Bad uniform ").concat(uniformName));
        }
    }
    return true;
}
function $b100fa53b681ec78$var$checkUniformValue(value) {
    if (Array.isArray(value) || ArrayBuffer.isView(value)) return $b100fa53b681ec78$var$checkUniformArray(value);
    if (isFinite(value)) return true;
    else if (value === true || value === false) return true;
    else if (value instanceof (0, $541c007d64b391ad$export$2e2bcd8739ae039)) return true;
    else if (value instanceof (0, $0082476f18a250b0$export$2e2bcd8739ae039)) return true;
    else if (value instanceof (0, $a0e9e15bc57c4882$export$2e2bcd8739ae039)) return Boolean(value.texture);
    return false;
}
function $b100fa53b681ec78$export$5ced140387f3d289(uniforms, key, value) {
    if (Array.isArray(value) || ArrayBuffer.isView(value)) {
        if (uniforms[key]) {
            const dest = uniforms[key];
            for(let i = 0, len = value.length; i < len; ++i)dest[i] = value[i];
        } else uniforms[key] = value.slice();
    } else uniforms[key] = value;
}
function $b100fa53b681ec78$var$checkUniformArray(value) {
    if (value.length === 0) return false;
    const checkLength = Math.min(value.length, 16);
    for(let i = 0; i < checkLength; ++i){
        if (!Number.isFinite(value[i])) return false;
    }
    return true;
}
function $b100fa53b681ec78$var$getSamplerSetter() {
    let cache = null;
    return (gl, location, value)=>{
        const update = cache !== value;
        if (update) {
            gl.uniform1i(location, value);
            cache = value;
        }
        return update;
    };
}
function $b100fa53b681ec78$var$getArraySetter(functionName, toArray, size, uniformSetter) {
    let cache = null;
    let cacheLength = null;
    return (gl, location, value)=>{
        const arrayValue = toArray(value, size);
        const length = arrayValue.length;
        let update = false;
        if (cache === null) {
            cache = new Float32Array(length);
            cacheLength = length;
            update = true;
        } else {
            (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(cacheLength === length, "Uniform length cannot change.");
            for(let i = 0; i < length; ++i)if (arrayValue[i] !== cache[i]) {
                update = true;
                break;
            }
        }
        if (update) {
            uniformSetter(gl, functionName, location, arrayValue);
            cache.set(arrayValue);
        }
        return update;
    };
}
function $b100fa53b681ec78$var$setVectorUniform(gl, functionName, location, value) {
    gl[functionName](location, value);
}
function $b100fa53b681ec78$var$setMatrixUniform(gl, functionName, location, value) {
    gl[functionName](location, false, value);
}



function $9ff4328555aea35a$export$2e2bcd8739ae039(shader) {
    let defaultName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "unnamed";
    const SHADER_NAME_REGEXP = /#define[\s*]SHADER_NAME[\s*]([A-Za-z0-9_-]+)[\s*]/;
    const match = shader.match(SHADER_NAME_REGEXP);
    return match ? match[1] : defaultName;
}


const $29004a5c99443ec5$var$GL_FRAGMENT_SHADER = 0x8b30;
const $29004a5c99443ec5$var$GL_VERTEX_SHADER = 0x8b31;
function $29004a5c99443ec5$export$2e2bcd8739ae039(type) {
    switch(type){
        case $29004a5c99443ec5$var$GL_FRAGMENT_SHADER:
            return "fragment";
        case $29004a5c99443ec5$var$GL_VERTEX_SHADER:
            return "vertex";
        default:
            return "unknown type";
    }
}


function $014ecae11c365433$export$2e2bcd8739ae039(errLog, src, shaderType) {
    const { shaderName: shaderName , errors: errors , warnings: warnings  } = $014ecae11c365433$export$b279b0ccf17fdc42(errLog, src, shaderType);
    return "GLSL compilation error in ".concat(shaderName, "\n\n").concat(errors, "\n").concat(warnings);
}
function $014ecae11c365433$export$b279b0ccf17fdc42(errLog, src, shaderType, shaderName) {
    const errorStrings = errLog.split(/\r?\n/);
    const errors = {};
    const warnings = {};
    const name = shaderName || (0, $9ff4328555aea35a$export$2e2bcd8739ae039)(src) || "(unnamed)";
    const shaderDescription = "".concat((0, $29004a5c99443ec5$export$2e2bcd8739ae039)(shaderType), " shader ").concat(name);
    for(let i = 0; i < errorStrings.length; i++){
        const errorString = errorStrings[i];
        if (errorString.length <= 1) continue;
        const segments = errorString.split(":");
        const type = segments[0];
        const line = parseInt(segments[2], 10);
        if (isNaN(line)) throw new Error("GLSL compilation error in ".concat(shaderDescription, ": ").concat(errLog));
        if (type !== "WARNING") errors[line] = errorString;
        else warnings[line] = errorString;
    }
    const lines = $014ecae11c365433$var$addLineNumbers(src);
    return {
        shaderName: shaderDescription,
        errors: $014ecae11c365433$var$formatErrors(errors, lines),
        warnings: $014ecae11c365433$var$formatErrors(warnings, lines)
    };
}
function $014ecae11c365433$var$formatErrors(errors, lines) {
    let message = "";
    for(let i = 0; i < lines.length; i++){
        const line = lines[i];
        if (!errors[i + 3] && !errors[i + 2] && !errors[i + 1]) continue;
        message += "".concat(line, "\n");
        if (errors[i + 1]) {
            const error = errors[i + 1];
            const segments = error.split(":", 3);
            const type = segments[0];
            const column = parseInt(segments[1], 10) || 0;
            const err = error.substring(segments.join(":").length + 1).trim();
            message += $014ecae11c365433$var$padLeft("^^^ ".concat(type, ": ").concat(err, "\n\n"), column);
        }
    }
    return message;
}
function $014ecae11c365433$var$addLineNumbers(string) {
    let start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    let delim = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ": ";
    const lines = string.split(/\r?\n/);
    const maxDigits = String(lines.length + start - 1).length;
    return lines.map((line, i)=>{
        const lineNumber = String(i + start);
        const digits = lineNumber.length;
        const prefix = $014ecae11c365433$var$padLeft(lineNumber, maxDigits - digits);
        return prefix + delim + line;
    });
}
function $014ecae11c365433$var$padLeft(string, digits) {
    let result = "";
    for(let i = 0; i < digits; ++i)result += " ";
    return "".concat(result).concat(string);
}






const $4700f6e92300c9e2$var$ERR_SOURCE = "Shader: GLSL source code must be a JavaScript string";
class $4700f6e92300c9e2$export$462bb059fed9d9e5 extends (0, $dabe379caebdf3da$export$2e2bcd8739ae039) {
    get [Symbol.toStringTag]() {
        return "Shader";
    }
    static getTypeName(shaderType) {
        switch(shaderType){
            case 35633:
                return "vertex-shader";
            case 35632:
                return "fragment-shader";
            default:
                (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(false);
                return "unknown";
        }
    }
    constructor(gl, props){
        (0, $325e733792a03f4e$export$9b0605fd3c935712)(gl);
        (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(typeof props.source === "string", $4700f6e92300c9e2$var$ERR_SOURCE);
        const id = (0, $9ff4328555aea35a$export$2e2bcd8739ae039)(props.source, null) || props.id || (0, $757dc76705f498e6$export$e2a22331486dcca0)("unnamed ".concat($4700f6e92300c9e2$export$462bb059fed9d9e5.getTypeName(props.shaderType)));
        super(gl, {
            id: id
        });
        this.shaderType = props.shaderType;
        this.source = props.source;
        this.initialize(props);
    }
    initialize(_ref) {
        let { source: source  } = _ref;
        const shaderName = (0, $9ff4328555aea35a$export$2e2bcd8739ae039)(source, null);
        if (shaderName) this.id = (0, $757dc76705f498e6$export$e2a22331486dcca0)(shaderName);
        this._compile(source);
    }
    getParameter(pname) {
        return this.gl.getShaderParameter(this.handle, pname);
    }
    toString() {
        return "".concat($4700f6e92300c9e2$export$462bb059fed9d9e5.getTypeName(this.shaderType), ":").concat(this.id);
    }
    getName() {
        return (0, $9ff4328555aea35a$export$2e2bcd8739ae039)(this.source) || "unnamed-shader";
    }
    getSource() {
        return this.gl.getShaderSource(this.handle);
    }
    getTranslatedSource() {
        const extension = this.gl.getExtension("WEBGL_debug_shaders");
        return extension ? extension.getTranslatedShaderSource(this.handle) : "No translated source available. WEBGL_debug_shaders not implemented";
    }
    _compile() {
        let source = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.source;
        if (!source.startsWith("#version ")) source = "#version 100\n".concat(source);
        this.source = source;
        this.gl.shaderSource(this.handle, this.source);
        this.gl.compileShader(this.handle);
        const compileStatus = this.getParameter(35713);
        if (!compileStatus) {
            const infoLog = this.gl.getShaderInfoLog(this.handle);
            const { shaderName: shaderName , errors: errors , warnings: warnings  } = (0, $014ecae11c365433$export$b279b0ccf17fdc42)(infoLog, this.source, this.shaderType, this.id);
            (0, $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3).error("GLSL compilation errors in ".concat(shaderName, "\n").concat(errors))();
            (0, $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3).warn("GLSL compilation warnings in ".concat(shaderName, "\n").concat(warnings))();
            throw new Error("GLSL compilation errors in ".concat(shaderName));
        }
    }
    _deleteHandle() {
        this.gl.deleteShader(this.handle);
    }
    _getOptsFromHandle() {
        return {
            type: this.getParameter(35663),
            source: this.getSource()
        };
    }
}
class $4700f6e92300c9e2$export$cb28509c217600d2 extends $4700f6e92300c9e2$export$462bb059fed9d9e5 {
    get [Symbol.toStringTag]() {
        return "VertexShader";
    }
    constructor(gl, props){
        if (typeof props === "string") props = {
            source: props
        };
        super(gl, Object.assign({}, props, {
            shaderType: 35633
        }));
    }
    _createHandle() {
        return this.gl.createShader(35633);
    }
}
class $4700f6e92300c9e2$export$2d38bde43c53f87a extends $4700f6e92300c9e2$export$462bb059fed9d9e5 {
    get [Symbol.toStringTag]() {
        return "FragmentShader";
    }
    constructor(gl, props){
        if (typeof props === "string") props = {
            source: props
        };
        super(gl, Object.assign({}, props, {
            shaderType: 35632
        }));
    }
    _createHandle() {
        return this.gl.createShader(35632);
    }
}





const $dd1bd7730cbb49ac$var$GL_BYTE = 0x1400;
const $dd1bd7730cbb49ac$var$GL_UNSIGNED_BYTE = 0x1401;
const $dd1bd7730cbb49ac$var$GL_SHORT = 0x1402;
const $dd1bd7730cbb49ac$var$GL_UNSIGNED_SHORT = 0x1403;
const $dd1bd7730cbb49ac$var$GL_POINTS = 0x0;
const $dd1bd7730cbb49ac$var$GL_LINES = 0x1;
const $dd1bd7730cbb49ac$var$GL_LINE_LOOP = 0x2;
const $dd1bd7730cbb49ac$var$GL_LINE_STRIP = 0x3;
const $dd1bd7730cbb49ac$var$GL_TRIANGLES = 0x4;
const $dd1bd7730cbb49ac$var$GL_TRIANGLE_STRIP = 0x5;
const $dd1bd7730cbb49ac$var$GL_TRIANGLE_FAN = 0x6;
const $dd1bd7730cbb49ac$var$GL_FLOAT = 0x1406;
const $dd1bd7730cbb49ac$var$GL_FLOAT_VEC2 = 0x8b50;
const $dd1bd7730cbb49ac$var$GL_FLOAT_VEC3 = 0x8b51;
const $dd1bd7730cbb49ac$var$GL_FLOAT_VEC4 = 0x8b52;
const $dd1bd7730cbb49ac$var$GL_INT = 0x1404;
const $dd1bd7730cbb49ac$var$GL_INT_VEC2 = 0x8b53;
const $dd1bd7730cbb49ac$var$GL_INT_VEC3 = 0x8b54;
const $dd1bd7730cbb49ac$var$GL_INT_VEC4 = 0x8b55;
const $dd1bd7730cbb49ac$var$GL_UNSIGNED_INT = 0x1405;
const $dd1bd7730cbb49ac$var$GL_UNSIGNED_INT_VEC2 = 0x8dc6;
const $dd1bd7730cbb49ac$var$GL_UNSIGNED_INT_VEC3 = 0x8dc7;
const $dd1bd7730cbb49ac$var$GL_UNSIGNED_INT_VEC4 = 0x8dc8;
const $dd1bd7730cbb49ac$var$GL_BOOL = 0x8b56;
const $dd1bd7730cbb49ac$var$GL_BOOL_VEC2 = 0x8b57;
const $dd1bd7730cbb49ac$var$GL_BOOL_VEC3 = 0x8b58;
const $dd1bd7730cbb49ac$var$GL_BOOL_VEC4 = 0x8b59;
const $dd1bd7730cbb49ac$var$GL_FLOAT_MAT2 = 0x8b5a;
const $dd1bd7730cbb49ac$var$GL_FLOAT_MAT3 = 0x8b5b;
const $dd1bd7730cbb49ac$var$GL_FLOAT_MAT4 = 0x8b5c;
const $dd1bd7730cbb49ac$var$GL_FLOAT_MAT2x3 = 0x8b65;
const $dd1bd7730cbb49ac$var$GL_FLOAT_MAT2x4 = 0x8b66;
const $dd1bd7730cbb49ac$var$GL_FLOAT_MAT3x2 = 0x8b67;
const $dd1bd7730cbb49ac$var$GL_FLOAT_MAT3x4 = 0x8b68;
const $dd1bd7730cbb49ac$var$GL_FLOAT_MAT4x2 = 0x8b69;
const $dd1bd7730cbb49ac$var$GL_FLOAT_MAT4x3 = 0x8b6a;
const $dd1bd7730cbb49ac$var$COMPOSITE_GL_TYPES = {
    [$dd1bd7730cbb49ac$var$GL_FLOAT]: [
        $dd1bd7730cbb49ac$var$GL_FLOAT,
        1,
        "float"
    ],
    [$dd1bd7730cbb49ac$var$GL_FLOAT_VEC2]: [
        $dd1bd7730cbb49ac$var$GL_FLOAT,
        2,
        "vec2"
    ],
    [$dd1bd7730cbb49ac$var$GL_FLOAT_VEC3]: [
        $dd1bd7730cbb49ac$var$GL_FLOAT,
        3,
        "vec3"
    ],
    [$dd1bd7730cbb49ac$var$GL_FLOAT_VEC4]: [
        $dd1bd7730cbb49ac$var$GL_FLOAT,
        4,
        "vec4"
    ],
    [$dd1bd7730cbb49ac$var$GL_INT]: [
        $dd1bd7730cbb49ac$var$GL_INT,
        1,
        "int"
    ],
    [$dd1bd7730cbb49ac$var$GL_INT_VEC2]: [
        $dd1bd7730cbb49ac$var$GL_INT,
        2,
        "ivec2"
    ],
    [$dd1bd7730cbb49ac$var$GL_INT_VEC3]: [
        $dd1bd7730cbb49ac$var$GL_INT,
        3,
        "ivec3"
    ],
    [$dd1bd7730cbb49ac$var$GL_INT_VEC4]: [
        $dd1bd7730cbb49ac$var$GL_INT,
        4,
        "ivec4"
    ],
    [$dd1bd7730cbb49ac$var$GL_UNSIGNED_INT]: [
        $dd1bd7730cbb49ac$var$GL_UNSIGNED_INT,
        1,
        "uint"
    ],
    [$dd1bd7730cbb49ac$var$GL_UNSIGNED_INT_VEC2]: [
        $dd1bd7730cbb49ac$var$GL_UNSIGNED_INT,
        2,
        "uvec2"
    ],
    [$dd1bd7730cbb49ac$var$GL_UNSIGNED_INT_VEC3]: [
        $dd1bd7730cbb49ac$var$GL_UNSIGNED_INT,
        3,
        "uvec3"
    ],
    [$dd1bd7730cbb49ac$var$GL_UNSIGNED_INT_VEC4]: [
        $dd1bd7730cbb49ac$var$GL_UNSIGNED_INT,
        4,
        "uvec4"
    ],
    [$dd1bd7730cbb49ac$var$GL_BOOL]: [
        $dd1bd7730cbb49ac$var$GL_FLOAT,
        1,
        "bool"
    ],
    [$dd1bd7730cbb49ac$var$GL_BOOL_VEC2]: [
        $dd1bd7730cbb49ac$var$GL_FLOAT,
        2,
        "bvec2"
    ],
    [$dd1bd7730cbb49ac$var$GL_BOOL_VEC3]: [
        $dd1bd7730cbb49ac$var$GL_FLOAT,
        3,
        "bvec3"
    ],
    [$dd1bd7730cbb49ac$var$GL_BOOL_VEC4]: [
        $dd1bd7730cbb49ac$var$GL_FLOAT,
        4,
        "bvec4"
    ],
    [$dd1bd7730cbb49ac$var$GL_FLOAT_MAT2]: [
        $dd1bd7730cbb49ac$var$GL_FLOAT,
        8,
        "mat2"
    ],
    [$dd1bd7730cbb49ac$var$GL_FLOAT_MAT2x3]: [
        $dd1bd7730cbb49ac$var$GL_FLOAT,
        8,
        "mat2x3"
    ],
    [$dd1bd7730cbb49ac$var$GL_FLOAT_MAT2x4]: [
        $dd1bd7730cbb49ac$var$GL_FLOAT,
        8,
        "mat2x4"
    ],
    [$dd1bd7730cbb49ac$var$GL_FLOAT_MAT3]: [
        $dd1bd7730cbb49ac$var$GL_FLOAT,
        12,
        "mat3"
    ],
    [$dd1bd7730cbb49ac$var$GL_FLOAT_MAT3x2]: [
        $dd1bd7730cbb49ac$var$GL_FLOAT,
        12,
        "mat3x2"
    ],
    [$dd1bd7730cbb49ac$var$GL_FLOAT_MAT3x4]: [
        $dd1bd7730cbb49ac$var$GL_FLOAT,
        12,
        "mat3x4"
    ],
    [$dd1bd7730cbb49ac$var$GL_FLOAT_MAT4]: [
        $dd1bd7730cbb49ac$var$GL_FLOAT,
        16,
        "mat4"
    ],
    [$dd1bd7730cbb49ac$var$GL_FLOAT_MAT4x2]: [
        $dd1bd7730cbb49ac$var$GL_FLOAT,
        16,
        "mat4x2"
    ],
    [$dd1bd7730cbb49ac$var$GL_FLOAT_MAT4x3]: [
        $dd1bd7730cbb49ac$var$GL_FLOAT,
        16,
        "mat4x3"
    ]
};
function $dd1bd7730cbb49ac$export$e50fcedcdc9b2c73(drawMode) {
    switch(drawMode){
        case $dd1bd7730cbb49ac$var$GL_POINTS:
            return $dd1bd7730cbb49ac$var$GL_POINTS;
        case $dd1bd7730cbb49ac$var$GL_LINES:
            return $dd1bd7730cbb49ac$var$GL_LINES;
        case $dd1bd7730cbb49ac$var$GL_LINE_STRIP:
            return $dd1bd7730cbb49ac$var$GL_LINES;
        case $dd1bd7730cbb49ac$var$GL_LINE_LOOP:
            return $dd1bd7730cbb49ac$var$GL_LINES;
        case $dd1bd7730cbb49ac$var$GL_TRIANGLES:
            return $dd1bd7730cbb49ac$var$GL_TRIANGLES;
        case $dd1bd7730cbb49ac$var$GL_TRIANGLE_STRIP:
            return $dd1bd7730cbb49ac$var$GL_TRIANGLES;
        case $dd1bd7730cbb49ac$var$GL_TRIANGLE_FAN:
            return $dd1bd7730cbb49ac$var$GL_TRIANGLES;
        default:
            (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(false);
            return 0;
    }
}
function $dd1bd7730cbb49ac$export$eee3601b0ff4cdda(_ref) {
    let { drawMode: drawMode , vertexCount: vertexCount  } = _ref;
    switch(drawMode){
        case $dd1bd7730cbb49ac$var$GL_POINTS:
        case $dd1bd7730cbb49ac$var$GL_LINE_LOOP:
            return vertexCount;
        case $dd1bd7730cbb49ac$var$GL_LINES:
            return vertexCount / 2;
        case $dd1bd7730cbb49ac$var$GL_LINE_STRIP:
            return vertexCount - 1;
        case $dd1bd7730cbb49ac$var$GL_TRIANGLES:
            return vertexCount / 3;
        case $dd1bd7730cbb49ac$var$GL_TRIANGLE_STRIP:
        case $dd1bd7730cbb49ac$var$GL_TRIANGLE_FAN:
            return vertexCount - 2;
        default:
            (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(false);
            return 0;
    }
}
function $dd1bd7730cbb49ac$export$bb010cc24ecaa644(_ref2) {
    let { drawMode: drawMode , vertexCount: vertexCount  } = _ref2;
    const primitiveCount = $dd1bd7730cbb49ac$export$eee3601b0ff4cdda({
        drawMode: drawMode,
        vertexCount: vertexCount
    });
    switch($dd1bd7730cbb49ac$export$e50fcedcdc9b2c73(drawMode)){
        case $dd1bd7730cbb49ac$var$GL_POINTS:
            return primitiveCount;
        case $dd1bd7730cbb49ac$var$GL_LINES:
            return primitiveCount * 2;
        case $dd1bd7730cbb49ac$var$GL_TRIANGLES:
            return primitiveCount * 3;
        default:
            (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(false);
            return 0;
    }
}
function $dd1bd7730cbb49ac$export$646982523c4faa11(compositeGLType) {
    const typeAndSize = $dd1bd7730cbb49ac$var$COMPOSITE_GL_TYPES[compositeGLType];
    if (!typeAndSize) return null;
    const [type, components] = typeAndSize;
    return {
        type: type,
        components: components
    };
}
function $dd1bd7730cbb49ac$export$508acc40581a1522(type, components) {
    switch(type){
        case $dd1bd7730cbb49ac$var$GL_BYTE:
        case $dd1bd7730cbb49ac$var$GL_UNSIGNED_BYTE:
        case $dd1bd7730cbb49ac$var$GL_SHORT:
        case $dd1bd7730cbb49ac$var$GL_UNSIGNED_SHORT:
            type = $dd1bd7730cbb49ac$var$GL_FLOAT;
            break;
        default:
    }
    for(const glType in $dd1bd7730cbb49ac$var$COMPOSITE_GL_TYPES){
        const [compType, compComponents, name] = $dd1bd7730cbb49ac$var$COMPOSITE_GL_TYPES[glType];
        if (compType === type && compComponents === components) return {
            glType: glType,
            name: name
        };
    }
    return null;
}


class $df93dc3d9cc17a6d$export$2e2bcd8739ae039 {
    constructor(program){
        this.id = program.id;
        this.attributeInfos = [];
        this.attributeInfosByName = {};
        this.attributeInfosByLocation = [];
        this.varyingInfos = [];
        this.varyingInfosByName = {};
        Object.seal(this);
        this._readAttributesFromProgram(program);
        this._readVaryingsFromProgram(program);
    }
    getAttributeInfo(locationOrName) {
        const location = Number(locationOrName);
        if (Number.isFinite(location)) return this.attributeInfosByLocation[location];
        return this.attributeInfosByName[locationOrName] || null;
    }
    getAttributeLocation(locationOrName) {
        const attributeInfo = this.getAttributeInfo(locationOrName);
        return attributeInfo ? attributeInfo.location : -1;
    }
    getAttributeAccessor(locationOrName) {
        const attributeInfo = this.getAttributeInfo(locationOrName);
        return attributeInfo ? attributeInfo.accessor : null;
    }
    getVaryingInfo(locationOrName) {
        const location = Number(locationOrName);
        if (Number.isFinite(location)) return this.varyingInfos[location];
        return this.varyingInfosByName[locationOrName] || null;
    }
    getVaryingIndex(locationOrName) {
        const varying = this.getVaryingInfo();
        return varying ? varying.location : -1;
    }
    getVaryingAccessor(locationOrName) {
        const varying = this.getVaryingInfo();
        return varying ? varying.accessor : null;
    }
    _readAttributesFromProgram(program) {
        const { gl: gl  } = program;
        const count = gl.getProgramParameter(program.handle, 35721);
        for(let index = 0; index < count; index++){
            const { name: name , type: type , size: size  } = gl.getActiveAttrib(program.handle, index);
            const location = gl.getAttribLocation(program.handle, name);
            if (location >= 0) this._addAttribute(location, name, type, size);
        }
        this.attributeInfos.sort((a, b)=>a.location - b.location);
    }
    _readVaryingsFromProgram(program) {
        const { gl: gl  } = program;
        if (!(0, $325e733792a03f4e$export$e3518b1ac7891039)(gl)) return;
        const count = gl.getProgramParameter(program.handle, 35971);
        for(let location = 0; location < count; location++){
            const { name: name , type: type , size: size  } = gl.getTransformFeedbackVarying(program.handle, location);
            this._addVarying(location, name, type, size);
        }
        this.varyingInfos.sort((a, b)=>a.location - b.location);
    }
    _addAttribute(location, name, compositeType, size) {
        const { type: type , components: components  } = (0, $dd1bd7730cbb49ac$export$646982523c4faa11)(compositeType);
        const accessor = {
            type: type,
            size: size * components
        };
        this._inferProperties(location, name, accessor);
        const attributeInfo = {
            location: location,
            name: name,
            accessor: new (0, $905df3b590d61c61$export$2e2bcd8739ae039)(accessor)
        };
        this.attributeInfos.push(attributeInfo);
        this.attributeInfosByLocation[location] = attributeInfo;
        this.attributeInfosByName[attributeInfo.name] = attributeInfo;
    }
    _inferProperties(location, name, accessor) {
        if (/instance/i.test(name)) accessor.divisor = 1;
    }
    _addVarying(location, name, compositeType, size) {
        const { type: type , components: components  } = (0, $dd1bd7730cbb49ac$export$646982523c4faa11)(compositeType);
        const accessor = new (0, $905df3b590d61c61$export$2e2bcd8739ae039)({
            type: type,
            size: size * components
        });
        const varying = {
            location: location,
            name: name,
            accessor: accessor
        };
        this.varyingInfos.push(varying);
        this.varyingInfosByName[varying.name] = varying;
    }
}








const $6fea3ad8e77f174f$var$LOG_PROGRAM_PERF_PRIORITY = 4;
const $6fea3ad8e77f174f$var$GL_SEPARATE_ATTRIBS = 0x8c8d;
const $6fea3ad8e77f174f$var$V6_DEPRECATED_METHODS = [
    "setVertexArray",
    "setAttributes",
    "setBuffers",
    "unsetBuffers",
    "use",
    "getUniformCount",
    "getUniformInfo",
    "getUniformLocation",
    "getUniformValue",
    "getVarying",
    "getFragDataLocation",
    "getAttachedShaders",
    "getAttributeCount",
    "getAttributeLocation",
    "getAttributeInfo"
];
class $6fea3ad8e77f174f$export$2e2bcd8739ae039 extends (0, $dabe379caebdf3da$export$2e2bcd8739ae039) {
    get [Symbol.toStringTag]() {
        return "Program";
    }
    constructor(gl){
        let props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        super(gl, props);
        this.stubRemovedMethods("Program", "v6.0", $6fea3ad8e77f174f$var$V6_DEPRECATED_METHODS);
        this._isCached = false;
        this.initialize(props);
        Object.seal(this);
        this._setId(props.id);
    }
    initialize() {
        let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        const { hash: hash , vs: vs , fs: fs , varyings: varyings , bufferMode: bufferMode = $6fea3ad8e77f174f$var$GL_SEPARATE_ATTRIBS  } = props;
        this.hash = hash || "";
        this.vs = typeof vs === "string" ? new (0, $4700f6e92300c9e2$export$cb28509c217600d2)(this.gl, {
            id: "".concat(props.id, "-vs"),
            source: vs
        }) : vs;
        this.fs = typeof fs === "string" ? new (0, $4700f6e92300c9e2$export$2d38bde43c53f87a)(this.gl, {
            id: "".concat(props.id, "-fs"),
            source: fs
        }) : fs;
        (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(this.vs instanceof (0, $4700f6e92300c9e2$export$cb28509c217600d2));
        (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(this.fs instanceof (0, $4700f6e92300c9e2$export$2d38bde43c53f87a));
        this.uniforms = {};
        this._textureUniforms = {};
        if (varyings && varyings.length > 0) {
            (0, $325e733792a03f4e$export$22897d77b4bb5316)(this.gl);
            this.varyings = varyings;
            this.gl2.transformFeedbackVaryings(this.handle, varyings, bufferMode);
        }
        this._compileAndLink();
        this._readUniformLocationsFromLinkedProgram();
        this.configuration = new (0, $df93dc3d9cc17a6d$export$2e2bcd8739ae039)(this);
        return this.setProps(props);
    }
    delete() {
        let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        if (this._isCached) return this;
        return super.delete(options);
    }
    setProps(props) {
        if ("uniforms" in props) this.setUniforms(props.uniforms);
        return this;
    }
    draw(_ref) {
        let { logPriority: logPriority , drawMode: drawMode = 4 , vertexCount: vertexCount , offset: offset = 0 , start: start , end: end , isIndexed: isIndexed = false , indexType: indexType = 5123 , instanceCount: instanceCount = 0 , isInstanced: isInstanced = instanceCount > 0 , vertexArray: vertexArray = null , transformFeedback: transformFeedback , framebuffer: framebuffer , parameters: parameters = {} , uniforms: uniforms , samplers: samplers  } = _ref;
        if (uniforms || samplers) {
            (0, $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3).deprecated("Program.draw({uniforms})", "Program.setUniforms(uniforms)")();
            this.setUniforms(uniforms || {});
        }
        if ((0, $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3).priority >= logPriority) {
            const fb = framebuffer ? framebuffer.id : "default";
            const message = "mode=".concat((0, $d2f1571231f3f4d0$export$a47fb462a08de82f)(this.gl, drawMode), " verts=").concat(vertexCount, " ") + "instances=".concat(instanceCount, " indexType=").concat((0, $d2f1571231f3f4d0$export$a47fb462a08de82f)(this.gl, indexType), " ") + "isInstanced=".concat(isInstanced, " isIndexed=").concat(isIndexed, " ") + "Framebuffer=".concat(fb);
            (0, $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3).log(logPriority, message)();
        }
        (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(vertexArray);
        this.gl.useProgram(this.handle);
        if (!this._areTexturesRenderable() || vertexCount === 0 || isInstanced && instanceCount === 0) return false;
        vertexArray.bindForDraw(vertexCount, instanceCount, ()=>{
            if (framebuffer !== undefined) parameters = Object.assign({}, parameters, {
                framebuffer: framebuffer
            });
            if (transformFeedback) {
                const primitiveMode = (0, $dd1bd7730cbb49ac$export$e50fcedcdc9b2c73)(drawMode);
                transformFeedback.begin(primitiveMode);
            }
            this._bindTextures();
            (0, $54220aa8b6471f1a$export$b1e7058a2936b651)(this.gl, parameters, ()=>{
                if (isIndexed && isInstanced) this.gl2.drawElementsInstanced(drawMode, vertexCount, indexType, offset, instanceCount);
                else if (isIndexed && (0, $325e733792a03f4e$export$e3518b1ac7891039)(this.gl) && !isNaN(start) && !isNaN(end)) this.gl2.drawRangeElements(drawMode, start, end, vertexCount, indexType, offset);
                else if (isIndexed) this.gl.drawElements(drawMode, vertexCount, indexType, offset);
                else if (isInstanced) this.gl2.drawArraysInstanced(drawMode, offset, vertexCount, instanceCount);
                else this.gl.drawArrays(drawMode, offset, vertexCount);
            });
            if (transformFeedback) transformFeedback.end();
        });
        return true;
    }
    setUniforms() {
        let uniforms = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        if ((0, $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3).priority >= 2) (0, $b100fa53b681ec78$export$c83bcc63b305493)(uniforms, this.id, this._uniformSetters);
        this.gl.useProgram(this.handle);
        for(const uniformName in uniforms){
            const uniform = uniforms[uniformName];
            const uniformSetter = this._uniformSetters[uniformName];
            if (uniformSetter) {
                let value = uniform;
                let textureUpdate = false;
                if (value instanceof (0, $a0e9e15bc57c4882$export$2e2bcd8739ae039)) value = value.texture;
                if (value instanceof (0, $541c007d64b391ad$export$2e2bcd8739ae039)) {
                    textureUpdate = this.uniforms[uniformName] !== uniform;
                    if (textureUpdate) {
                        if (uniformSetter.textureIndex === undefined) uniformSetter.textureIndex = this._textureIndexCounter++;
                        const texture = value;
                        const { textureIndex: textureIndex  } = uniformSetter;
                        texture.bind(textureIndex);
                        value = textureIndex;
                        this._textureUniforms[uniformName] = texture;
                    } else value = uniformSetter.textureIndex;
                } else if (this._textureUniforms[uniformName]) delete this._textureUniforms[uniformName];
                if (uniformSetter(value) || textureUpdate) (0, $b100fa53b681ec78$export$5ced140387f3d289)(this.uniforms, uniformName, uniform);
            }
        }
        return this;
    }
    _areTexturesRenderable() {
        let texturesRenderable = true;
        for(const uniformName in this._textureUniforms){
            const texture = this._textureUniforms[uniformName];
            texture.update();
            texturesRenderable = texturesRenderable && texture.loaded;
        }
        return texturesRenderable;
    }
    _bindTextures() {
        for(const uniformName in this._textureUniforms){
            const textureIndex = this._uniformSetters[uniformName].textureIndex;
            this._textureUniforms[uniformName].bind(textureIndex);
        }
    }
    _createHandle() {
        return this.gl.createProgram();
    }
    _deleteHandle() {
        this.gl.deleteProgram(this.handle);
    }
    _getOptionsFromHandle(handle) {
        const shaderHandles = this.gl.getAttachedShaders(handle);
        const opts = {};
        for (const shaderHandle of shaderHandles){
            const type = this.gl.getShaderParameter(this.handle, 35663);
            switch(type){
                case 35633:
                    opts.vs = new (0, $4700f6e92300c9e2$export$cb28509c217600d2)({
                        handle: shaderHandle
                    });
                    break;
                case 35632:
                    opts.fs = new (0, $4700f6e92300c9e2$export$2d38bde43c53f87a)({
                        handle: shaderHandle
                    });
                    break;
                default:
            }
        }
        return opts;
    }
    _getParameter(pname) {
        return this.gl.getProgramParameter(this.handle, pname);
    }
    _setId(id) {
        if (!id) {
            const programName = this._getName();
            this.id = (0, $757dc76705f498e6$export$e2a22331486dcca0)(programName);
        }
    }
    _getName() {
        let programName = this.vs.getName() || this.fs.getName();
        programName = programName.replace(/shader/i, "");
        programName = programName ? "".concat(programName, "-program") : "program";
        return programName;
    }
    _compileAndLink() {
        const { gl: gl  } = this;
        gl.attachShader(this.handle, this.vs.handle);
        gl.attachShader(this.handle, this.fs.handle);
        (0, $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3).time($6fea3ad8e77f174f$var$LOG_PROGRAM_PERF_PRIORITY, "linkProgram for ".concat(this._getName()))();
        gl.linkProgram(this.handle);
        (0, $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3).timeEnd($6fea3ad8e77f174f$var$LOG_PROGRAM_PERF_PRIORITY, "linkProgram for ".concat(this._getName()))();
        if (gl.debug || (0, $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3).level > 0) {
            const linked = gl.getProgramParameter(this.handle, 35714);
            if (!linked) throw new Error("Error linking: ".concat(gl.getProgramInfoLog(this.handle)));
            gl.validateProgram(this.handle);
            const validated = gl.getProgramParameter(this.handle, 35715);
            if (!validated) throw new Error("Error validating: ".concat(gl.getProgramInfoLog(this.handle)));
        }
    }
    _readUniformLocationsFromLinkedProgram() {
        const { gl: gl  } = this;
        this._uniformSetters = {};
        this._uniformCount = this._getParameter(35718);
        for(let i = 0; i < this._uniformCount; i++){
            const info = this.gl.getActiveUniform(this.handle, i);
            const { name: name  } = (0, $b100fa53b681ec78$export$ae5f39dc6a50a1c7)(info.name);
            let location = gl.getUniformLocation(this.handle, name);
            this._uniformSetters[name] = (0, $b100fa53b681ec78$export$c2b5b6d0be3c2cf0)(gl, location, info);
            if (info.size > 1) for(let l = 0; l < info.size; l++){
                location = gl.getUniformLocation(this.handle, "".concat(name, "[").concat(l, "]"));
                this._uniformSetters["".concat(name, "[").concat(l, "]")] = (0, $b100fa53b681ec78$export$c2b5b6d0be3c2cf0)(gl, location, info);
            }
        }
        this._textureIndexCounter = 0;
    }
    getActiveUniforms(uniformIndices, pname) {
        return this.gl2.getActiveUniforms(this.handle, uniformIndices, pname);
    }
    getUniformBlockIndex(blockName) {
        return this.gl2.getUniformBlockIndex(this.handle, blockName);
    }
    getActiveUniformBlockParameter(blockIndex, pname) {
        return this.gl2.getActiveUniformBlockParameter(this.handle, blockIndex, pname);
    }
    uniformBlockBinding(blockIndex, blockBinding) {
        this.gl2.uniformBlockBinding(this.handle, blockIndex, blockBinding);
    }
}





const $6db1ae640aab9558$var$GL_QUERY_RESULT = 0x8866;
const $6db1ae640aab9558$var$GL_QUERY_RESULT_AVAILABLE = 0x8867;
const $6db1ae640aab9558$var$GL_TIME_ELAPSED_EXT = 0x88bf;
const $6db1ae640aab9558$var$GL_GPU_DISJOINT_EXT = 0x8fbb;
const $6db1ae640aab9558$var$GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN = 0x8c88;
const $6db1ae640aab9558$var$GL_ANY_SAMPLES_PASSED = 0x8c2f;
const $6db1ae640aab9558$var$GL_ANY_SAMPLES_PASSED_CONSERVATIVE = 0x8d6a;
class $6db1ae640aab9558$export$2e2bcd8739ae039 extends (0, $dabe379caebdf3da$export$2e2bcd8739ae039) {
    get [Symbol.toStringTag]() {
        return "Query";
    }
    static isSupported(gl) {
        let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
        const webgl2 = (0, $325e733792a03f4e$export$e3518b1ac7891039)(gl);
        const hasTimerQuery = (0, $75ff6bc03ebbcaf6$export$990fdf4f5aca9ddb)(gl, (0, $8cba87f65ded858b$export$d6a5c11f04f75862).TIMER_QUERY);
        let supported = webgl2 || hasTimerQuery;
        for (const key of opts)switch(key){
            case "queries":
                supported = supported && webgl2;
                break;
            case "timers":
                supported = supported && hasTimerQuery;
                break;
            default:
                (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(false);
        }
        return supported;
    }
    constructor(gl){
        let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        super(gl, opts);
        this.target = null;
        this._queryPending = false;
        this._pollingPromise = null;
        Object.seal(this);
    }
    beginTimeElapsedQuery() {
        return this.begin($6db1ae640aab9558$var$GL_TIME_ELAPSED_EXT);
    }
    beginOcclusionQuery() {
        let { conservative: conservative = false  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        return this.begin(conservative ? $6db1ae640aab9558$var$GL_ANY_SAMPLES_PASSED_CONSERVATIVE : $6db1ae640aab9558$var$GL_ANY_SAMPLES_PASSED);
    }
    beginTransformFeedbackQuery() {
        return this.begin($6db1ae640aab9558$var$GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN);
    }
    begin(target) {
        if (this._queryPending) return this;
        this.target = target;
        this.gl2.beginQuery(this.target, this.handle);
        return this;
    }
    end() {
        if (this._queryPending) return this;
        if (this.target) {
            this.gl2.endQuery(this.target);
            this.target = null;
            this._queryPending = true;
        }
        return this;
    }
    isResultAvailable() {
        if (!this._queryPending) return false;
        const resultAvailable = this.gl2.getQueryParameter(this.handle, $6db1ae640aab9558$var$GL_QUERY_RESULT_AVAILABLE);
        if (resultAvailable) this._queryPending = false;
        return resultAvailable;
    }
    isTimerDisjoint() {
        return this.gl2.getParameter($6db1ae640aab9558$var$GL_GPU_DISJOINT_EXT);
    }
    getResult() {
        return this.gl2.getQueryParameter(this.handle, $6db1ae640aab9558$var$GL_QUERY_RESULT);
    }
    getTimerMilliseconds() {
        return this.getResult() / 1e6;
    }
    createPoll() {
        let limit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Number.POSITIVE_INFINITY;
        if (this._pollingPromise) return this._pollingPromise;
        let counter = 0;
        this._pollingPromise = new Promise((resolve, reject)=>{
            const poll = ()=>{
                if (this.isResultAvailable()) {
                    resolve(this.getResult());
                    this._pollingPromise = null;
                } else if ((counter++) > limit) {
                    reject("Timed out");
                    this._pollingPromise = null;
                } else requestAnimationFrame(poll);
            };
            requestAnimationFrame(poll);
        });
        return this._pollingPromise;
    }
    _createHandle() {
        return $6db1ae640aab9558$export$2e2bcd8739ae039.isSupported(this.gl) ? this.gl2.createQuery() : null;
    }
    _deleteHandle() {
        this.gl2.deleteQuery(this.handle);
    }
}





class $feb45ae040c88295$export$2e2bcd8739ae039 extends (0, $dabe379caebdf3da$export$2e2bcd8739ae039) {
    get [Symbol.toStringTag]() {
        return "TransformFeedback";
    }
    static isSupported(gl) {
        return (0, $325e733792a03f4e$export$e3518b1ac7891039)(gl);
    }
    constructor(gl){
        let props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        (0, $325e733792a03f4e$export$22897d77b4bb5316)(gl);
        super(gl, props);
        this.initialize(props);
        this.stubRemovedMethods("TransformFeedback", "v6.0", [
            "pause",
            "resume"
        ]);
        Object.seal(this);
    }
    initialize() {
        let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        this.buffers = {};
        this.unused = {};
        this.configuration = null;
        this.bindOnUse = true;
        if (!(0, $757dc76705f498e6$export$23cfe696632d10f4)(this.buffers)) this.bind(()=>this._unbindBuffers());
        this.setProps(props);
        return this;
    }
    setProps(props) {
        if ("program" in props) this.configuration = props.program && props.program.configuration;
        if ("configuration" in props) this.configuration = props.configuration;
        if ("bindOnUse" in props) props = props.bindOnUse;
        if ("buffers" in props) this.setBuffers(props.buffers);
    }
    setBuffers() {
        let buffers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        this.bind(()=>{
            for(const bufferName in buffers)this.setBuffer(bufferName, buffers[bufferName]);
        });
        return this;
    }
    setBuffer(locationOrName, bufferOrParams) {
        const location = this._getVaryingIndex(locationOrName);
        const { buffer: buffer , byteSize: byteSize , byteOffset: byteOffset  } = this._getBufferParams(bufferOrParams);
        if (location < 0) {
            this.unused[locationOrName] = buffer;
            (0, $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3).warn("".concat(this.id, " unused varying buffer ").concat(locationOrName))();
            return this;
        }
        this.buffers[location] = bufferOrParams;
        if (!this.bindOnUse) this._bindBuffer(location, buffer, byteOffset, byteSize);
        return this;
    }
    begin() {
        let primitiveMode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        this.gl.bindTransformFeedback(36386, this.handle);
        this._bindBuffers();
        this.gl.beginTransformFeedback(primitiveMode);
        return this;
    }
    end() {
        this.gl.endTransformFeedback();
        this._unbindBuffers();
        this.gl.bindTransformFeedback(36386, null);
        return this;
    }
    _getBufferParams(bufferOrParams) {
        let byteOffset;
        let byteSize;
        let buffer;
        if (bufferOrParams instanceof (0, $28a69bf6d03705d1$export$2e2bcd8739ae039) === false) {
            buffer = bufferOrParams.buffer;
            byteSize = bufferOrParams.byteSize;
            byteOffset = bufferOrParams.byteOffset;
        } else buffer = bufferOrParams;
        if (byteOffset !== undefined || byteSize !== undefined) {
            byteOffset = byteOffset || 0;
            byteSize = byteSize || buffer.byteLength - byteOffset;
        }
        return {
            buffer: buffer,
            byteOffset: byteOffset,
            byteSize: byteSize
        };
    }
    _getVaryingInfo(locationOrName) {
        return this.configuration && this.configuration.getVaryingInfo(locationOrName);
    }
    _getVaryingIndex(locationOrName) {
        if (this.configuration) return this.configuration.getVaryingInfo(locationOrName).location;
        const location = Number(locationOrName);
        return Number.isFinite(location) ? location : -1;
    }
    _bindBuffers() {
        if (this.bindOnUse) for(const bufferIndex in this.buffers){
            const { buffer: buffer , byteSize: byteSize , byteOffset: byteOffset  } = this._getBufferParams(this.buffers[bufferIndex]);
            this._bindBuffer(bufferIndex, buffer, byteOffset, byteSize);
        }
    }
    _unbindBuffers() {
        if (this.bindOnUse) for(const bufferIndex in this.buffers)this._bindBuffer(bufferIndex, null);
    }
    _bindBuffer(index, buffer) {
        let byteOffset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        let byteSize = arguments.length > 3 ? arguments[3] : undefined;
        const handle = buffer && buffer.handle;
        if (!handle || byteSize === undefined) this.gl.bindBufferBase(35982, index, handle);
        else this.gl.bindBufferRange(35982, index, handle, byteOffset, byteSize);
        return this;
    }
    _createHandle() {
        return this.gl.createTransformFeedback();
    }
    _deleteHandle() {
        this.gl.deleteTransformFeedback(this.handle);
    }
    _bindHandle(handle) {
        this.gl.bindTransformFeedback(36386, this.handle);
    }
}







let $a28ad6f21f92ee46$var$arrayBuffer = null;
function $a28ad6f21f92ee46$export$2e3ce519f08759f7(byteLength) {
    if (!$a28ad6f21f92ee46$var$arrayBuffer || $a28ad6f21f92ee46$var$arrayBuffer.byteLength < byteLength) $a28ad6f21f92ee46$var$arrayBuffer = new ArrayBuffer(byteLength);
    return $a28ad6f21f92ee46$var$arrayBuffer;
}
function $a28ad6f21f92ee46$export$4c3ca7f6f110bd92(Type, length) {
    const scratchArrayBuffer = $a28ad6f21f92ee46$export$2e3ce519f08759f7(Type.BYTES_PER_ELEMENT * length);
    return new Type(scratchArrayBuffer, 0, length);
}
function $a28ad6f21f92ee46$export$57295b69bf9c5d15(_ref) {
    let { target: target , source: source , start: start = 0 , count: count = 1  } = _ref;
    const length = source.length;
    const total = count * length;
    let copied = 0;
    for(let i = start; copied < length; copied++)target[i++] = source[copied];
    while(copied < total)if (copied < total - copied) {
        target.copyWithin(start + copied, start, start + copied);
        copied *= 2;
    } else {
        target.copyWithin(start + copied, start, start + total - copied);
        copied = total;
    }
    return target;
}




const $585a766bd4af6d9f$var$ERR_ELEMENTS = "elements must be GL.ELEMENT_ARRAY_BUFFER";
class $585a766bd4af6d9f$export$2e2bcd8739ae039 extends (0, $dabe379caebdf3da$export$2e2bcd8739ae039) {
    get [Symbol.toStringTag]() {
        return "VertexArrayObject";
    }
    static isSupported(gl) {
        let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        if (options.constantAttributeZero) return (0, $325e733792a03f4e$export$e3518b1ac7891039)(gl) || (0, $ef7c7b0387e72f27$export$2e2bcd8739ae039)() === "Chrome";
        return true;
    }
    static getDefaultArray(gl) {
        gl.luma = gl.luma || {};
        if (!gl.luma.defaultVertexArray) gl.luma.defaultVertexArray = new $585a766bd4af6d9f$export$2e2bcd8739ae039(gl, {
            handle: null,
            isDefaultArray: true
        });
        return gl.luma.defaultVertexArray;
    }
    static getMaxAttributes(gl) {
        $585a766bd4af6d9f$export$2e2bcd8739ae039.MAX_ATTRIBUTES = $585a766bd4af6d9f$export$2e2bcd8739ae039.MAX_ATTRIBUTES || gl.getParameter(34921);
        return $585a766bd4af6d9f$export$2e2bcd8739ae039.MAX_ATTRIBUTES;
    }
    static setConstant(gl, location, array) {
        switch(array.constructor){
            case Float32Array:
                $585a766bd4af6d9f$export$2e2bcd8739ae039._setConstantFloatArray(gl, location, array);
                break;
            case Int32Array:
                $585a766bd4af6d9f$export$2e2bcd8739ae039._setConstantIntArray(gl, location, array);
                break;
            case Uint32Array:
                $585a766bd4af6d9f$export$2e2bcd8739ae039._setConstantUintArray(gl, location, array);
                break;
            default:
                (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(false);
        }
    }
    constructor(gl){
        let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        const id = opts.id || opts.program && opts.program.id;
        super(gl, Object.assign({}, opts, {
            id: id
        }));
        this.buffer = null;
        this.bufferValue = null;
        this.isDefaultArray = opts.isDefaultArray || false;
        this.gl2 = gl;
        this.initialize(opts);
        Object.seal(this);
    }
    delete() {
        super.delete();
        if (this.buffer) this.buffer.delete();
        return this;
    }
    get MAX_ATTRIBUTES() {
        return $585a766bd4af6d9f$export$2e2bcd8739ae039.getMaxAttributes(this.gl);
    }
    initialize() {
        let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        return this.setProps(props);
    }
    setProps(props) {
        return this;
    }
    setElementBuffer() {
        let elementBuffer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
        let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(!elementBuffer || elementBuffer.target === 34963, $585a766bd4af6d9f$var$ERR_ELEMENTS);
        this.bind(()=>{
            this.gl.bindBuffer(34963, elementBuffer ? elementBuffer.handle : null);
        });
        return this;
    }
    setBuffer(location, buffer, accessor) {
        if (buffer.target === 34963) return this.setElementBuffer(buffer, accessor);
        const { size: size , type: type , stride: stride , offset: offset , normalized: normalized , integer: integer , divisor: divisor  } = accessor;
        const { gl: gl , gl2: gl2  } = this;
        location = Number(location);
        this.bind(()=>{
            gl.bindBuffer(34962, buffer.handle);
            if (integer) {
                (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)((0, $325e733792a03f4e$export$e3518b1ac7891039)(gl));
                gl2.vertexAttribIPointer(location, size, type, stride, offset);
            } else gl.vertexAttribPointer(location, size, type, normalized, stride, offset);
            gl.enableVertexAttribArray(location);
            gl2.vertexAttribDivisor(location, divisor || 0);
        });
        return this;
    }
    enable(location) {
        let enable = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        const disablingAttributeZero = !enable && location === 0 && !$585a766bd4af6d9f$export$2e2bcd8739ae039.isSupported(this.gl, {
            constantAttributeZero: true
        });
        if (!disablingAttributeZero) {
            location = Number(location);
            this.bind(()=>enable ? this.gl.enableVertexAttribArray(location) : this.gl.disableVertexAttribArray(location));
        }
        return this;
    }
    getConstantBuffer(elementCount, value) {
        const constantValue = this._normalizeConstantArrayValue(value);
        const byteLength = constantValue.byteLength * elementCount;
        const length = constantValue.length * elementCount;
        let updateNeeded = !this.buffer;
        this.buffer = this.buffer || new (0, $28a69bf6d03705d1$export$2e2bcd8739ae039)(this.gl, byteLength);
        updateNeeded = updateNeeded || this.buffer.reallocate(byteLength);
        updateNeeded = updateNeeded || !this._compareConstantArrayValues(constantValue, this.bufferValue);
        if (updateNeeded) {
            const typedArray = (0, $a28ad6f21f92ee46$export$4c3ca7f6f110bd92)(value.constructor, length);
            (0, $a28ad6f21f92ee46$export$57295b69bf9c5d15)({
                target: typedArray,
                source: constantValue,
                start: 0,
                count: length
            });
            this.buffer.subData(typedArray);
            this.bufferValue = value;
        }
        return this.buffer;
    }
    _normalizeConstantArrayValue(arrayValue) {
        if (Array.isArray(arrayValue)) return new Float32Array(arrayValue);
        return arrayValue;
    }
    _compareConstantArrayValues(v1, v2) {
        if (!v1 || !v2 || v1.length !== v2.length || v1.constructor !== v2.constructor) return false;
        for(let i = 0; i < v1.length; ++i){
            if (v1[i] !== v2[i]) return false;
        }
        return true;
    }
    static _setConstantFloatArray(gl, location, array) {
        switch(array.length){
            case 1:
                gl.vertexAttrib1fv(location, array);
                break;
            case 2:
                gl.vertexAttrib2fv(location, array);
                break;
            case 3:
                gl.vertexAttrib3fv(location, array);
                break;
            case 4:
                gl.vertexAttrib4fv(location, array);
                break;
            default:
                (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(false);
        }
    }
    static _setConstantIntArray(gl, location, array) {
        (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)((0, $325e733792a03f4e$export$e3518b1ac7891039)(gl));
        switch(array.length){
            case 1:
                gl.vertexAttribI1iv(location, array);
                break;
            case 2:
                gl.vertexAttribI2iv(location, array);
                break;
            case 3:
                gl.vertexAttribI3iv(location, array);
                break;
            case 4:
                gl.vertexAttribI4iv(location, array);
                break;
            default:
                (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(false);
        }
    }
    static _setConstantUintArray(gl, location, array) {
        (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)((0, $325e733792a03f4e$export$e3518b1ac7891039)(gl));
        switch(array.length){
            case 1:
                gl.vertexAttribI1uiv(location, array);
                break;
            case 2:
                gl.vertexAttribI2uiv(location, array);
                break;
            case 3:
                gl.vertexAttribI3uiv(location, array);
                break;
            case 4:
                gl.vertexAttribI4uiv(location, array);
                break;
            default:
                (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(false);
        }
    }
    _createHandle() {
        const gl2 = this.gl;
        return gl2.createVertexArray();
    }
    _deleteHandle(handle) {
        this.gl2.deleteVertexArray(handle);
        return [
            this.elements
        ];
    }
    _bindHandle(handle) {
        this.gl2.bindVertexArray(handle);
    }
    _getParameter(pname, _ref) {
        let { location: location  } = _ref;
        (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(Number.isFinite(location));
        return this.bind(()=>{
            switch(pname){
                case 34373:
                    return this.gl.getVertexAttribOffset(location, pname);
                default:
                    return this.gl.getVertexAttrib(location, pname);
            }
        });
    }
}




const $012b7736d6299c03$var$ERR_ATTRIBUTE_TYPE = "VertexArray: attributes must be Buffers or constants (i.e. typed array)";
const $012b7736d6299c03$var$MULTI_LOCATION_ATTRIBUTE_REGEXP = /^(.+)__LOCATION_([0-9]+)$/;
const $012b7736d6299c03$var$DEPRECATIONS_V6 = [
    "setBuffers",
    "setGeneric",
    "clearBindings",
    "setLocations",
    "setGenericValues",
    "setDivisor",
    "enable",
    "disable"
];
class $012b7736d6299c03$export$2e2bcd8739ae039 {
    constructor(gl){
        let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        const id = opts.id || opts.program && opts.program.id;
        this.id = id;
        this.gl = gl;
        this.configuration = null;
        this.elements = null;
        this.elementsAccessor = null;
        this.values = null;
        this.accessors = null;
        this.unused = null;
        this.drawParams = null;
        this.buffer = null;
        this.attributes = {};
        this.vertexArrayObject = new (0, $585a766bd4af6d9f$export$2e2bcd8739ae039)(gl);
        (0, $cd105bc7922a3ca2$export$5c9302507afeb7af)(this, "VertexArray", "v6.0", $012b7736d6299c03$var$DEPRECATIONS_V6);
        this.initialize(opts);
        Object.seal(this);
    }
    delete() {
        if (this.buffer) this.buffer.delete();
        this.vertexArrayObject.delete();
    }
    initialize() {
        let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        this.reset();
        this.configuration = null;
        this.bindOnUse = false;
        return this.setProps(props);
    }
    reset() {
        this.elements = null;
        this.elementsAccessor = null;
        const { MAX_ATTRIBUTES: MAX_ATTRIBUTES  } = this.vertexArrayObject;
        this.values = new Array(MAX_ATTRIBUTES).fill(null);
        this.accessors = new Array(MAX_ATTRIBUTES).fill(null);
        this.unused = {};
        this.drawParams = null;
        return this;
    }
    setProps(props) {
        if ("program" in props) this.configuration = props.program && props.program.configuration;
        if ("configuration" in props) this.configuration = props.configuration;
        if ("attributes" in props) this.setAttributes(props.attributes);
        if ("elements" in props) this.setElementBuffer(props.elements);
        if ("bindOnUse" in props) props = props.bindOnUse;
        return this;
    }
    clearDrawParams() {
        this.drawParams = null;
    }
    getDrawParams() {
        this.drawParams = this.drawParams || this._updateDrawParams();
        return this.drawParams;
    }
    setAttributes(attributes) {
        Object.assign(this.attributes, attributes);
        this.vertexArrayObject.bind(()=>{
            for(const locationOrName in attributes){
                const value = attributes[locationOrName];
                this._setAttribute(locationOrName, value);
            }
            this.gl.bindBuffer(34962, null);
        });
        return this;
    }
    setElementBuffer() {
        let elementBuffer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
        let accessor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        this.elements = elementBuffer;
        this.elementsAccessor = accessor;
        this.clearDrawParams();
        this.vertexArrayObject.setElementBuffer(elementBuffer, accessor);
        return this;
    }
    setBuffer(locationOrName, buffer) {
        let appAccessor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        if (buffer.target === 34963) return this.setElementBuffer(buffer, appAccessor);
        const { location: location , accessor: accessor  } = this._resolveLocationAndAccessor(locationOrName, buffer, buffer.accessor, appAccessor);
        if (location >= 0) {
            this.values[location] = buffer;
            this.accessors[location] = accessor;
            this.clearDrawParams();
            this.vertexArrayObject.setBuffer(location, buffer, accessor);
        }
        return this;
    }
    setConstant(locationOrName, arrayValue) {
        let appAccessor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        const { location: location , accessor: accessor  } = this._resolveLocationAndAccessor(locationOrName, arrayValue, Object.assign({
            size: arrayValue.length
        }, appAccessor));
        if (location >= 0) {
            arrayValue = this.vertexArrayObject._normalizeConstantArrayValue(arrayValue);
            this.values[location] = arrayValue;
            this.accessors[location] = accessor;
            this.clearDrawParams();
            this.vertexArrayObject.enable(location, false);
        }
        return this;
    }
    unbindBuffers() {
        this.vertexArrayObject.bind(()=>{
            if (this.elements) this.vertexArrayObject.setElementBuffer(null);
            this.buffer = this.buffer || new (0, $28a69bf6d03705d1$export$2e2bcd8739ae039)(this.gl, {
                accessor: {
                    size: 4
                }
            });
            for(let location = 0; location < this.vertexArrayObject.MAX_ATTRIBUTES; location++)if (this.values[location] instanceof (0, $28a69bf6d03705d1$export$2e2bcd8739ae039)) {
                this.gl.disableVertexAttribArray(location);
                this.gl.bindBuffer(34962, this.buffer.handle);
                this.gl.vertexAttribPointer(location, 1, 5126, false, 0, 0);
            }
        });
        return this;
    }
    bindBuffers() {
        this.vertexArrayObject.bind(()=>{
            if (this.elements) this.setElementBuffer(this.elements);
            for(let location = 0; location < this.vertexArrayObject.MAX_ATTRIBUTES; location++){
                const buffer = this.values[location];
                if (buffer instanceof (0, $28a69bf6d03705d1$export$2e2bcd8739ae039)) this.setBuffer(location, buffer);
            }
        });
        return this;
    }
    bindForDraw(vertexCount, instanceCount, func) {
        let value;
        this.vertexArrayObject.bind(()=>{
            this._setConstantAttributes(vertexCount, instanceCount);
            value = func();
        });
        return value;
    }
    _resolveLocationAndAccessor(locationOrName, value, valueAccessor, appAccessor) {
        const INVALID_RESULT = {
            location: -1,
            accessor: null
        };
        const { location: location , name: name  } = this._getAttributeIndex(locationOrName);
        if (!Number.isFinite(location) || location < 0) {
            this.unused[locationOrName] = value;
            (0, $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3).once(3, ()=>"unused value ".concat(locationOrName, " in ").concat(this.id))();
            return INVALID_RESULT;
        }
        const accessInfo = this._getAttributeInfo(name || location);
        if (!accessInfo) return INVALID_RESULT;
        const currentAccessor = this.accessors[location] || {};
        const accessor = (0, $905df3b590d61c61$export$2e2bcd8739ae039).resolve(accessInfo.accessor, currentAccessor, valueAccessor, appAccessor);
        const { size: size , type: type  } = accessor;
        (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(Number.isFinite(size) && Number.isFinite(type));
        return {
            location: location,
            accessor: accessor
        };
    }
    _getAttributeInfo(attributeName) {
        return this.configuration && this.configuration.getAttributeInfo(attributeName);
    }
    _getAttributeIndex(locationOrName) {
        const location = Number(locationOrName);
        if (Number.isFinite(location)) return {
            location: location
        };
        const multiLocation = $012b7736d6299c03$var$MULTI_LOCATION_ATTRIBUTE_REGEXP.exec(locationOrName);
        const name = multiLocation ? multiLocation[1] : locationOrName;
        const locationOffset = multiLocation ? Number(multiLocation[2]) : 0;
        if (this.configuration) return {
            location: this.configuration.getAttributeLocation(name) + locationOffset,
            name: name
        };
        return {
            location: -1
        };
    }
    _setAttribute(locationOrName, value) {
        if (value instanceof (0, $28a69bf6d03705d1$export$2e2bcd8739ae039)) this.setBuffer(locationOrName, value);
        else if (Array.isArray(value) && value.length && value[0] instanceof (0, $28a69bf6d03705d1$export$2e2bcd8739ae039)) {
            const buffer = value[0];
            const accessor = value[1];
            this.setBuffer(locationOrName, buffer, accessor);
        } else if (ArrayBuffer.isView(value) || Array.isArray(value)) {
            const constant = value;
            this.setConstant(locationOrName, constant);
        } else if (value.buffer instanceof (0, $28a69bf6d03705d1$export$2e2bcd8739ae039)) {
            const accessor = value;
            this.setBuffer(locationOrName, accessor.buffer, accessor);
        } else throw new Error($012b7736d6299c03$var$ERR_ATTRIBUTE_TYPE);
    }
    _setConstantAttributes(vertexCount, instanceCount) {
        const elementCount = Math.max(vertexCount | 0, instanceCount | 0);
        let constant = this.values[0];
        if (ArrayBuffer.isView(constant)) this._setConstantAttributeZero(constant, elementCount);
        for(let location = 1; location < this.vertexArrayObject.MAX_ATTRIBUTES; location++){
            constant = this.values[location];
            if (ArrayBuffer.isView(constant)) this._setConstantAttribute(location, constant);
        }
    }
    _setConstantAttributeZero(constant, elementCount) {
        if ((0, $585a766bd4af6d9f$export$2e2bcd8739ae039).isSupported(this.gl, {
            constantAttributeZero: true
        })) {
            this._setConstantAttribute(0, constant);
            return;
        }
        const buffer = this.vertexArrayObject.getConstantBuffer(elementCount, constant);
        this.vertexArrayObject.setBuffer(0, buffer, this.accessors[0]);
    }
    _setConstantAttribute(location, constant) {
        (0, $585a766bd4af6d9f$export$2e2bcd8739ae039).setConstant(this.gl, location, constant);
    }
    _updateDrawParams() {
        const drawParams = {
            isIndexed: false,
            isInstanced: false,
            indexCount: Infinity,
            vertexCount: Infinity,
            instanceCount: Infinity
        };
        for(let location = 0; location < this.vertexArrayObject.MAX_ATTRIBUTES; location++)this._updateDrawParamsForLocation(drawParams, location);
        if (this.elements) {
            drawParams.elementCount = this.elements.getElementCount(this.elements.accessor);
            drawParams.isIndexed = true;
            drawParams.indexType = this.elementsAccessor.type || this.elements.accessor.type;
            drawParams.indexOffset = this.elementsAccessor.offset || 0;
        }
        if (drawParams.indexCount === Infinity) drawParams.indexCount = 0;
        if (drawParams.vertexCount === Infinity) drawParams.vertexCount = 0;
        if (drawParams.instanceCount === Infinity) drawParams.instanceCount = 0;
        return drawParams;
    }
    _updateDrawParamsForLocation(drawParams, location) {
        const value = this.values[location];
        const accessor = this.accessors[location];
        if (!value) return;
        const { divisor: divisor  } = accessor;
        const isInstanced = divisor > 0;
        drawParams.isInstanced = drawParams.isInstanced || isInstanced;
        if (value instanceof (0, $28a69bf6d03705d1$export$2e2bcd8739ae039)) {
            const buffer = value;
            if (isInstanced) {
                const instanceCount = buffer.getVertexCount(accessor);
                drawParams.instanceCount = Math.min(drawParams.instanceCount, instanceCount);
            } else {
                const vertexCount = buffer.getVertexCount(accessor);
                drawParams.vertexCount = Math.min(drawParams.vertexCount, vertexCount);
            }
        }
    }
    setElements() {
        let elementBuffer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
        let accessor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        (0, $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3).deprecated("setElements", "setElementBuffer")();
        return this.setElementBuffer(elementBuffer, accessor);
    }
}

function $5cc96d47f4335f1d$export$2e2bcd8739ae039(source) {
    let version = 100;
    const words = source.match(/[^\s]+/g);
    if (words.length >= 2 && words[0] === "#version") {
        const v = parseInt(words[1], 10);
        if (Number.isFinite(v)) version = v;
    }
    return version;
}


function $fe0b523f7d230853$var$formatArrayValue(v, opts) {
    const { maxElts: maxElts = 16 , size: size = 1  } = opts;
    let string = "[";
    for(let i = 0; i < v.length && i < maxElts; ++i){
        if (i > 0) string += ",".concat(i % size === 0 ? " " : "");
        string += $fe0b523f7d230853$export$7c4d25c0c3217d8c(v[i], opts);
    }
    const terminator = v.length > maxElts ? "..." : "]";
    return "".concat(string).concat(terminator);
}
function $fe0b523f7d230853$export$7c4d25c0c3217d8c(v) {
    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    const EPSILON = 1e-16;
    const { isInteger: isInteger = false  } = opts;
    if (Array.isArray(v) || ArrayBuffer.isView(v)) return $fe0b523f7d230853$var$formatArrayValue(v, opts);
    if (!Number.isFinite(v)) return String(v);
    if (Math.abs(v) < EPSILON) return isInteger ? "0" : "0.";
    if (isInteger) return v.toFixed(0);
    if (Math.abs(v) > 100 && Math.abs(v) < 10000) return v.toFixed(0);
    const string = v.toPrecision(2);
    const decimal = string.indexOf(".0");
    return decimal === string.length - 2 ? string.slice(0, -1) : string;
}


function $d325c11ca8c9db0d$export$72be64c472054e23(_ref) {
    let { header: header = "Uniforms" , program: program , uniforms: uniforms , undefinedOnly: undefinedOnly = false  } = _ref;
    (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(program);
    const SHADER_MODULE_UNIFORM_REGEXP = ".*_.*";
    const PROJECT_MODULE_UNIFORM_REGEXP = ".*Matrix";
    const uniformLocations = program._uniformSetters;
    const table = {};
    const uniformNames = Object.keys(uniformLocations).sort();
    let count = 0;
    for (const uniformName of uniformNames){
        if (!uniformName.match(SHADER_MODULE_UNIFORM_REGEXP) && !uniformName.match(PROJECT_MODULE_UNIFORM_REGEXP)) {
            if ($d325c11ca8c9db0d$var$addUniformToTable({
                table: table,
                header: header,
                uniforms: uniforms,
                uniformName: uniformName,
                undefinedOnly: undefinedOnly
            })) count++;
        }
    }
    for (const uniformName1 of uniformNames){
        if (uniformName1.match(PROJECT_MODULE_UNIFORM_REGEXP)) {
            if ($d325c11ca8c9db0d$var$addUniformToTable({
                table: table,
                header: header,
                uniforms: uniforms,
                uniformName: uniformName1,
                undefinedOnly: undefinedOnly
            })) count++;
        }
    }
    for (const uniformName2 of uniformNames){
        if (!table[uniformName2]) {
            if ($d325c11ca8c9db0d$var$addUniformToTable({
                table: table,
                header: header,
                uniforms: uniforms,
                uniformName: uniformName2,
                undefinedOnly: undefinedOnly
            })) count++;
        }
    }
    let unusedCount = 0;
    const unusedTable = {};
    if (!undefinedOnly) for(const uniformName3 in uniforms){
        const uniform = uniforms[uniformName3];
        if (!table[uniformName3]) {
            unusedCount++;
            unusedTable[uniformName3] = {
                Type: "NOT USED: ".concat(uniform),
                [header]: (0, $fe0b523f7d230853$export$7c4d25c0c3217d8c)(uniform)
            };
        }
    }
    return {
        table: table,
        count: count,
        unusedTable: unusedTable,
        unusedCount: unusedCount
    };
}
function $d325c11ca8c9db0d$var$addUniformToTable(_ref2) {
    let { table: table , header: header , uniforms: uniforms , uniformName: uniformName , undefinedOnly: undefinedOnly  } = _ref2;
    const value = uniforms[uniformName];
    const isDefined = $d325c11ca8c9db0d$var$isUniformDefined(value);
    if (!undefinedOnly || !isDefined) {
        table[uniformName] = {
            [header]: isDefined ? (0, $fe0b523f7d230853$export$7c4d25c0c3217d8c)(value) : "N/A",
            "Uniform Type": isDefined ? value : "NOT PROVIDED"
        };
        return true;
    }
    return false;
}
function $d325c11ca8c9db0d$var$isUniformDefined(value) {
    return value !== undefined && value !== null;
}





function $425f6c53ea308543$export$f05218eded921e71(_ref) {
    let { vertexArray: vertexArray , header: header = "Attributes"  } = _ref;
    if (!vertexArray.configuration) return {};
    const table = {};
    if (vertexArray.elements) table.ELEMENT_ARRAY_BUFFER = $425f6c53ea308543$var$getDebugTableRow(vertexArray, vertexArray.elements, null, header);
    const attributes = vertexArray.values;
    for(const attributeLocation in attributes){
        const info = vertexArray._getAttributeInfo(attributeLocation);
        if (info) {
            let rowHeader = "".concat(attributeLocation, ": ").concat(info.name);
            const accessor = vertexArray.accessors[info.location];
            if (accessor) rowHeader = "".concat(attributeLocation, ": ").concat($425f6c53ea308543$var$getGLSLDeclaration(info.name, accessor));
            table[rowHeader] = $425f6c53ea308543$var$getDebugTableRow(vertexArray, attributes[attributeLocation], accessor, header);
        }
    }
    return table;
}
function $425f6c53ea308543$var$getDebugTableRow(vertexArray, attribute, accessor, header) {
    const { gl: gl  } = vertexArray;
    if (!attribute) return {
        [header]: "null",
        "Format ": "N/A"
    };
    let type = "NOT PROVIDED";
    let size = 1;
    let verts = 0;
    let bytes = 0;
    let isInteger;
    let marker;
    let value;
    if (accessor) {
        type = accessor.type;
        size = accessor.size;
        type = String(type).replace("Array", "");
        isInteger = type.indexOf("nt") !== -1;
    }
    if (attribute instanceof (0, $28a69bf6d03705d1$export$2e2bcd8739ae039)) {
        const buffer = attribute;
        const { data: data , changed: changed  } = buffer.getDebugData();
        marker = changed ? "*" : "";
        value = data;
        bytes = buffer.byteLength;
        verts = bytes / data.BYTES_PER_ELEMENT / size;
        let format;
        if (accessor) {
            const instanced = accessor.divisor > 0;
            format = "".concat(instanced ? "I " : "P ", " ").concat(verts, " (x").concat(size, "=").concat(bytes, " bytes ").concat((0, $d2f1571231f3f4d0$export$a47fb462a08de82f)(gl, type), ")");
        } else {
            isInteger = true;
            format = "".concat(bytes, " bytes");
        }
        return {
            [header]: "".concat(marker).concat((0, $fe0b523f7d230853$export$7c4d25c0c3217d8c)(value, {
                size: size,
                isInteger: isInteger
            })),
            "Format ": format
        };
    }
    value = attribute;
    size = attribute.length;
    type = String(attribute.constructor.name).replace("Array", "");
    isInteger = type.indexOf("nt") !== -1;
    return {
        [header]: "".concat((0, $fe0b523f7d230853$export$7c4d25c0c3217d8c)(value, {
            size: size,
            isInteger: isInteger
        }), " (constant)"),
        "Format ": "".concat(size, "x").concat(type, " (constant)")
    };
}
function $425f6c53ea308543$var$getGLSLDeclaration(name, accessor) {
    const { type: type , size: size  } = accessor;
    const typeAndName = (0, $dd1bd7730cbb49ac$export$508acc40581a1522)(type, size);
    return typeAndName ? "".concat(name, " (").concat(typeAndName.name, ")") : name;
}


function $d892712aaf8139ba$export$826103546372d55e(config) {
    const table = {};
    const header = "Accessors for ".concat(config.id);
    for (const attributeInfo of config.attributeInfos)if (attributeInfo) {
        const glslDeclaration = $d892712aaf8139ba$var$getGLSLDeclaration(attributeInfo);
        table["in ".concat(glslDeclaration)] = {
            [header]: JSON.stringify(attributeInfo.accessor)
        };
    }
    for (const varyingInfo of config.varyingInfos)if (varyingInfo) {
        const glslDeclaration = $d892712aaf8139ba$var$getGLSLDeclaration(varyingInfo);
        table["out ".concat(glslDeclaration)] = {
            [header]: JSON.stringify(varyingInfo.accessor)
        };
    }
    return table;
}
function $d892712aaf8139ba$var$getGLSLDeclaration(attributeInfo) {
    const { type: type , size: size  } = attributeInfo.accessor;
    const typeAndName = (0, $dd1bd7730cbb49ac$export$508acc40581a1522)(type, size);
    if (typeAndName) return "".concat(typeAndName.name, " ").concat(attributeInfo.name);
    return attributeInfo.name;
}





const $8a761c509fabf16c$var$isPage = (0, $58cc8c917413a7dc$export$2e2bcd8739ae039)() && typeof document !== "undefined";
let $8a761c509fabf16c$var$statIdCounter = 0;
class $8a761c509fabf16c$export$2e2bcd8739ae039 {
    constructor(){
        let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        const { onCreateContext: onCreateContext = (opts)=>(0, $f89b67ad8c6f5746$export$a32ea65c51ffebe7)(opts) , onAddHTML: onAddHTML = null , onInitialize: onInitialize = ()=>{} , onRender: onRender = ()=>{} , onFinalize: onFinalize = ()=>{} , onError: onError , gl: gl = null , glOptions: glOptions = {} , debug: debug = false , createFramebuffer: createFramebuffer = false , autoResizeViewport: autoResizeViewport = true , autoResizeDrawingBuffer: autoResizeDrawingBuffer = true , stats: stats = (0, $0a3fbec7776af5cb$export$fb95d6e12d0fb414).get("animation-loop-".concat($8a761c509fabf16c$var$statIdCounter++))  } = props;
        let { useDevicePixels: useDevicePixels = true  } = props;
        if ("useDevicePixelRatio" in props) {
            (0, $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3).deprecated("useDevicePixelRatio", "useDevicePixels")();
            useDevicePixels = props.useDevicePixelRatio;
        }
        this.props = {
            onCreateContext: onCreateContext,
            onAddHTML: onAddHTML,
            onInitialize: onInitialize,
            onRender: onRender,
            onFinalize: onFinalize,
            onError: onError,
            gl: gl,
            glOptions: glOptions,
            debug: debug,
            createFramebuffer: createFramebuffer
        };
        this.gl = gl;
        this.needsRedraw = null;
        this.timeline = null;
        this.stats = stats;
        this.cpuTime = this.stats.get("CPU Time");
        this.gpuTime = this.stats.get("GPU Time");
        this.frameRate = this.stats.get("Frame Rate");
        this._initialized = false;
        this._running = false;
        this._animationFrameId = null;
        this._nextFramePromise = null;
        this._resolveNextFrame = null;
        this._cpuStartTime = 0;
        this.setProps({
            autoResizeViewport: autoResizeViewport,
            autoResizeDrawingBuffer: autoResizeDrawingBuffer,
            useDevicePixels: useDevicePixels
        });
        this.start = this.start.bind(this);
        this.stop = this.stop.bind(this);
        this._pageLoadPromise = null;
        this._onMousemove = this._onMousemove.bind(this);
        this._onMouseleave = this._onMouseleave.bind(this);
    }
    delete() {
        this.stop();
        this._setDisplay(null);
    }
    setNeedsRedraw(reason) {
        (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(typeof reason === "string");
        this.needsRedraw = this.needsRedraw || reason;
        return this;
    }
    setProps(props) {
        if ("autoResizeViewport" in props) this.autoResizeViewport = props.autoResizeViewport;
        if ("autoResizeDrawingBuffer" in props) this.autoResizeDrawingBuffer = props.autoResizeDrawingBuffer;
        if ("useDevicePixels" in props) this.useDevicePixels = props.useDevicePixels;
        return this;
    }
    start() {
        let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        if (this._running) return this;
        this._running = true;
        const startPromise = this._getPageLoadPromise().then(()=>{
            if (!this._running || this._initialized) return null;
            this._createWebGLContext(opts);
            this._createFramebuffer();
            this._startEventHandling();
            this._initializeCallbackData();
            this._updateCallbackData();
            this._resizeCanvasDrawingBuffer();
            this._resizeViewport();
            this._gpuTimeQuery = (0, $6db1ae640aab9558$export$2e2bcd8739ae039).isSupported(this.gl, [
                "timers"
            ]) ? new (0, $6db1ae640aab9558$export$2e2bcd8739ae039)(this.gl) : null;
            this._initialized = true;
            return this.onInitialize(this.animationProps);
        }).then((appContext)=>{
            if (this._running) {
                this._addCallbackData(appContext || {});
                if (appContext !== false) this._startLoop();
            }
        });
        if (this.props.onError) startPromise.catch(this.props.onError);
        return this;
    }
    redraw() {
        if (this.isContextLost()) return this;
        this._beginTimers();
        this._setupFrame();
        this._updateCallbackData();
        this._renderFrame(this.animationProps);
        this._clearNeedsRedraw();
        if (this.offScreen && this.gl.commit) this.gl.commit();
        if (this._resolveNextFrame) {
            this._resolveNextFrame(this);
            this._nextFramePromise = null;
            this._resolveNextFrame = null;
        }
        this._endTimers();
        return this;
    }
    stop() {
        if (this._running) {
            this._finalizeCallbackData();
            this._cancelAnimationFrame(this._animationFrameId);
            this._nextFramePromise = null;
            this._resolveNextFrame = null;
            this._animationFrameId = null;
            this._running = false;
        }
        return this;
    }
    attachTimeline(timeline) {
        this.timeline = timeline;
        return this.timeline;
    }
    detachTimeline() {
        this.timeline = null;
    }
    waitForRender() {
        this.setNeedsRedraw("waitForRender");
        if (!this._nextFramePromise) this._nextFramePromise = new Promise((resolve)=>{
            this._resolveNextFrame = resolve;
        });
        return this._nextFramePromise;
    }
    async toDataURL() {
        this.setNeedsRedraw("toDataURL");
        await this.waitForRender();
        return this.gl.canvas.toDataURL();
    }
    isContextLost() {
        return this.gl.isContextLost();
    }
    onCreateContext() {
        return this.props.onCreateContext(...arguments);
    }
    onInitialize() {
        return this.props.onInitialize(...arguments);
    }
    onRender() {
        return this.props.onRender(...arguments);
    }
    onFinalize() {
        return this.props.onFinalize(...arguments);
    }
    getHTMLControlValue(id) {
        let defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
        const element = document.getElementById(id);
        return element ? Number(element.value) : defaultValue;
    }
    setViewParameters() {
        (0, $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3).removed("AnimationLoop.setViewParameters", "AnimationLoop.setProps")();
        return this;
    }
    _startLoop() {
        const renderFrame = ()=>{
            if (!this._running) return;
            this.redraw();
            this._animationFrameId = this._requestAnimationFrame(renderFrame);
        };
        this._cancelAnimationFrame(this._animationFrameId);
        this._animationFrameId = this._requestAnimationFrame(renderFrame);
    }
    _getPageLoadPromise() {
        if (!this._pageLoadPromise) this._pageLoadPromise = $8a761c509fabf16c$var$isPage ? new Promise((resolve, reject)=>{
            if ($8a761c509fabf16c$var$isPage && document.readyState === "complete") {
                resolve(document);
                return;
            }
            window.addEventListener("load", ()=>{
                resolve(document);
            });
        }) : Promise.resolve({});
        return this._pageLoadPromise;
    }
    _setDisplay(display) {
        if (this.display) {
            this.display.delete();
            this.display.animationLoop = null;
        }
        if (display) display.animationLoop = this;
        this.display = display;
    }
    _cancelAnimationFrame(animationFrameId) {
        if (this.display && this.display.cancelAnimationFrame) return this.display.cancelAnimationFrame(animationFrameId);
        return (0, $cb3c1c602b31e96d$export$e00521de187a817a)(animationFrameId);
    }
    _requestAnimationFrame(renderFrameCallback) {
        if (this._running) {
            if (this.display && this.display.requestAnimationFrame) return this.display.requestAnimationFrame(renderFrameCallback);
            return (0, $cb3c1c602b31e96d$export$6cb2c4c0a22909c0)(renderFrameCallback);
        }
        return undefined;
    }
    _renderFrame() {
        if (this.display) {
            this.display._renderFrame(...arguments);
            return;
        }
        this.onRender(...arguments);
    }
    _clearNeedsRedraw() {
        this.needsRedraw = null;
    }
    _setupFrame() {
        this._resizeCanvasDrawingBuffer();
        this._resizeViewport();
        this._resizeFramebuffer();
    }
    _initializeCallbackData() {
        this.animationProps = {
            gl: this.gl,
            stop: this.stop,
            canvas: this.gl.canvas,
            framebuffer: this.framebuffer,
            useDevicePixels: this.useDevicePixels,
            needsRedraw: null,
            startTime: Date.now(),
            engineTime: 0,
            tick: 0,
            tock: 0,
            time: 0,
            _timeline: this.timeline,
            _loop: this,
            _animationLoop: this,
            _mousePosition: null
        };
    }
    _updateCallbackData() {
        const { width: width , height: height , aspect: aspect  } = this._getSizeAndAspect();
        if (width !== this.animationProps.width || height !== this.animationProps.height) this.setNeedsRedraw("drawing buffer resized");
        if (aspect !== this.animationProps.aspect) this.setNeedsRedraw("drawing buffer aspect changed");
        this.animationProps.width = width;
        this.animationProps.height = height;
        this.animationProps.aspect = aspect;
        this.animationProps.needsRedraw = this.needsRedraw;
        this.animationProps.engineTime = Date.now() - this.animationProps.startTime;
        if (this.timeline) this.timeline.update(this.animationProps.engineTime);
        this.animationProps.tick = Math.floor(this.animationProps.time / 1000 * 60);
        this.animationProps.tock++;
        this.animationProps.time = this.timeline ? this.timeline.getTime() : this.animationProps.engineTime;
        this.animationProps._offScreen = this.offScreen;
    }
    _finalizeCallbackData() {
        this.onFinalize(this.animationProps);
    }
    _addCallbackData(appContext) {
        if (typeof appContext === "object" && appContext !== null) this.animationProps = Object.assign({}, this.animationProps, appContext);
    }
    _createWebGLContext(opts) {
        this.offScreen = opts.canvas && typeof OffscreenCanvas !== "undefined" && opts.canvas instanceof OffscreenCanvas;
        opts = Object.assign({}, opts, this.props.glOptions);
        this.gl = this.props.gl ? (0, $f89b67ad8c6f5746$export$6b6cef073fe6a207)(this.props.gl, opts) : this.onCreateContext(opts);
        if (!(0, $325e733792a03f4e$export$3a471d0dd6792be6)(this.gl)) throw new Error("AnimationLoop.onCreateContext - illegal context returned");
        (0, $54220aa8b6471f1a$export$2ee1427ea70eaaab)(this.gl);
        this._createInfoDiv();
    }
    _createInfoDiv() {
        if (this.gl.canvas && this.props.onAddHTML) {
            const wrapperDiv = document.createElement("div");
            document.body.appendChild(wrapperDiv);
            wrapperDiv.style.position = "relative";
            const div = document.createElement("div");
            div.style.position = "absolute";
            div.style.left = "10px";
            div.style.bottom = "10px";
            div.style.width = "300px";
            div.style.background = "white";
            wrapperDiv.appendChild(this.gl.canvas);
            wrapperDiv.appendChild(div);
            const html = this.props.onAddHTML(div);
            if (html) div.innerHTML = html;
        }
    }
    _getSizeAndAspect() {
        const width = this.gl.drawingBufferWidth;
        const height = this.gl.drawingBufferHeight;
        let aspect = 1;
        const { canvas: canvas  } = this.gl;
        if (canvas && canvas.clientHeight) aspect = canvas.clientWidth / canvas.clientHeight;
        else if (width > 0 && height > 0) aspect = width / height;
        return {
            width: width,
            height: height,
            aspect: aspect
        };
    }
    _resizeViewport() {
        if (this.autoResizeViewport) this.gl.viewport(0, 0, this.gl.drawingBufferWidth, this.gl.drawingBufferHeight);
    }
    _resizeCanvasDrawingBuffer() {
        if (this.autoResizeDrawingBuffer) (0, $f89b67ad8c6f5746$export$4ed444b69b8944fd)(this.gl, {
            useDevicePixels: this.useDevicePixels
        });
    }
    _createFramebuffer() {
        if (this.props.createFramebuffer) this.framebuffer = new (0, $a0e9e15bc57c4882$export$2e2bcd8739ae039)(this.gl);
    }
    _resizeFramebuffer() {
        if (this.framebuffer) this.framebuffer.resize({
            width: this.gl.drawingBufferWidth,
            height: this.gl.drawingBufferHeight
        });
    }
    _beginTimers() {
        this.frameRate.timeEnd();
        this.frameRate.timeStart();
        if (this._gpuTimeQuery && this._gpuTimeQuery.isResultAvailable() && !this._gpuTimeQuery.isTimerDisjoint()) this.stats.get("GPU Time").addTime(this._gpuTimeQuery.getTimerMilliseconds());
        if (this._gpuTimeQuery) this._gpuTimeQuery.beginTimeElapsedQuery();
        this.cpuTime.timeStart();
    }
    _endTimers() {
        this.cpuTime.timeEnd();
        if (this._gpuTimeQuery) this._gpuTimeQuery.end();
    }
    _startEventHandling() {
        const { canvas: canvas  } = this.gl;
        if (canvas) {
            canvas.addEventListener("mousemove", this._onMousemove);
            canvas.addEventListener("mouseleave", this._onMouseleave);
        }
    }
    _onMousemove(e) {
        this.animationProps._mousePosition = [
            e.offsetX,
            e.offsetY
        ];
    }
    _onMouseleave(e) {
        this.animationProps._mousePosition = null;
    }
}


const $23d7a12f17d9f134$export$9abae82e87f5416d = "vs";
const $23d7a12f17d9f134$export$71cb6c7fe82525af = "fs";


function $72fc9985edf189bb$export$2e2bcd8739ae039(condition, message) {
    if (!condition) throw new Error(message || "shadertools: assertion failed.");
}



const $2692d3bb490bbb66$var$TYPE_DEFINITIONS = {
    number: {
        validate (value, propType) {
            return Number.isFinite(value) && (!("max" in propType) || value <= propType.max) && (!("min" in propType) || value >= propType.min);
        }
    },
    array: {
        validate (value, propType) {
            return Array.isArray(value) || ArrayBuffer.isView(value);
        }
    }
};
function $2692d3bb490bbb66$export$6335b16489944934(propDefs) {
    const propTypes = {};
    for(const propName in propDefs){
        const propDef = propDefs[propName];
        const propType = $2692d3bb490bbb66$var$parsePropType(propDef);
        propTypes[propName] = propType;
    }
    return propTypes;
}
function $2692d3bb490bbb66$var$parsePropType(propDef) {
    let type = $2692d3bb490bbb66$var$getTypeOf(propDef);
    if (type === "object") {
        if (!propDef) return {
            type: "object",
            value: null
        };
        if ("type" in propDef) return Object.assign({}, propDef, $2692d3bb490bbb66$var$TYPE_DEFINITIONS[propDef.type]);
        if (!("value" in propDef)) return {
            type: "object",
            value: propDef
        };
        type = $2692d3bb490bbb66$var$getTypeOf(propDef.value);
        return Object.assign({
            type: type
        }, propDef, $2692d3bb490bbb66$var$TYPE_DEFINITIONS[type]);
    }
    return Object.assign({
        type: type,
        value: propDef
    }, $2692d3bb490bbb66$var$TYPE_DEFINITIONS[type]);
}
function $2692d3bb490bbb66$var$getTypeOf(value) {
    if (Array.isArray(value) || ArrayBuffer.isView(value)) return "array";
    return typeof value;
}


const $f3f714d708c06682$var$VERTEX_SHADER = "vs";
const $f3f714d708c06682$var$FRAGMENT_SHADER = "fs";
class $f3f714d708c06682$export$2e2bcd8739ae039 {
    constructor(_ref){
        let { name: name , vs: vs , fs: fs , dependencies: dependencies = [] , uniforms: uniforms , getUniforms: getUniforms , deprecations: deprecations = [] , defines: defines = {} , inject: inject = {} , vertexShader: vertexShader , fragmentShader: fragmentShader  } = _ref;
        (0, $72fc9985edf189bb$export$2e2bcd8739ae039)(typeof name === "string");
        this.name = name;
        this.vs = vs || vertexShader;
        this.fs = fs || fragmentShader;
        this.getModuleUniforms = getUniforms;
        this.dependencies = dependencies;
        this.deprecations = this._parseDeprecationDefinitions(deprecations);
        this.defines = defines;
        this.injections = $f3f714d708c06682$var$normalizeInjections(inject);
        if (uniforms) this.uniforms = (0, $2692d3bb490bbb66$export$6335b16489944934)(uniforms);
    }
    getModuleSource(type) {
        let moduleSource;
        switch(type){
            case $f3f714d708c06682$var$VERTEX_SHADER:
                moduleSource = this.vs || "";
                break;
            case $f3f714d708c06682$var$FRAGMENT_SHADER:
                moduleSource = this.fs || "";
                break;
            default:
                (0, $72fc9985edf189bb$export$2e2bcd8739ae039)(false);
        }
        return "#define MODULE_".concat(this.name.toUpperCase().replace(/[^0-9a-z]/gi, "_"), "\n").concat(moduleSource, "// END MODULE_").concat(this.name, "\n\n");
    }
    getUniforms(opts, uniforms) {
        if (this.getModuleUniforms) return this.getModuleUniforms(opts, uniforms);
        if (this.uniforms) return this._defaultGetUniforms(opts);
        return {};
    }
    getDefines() {
        return this.defines;
    }
    checkDeprecations(shaderSource, log) {
        this.deprecations.forEach((def)=>{
            if (def.regex.test(shaderSource)) {
                if (def.deprecated) log.deprecated(def.old, def.new)();
                else log.removed(def.old, def.new)();
            }
        });
    }
    _parseDeprecationDefinitions(deprecations) {
        deprecations.forEach((def)=>{
            switch(def.type){
                case "function":
                    def.regex = new RegExp("\\b".concat(def.old, "\\("));
                    break;
                default:
                    def.regex = new RegExp("".concat(def.type, " ").concat(def.old, ";"));
            }
        });
        return deprecations;
    }
    _defaultGetUniforms() {
        let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        const uniforms = {};
        const propTypes = this.uniforms;
        for(const key in propTypes){
            const propDef = propTypes[key];
            if (key in opts && !propDef.private) {
                if (propDef.validate) (0, $72fc9985edf189bb$export$2e2bcd8739ae039)(propDef.validate(opts[key], propDef), "".concat(this.name, ": invalid ").concat(key));
                uniforms[key] = opts[key];
            } else uniforms[key] = propDef.value;
        }
        return uniforms;
    }
}
function $f3f714d708c06682$export$68c1c1f4f5c924cc(module) {
    if (!module.normalized) {
        module.normalized = true;
        if (module.uniforms && !module.getUniforms) {
            const shaderModule = new $f3f714d708c06682$export$2e2bcd8739ae039(module);
            module.getUniforms = shaderModule.getUniforms.bind(shaderModule);
        }
    }
    return module;
}
function $f3f714d708c06682$var$normalizeInjections(injections) {
    const result = {
        vs: {},
        fs: {}
    };
    for(const hook in injections){
        let injection = injections[hook];
        const stage = hook.slice(0, 2);
        if (typeof injection === "string") injection = {
            order: 0,
            injection: injection
        };
        result[stage][hook] = injection;
    }
    return result;
}



function $b48d7b90009bb09d$export$85f943437bcc1df(modules) {
    return $b48d7b90009bb09d$var$getShaderDependencies($b48d7b90009bb09d$var$instantiateModules(modules));
}
function $b48d7b90009bb09d$var$getShaderDependencies(modules) {
    const moduleMap = {};
    const moduleDepth = {};
    $b48d7b90009bb09d$var$getDependencyGraph({
        modules: modules,
        level: 0,
        moduleMap: moduleMap,
        moduleDepth: moduleDepth
    });
    return Object.keys(moduleDepth).sort((a, b)=>moduleDepth[b] - moduleDepth[a]).map((name)=>moduleMap[name]);
}
function $b48d7b90009bb09d$var$getDependencyGraph(_ref) {
    let { modules: modules , level: level , moduleMap: moduleMap , moduleDepth: moduleDepth  } = _ref;
    if (level >= 5) throw new Error("Possible loop in shader dependency graph");
    for (const module of modules){
        moduleMap[module.name] = module;
        if (moduleDepth[module.name] === undefined || moduleDepth[module.name] < level) moduleDepth[module.name] = level;
    }
    for (const module1 of modules)if (module1.dependencies) $b48d7b90009bb09d$var$getDependencyGraph({
        modules: module1.dependencies,
        level: level + 1,
        moduleMap: moduleMap,
        moduleDepth: moduleDepth
    });
}
function $b48d7b90009bb09d$var$instantiateModules(modules, seen) {
    return modules.map((module)=>{
        if (module instanceof (0, $f3f714d708c06682$export$2e2bcd8739ae039)) return module;
        (0, $72fc9985edf189bb$export$2e2bcd8739ae039)(typeof module !== "string", "Shader module use by name is deprecated. Import shader module '".concat(module, "' and use it directly."));
        (0, $72fc9985edf189bb$export$2e2bcd8739ae039)(module.name, "shader module has no name");
        module = new (0, $f3f714d708c06682$export$2e2bcd8739ae039)(module);
        module.dependencies = $b48d7b90009bb09d$var$instantiateModules(module.dependencies);
        return module;
    });
}
const $b48d7b90009bb09d$export$b63c82f0e67dfc21 = {
    getShaderDependencies: $b48d7b90009bb09d$var$getShaderDependencies,
    getDependencyGraph: $b48d7b90009bb09d$var$getDependencyGraph
};


function $3020e6049f10c7c7$export$2e2bcd8739ae039() {
    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const navigator = typeof window !== "undefined" ? window.navigator || {} : {};
    const userAgent = opts.userAgent || navigator.userAgent || "";
    const isMSIE = userAgent.indexOf("MSIE ") !== -1;
    const isTrident = userAgent.indexOf("Trident/") !== -1;
    return isMSIE || isTrident;
}



const $56722cd4a954f9d7$var$GL_VENDOR = 0x1f00;
const $56722cd4a954f9d7$var$GL_RENDERER = 0x1f01;
const $56722cd4a954f9d7$var$GL_VERSION = 0x1f02;
const $56722cd4a954f9d7$var$GL_SHADING_LANGUAGE_VERSION = 0x8b8c;
const $56722cd4a954f9d7$var$WEBGL_FEATURES = {
    GLSL_FRAG_DATA: [
        "WEBGL_draw_buffers",
        true
    ],
    GLSL_FRAG_DEPTH: [
        "EXT_frag_depth",
        true
    ],
    GLSL_DERIVATIVES: [
        "OES_standard_derivatives",
        true
    ],
    GLSL_TEXTURE_LOD: [
        "EXT_shader_texture_lod",
        true
    ]
};
const $56722cd4a954f9d7$export$d6a5c11f04f75862 = {};
Object.keys($56722cd4a954f9d7$var$WEBGL_FEATURES).forEach((key)=>{
    $56722cd4a954f9d7$export$d6a5c11f04f75862[key] = key;
});
function $56722cd4a954f9d7$var$isWebGL2(gl) {
    if (typeof WebGL2RenderingContext !== "undefined" && gl instanceof WebGL2RenderingContext) return true;
    return Boolean(gl && gl._version === 2);
}
function $56722cd4a954f9d7$export$906f0ebe0848c767(gl) {
    const info = gl.getExtension("WEBGL_debug_renderer_info");
    const vendor = gl.getParameter(info && info.UNMASKED_VENDOR_WEBGL || $56722cd4a954f9d7$var$GL_VENDOR);
    const renderer = gl.getParameter(info && info.UNMASKED_RENDERER_WEBGL || $56722cd4a954f9d7$var$GL_RENDERER);
    const gpuVendor = $56722cd4a954f9d7$var$identifyGPUVendor(vendor, renderer);
    const gpuInfo = {
        gpuVendor: gpuVendor,
        vendor: vendor,
        renderer: renderer,
        version: gl.getParameter($56722cd4a954f9d7$var$GL_VERSION),
        shadingLanguageVersion: gl.getParameter($56722cd4a954f9d7$var$GL_SHADING_LANGUAGE_VERSION)
    };
    return gpuInfo;
}
function $56722cd4a954f9d7$var$identifyGPUVendor(vendor, renderer) {
    if (vendor.match(/NVIDIA/i) || renderer.match(/NVIDIA/i)) return "NVIDIA";
    if (vendor.match(/INTEL/i) || renderer.match(/INTEL/i)) return "INTEL";
    if (vendor.match(/AMD/i) || renderer.match(/AMD/i) || vendor.match(/ATI/i) || renderer.match(/ATI/i)) return "AMD";
    return "UNKNOWN GPU";
}
const $56722cd4a954f9d7$var$compiledGlslExtensions = {};
function $56722cd4a954f9d7$export$e5033c6f31304d8c(gl, cap) {
    let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    const feature = $56722cd4a954f9d7$var$WEBGL_FEATURES[cap];
    (0, $72fc9985edf189bb$export$2e2bcd8739ae039)(feature, cap);
    if (!(0, $3020e6049f10c7c7$export$2e2bcd8739ae039)(opts)) return true;
    if (cap in $56722cd4a954f9d7$var$compiledGlslExtensions) return $56722cd4a954f9d7$var$compiledGlslExtensions[cap];
    const extensionName = feature[0];
    const behavior = opts.behavior || "enable";
    const source = "#extension GL_".concat(extensionName, " : ").concat(behavior, "\nvoid main(void) {}");
    const shader = gl.createShader(35633);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    const canCompile = gl.getShaderParameter(shader, 35713);
    gl.deleteShader(shader);
    $56722cd4a954f9d7$var$compiledGlslExtensions[cap] = canCompile;
    return canCompile;
}
function $56722cd4a954f9d7$var$getFeature(gl, cap) {
    const feature = $56722cd4a954f9d7$var$WEBGL_FEATURES[cap];
    (0, $72fc9985edf189bb$export$2e2bcd8739ae039)(feature, cap);
    const extensionName = $56722cd4a954f9d7$var$isWebGL2(gl) ? feature[1] || feature[0] : feature[0];
    const value = typeof extensionName === "string" ? Boolean(gl.getExtension(extensionName)) : extensionName;
    (0, $72fc9985edf189bb$export$2e2bcd8739ae039)(value === false || value === true);
    return value;
}
function $56722cd4a954f9d7$export$990fdf4f5aca9ddb(gl, features) {
    features = Array.isArray(features) ? features : [
        features
    ];
    return features.every((feature)=>$56722cd4a954f9d7$var$getFeature(gl, feature));
}


function $2fbefa35cddc42a2$export$2c56069b1b5c9cc2(gl) {
    const debugInfo = (0, $56722cd4a954f9d7$export$906f0ebe0848c767)(gl);
    switch(debugInfo.gpuVendor.toLowerCase()){
        case "nvidia":
            return "#define NVIDIA_GPU\n// Nvidia optimizes away the calculation necessary for emulated fp64\n#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1\n";
        case "intel":
            return "#define INTEL_GPU\n// Intel optimizes away the calculation necessary for emulated fp64\n#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1\n// Intel's built-in 'tan' function doesn't have acceptable precision\n#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1\n// Intel GPU doesn't have full 32 bits precision in same cases, causes overflow\n#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1\n";
        case "amd":
            return "#define AMD_GPU\n";
        default:
            return "#define DEFAULT_GPU\n// Prevent driver from optimizing away the calculation necessary for emulated fp64\n#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1\n// Intel's built-in 'tan' function doesn't have acceptable precision\n#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1\n// Intel GPU doesn't have full 32 bits precision in same cases, causes overflow\n#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1\n";
    }
}
function $2fbefa35cddc42a2$export$e7726ded64e86312(gl, glslVersion, isFragment) {
    let versionDefines = "#if (__VERSION__ > 120)\n\n# define FEATURE_GLSL_DERIVATIVES\n# define FEATURE_GLSL_DRAW_BUFFERS\n# define FEATURE_GLSL_FRAG_DEPTH\n# define FEATURE_GLSL_TEXTURE_LOD\n\n// DEPRECATED FLAGS, remove in v9\n# define FRAG_DEPTH\n# define DERIVATIVES\n# define DRAW_BUFFERS\n# define TEXTURE_LOD\n\n#endif // __VERSION\n";
    if ((0, $56722cd4a954f9d7$export$990fdf4f5aca9ddb)(gl, (0, $56722cd4a954f9d7$export$d6a5c11f04f75862).GLSL_FRAG_DEPTH)) versionDefines += "\n// FRAG_DEPTH => gl_FragDepth is available\n#ifdef GL_EXT_frag_depth\n#extension GL_EXT_frag_depth : enable\n# define FEATURE_GLSL_FRAG_DEPTH\n# define FRAG_DEPTH\n# define gl_FragDepth gl_FragDepthEXT\n#endif\n";
    if ((0, $56722cd4a954f9d7$export$990fdf4f5aca9ddb)(gl, (0, $56722cd4a954f9d7$export$d6a5c11f04f75862).GLSL_DERIVATIVES) && (0, $56722cd4a954f9d7$export$e5033c6f31304d8c)(gl, (0, $56722cd4a954f9d7$export$d6a5c11f04f75862).GLSL_DERIVATIVES)) versionDefines += "\n// DERIVATIVES => dxdF, dxdY and fwidth are available\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives : enable\n# define FEATURE_GLSL_DERIVATIVES\n# define DERIVATIVES\n#endif\n";
    if ((0, $56722cd4a954f9d7$export$990fdf4f5aca9ddb)(gl, (0, $56722cd4a954f9d7$export$d6a5c11f04f75862).GLSL_FRAG_DATA) && (0, $56722cd4a954f9d7$export$e5033c6f31304d8c)(gl, (0, $56722cd4a954f9d7$export$d6a5c11f04f75862).GLSL_FRAG_DATA, {
        behavior: "require"
    })) versionDefines += "\n// DRAW_BUFFERS => gl_FragData[] is available\n#ifdef GL_EXT_draw_buffers\n#extension GL_EXT_draw_buffers : require\n#define FEATURE_GLSL_DRAW_BUFFERS\n#define DRAW_BUFFERS\n#endif\n";
    if ((0, $56722cd4a954f9d7$export$990fdf4f5aca9ddb)(gl, (0, $56722cd4a954f9d7$export$d6a5c11f04f75862).GLSL_TEXTURE_LOD)) versionDefines += "// TEXTURE_LOD => texture2DLod etc are available\n#ifdef GL_EXT_shader_texture_lod\n#extension GL_EXT_shader_texture_lod : enable\n\n# define FEATURE_GLSL_TEXTURE_LOD\n# define TEXTURE_LOD\n\n#endif\n";
    return versionDefines;
}


const $06b8554819c1cfcf$export$1c7c27df7700ab1e = "#ifdef MODULE_LOGDEPTH\n  logdepth_adjustPosition(gl_Position);\n#endif\n";
const $06b8554819c1cfcf$export$eb0c6f0420228c53 = "#ifdef MODULE_MATERIAL\n  gl_FragColor = material_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_LIGHTING\n  gl_FragColor = lighting_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_FOG\n  gl_FragColor = fog_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_PICKING\n  gl_FragColor = picking_filterHighlightColor(gl_FragColor);\n  gl_FragColor = picking_filterPickingColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_LOGDEPTH\n  logdepth_setFragDepth();\n#endif\n";




const $e03481e8f5a496cf$var$MODULE_INJECTORS = {
    [(0, $23d7a12f17d9f134$export$9abae82e87f5416d)]: (0, $06b8554819c1cfcf$export$1c7c27df7700ab1e),
    [(0, $23d7a12f17d9f134$export$71cb6c7fe82525af)]: (0, $06b8554819c1cfcf$export$eb0c6f0420228c53)
};
const $e03481e8f5a496cf$export$62f6e317489649e6 = "__LUMA_INJECT_DECLARATIONS__";
const $e03481e8f5a496cf$var$REGEX_START_OF_MAIN = /void\s+main\s*\([^)]*\)\s*\{\n?/;
const $e03481e8f5a496cf$var$REGEX_END_OF_MAIN = /}\n?[^{}]*$/;
const $e03481e8f5a496cf$var$fragments = [];
function $e03481e8f5a496cf$export$2e2bcd8739ae039(source, type, inject) {
    let injectStandardStubs = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    const isVertex = type === (0, $23d7a12f17d9f134$export$9abae82e87f5416d);
    for(const key in inject){
        const fragmentData = inject[key];
        fragmentData.sort((a, b)=>a.order - b.order);
        $e03481e8f5a496cf$var$fragments.length = fragmentData.length;
        for(let i = 0, len = fragmentData.length; i < len; ++i)$e03481e8f5a496cf$var$fragments[i] = fragmentData[i].injection;
        const fragmentString = "".concat($e03481e8f5a496cf$var$fragments.join("\n"), "\n");
        switch(key){
            case "vs:#decl":
                if (isVertex) source = source.replace($e03481e8f5a496cf$export$62f6e317489649e6, fragmentString);
                break;
            case "vs:#main-start":
                if (isVertex) source = source.replace($e03481e8f5a496cf$var$REGEX_START_OF_MAIN, (match)=>match + fragmentString);
                break;
            case "vs:#main-end":
                if (isVertex) source = source.replace($e03481e8f5a496cf$var$REGEX_END_OF_MAIN, (match)=>fragmentString + match);
                break;
            case "fs:#decl":
                if (!isVertex) source = source.replace($e03481e8f5a496cf$export$62f6e317489649e6, fragmentString);
                break;
            case "fs:#main-start":
                if (!isVertex) source = source.replace($e03481e8f5a496cf$var$REGEX_START_OF_MAIN, (match)=>match + fragmentString);
                break;
            case "fs:#main-end":
                if (!isVertex) source = source.replace($e03481e8f5a496cf$var$REGEX_END_OF_MAIN, (match)=>fragmentString + match);
                break;
            default:
                source = source.replace(key, (match)=>match + fragmentString);
        }
    }
    source = source.replace($e03481e8f5a496cf$export$62f6e317489649e6, "");
    if (injectStandardStubs) source = source.replace(/\}\s*$/, (match)=>match + $e03481e8f5a496cf$var$MODULE_INJECTORS[type]);
    return source;
}
function $e03481e8f5a496cf$export$cef13ee8fb8f32f3(injects) {
    const result = {};
    (0, $72fc9985edf189bb$export$2e2bcd8739ae039)(Array.isArray(injects) && injects.length > 1);
    injects.forEach((inject)=>{
        for(const key in inject)result[key] = result[key] ? "".concat(result[key], "\n").concat(inject[key]) : inject[key];
    });
    return result;
}


function $0a454f71c6acc901$var$testVariable(qualifier) {
    return new RegExp("\\b".concat(qualifier, "[ \\t]+(\\w+[ \\t]+\\w+(\\[\\w+\\])?;)"), "g");
}
const $0a454f71c6acc901$var$ES300_REPLACEMENTS = [
    [
        /^(#version[ \t]+(100|300[ \t]+es))?[ \t]*\n/,
        "#version 300 es\n"
    ],
    [
        /\btexture(2D|2DProj|Cube)Lod(EXT)?\(/g,
        "textureLod("
    ],
    [
        /\btexture(2D|2DProj|Cube)(EXT)?\(/g,
        "texture("
    ]
];
const $0a454f71c6acc901$var$ES300_VERTEX_REPLACEMENTS = [
    ...$0a454f71c6acc901$var$ES300_REPLACEMENTS,
    [
        $0a454f71c6acc901$var$testVariable("attribute"),
        "in $1"
    ],
    [
        $0a454f71c6acc901$var$testVariable("varying"),
        "out $1"
    ]
];
const $0a454f71c6acc901$var$ES300_FRAGMENT_REPLACEMENTS = [
    ...$0a454f71c6acc901$var$ES300_REPLACEMENTS,
    [
        $0a454f71c6acc901$var$testVariable("varying"),
        "in $1"
    ]
];
const $0a454f71c6acc901$var$ES100_REPLACEMENTS = [
    [
        /^#version[ \t]+300[ \t]+es/,
        "#version 100"
    ],
    [
        /\btexture(2D|2DProj|Cube)Lod\(/g,
        "texture$1LodEXT("
    ],
    [
        /\btexture\(/g,
        "texture2D("
    ],
    [
        /\btextureLod\(/g,
        "texture2DLodEXT("
    ]
];
const $0a454f71c6acc901$var$ES100_VERTEX_REPLACEMENTS = [
    ...$0a454f71c6acc901$var$ES100_REPLACEMENTS,
    [
        $0a454f71c6acc901$var$testVariable("in"),
        "attribute $1"
    ],
    [
        $0a454f71c6acc901$var$testVariable("out"),
        "varying $1"
    ]
];
const $0a454f71c6acc901$var$ES100_FRAGMENT_REPLACEMENTS = [
    ...$0a454f71c6acc901$var$ES100_REPLACEMENTS,
    [
        $0a454f71c6acc901$var$testVariable("in"),
        "varying $1"
    ]
];
const $0a454f71c6acc901$var$ES100_FRAGMENT_OUTPUT_NAME = "gl_FragColor";
const $0a454f71c6acc901$var$ES300_FRAGMENT_OUTPUT_REGEX = /\bout[ \t]+vec4[ \t]+(\w+)[ \t]*;\n?/;
const $0a454f71c6acc901$var$REGEX_START_OF_MAIN = /void\s+main\s*\([^)]*\)\s*\{\n?/;
function $0a454f71c6acc901$export$2e2bcd8739ae039(source, targetGLSLVersion, isVertex) {
    switch(targetGLSLVersion){
        case 300:
            return isVertex ? $0a454f71c6acc901$var$convertShader(source, $0a454f71c6acc901$var$ES300_VERTEX_REPLACEMENTS) : $0a454f71c6acc901$var$convertFragmentShaderTo300(source);
        case 100:
            return isVertex ? $0a454f71c6acc901$var$convertShader(source, $0a454f71c6acc901$var$ES100_VERTEX_REPLACEMENTS) : $0a454f71c6acc901$var$convertFragmentShaderTo100(source);
        default:
            throw new Error("unknown GLSL version ".concat(targetGLSLVersion));
    }
}
function $0a454f71c6acc901$var$convertShader(source, replacements) {
    for (const [pattern, replacement] of replacements)source = source.replace(pattern, replacement);
    return source;
}
function $0a454f71c6acc901$var$convertFragmentShaderTo300(source) {
    source = $0a454f71c6acc901$var$convertShader(source, $0a454f71c6acc901$var$ES300_FRAGMENT_REPLACEMENTS);
    const outputMatch = source.match($0a454f71c6acc901$var$ES300_FRAGMENT_OUTPUT_REGEX);
    if (outputMatch) {
        const outputName = outputMatch[1];
        source = source.replace(new RegExp("\\b".concat($0a454f71c6acc901$var$ES100_FRAGMENT_OUTPUT_NAME, "\\b"), "g"), outputName);
    } else {
        const outputName = "fragmentColor";
        source = source.replace($0a454f71c6acc901$var$REGEX_START_OF_MAIN, (match)=>"out vec4 ".concat(outputName, ";\n").concat(match)).replace(new RegExp("\\b".concat($0a454f71c6acc901$var$ES100_FRAGMENT_OUTPUT_NAME, "\\b"), "g"), outputName);
    }
    return source;
}
function $0a454f71c6acc901$var$convertFragmentShaderTo100(source) {
    source = $0a454f71c6acc901$var$convertShader(source, $0a454f71c6acc901$var$ES100_FRAGMENT_REPLACEMENTS);
    const outputMatch = source.match($0a454f71c6acc901$var$ES300_FRAGMENT_OUTPUT_REGEX);
    if (outputMatch) {
        const outputName = outputMatch[1];
        source = source.replace($0a454f71c6acc901$var$ES300_FRAGMENT_OUTPUT_REGEX, "").replace(new RegExp("\\b".concat(outputName, "\\b"), "g"), $0a454f71c6acc901$var$ES100_FRAGMENT_OUTPUT_NAME);
    }
    return source;
}



const $aefa4a4b3d440d18$var$INJECT_SHADER_DECLARATIONS = "\n\n".concat((0, $e03481e8f5a496cf$export$62f6e317489649e6), "\n\n");
const $aefa4a4b3d440d18$var$SHADER_TYPE = {
    [(0, $23d7a12f17d9f134$export$9abae82e87f5416d)]: "vertex",
    [(0, $23d7a12f17d9f134$export$71cb6c7fe82525af)]: "fragment"
};
const $aefa4a4b3d440d18$var$FRAGMENT_SHADER_PROLOGUE = "precision highp float;\n\n";
function $aefa4a4b3d440d18$export$284ff2a142913562(gl, opts) {
    const { vs: vs , fs: fs  } = opts;
    const modules = (0, $b48d7b90009bb09d$export$85f943437bcc1df)(opts.modules || []);
    return {
        gl: gl,
        vs: $aefa4a4b3d440d18$var$assembleShader(gl, Object.assign({}, opts, {
            source: vs,
            type: (0, $23d7a12f17d9f134$export$9abae82e87f5416d),
            modules: modules
        })),
        fs: $aefa4a4b3d440d18$var$assembleShader(gl, Object.assign({}, opts, {
            source: fs,
            type: (0, $23d7a12f17d9f134$export$71cb6c7fe82525af),
            modules: modules
        })),
        getUniforms: $aefa4a4b3d440d18$var$assembleGetUniforms(modules)
    };
}
function $aefa4a4b3d440d18$var$assembleShader(gl, _ref) {
    let { id: id , source: source , type: type , modules: modules , defines: defines = {} , hookFunctions: hookFunctions = [] , inject: inject = {} , transpileToGLSL100: transpileToGLSL100 = false , prologue: prologue = true , log: log  } = _ref;
    (0, $72fc9985edf189bb$export$2e2bcd8739ae039)(typeof source === "string", "shader source must be a string");
    const isVertex = type === (0, $23d7a12f17d9f134$export$9abae82e87f5416d);
    const sourceLines = source.split("\n");
    let glslVersion = 100;
    let versionLine = "";
    let coreSource = source;
    if (sourceLines[0].indexOf("#version ") === 0) {
        glslVersion = 300;
        versionLine = sourceLines[0];
        coreSource = sourceLines.slice(1).join("\n");
    } else versionLine = "#version ".concat(glslVersion);
    const allDefines = {};
    modules.forEach((module)=>{
        Object.assign(allDefines, module.getDefines());
    });
    Object.assign(allDefines, defines);
    let assembledSource = prologue ? "".concat(versionLine, "\n").concat($aefa4a4b3d440d18$var$getShaderName({
        id: id,
        source: source,
        type: type
    }), "\n").concat($aefa4a4b3d440d18$var$getShaderType({
        type: type
    }), "\n").concat((0, $2fbefa35cddc42a2$export$2c56069b1b5c9cc2)(gl), "\n").concat((0, $2fbefa35cddc42a2$export$e7726ded64e86312)(gl, glslVersion, !isVertex), "\n").concat($aefa4a4b3d440d18$var$getApplicationDefines(allDefines), "\n").concat(isVertex ? "" : $aefa4a4b3d440d18$var$FRAGMENT_SHADER_PROLOGUE, "\n") : "".concat(versionLine, "\n");
    const hookFunctionMap = $aefa4a4b3d440d18$var$normalizeHookFunctions(hookFunctions);
    const hookInjections = {};
    const declInjections = {};
    const mainInjections = {};
    for(const key in inject){
        const injection = typeof inject[key] === "string" ? {
            injection: inject[key],
            order: 0
        } : inject[key];
        const match = key.match(/^(v|f)s:(#)?([\w-]+)$/);
        if (match) {
            const hash = match[2];
            const name = match[3];
            if (hash) {
                if (name === "decl") declInjections[key] = [
                    injection
                ];
                else mainInjections[key] = [
                    injection
                ];
            } else hookInjections[key] = [
                injection
            ];
        } else mainInjections[key] = [
            injection
        ];
    }
    for (const module1 of modules){
        if (log) module1.checkDeprecations(coreSource, log);
        const moduleSource = module1.getModuleSource(type, glslVersion);
        assembledSource += moduleSource;
        const injections = module1.injections[type];
        for(const key in injections){
            const match = key.match(/^(v|f)s:#([\w-]+)$/);
            if (match) {
                const name = match[2];
                const injectionType = name === "decl" ? declInjections : mainInjections;
                injectionType[key] = injectionType[key] || [];
                injectionType[key].push(injections[key]);
            } else {
                hookInjections[key] = hookInjections[key] || [];
                hookInjections[key].push(injections[key]);
            }
        }
    }
    assembledSource += $aefa4a4b3d440d18$var$INJECT_SHADER_DECLARATIONS;
    assembledSource = (0, $e03481e8f5a496cf$export$2e2bcd8739ae039)(assembledSource, type, declInjections);
    assembledSource += $aefa4a4b3d440d18$var$getHookFunctions(hookFunctionMap[type], hookInjections);
    assembledSource += coreSource;
    assembledSource = (0, $e03481e8f5a496cf$export$2e2bcd8739ae039)(assembledSource, type, mainInjections);
    assembledSource = (0, $0a454f71c6acc901$export$2e2bcd8739ae039)(assembledSource, transpileToGLSL100 ? 100 : glslVersion, isVertex);
    return assembledSource;
}
function $aefa4a4b3d440d18$var$assembleGetUniforms(modules) {
    return function getUniforms(opts) {
        const uniforms = {};
        for (const module of modules){
            const moduleUniforms = module.getUniforms(opts, uniforms);
            Object.assign(uniforms, moduleUniforms);
        }
        return uniforms;
    };
}
function $aefa4a4b3d440d18$var$getShaderType(_ref2) {
    let { type: type  } = _ref2;
    return "\n#define SHADER_TYPE_".concat($aefa4a4b3d440d18$var$SHADER_TYPE[type].toUpperCase(), "\n");
}
function $aefa4a4b3d440d18$var$getShaderName(_ref3) {
    let { id: id , source: source , type: type  } = _ref3;
    const injectShaderName = id && typeof id === "string" && source.indexOf("SHADER_NAME") === -1;
    return injectShaderName ? "\n#define SHADER_NAME ".concat(id, "_").concat($aefa4a4b3d440d18$var$SHADER_TYPE[type], "\n\n") : "";
}
function $aefa4a4b3d440d18$var$getApplicationDefines() {
    let defines = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let count = 0;
    let sourceText = "";
    for(const define in defines){
        if (count === 0) sourceText += "\n// APPLICATION DEFINES\n";
        count++;
        const value = defines[define];
        if (value || Number.isFinite(value)) sourceText += "#define ".concat(define.toUpperCase(), " ").concat(defines[define], "\n");
    }
    if (count === 0) sourceText += "\n";
    return sourceText;
}
function $aefa4a4b3d440d18$var$getHookFunctions(hookFunctions, hookInjections) {
    let result = "";
    for(const hookName in hookFunctions){
        const hookFunction = hookFunctions[hookName];
        result += "void ".concat(hookFunction.signature, " {\n");
        if (hookFunction.header) result += "  ".concat(hookFunction.header);
        if (hookInjections[hookName]) {
            const injections = hookInjections[hookName];
            injections.sort((a, b)=>a.order - b.order);
            for (const injection of injections)result += "  ".concat(injection.injection, "\n");
        }
        if (hookFunction.footer) result += "  ".concat(hookFunction.footer);
        result += "}\n";
    }
    return result;
}
function $aefa4a4b3d440d18$var$normalizeHookFunctions(hookFunctions) {
    const result = {
        vs: {},
        fs: {}
    };
    hookFunctions.forEach((hook)=>{
        let opts;
        if (typeof hook !== "string") {
            opts = hook;
            hook = opts.hook;
        } else opts = {};
        hook = hook.trim();
        const [stage, signature] = hook.split(":");
        const name = hook.replace(/\(.+/, "");
        result[stage][name] = Object.assign(opts, {
            signature: signature
        });
    });
    return result;
}


const $b14a5ab92b562947$var$FS100 = "void main() {gl_FragColor = vec4(0);}";
const $b14a5ab92b562947$var$FS_GLES = "out vec4 transform_output;\nvoid main() {\n  transform_output = vec4(0);\n}";
const $b14a5ab92b562947$var$FS300 = "#version 300 es\n".concat($b14a5ab92b562947$var$FS_GLES);
function $b14a5ab92b562947$export$ca11e09347dd6309(line, qualifiers) {
    qualifiers = Array.isArray(qualifiers) ? qualifiers : [
        qualifiers
    ];
    const words = line.replace(/^\s+/, "").split(/\s+/);
    const [qualifier, type, definition] = words;
    if (!qualifiers.includes(qualifier) || !type || !definition) return null;
    const name = definition.split(";")[0];
    return {
        qualifier: qualifier,
        type: type,
        name: name
    };
}
function $b14a5ab92b562947$export$523a4d4d9f32ef9e() {
    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const { version: version = 100 , input: input , inputType: inputType , output: output  } = options;
    if (!input) {
        if (version === 300) return $b14a5ab92b562947$var$FS300;
        else if (version > 300) return "#version ".concat(version, "\n").concat($b14a5ab92b562947$var$FS_GLES);
        return $b14a5ab92b562947$var$FS100;
    }
    const outputValue = $b14a5ab92b562947$export$5616b9a44ef98392(input, inputType);
    if (version >= 300) return "#version ".concat(version, " ").concat(version === 300 ? "es" : "", "\nin ").concat(inputType, " ").concat(input, ";\nout vec4 ").concat(output, ";\nvoid main() {\n  ").concat(output, " = ").concat(outputValue, ";\n}");
    return "varying ".concat(inputType, " ").concat(input, ";\nvoid main() {\n  gl_FragColor = ").concat(outputValue, ";\n}");
}
function $b14a5ab92b562947$export$7c9d09032d11b05d(type) {
    switch(type){
        case "float":
            return "x";
        case "vec2":
            return "xy";
        case "vec3":
            return "xyz";
        case "vec4":
            return "xyzw";
        default:
            (0, $72fc9985edf189bb$export$2e2bcd8739ae039)(false);
            return null;
    }
}
function $b14a5ab92b562947$export$7d9650494fc7500d(type) {
    switch(type){
        case "float":
            return 1;
        case "vec2":
            return 2;
        case "vec3":
            return 3;
        case "vec4":
            return 4;
        default:
            (0, $72fc9985edf189bb$export$2e2bcd8739ae039)(false);
            return null;
    }
}
function $b14a5ab92b562947$export$5616b9a44ef98392(variable, type) {
    switch(type){
        case "float":
            return "vec4(".concat(variable, ", 0.0, 0.0, 1.0)");
        case "vec2":
            return "vec4(".concat(variable, ", 0.0, 1.0)");
        case "vec3":
            return "vec4(".concat(variable, ", 1.0)");
        case "vec4":
            return variable;
        default:
            (0, $72fc9985edf189bb$export$2e2bcd8739ae039)(false);
            return null;
    }
}

const $65fa5645ea84a164$var$fp32shader = "#ifdef LUMA_FP32_TAN_PRECISION_WORKAROUND\nconst float TWO_PI = 6.2831854820251465;\nconst float PI_2 = 1.5707963705062866;\nconst float PI_16 = 0.1963495463132858;\n\nconst float SIN_TABLE_0 = 0.19509032368659973;\nconst float SIN_TABLE_1 = 0.3826834261417389;\nconst float SIN_TABLE_2 = 0.5555702447891235;\nconst float SIN_TABLE_3 = 0.7071067690849304;\n\nconst float COS_TABLE_0 = 0.9807852506637573;\nconst float COS_TABLE_1 = 0.9238795042037964;\nconst float COS_TABLE_2 = 0.8314695954322815;\nconst float COS_TABLE_3 = 0.7071067690849304;\n\nconst float INVERSE_FACTORIAL_3 = 1.666666716337204e-01;\nconst float INVERSE_FACTORIAL_5 = 8.333333767950535e-03;\nconst float INVERSE_FACTORIAL_7 = 1.9841270113829523e-04;\nconst float INVERSE_FACTORIAL_9 = 2.75573188446287533e-06;\n\nfloat sin_taylor_fp32(float a) {\n  float r, s, t, x;\n\n  if (a == 0.0) {\n    return 0.0;\n  }\n\n  x = -a * a;\n  s = a;\n  r = a;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_3;\n  s = s + t;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_5;\n  s = s + t;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_7;\n  s = s + t;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_9;\n  s = s + t;\n\n  return s;\n}\n\nvoid sincos_taylor_fp32(float a, out float sin_t, out float cos_t) {\n  if (a == 0.0) {\n    sin_t = 0.0;\n    cos_t = 1.0;\n  }\n  sin_t = sin_taylor_fp32(a);\n  cos_t = sqrt(1.0 - sin_t * sin_t);\n}\n\nfloat tan_taylor_fp32(float a) {\n    float sin_a;\n    float cos_a;\n\n    if (a == 0.0) {\n        return 0.0;\n    }\n    float z = floor(a / TWO_PI);\n    float r = a - TWO_PI * z;\n\n    float t;\n    float q = floor(r / PI_2 + 0.5);\n    int j = int(q);\n\n    if (j < -2 || j > 2) {\n        return 1.0 / 0.0;\n    }\n\n    t = r - PI_2 * q;\n\n    q = floor(t / PI_16 + 0.5);\n    int k = int(q);\n    int abs_k = int(abs(float(k)));\n\n    if (abs_k > 4) {\n        return 1.0 / 0.0;\n    } else {\n        t = t - PI_16 * q;\n    }\n\n    float u = 0.0;\n    float v = 0.0;\n\n    float sin_t, cos_t;\n    float s, c;\n    sincos_taylor_fp32(t, sin_t, cos_t);\n\n    if (k == 0) {\n        s = sin_t;\n        c = cos_t;\n    } else {\n        if (abs(float(abs_k) - 1.0) < 0.5) {\n            u = COS_TABLE_0;\n            v = SIN_TABLE_0;\n        } else if (abs(float(abs_k) - 2.0) < 0.5) {\n            u = COS_TABLE_1;\n            v = SIN_TABLE_1;\n        } else if (abs(float(abs_k) - 3.0) < 0.5) {\n            u = COS_TABLE_2;\n            v = SIN_TABLE_2;\n        } else if (abs(float(abs_k) - 4.0) < 0.5) {\n            u = COS_TABLE_3;\n            v = SIN_TABLE_3;\n        }\n        if (k > 0) {\n            s = u * sin_t + v * cos_t;\n            c = u * cos_t - v * sin_t;\n        } else {\n            s = u * sin_t - v * cos_t;\n            c = u * cos_t + v * sin_t;\n        }\n    }\n\n    if (j == 0) {\n        sin_a = s;\n        cos_a = c;\n    } else if (j == 1) {\n        sin_a = c;\n        cos_a = -s;\n    } else if (j == -1) {\n        sin_a = -c;\n        cos_a = s;\n    } else {\n        sin_a = -s;\n        cos_a = -c;\n    }\n    return sin_a / cos_a;\n}\n#endif\n\nfloat tan_fp32(float a) {\n#ifdef LUMA_FP32_TAN_PRECISION_WORKAROUND\n  return tan_taylor_fp32(a);\n#else\n  return tan(a);\n#endif\n}\n";
const $65fa5645ea84a164$export$d4bf4ab3180407a1 = {
    name: "fp32",
    vs: $65fa5645ea84a164$var$fp32shader,
    fs: null
};

const $7e9d081b840cbf62$var$DEFAULT_HIGHLIGHT_COLOR = new Uint8Array([
    0,
    255,
    255,
    255
]);
const $7e9d081b840cbf62$var$DEFAULT_MODULE_OPTIONS = {
    pickingSelectedColor: null,
    pickingHighlightColor: $7e9d081b840cbf62$var$DEFAULT_HIGHLIGHT_COLOR,
    pickingActive: false,
    pickingAttribute: false
};
function $7e9d081b840cbf62$var$getUniforms() {
    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : $7e9d081b840cbf62$var$DEFAULT_MODULE_OPTIONS;
    const uniforms = {};
    if (opts.pickingSelectedColor !== undefined) {
        if (!opts.pickingSelectedColor) uniforms.picking_uSelectedColorValid = 0;
        else {
            const selectedColor = opts.pickingSelectedColor.slice(0, 3);
            uniforms.picking_uSelectedColorValid = 1;
            uniforms.picking_uSelectedColor = selectedColor;
        }
    }
    if (opts.pickingHighlightColor) {
        const color = Array.from(opts.pickingHighlightColor, (x)=>x / 255);
        if (!Number.isFinite(color[3])) color[3] = 1;
        uniforms.picking_uHighlightColor = color;
    }
    if (opts.pickingActive !== undefined) {
        uniforms.picking_uActive = Boolean(opts.pickingActive);
        uniforms.picking_uAttribute = Boolean(opts.pickingAttribute);
    }
    return uniforms;
}
const $7e9d081b840cbf62$var$vs = "uniform bool picking_uActive;\nuniform bool picking_uAttribute;\nuniform vec3 picking_uSelectedColor;\nuniform bool picking_uSelectedColorValid;\n\nout vec4 picking_vRGBcolor_Avalid;\n\nconst float COLOR_SCALE = 1. / 255.;\n\nbool picking_isColorValid(vec3 color) {\n  return dot(color, vec3(1.0)) > 0.001;\n}\n\nbool isVertexPicked(vec3 vertexColor) {\n  return\n    picking_uSelectedColorValid &&\n    !picking_isColorValid(abs(vertexColor - picking_uSelectedColor));\n}\n\nvoid picking_setPickingColor(vec3 pickingColor) {\n  if (picking_uActive) {\n    picking_vRGBcolor_Avalid.a = float(picking_isColorValid(pickingColor));\n\n    if (!picking_uAttribute) {\n      picking_vRGBcolor_Avalid.rgb = pickingColor * COLOR_SCALE;\n    }\n  } else {\n    picking_vRGBcolor_Avalid.a = float(isVertexPicked(pickingColor));\n  }\n}\n\nvoid picking_setPickingAttribute(float value) {\n  if (picking_uAttribute) {\n    picking_vRGBcolor_Avalid.r = value;\n  }\n}\nvoid picking_setPickingAttribute(vec2 value) {\n  if (picking_uAttribute) {\n    picking_vRGBcolor_Avalid.rg = value;\n  }\n}\nvoid picking_setPickingAttribute(vec3 value) {\n  if (picking_uAttribute) {\n    picking_vRGBcolor_Avalid.rgb = value;\n  }\n}\n";
const $7e9d081b840cbf62$var$fs = "uniform bool picking_uActive;\nuniform vec3 picking_uSelectedColor;\nuniform vec4 picking_uHighlightColor;\n\nin vec4 picking_vRGBcolor_Avalid;\nvec4 picking_filterHighlightColor(vec4 color) {\n  if (picking_uActive) {\n    return color;\n  }\n  bool selected = bool(picking_vRGBcolor_Avalid.a);\n\n  if (selected) {\n    float highLightAlpha = picking_uHighlightColor.a;\n    float blendedAlpha = highLightAlpha + color.a * (1.0 - highLightAlpha);\n    float highLightRatio = highLightAlpha / blendedAlpha;\n\n    vec3 blendedRGB = mix(color.rgb, picking_uHighlightColor.rgb, highLightRatio);\n    return vec4(blendedRGB, blendedAlpha);\n  } else {\n    return color;\n  }\n}\nvec4 picking_filterPickingColor(vec4 color) {\n  if (picking_uActive) {\n    if (picking_vRGBcolor_Avalid.a == 0.0) {\n      discard;\n    }\n    return picking_vRGBcolor_Avalid;\n  }\n  return color;\n}\nvec4 picking_filterColor(vec4 color) {\n  vec4 highightColor = picking_filterHighlightColor(color);\n  return picking_filterPickingColor(highightColor);\n}\n\n";
const $7e9d081b840cbf62$export$1f1790962c6071cf = {
    name: "picking",
    vs: $7e9d081b840cbf62$var$vs,
    fs: $7e9d081b840cbf62$var$fs,
    getUniforms: $7e9d081b840cbf62$var$getUniforms
};

const $3812d8ee6528adfc$var$vs = "attribute float transform_elementID;\nvec2 transform_getPixelSizeHalf(vec2 size) {\n  return vec2(1.) / (2. * size);\n}\n\nvec2 transform_getPixelIndices(vec2 texSize, vec2 pixelSizeHalf) {\n  float yIndex = floor((transform_elementID / texSize[0]) + pixelSizeHalf[1]);\n  float xIndex = transform_elementID - (yIndex * texSize[0]);\n  return vec2(xIndex, yIndex);\n}\nvec2 transform_getTexCoord(vec2 size) {\n  vec2 pixelSizeHalf = transform_getPixelSizeHalf(size);\n  vec2 indices = transform_getPixelIndices(size, pixelSizeHalf);\n  vec2 coord = indices / size + pixelSizeHalf;\n  return coord;\n}\nvec2 transform_getPos(vec2 size) {\n  vec2 texCoord = transform_getTexCoord(size);\n  vec2 pos = (texCoord * (2.0, 2.0)) - (1., 1.);\n  return pos;\n}\nvec4 transform_getInput(sampler2D texSampler, vec2 size) {\n  vec2 texCoord = transform_getTexCoord(size);\n  vec4 textureColor = texture2D(texSampler, texCoord);\n  return textureColor;\n}\n";
const $3812d8ee6528adfc$export$51186ad6e864892a = {
    name: "transform",
    vs: $3812d8ee6528adfc$var$vs,
    fs: null
};





class $389aec4f13e2bfb5$export$2e2bcd8739ae039 {
    static getDefaultProgramManager(gl) {
        gl.luma = gl.luma || {};
        gl.luma.defaultProgramManager = gl.luma.defaultProgramManager || new $389aec4f13e2bfb5$export$2e2bcd8739ae039(gl);
        return gl.luma.defaultProgramManager;
    }
    constructor(gl){
        this.gl = gl;
        this._programCache = {};
        this._getUniforms = {};
        this._registeredModules = {};
        this._hookFunctions = [];
        this._defaultModules = [];
        this._hashes = {};
        this._hashCounter = 0;
        this.stateHash = 0;
        this._useCounts = {};
    }
    addDefaultModule(module) {
        if (!this._defaultModules.find((m)=>m.name === module.name)) this._defaultModules.push(module);
        this.stateHash++;
    }
    removeDefaultModule(module) {
        const moduleName = typeof module === "string" ? module : module.name;
        this._defaultModules = this._defaultModules.filter((m)=>m.name !== moduleName);
        this.stateHash++;
    }
    addShaderHook(hook, opts) {
        if (opts) hook = Object.assign(opts, {
            hook: hook
        });
        this._hookFunctions.push(hook);
        this.stateHash++;
    }
    get() {
        let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        const { vs: vs = "" , fs: fs = "" , defines: defines = {} , inject: inject = {} , varyings: varyings = [] , bufferMode: bufferMode = 0x8c8d , transpileToGLSL100: transpileToGLSL100 = false  } = props;
        const modules = this._getModuleList(props.modules);
        const vsHash = this._getHash(vs);
        const fsHash = this._getHash(fs);
        const moduleHashes = modules.map((m)=>this._getHash(m.name)).sort();
        const varyingHashes = varyings.map((v)=>this._getHash(v));
        const defineKeys = Object.keys(defines).sort();
        const injectKeys = Object.keys(inject).sort();
        const defineHashes = [];
        const injectHashes = [];
        for (const key of defineKeys){
            defineHashes.push(this._getHash(key));
            defineHashes.push(this._getHash(defines[key]));
        }
        for (const key1 of injectKeys){
            injectHashes.push(this._getHash(key1));
            injectHashes.push(this._getHash(inject[key1]));
        }
        const hash = "".concat(vsHash, "/").concat(fsHash, "D").concat(defineHashes.join("/"), "M").concat(moduleHashes.join("/"), "I").concat(injectHashes.join("/"), "V").concat(varyingHashes.join("/"), "H").concat(this.stateHash, "B").concat(bufferMode).concat(transpileToGLSL100 ? "T" : "");
        if (!this._programCache[hash]) {
            const assembled = (0, $aefa4a4b3d440d18$export$284ff2a142913562)(this.gl, {
                vs: vs,
                fs: fs,
                modules: modules,
                inject: inject,
                defines: defines,
                hookFunctions: this._hookFunctions,
                transpileToGLSL100: transpileToGLSL100
            });
            this._programCache[hash] = new (0, $6fea3ad8e77f174f$export$2e2bcd8739ae039)(this.gl, {
                hash: hash,
                vs: assembled.vs,
                fs: assembled.fs,
                varyings: varyings,
                bufferMode: bufferMode
            });
            this._getUniforms[hash] = assembled.getUniforms || ((x)=>{});
            this._useCounts[hash] = 0;
        }
        this._useCounts[hash]++;
        return this._programCache[hash];
    }
    getUniforms(program) {
        return this._getUniforms[program.hash] || null;
    }
    release(program) {
        const hash = program.hash;
        this._useCounts[hash]--;
        if (this._useCounts[hash] === 0) {
            this._programCache[hash].delete();
            delete this._programCache[hash];
            delete this._getUniforms[hash];
            delete this._useCounts[hash];
        }
    }
    _getHash(key) {
        if (this._hashes[key] === undefined) this._hashes[key] = this._hashCounter++;
        return this._hashes[key];
    }
    _getModuleList() {
        let appModules = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
        const modules = new Array(this._defaultModules.length + appModules.length);
        const seen = {};
        let count = 0;
        for(let i = 0, len = this._defaultModules.length; i < len; ++i){
            const module = this._defaultModules[i];
            const name = module.name;
            modules[count++] = module;
            seen[name] = true;
        }
        for(let i1 = 0, len1 = appModules.length; i1 < len1; ++i1){
            const module = appModules[i1];
            const name = module.name;
            if (!seen[name]) {
                modules[count++] = module;
                seen[name] = true;
            }
        }
        modules.length = count;
        return modules;
    }
}





const $bb5aa92f5c43a56c$var$GLTF_TO_LUMA_ATTRIBUTE_MAP = {
    POSITION: "positions",
    NORMAL: "normals",
    COLOR_0: "colors",
    TEXCOORD_0: "texCoords",
    TEXCOORD_1: "texCoords1",
    TEXCOORD_2: "texCoords2"
};
function $bb5aa92f5c43a56c$export$7e4fab05163ba2d1(gl, geometry, options) {
    const buffers = {};
    let indices = geometry.indices;
    for(const name in geometry.attributes){
        const attribute = geometry.attributes[name];
        const remappedName = $bb5aa92f5c43a56c$var$mapAttributeName(name, options);
        if (name === "indices") indices = attribute;
        else if (attribute.constant) buffers[remappedName] = attribute.value;
        else {
            const typedArray = attribute.value;
            const accessor = {
                ...attribute
            };
            delete accessor.value;
            buffers[remappedName] = [
                new (0, $28a69bf6d03705d1$export$2e2bcd8739ae039)(gl, typedArray),
                accessor
            ];
            $bb5aa92f5c43a56c$export$3f504f33778aed92(name, accessor);
        }
    }
    if (indices) {
        const data = indices.value || indices;
        (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(data instanceof Uint16Array || data instanceof Uint32Array, 'attribute array for "indices" must be of integer type');
        const accessor = {
            size: 1,
            isIndexed: indices.isIndexed === undefined ? true : indices.isIndexed
        };
        buffers.indices = [
            new (0, $28a69bf6d03705d1$export$2e2bcd8739ae039)(gl, {
                data: data,
                target: 34963
            }),
            accessor
        ];
    }
    return buffers;
}
function $bb5aa92f5c43a56c$var$mapAttributeName(name, options) {
    const { attributeMap: attributeMap = $bb5aa92f5c43a56c$var$GLTF_TO_LUMA_ATTRIBUTE_MAP  } = options || {};
    return attributeMap && attributeMap[name] || name;
}
function $bb5aa92f5c43a56c$export$3f504f33778aed92(attributeName, attribute) {
    let category;
    switch(attributeName){
        case "texCoords":
        case "texCoord1":
        case "texCoord2":
        case "texCoord3":
            category = "uvs";
            break;
        case "vertices":
        case "positions":
        case "normals":
        case "pickingColors":
            category = "vectors";
            break;
        default:
    }
    switch(category){
        case "vectors":
            attribute.size = attribute.size || 3;
            break;
        case "uvs":
            attribute.size = attribute.size || 2;
            break;
        default:
    }
    (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(Number.isFinite(attribute.size), "attribute ".concat(attributeName, " needs size"));
}


const $d4b5fa431316d551$var$LOG_DRAW_PRIORITY = 2;
const $d4b5fa431316d551$var$LOG_DRAW_TIMEOUT = 10000;
const $d4b5fa431316d551$var$ERR_MODEL_PARAMS = "Model needs drawMode and vertexCount";
const $d4b5fa431316d551$var$NOOP = ()=>{};
const $d4b5fa431316d551$var$DRAW_PARAMS = {};
class $d4b5fa431316d551$export$2e2bcd8739ae039 {
    constructor(gl){
        let props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        const { id: id = (0, $757dc76705f498e6$export$e2a22331486dcca0)("model")  } = props;
        (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)((0, $325e733792a03f4e$export$3a471d0dd6792be6)(gl));
        this.id = id;
        this.gl = gl;
        this.id = props.id || (0, $757dc76705f498e6$export$e2a22331486dcca0)("Model");
        this.lastLogTime = 0;
        this.animated = false;
        this.initialize(props);
    }
    initialize(props) {
        this.props = {};
        this.programManager = props.programManager || (0, $389aec4f13e2bfb5$export$2e2bcd8739ae039).getDefaultProgramManager(this.gl);
        this._programManagerState = -1;
        this._managedProgram = false;
        const { program: program = null , vs: vs , fs: fs , modules: modules , defines: defines , inject: inject , varyings: varyings , bufferMode: bufferMode , transpileToGLSL100: transpileToGLSL100  } = props;
        this.programProps = {
            program: program,
            vs: vs,
            fs: fs,
            modules: modules,
            defines: defines,
            inject: inject,
            varyings: varyings,
            bufferMode: bufferMode,
            transpileToGLSL100: transpileToGLSL100
        };
        this.program = null;
        this.vertexArray = null;
        this._programDirty = true;
        this.userData = {};
        this.needsRedraw = true;
        this._attributes = {};
        this.attributes = {};
        this.uniforms = {};
        this.pickable = true;
        this._checkProgram();
        this.setUniforms(Object.assign({}, this.getModuleUniforms(props.moduleSettings)));
        this.drawMode = props.drawMode !== undefined ? props.drawMode : 4;
        this.vertexCount = props.vertexCount || 0;
        this.geometryBuffers = {};
        this.isInstanced = props.isInstanced || props.instanced || props.instanceCount > 0;
        this._setModelProps(props);
        this.geometry = {};
        (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(this.drawMode !== undefined && Number.isFinite(this.vertexCount), $d4b5fa431316d551$var$ERR_MODEL_PARAMS);
    }
    setProps(props) {
        this._setModelProps(props);
    }
    delete() {
        for(const key in this._attributes)if (this._attributes[key] !== this.attributes[key]) this._attributes[key].delete();
        if (this._managedProgram) {
            this.programManager.release(this.program);
            this._managedProgram = false;
        }
        this.vertexArray.delete();
        this._deleteGeometryBuffers();
    }
    getDrawMode() {
        return this.drawMode;
    }
    getVertexCount() {
        return this.vertexCount;
    }
    getInstanceCount() {
        return this.instanceCount;
    }
    getAttributes() {
        return this.attributes;
    }
    getProgram() {
        return this.program;
    }
    setProgram(props) {
        const { program: program , vs: vs , fs: fs , modules: modules , defines: defines , inject: inject , varyings: varyings , bufferMode: bufferMode , transpileToGLSL100: transpileToGLSL100  } = props;
        this.programProps = {
            program: program,
            vs: vs,
            fs: fs,
            modules: modules,
            defines: defines,
            inject: inject,
            varyings: varyings,
            bufferMode: bufferMode,
            transpileToGLSL100: transpileToGLSL100
        };
        this._programDirty = true;
    }
    getUniforms() {
        return this.uniforms;
    }
    setDrawMode(drawMode) {
        this.drawMode = drawMode;
        return this;
    }
    setVertexCount(vertexCount) {
        (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(Number.isFinite(vertexCount));
        this.vertexCount = vertexCount;
        return this;
    }
    setInstanceCount(instanceCount) {
        (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(Number.isFinite(instanceCount));
        this.instanceCount = instanceCount;
        return this;
    }
    setGeometry(geometry) {
        this.drawMode = geometry.drawMode;
        this.vertexCount = geometry.getVertexCount();
        this._deleteGeometryBuffers();
        this.geometryBuffers = (0, $bb5aa92f5c43a56c$export$7e4fab05163ba2d1)(this.gl, geometry);
        this.vertexArray.setAttributes(this.geometryBuffers);
        return this;
    }
    setAttributes() {
        let attributes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        if ((0, $757dc76705f498e6$export$23cfe696632d10f4)(attributes)) return this;
        const normalizedAttributes = {};
        for(const name in attributes){
            const attribute = attributes[name];
            normalizedAttributes[name] = attribute.getValue ? attribute.getValue() : attribute;
        }
        this.vertexArray.setAttributes(normalizedAttributes);
        return this;
    }
    setUniforms() {
        let uniforms = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        Object.assign(this.uniforms, uniforms);
        return this;
    }
    getModuleUniforms(opts) {
        this._checkProgram();
        const getUniforms = this.programManager.getUniforms(this.program);
        if (getUniforms) return getUniforms(opts);
        return {};
    }
    updateModuleSettings(opts) {
        const uniforms = this.getModuleUniforms(opts || {});
        return this.setUniforms(uniforms);
    }
    clear(opts) {
        (0, $9d2da77370080708$export$42ffd38884aecdac)(this.program.gl, opts);
        return this;
    }
    draw() {
        let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        this._checkProgram();
        const { moduleSettings: moduleSettings = null , framebuffer: framebuffer , uniforms: uniforms = {} , attributes: attributes = {} , transformFeedback: transformFeedback = this.transformFeedback , parameters: parameters = {} , vertexArray: vertexArray = this.vertexArray  } = opts;
        this.setAttributes(attributes);
        this.updateModuleSettings(moduleSettings);
        this.setUniforms(uniforms);
        let logPriority;
        if ((0, $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3).priority >= $d4b5fa431316d551$var$LOG_DRAW_PRIORITY) logPriority = this._logDrawCallStart($d4b5fa431316d551$var$LOG_DRAW_PRIORITY);
        const drawParams = this.vertexArray.getDrawParams();
        const { isIndexed: isIndexed = drawParams.isIndexed , indexType: indexType = drawParams.indexType , indexOffset: indexOffset = drawParams.indexOffset , vertexArrayInstanced: vertexArrayInstanced = drawParams.isInstanced  } = this.props;
        if (vertexArrayInstanced && !this.isInstanced) (0, $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3).warn("Found instanced attributes on non-instanced model", this.id)();
        const { isInstanced: isInstanced , instanceCount: instanceCount  } = this;
        const { onBeforeRender: onBeforeRender = $d4b5fa431316d551$var$NOOP , onAfterRender: onAfterRender = $d4b5fa431316d551$var$NOOP  } = this.props;
        onBeforeRender();
        this.program.setUniforms(this.uniforms);
        const didDraw = this.program.draw(Object.assign($d4b5fa431316d551$var$DRAW_PARAMS, opts, {
            logPriority: logPriority,
            uniforms: null,
            framebuffer: framebuffer,
            parameters: parameters,
            drawMode: this.getDrawMode(),
            vertexCount: this.getVertexCount(),
            vertexArray: vertexArray,
            transformFeedback: transformFeedback,
            isIndexed: isIndexed,
            indexType: indexType,
            isInstanced: isInstanced,
            instanceCount: instanceCount,
            offset: isIndexed ? indexOffset : 0
        }));
        onAfterRender();
        if ((0, $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3).priority >= $d4b5fa431316d551$var$LOG_DRAW_PRIORITY) this._logDrawCallEnd(logPriority, vertexArray, framebuffer);
        return didDraw;
    }
    transform() {
        let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        const { discard: discard = true , feedbackBuffers: feedbackBuffers , unbindModels: unbindModels = []  } = opts;
        let { parameters: parameters  } = opts;
        if (feedbackBuffers) this._setFeedbackBuffers(feedbackBuffers);
        if (discard) parameters = Object.assign({}, parameters, {
            [35977]: discard
        });
        unbindModels.forEach((model)=>model.vertexArray.unbindBuffers());
        try {
            this.draw(Object.assign({}, opts, {
                parameters: parameters
            }));
        } finally{
            unbindModels.forEach((model)=>model.vertexArray.bindBuffers());
        }
        return this;
    }
    render() {
        let uniforms = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        (0, $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3).warn("Model.render() is deprecated. Use Model.setUniforms() and Model.draw()")();
        return this.setUniforms(uniforms).draw();
    }
    _setModelProps(props) {
        Object.assign(this.props, props);
        if ("uniforms" in props) this.setUniforms(props.uniforms);
        if ("pickable" in props) this.pickable = props.pickable;
        if ("instanceCount" in props) this.instanceCount = props.instanceCount;
        if ("geometry" in props) this.setGeometry(props.geometry);
        if ("attributes" in props) this.setAttributes(props.attributes);
        if ("_feedbackBuffers" in props) this._setFeedbackBuffers(props._feedbackBuffers);
    }
    _checkProgram() {
        const needsUpdate = this._programDirty || this.programManager.stateHash !== this._programManagerState;
        if (!needsUpdate) return;
        let { program: program  } = this.programProps;
        if (program) this._managedProgram = false;
        else {
            const { vs: vs , fs: fs , modules: modules , inject: inject , defines: defines , varyings: varyings , bufferMode: bufferMode , transpileToGLSL100: transpileToGLSL100  } = this.programProps;
            program = this.programManager.get({
                vs: vs,
                fs: fs,
                modules: modules,
                inject: inject,
                defines: defines,
                varyings: varyings,
                bufferMode: bufferMode,
                transpileToGLSL100: transpileToGLSL100
            });
            if (this.program && this._managedProgram) this.programManager.release(this.program);
            this._programManagerState = this.programManager.stateHash;
            this._managedProgram = true;
        }
        (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(program instanceof (0, $6fea3ad8e77f174f$export$2e2bcd8739ae039), "Model needs a program");
        this._programDirty = false;
        if (program === this.program) return;
        this.program = program;
        if (this.vertexArray) this.vertexArray.setProps({
            program: this.program,
            attributes: this.vertexArray.attributes
        });
        else this.vertexArray = new (0, $012b7736d6299c03$export$2e2bcd8739ae039)(this.gl, {
            program: this.program
        });
        this.setUniforms(Object.assign({}, this.getModuleUniforms()));
    }
    _deleteGeometryBuffers() {
        for(const name in this.geometryBuffers){
            const buffer = this.geometryBuffers[name][0] || this.geometryBuffers[name];
            if (buffer instanceof (0, $28a69bf6d03705d1$export$2e2bcd8739ae039)) buffer.delete();
        }
    }
    _setAnimationProps(animationProps) {
        if (this.animated) (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(animationProps, "Model.draw(): animated uniforms but no animationProps");
    }
    _setFeedbackBuffers() {
        let feedbackBuffers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        if ((0, $757dc76705f498e6$export$23cfe696632d10f4)(feedbackBuffers)) return this;
        const { gl: gl  } = this.program;
        this.transformFeedback = this.transformFeedback || new (0, $feb45ae040c88295$export$2e2bcd8739ae039)(gl, {
            program: this.program
        });
        this.transformFeedback.setBuffers(feedbackBuffers);
        return this;
    }
    _logDrawCallStart(logLevel) {
        const logDrawTimeout = logLevel > 3 ? 0 : $d4b5fa431316d551$var$LOG_DRAW_TIMEOUT;
        if (Date.now() - this.lastLogTime < logDrawTimeout) return undefined;
        this.lastLogTime = Date.now();
        (0, $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3).group($d4b5fa431316d551$var$LOG_DRAW_PRIORITY, ">>> DRAWING MODEL ".concat(this.id), {
            collapsed: (0, $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3).level <= 2
        })();
        return logLevel;
    }
    _logDrawCallEnd(logLevel, vertexArray, uniforms, framebuffer) {
        if (logLevel === undefined) return;
        const attributeTable = (0, $425f6c53ea308543$export$f05218eded921e71)({
            vertexArray: vertexArray,
            header: "".concat(this.id, " attributes"),
            attributes: this._attributes
        });
        const { table: uniformTable , unusedTable: unusedTable , unusedCount: unusedCount  } = (0, $d325c11ca8c9db0d$export$72be64c472054e23)({
            header: "".concat(this.id, " uniforms"),
            program: this.program,
            uniforms: Object.assign({}, this.program.uniforms, uniforms)
        });
        const { table: missingTable , count: missingCount  } = (0, $d325c11ca8c9db0d$export$72be64c472054e23)({
            header: "".concat(this.id, " uniforms"),
            program: this.program,
            uniforms: Object.assign({}, this.program.uniforms, uniforms),
            undefinedOnly: true
        });
        if (missingCount > 0) (0, $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3).log("MISSING UNIFORMS", Object.keys(missingTable))();
        if (unusedCount > 0) (0, $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3).log("UNUSED UNIFORMS", Object.keys(unusedTable))();
        const configTable = (0, $d892712aaf8139ba$export$826103546372d55e)(this.vertexArray.configuration);
        (0, $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3).table(logLevel, attributeTable)();
        (0, $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3).table(logLevel, uniformTable)();
        (0, $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3).table(logLevel + 1, configTable)();
        if (framebuffer) framebuffer.log({
            logLevel: $d4b5fa431316d551$var$LOG_DRAW_PRIORITY,
            message: "Rendered to ".concat(framebuffer.id)
        });
        (0, $ca3fc36d0fd01a6a$export$bef1f36f5486a6a3).groupEnd($d4b5fa431316d551$var$LOG_DRAW_PRIORITY)();
    }
}





class $75029039b1643eaf$export$2e2bcd8739ae039 {
    constructor(gl){
        let props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        this.gl = gl;
        this.currentIndex = 0;
        this.feedbackMap = {};
        this.varyings = null;
        this.bindings = [];
        this.resources = {};
        this._initialize(props);
        Object.seal(this);
    }
    setupResources(opts) {
        for (const binding of this.bindings)this._setupTransformFeedback(binding, opts);
    }
    updateModelProps() {
        let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        const { varyings: varyings  } = this;
        if (varyings.length > 0) props = Object.assign({}, props, {
            varyings: varyings
        });
        return props;
    }
    getDrawOptions() {
        let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        const binding = this.bindings[this.currentIndex];
        const { sourceBuffers: sourceBuffers , transformFeedback: transformFeedback  } = binding;
        const attributes = Object.assign({}, sourceBuffers, opts.attributes);
        return {
            attributes: attributes,
            transformFeedback: transformFeedback
        };
    }
    swap() {
        if (this.feedbackMap) {
            this.currentIndex = this._getNextIndex();
            return true;
        }
        return false;
    }
    update() {
        let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        this._setupBuffers(opts);
    }
    getBuffer(varyingName) {
        const { feedbackBuffers: feedbackBuffers  } = this.bindings[this.currentIndex];
        const bufferOrParams = varyingName ? feedbackBuffers[varyingName] : null;
        if (!bufferOrParams) return null;
        return bufferOrParams instanceof (0, $28a69bf6d03705d1$export$2e2bcd8739ae039) ? bufferOrParams : bufferOrParams.buffer;
    }
    getData() {
        let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        const { varyingName: varyingName  } = options;
        const buffer = this.getBuffer(varyingName);
        if (buffer) return buffer.getData();
        return null;
    }
    delete() {
        for(const name in this.resources)this.resources[name].delete();
    }
    _initialize() {
        let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        this._setupBuffers(props);
        this.varyings = props.varyings || Object.keys(this.bindings[this.currentIndex].feedbackBuffers);
        if (this.varyings.length > 0) (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)((0, $325e733792a03f4e$export$e3518b1ac7891039)(this.gl));
    }
    _getFeedbackBuffers(props) {
        const { sourceBuffers: sourceBuffers = {}  } = props;
        const feedbackBuffers = {};
        if (this.bindings[this.currentIndex]) Object.assign(feedbackBuffers, this.bindings[this.currentIndex].feedbackBuffers);
        if (this.feedbackMap) for(const sourceName in this.feedbackMap){
            const feedbackName = this.feedbackMap[sourceName];
            if (sourceName in sourceBuffers) feedbackBuffers[feedbackName] = sourceName;
        }
        Object.assign(feedbackBuffers, props.feedbackBuffers);
        for(const bufferName in feedbackBuffers){
            const bufferOrRef = feedbackBuffers[bufferName];
            if (typeof bufferOrRef === "string") {
                const sourceBuffer = sourceBuffers[bufferOrRef];
                const { byteLength: byteLength , usage: usage , accessor: accessor  } = sourceBuffer;
                feedbackBuffers[bufferName] = this._createNewBuffer(bufferName, {
                    byteLength: byteLength,
                    usage: usage,
                    accessor: accessor
                });
            }
        }
        return feedbackBuffers;
    }
    _setupBuffers() {
        let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        const { sourceBuffers: sourceBuffers = null  } = props;
        Object.assign(this.feedbackMap, props.feedbackMap);
        const feedbackBuffers = this._getFeedbackBuffers(props);
        this._updateBindings({
            sourceBuffers: sourceBuffers,
            feedbackBuffers: feedbackBuffers
        });
    }
    _setupTransformFeedback(binding, _ref) {
        let { model: model  } = _ref;
        const { program: program  } = model;
        binding.transformFeedback = new (0, $feb45ae040c88295$export$2e2bcd8739ae039)(this.gl, {
            program: program,
            buffers: binding.feedbackBuffers
        });
    }
    _updateBindings(opts) {
        this.bindings[this.currentIndex] = this._updateBinding(this.bindings[this.currentIndex], opts);
        if (this.feedbackMap) {
            const { sourceBuffers: sourceBuffers , feedbackBuffers: feedbackBuffers  } = this._swapBuffers(this.bindings[this.currentIndex]);
            const nextIndex = this._getNextIndex();
            this.bindings[nextIndex] = this._updateBinding(this.bindings[nextIndex], {
                sourceBuffers: sourceBuffers,
                feedbackBuffers: feedbackBuffers
            });
        }
    }
    _updateBinding(binding, opts) {
        if (!binding) return {
            sourceBuffers: Object.assign({}, opts.sourceBuffers),
            feedbackBuffers: Object.assign({}, opts.feedbackBuffers)
        };
        Object.assign(binding.sourceBuffers, opts.sourceBuffers);
        Object.assign(binding.feedbackBuffers, opts.feedbackBuffers);
        if (binding.transformFeedback) binding.transformFeedback.setBuffers(binding.feedbackBuffers);
        return binding;
    }
    _swapBuffers(opts) {
        if (!this.feedbackMap) return null;
        const sourceBuffers = Object.assign({}, opts.sourceBuffers);
        const feedbackBuffers = Object.assign({}, opts.feedbackBuffers);
        for(const srcName in this.feedbackMap){
            const dstName = this.feedbackMap[srcName];
            sourceBuffers[srcName] = opts.feedbackBuffers[dstName];
            feedbackBuffers[dstName] = opts.sourceBuffers[srcName];
            (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(feedbackBuffers[dstName] instanceof (0, $28a69bf6d03705d1$export$2e2bcd8739ae039));
        }
        return {
            sourceBuffers: sourceBuffers,
            feedbackBuffers: feedbackBuffers
        };
    }
    _createNewBuffer(name, opts) {
        const buffer = new (0, $28a69bf6d03705d1$export$2e2bcd8739ae039)(this.gl, opts);
        if (this.resources[name]) this.resources[name].delete();
        this.resources[name] = buffer;
        return buffer;
    }
    _getNextIndex() {
        return (this.currentIndex + 1) % 2;
    }
}






const $dffd16a246e7d0e0$var$SAMPLER_UNIFORM_PREFIX = "transform_uSampler_";
const $dffd16a246e7d0e0$var$SIZE_UNIFORM_PREFIX = "transform_uSize_";
const $dffd16a246e7d0e0$var$VS_POS_VARIABLE = "transform_position";
function $dffd16a246e7d0e0$export$5a059e62d0049ef0(_ref) {
    let { vs: vs , sourceTextureMap: sourceTextureMap , targetTextureVarying: targetTextureVarying , targetTexture: targetTexture  } = _ref;
    const texAttributeNames = Object.keys(sourceTextureMap);
    let sourceCount = texAttributeNames.length;
    let targetTextureType = null;
    const samplerTextureMap = {};
    let updatedVs = vs;
    let finalInject = {};
    if (sourceCount > 0 || targetTextureVarying) {
        const vsLines = updatedVs.split("\n");
        const updateVsLines = vsLines.slice();
        vsLines.forEach((line, index, lines)=>{
            if (sourceCount > 0) {
                const updated = $dffd16a246e7d0e0$export$b3d21cd7dabd1c6(line, sourceTextureMap);
                if (updated) {
                    const { updatedLine: updatedLine , inject: inject  } = updated;
                    updateVsLines[index] = updatedLine;
                    finalInject = (0, $e03481e8f5a496cf$export$cef13ee8fb8f32f3)([
                        finalInject,
                        inject
                    ]);
                    Object.assign(samplerTextureMap, updated.samplerTextureMap);
                    sourceCount--;
                }
            }
            if (targetTextureVarying && !targetTextureType) targetTextureType = $dffd16a246e7d0e0$export$997a69001b588146(line, targetTextureVarying);
        });
        if (targetTextureVarying) {
            (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(targetTexture);
            const sizeName = "".concat($dffd16a246e7d0e0$var$SIZE_UNIFORM_PREFIX).concat(targetTextureVarying);
            const uniformDeclaration = "uniform vec2 ".concat(sizeName, ";\n");
            const posInstructions = "     vec2 ".concat($dffd16a246e7d0e0$var$VS_POS_VARIABLE, " = transform_getPos(").concat(sizeName, ");\n     gl_Position = vec4(").concat($dffd16a246e7d0e0$var$VS_POS_VARIABLE, ", 0, 1.);\n");
            const inject = {
                "vs:#decl": uniformDeclaration,
                "vs:#main-start": posInstructions
            };
            finalInject = (0, $e03481e8f5a496cf$export$cef13ee8fb8f32f3)([
                finalInject,
                inject
            ]);
        }
        updatedVs = updateVsLines.join("\n");
    }
    return {
        vs: updatedVs,
        targetTextureType: targetTextureType,
        inject: finalInject,
        samplerTextureMap: samplerTextureMap
    };
}
function $dffd16a246e7d0e0$export$9265f23b64eee61d(_ref2) {
    let { sourceTextureMap: sourceTextureMap , targetTextureVarying: targetTextureVarying , targetTexture: targetTexture  } = _ref2;
    const uniforms = {};
    let width;
    let height;
    if (targetTextureVarying) {
        ({ width: width , height: height  } = targetTexture);
        uniforms["".concat($dffd16a246e7d0e0$var$SIZE_UNIFORM_PREFIX).concat(targetTextureVarying)] = [
            width,
            height
        ];
    }
    for(const textureName in sourceTextureMap){
        ({ width: width , height: height  } = sourceTextureMap[textureName]);
        uniforms["".concat($dffd16a246e7d0e0$var$SIZE_UNIFORM_PREFIX).concat(textureName)] = [
            width,
            height
        ];
    }
    return uniforms;
}
function $dffd16a246e7d0e0$var$getAttributeDefinition(line) {
    return (0, $b14a5ab92b562947$export$ca11e09347dd6309)(line, [
        "attribute",
        "in"
    ]);
}
function $dffd16a246e7d0e0$var$getSamplerDeclerations(textureName) {
    const samplerName = "".concat($dffd16a246e7d0e0$var$SAMPLER_UNIFORM_PREFIX).concat(textureName);
    const sizeName = "".concat($dffd16a246e7d0e0$var$SIZE_UNIFORM_PREFIX).concat(textureName);
    const uniformDeclerations = "  uniform sampler2D ".concat(samplerName, ";\n  uniform vec2 ").concat(sizeName, ";");
    return {
        samplerName: samplerName,
        sizeName: sizeName,
        uniformDeclerations: uniformDeclerations
    };
}
function $dffd16a246e7d0e0$export$997a69001b588146(line, varying) {
    const qualaiferDetails = (0, $b14a5ab92b562947$export$ca11e09347dd6309)(line, [
        "varying",
        "out"
    ]);
    if (!qualaiferDetails) return null;
    return qualaiferDetails.name === varying ? qualaiferDetails.type : null;
}
function $dffd16a246e7d0e0$export$b3d21cd7dabd1c6(line, textureMap) {
    const samplerTextureMap = {};
    const attributeData = $dffd16a246e7d0e0$var$getAttributeDefinition(line);
    if (!attributeData) return null;
    const { type: type , name: name  } = attributeData;
    if (name && textureMap[name]) {
        const updatedLine = "// ".concat(line, " => Replaced by Transform with a sampler");
        const { samplerName: samplerName , sizeName: sizeName , uniformDeclerations: uniformDeclerations  } = $dffd16a246e7d0e0$var$getSamplerDeclerations(name);
        const channels = (0, $b14a5ab92b562947$export$7c9d09032d11b05d)(type);
        const sampleInstruction = "  ".concat(type, " ").concat(name, " = transform_getInput(").concat(samplerName, ", ").concat(sizeName, ").").concat(channels, ";\n");
        samplerTextureMap[samplerName] = name;
        const inject = {
            "vs:#decl": uniformDeclerations,
            "vs:#main-start": sampleInstruction
        };
        return {
            updatedLine: updatedLine,
            inject: inject,
            samplerTextureMap: samplerTextureMap
        };
    }
    return null;
}


const $30acc33c414d48f4$var$SRC_TEX_PARAMETER_OVERRIDES = {
    [10241]: 9728,
    [10240]: 9728,
    [10242]: 33071,
    [10243]: 33071
};
const $30acc33c414d48f4$var$FS_OUTPUT_VARIABLE = "transform_output";
class $30acc33c414d48f4$export$2e2bcd8739ae039 {
    constructor(gl){
        let props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        this.gl = gl;
        this.id = this.currentIndex = 0;
        this._swapTexture = null;
        this.targetTextureVarying = null;
        this.targetTextureType = null;
        this.samplerTextureMap = null;
        this.bindings = [];
        this.resources = {};
        this._initialize(props);
        Object.seal(this);
    }
    updateModelProps() {
        let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        const updatedModelProps = this._processVertexShader(props);
        return Object.assign({}, props, updatedModelProps);
    }
    getDrawOptions() {
        let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        const { sourceBuffers: sourceBuffers , sourceTextures: sourceTextures , framebuffer: framebuffer , targetTexture: targetTexture  } = this.bindings[this.currentIndex];
        const attributes = Object.assign({}, sourceBuffers, opts.attributes);
        const uniforms = Object.assign({}, opts.uniforms);
        const parameters = Object.assign({}, opts.parameters);
        let discard = opts.discard;
        if (this.hasSourceTextures || this.hasTargetTexture) {
            attributes.transform_elementID = this.elementIDBuffer;
            for(const sampler in this.samplerTextureMap){
                const textureName = this.samplerTextureMap[sampler];
                uniforms[sampler] = sourceTextures[textureName];
            }
            this._setSourceTextureParameters();
            const sizeUniforms = (0, $dffd16a246e7d0e0$export$9265f23b64eee61d)({
                sourceTextureMap: sourceTextures,
                targetTextureVarying: this.targetTextureVarying,
                targetTexture: targetTexture
            });
            Object.assign(uniforms, sizeUniforms);
        }
        if (this.hasTargetTexture) {
            discard = false;
            parameters.viewport = [
                0,
                0,
                framebuffer.width,
                framebuffer.height
            ];
        }
        return {
            attributes: attributes,
            framebuffer: framebuffer,
            uniforms: uniforms,
            discard: discard,
            parameters: parameters
        };
    }
    swap() {
        if (this._swapTexture) {
            this.currentIndex = this._getNextIndex();
            return true;
        }
        return false;
    }
    update() {
        let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        this._setupTextures(opts);
    }
    getTargetTexture() {
        const { targetTexture: targetTexture  } = this.bindings[this.currentIndex];
        return targetTexture;
    }
    getData() {
        let { packed: packed = false  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        const { framebuffer: framebuffer  } = this.bindings[this.currentIndex];
        const pixels = (0, $c192e756436d1779$export$f9f2f48e7f9faaa5)(framebuffer);
        if (!packed) return pixels;
        const ArrayType = pixels.constructor;
        const channelCount = (0, $b14a5ab92b562947$export$7d9650494fc7500d)(this.targetTextureType);
        const packedPixels = new ArrayType(pixels.length * channelCount / 4);
        let packCount = 0;
        for(let i = 0; i < pixels.length; i += 4)for(let j = 0; j < channelCount; j++)packedPixels[packCount++] = pixels[i + j];
        return packedPixels;
    }
    getFramebuffer() {
        const currentResources = this.bindings[this.currentIndex];
        return currentResources.framebuffer;
    }
    delete() {
        if (this.ownTexture) this.ownTexture.delete();
        if (this.elementIDBuffer) this.elementIDBuffer.delete();
    }
    _initialize() {
        let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        const { _targetTextureVarying: _targetTextureVarying , _swapTexture: _swapTexture  } = props;
        this._swapTexture = _swapTexture;
        this.targetTextureVarying = _targetTextureVarying;
        this.hasTargetTexture = _targetTextureVarying;
        this._setupTextures(props);
    }
    _createTargetTexture(props) {
        const { sourceTextures: sourceTextures , textureOrReference: textureOrReference  } = props;
        if (textureOrReference instanceof (0, $df31c887249e3faa$export$2e2bcd8739ae039)) return textureOrReference;
        const refTexture = sourceTextures[textureOrReference];
        if (!refTexture) return null;
        this._targetRefTexName = textureOrReference;
        return this._createNewTexture(refTexture);
    }
    _setupTextures() {
        let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        const { sourceBuffers: sourceBuffers , _sourceTextures: _sourceTextures = {} , _targetTexture: _targetTexture  } = props;
        const targetTexture = this._createTargetTexture({
            sourceTextures: _sourceTextures,
            textureOrReference: _targetTexture
        });
        this.hasSourceTextures = this.hasSourceTextures || _sourceTextures && Object.keys(_sourceTextures).length > 0;
        this._updateBindings({
            sourceBuffers: sourceBuffers,
            sourceTextures: _sourceTextures,
            targetTexture: targetTexture
        });
        if ("elementCount" in props) this._updateElementIDBuffer(props.elementCount);
    }
    _updateElementIDBuffer(elementCount) {
        if (typeof elementCount !== "number" || this.elementCount >= elementCount) return;
        const elementIds = new Float32Array(elementCount);
        elementIds.forEach((_, index, array)=>{
            array[index] = index;
        });
        if (!this.elementIDBuffer) this.elementIDBuffer = new (0, $28a69bf6d03705d1$export$2e2bcd8739ae039)(this.gl, {
            data: elementIds,
            accessor: {
                size: 1
            }
        });
        else this.elementIDBuffer.setData({
            data: elementIds
        });
        this.elementCount = elementCount;
    }
    _updateBindings(opts) {
        this.bindings[this.currentIndex] = this._updateBinding(this.bindings[this.currentIndex], opts);
        if (this._swapTexture) {
            const { sourceTextures: sourceTextures , targetTexture: targetTexture  } = this._swapTextures(this.bindings[this.currentIndex]);
            const nextIndex = this._getNextIndex();
            this.bindings[nextIndex] = this._updateBinding(this.bindings[nextIndex], {
                sourceTextures: sourceTextures,
                targetTexture: targetTexture
            });
        }
    }
    _updateBinding(binding, opts) {
        const { sourceBuffers: sourceBuffers , sourceTextures: sourceTextures , targetTexture: targetTexture  } = opts;
        if (!binding) binding = {
            sourceBuffers: {},
            sourceTextures: {},
            targetTexture: null
        };
        Object.assign(binding.sourceTextures, sourceTextures);
        Object.assign(binding.sourceBuffers, sourceBuffers);
        if (targetTexture) {
            binding.targetTexture = targetTexture;
            const { width: width , height: height  } = targetTexture;
            const { framebuffer: framebuffer  } = binding;
            if (framebuffer) {
                framebuffer.update({
                    attachments: {
                        [36064]: targetTexture
                    },
                    resizeAttachments: false
                });
                framebuffer.resize({
                    width: width,
                    height: height
                });
            } else binding.framebuffer = new (0, $a0e9e15bc57c4882$export$2e2bcd8739ae039)(this.gl, {
                id: "transform-framebuffer",
                width: width,
                height: height,
                attachments: {
                    [36064]: targetTexture
                }
            });
        }
        return binding;
    }
    _setSourceTextureParameters() {
        const index = this.currentIndex;
        const { sourceTextures: sourceTextures  } = this.bindings[index];
        for(const name in sourceTextures)sourceTextures[name].setParameters($30acc33c414d48f4$var$SRC_TEX_PARAMETER_OVERRIDES);
    }
    _swapTextures(opts) {
        if (!this._swapTexture) return null;
        const sourceTextures = Object.assign({}, opts.sourceTextures);
        sourceTextures[this._swapTexture] = opts.targetTexture;
        const targetTexture = opts.sourceTextures[this._swapTexture];
        return {
            sourceTextures: sourceTextures,
            targetTexture: targetTexture
        };
    }
    _createNewTexture(refTexture) {
        const texture = (0, $379077f7c038ee76$export$a502ec217e00cfb1)(refTexture, {
            parameters: {
                [10241]: 9728,
                [10240]: 9728,
                [10242]: 33071,
                [10243]: 33071
            },
            pixelStore: {
                [37440]: false
            }
        });
        if (this.ownTexture) this.ownTexture.delete();
        this.ownTexture = texture;
        return texture;
    }
    _getNextIndex() {
        return (this.currentIndex + 1) % 2;
    }
    _processVertexShader() {
        let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        const { sourceTextures: sourceTextures , targetTexture: targetTexture  } = this.bindings[this.currentIndex];
        const { vs: vs , uniforms: uniforms , targetTextureType: targetTextureType , inject: inject , samplerTextureMap: samplerTextureMap  } = (0, $dffd16a246e7d0e0$export$5a059e62d0049ef0)({
            vs: props.vs,
            sourceTextureMap: sourceTextures,
            targetTextureVarying: this.targetTextureVarying,
            targetTexture: targetTexture
        });
        const combinedInject = (0, $e03481e8f5a496cf$export$cef13ee8fb8f32f3)([
            props.inject || {},
            inject
        ]);
        this.targetTextureType = targetTextureType;
        this.samplerTextureMap = samplerTextureMap;
        const fs = props._fs || (0, $b14a5ab92b562947$export$523a4d4d9f32ef9e)({
            version: (0, $5cc96d47f4335f1d$export$2e2bcd8739ae039)(vs),
            input: this.targetTextureVarying,
            inputType: targetTextureType,
            output: $30acc33c414d48f4$var$FS_OUTPUT_VARIABLE
        });
        const modules = this.hasSourceTextures || this.targetTextureVarying ? [
            (0, $3812d8ee6528adfc$export$51186ad6e864892a)
        ].concat(props.modules || []) : props.modules;
        return {
            vs: vs,
            fs: fs,
            modules: modules,
            uniforms: uniforms,
            inject: combinedInject
        };
    }
}





class $00030bb52e16e5ae$export$2e2bcd8739ae039 {
    static isSupported(gl) {
        return (0, $325e733792a03f4e$export$e3518b1ac7891039)(gl);
    }
    constructor(gl){
        let props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        this.gl = gl;
        this.model = null;
        this.elementCount = 0;
        this.bufferTransform = null;
        this.textureTransform = null;
        this.elementIDBuffer = null;
        this._initialize(props);
        Object.seal(this);
    }
    delete() {
        const { model: model , bufferTransform: bufferTransform , textureTransform: textureTransform  } = this;
        if (model) model.delete();
        if (bufferTransform) bufferTransform.delete();
        if (textureTransform) textureTransform.delete();
    }
    run() {
        let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        const { clearRenderTarget: clearRenderTarget = true  } = opts;
        const updatedOpts = this._updateDrawOptions(opts);
        if (clearRenderTarget && updatedOpts.framebuffer) updatedOpts.framebuffer.clear({
            color: true
        });
        this.model.transform(updatedOpts);
    }
    swap() {
        let swapped = false;
        const resourceTransforms = [
            this.bufferTransform,
            this.textureTransform
        ].filter(Boolean);
        for (const resourceTransform of resourceTransforms)swapped = swapped || resourceTransform.swap();
        (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(swapped, "Nothing to swap");
    }
    getBuffer() {
        let varyingName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
        return this.bufferTransform && this.bufferTransform.getBuffer(varyingName);
    }
    getData() {
        let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        const resourceTransforms = [
            this.bufferTransform,
            this.textureTransform
        ].filter(Boolean);
        for (const resourceTransform of resourceTransforms){
            const data = resourceTransform.getData(opts);
            if (data) return data;
        }
        return null;
    }
    getFramebuffer() {
        return this.textureTransform && this.textureTransform.getFramebuffer();
    }
    update() {
        let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        if ("elementCount" in opts) this.model.setVertexCount(opts.elementCount);
        const resourceTransforms = [
            this.bufferTransform,
            this.textureTransform
        ].filter(Boolean);
        for (const resourceTransform of resourceTransforms)resourceTransform.update(opts);
    }
    _initialize() {
        let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        const { gl: gl  } = this;
        this._buildResourceTransforms(gl, props);
        props = this._updateModelProps(props);
        this.model = new (0, $d4b5fa431316d551$export$2e2bcd8739ae039)(gl, Object.assign({}, props, {
            fs: props.fs || (0, $b14a5ab92b562947$export$523a4d4d9f32ef9e)({
                version: (0, $5cc96d47f4335f1d$export$2e2bcd8739ae039)(props.vs)
            }),
            id: props.id || "transform-model",
            drawMode: props.drawMode || 0,
            vertexCount: props.elementCount
        }));
        this.bufferTransform && this.bufferTransform.setupResources({
            model: this.model
        });
    }
    _updateModelProps(props) {
        let updatedProps = Object.assign({}, props);
        const resourceTransforms = [
            this.bufferTransform,
            this.textureTransform
        ].filter(Boolean);
        for (const resourceTransform of resourceTransforms)updatedProps = resourceTransform.updateModelProps(updatedProps);
        return updatedProps;
    }
    _buildResourceTransforms(gl, props) {
        if ($00030bb52e16e5ae$var$canCreateBufferTransform(props)) this.bufferTransform = new (0, $75029039b1643eaf$export$2e2bcd8739ae039)(gl, props);
        if ($00030bb52e16e5ae$var$canCreateTextureTransform(props)) this.textureTransform = new (0, $30acc33c414d48f4$export$2e2bcd8739ae039)(gl, props);
        (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(this.bufferTransform || this.textureTransform, "must provide source/feedback buffers or source/target textures");
    }
    _updateDrawOptions(opts) {
        let updatedOpts = Object.assign({}, opts);
        const resourceTransforms = [
            this.bufferTransform,
            this.textureTransform
        ].filter(Boolean);
        for (const resourceTransform of resourceTransforms)updatedOpts = Object.assign(updatedOpts, resourceTransform.getDrawOptions(updatedOpts));
        return updatedOpts;
    }
}
function $00030bb52e16e5ae$var$canCreateBufferTransform(props) {
    if (!(0, $757dc76705f498e6$export$23cfe696632d10f4)(props.feedbackBuffers) || !(0, $757dc76705f498e6$export$23cfe696632d10f4)(props.feedbackMap) || props.varyings && props.varyings.length > 0) return true;
    return false;
}
function $00030bb52e16e5ae$var$canCreateTextureTransform(props) {
    if (!(0, $757dc76705f498e6$export$23cfe696632d10f4)(props._sourceTextures) || props._targetTexture || props._targetTextureVarying) return true;
    return false;
}


const $71650ad4c5341938$export$7bd2e4b5b3cb4007 = {
    POINTS: 0x0000,
    LINES: 0x0001,
    LINE_LOOP: 0x0002,
    LINE_STRIP: 0x0003,
    TRIANGLES: 0x0004,
    TRIANGLE_STRIP: 0x0005,
    TRIANGLE_FAN: 0x0006
};
class $71650ad4c5341938$export$2e2bcd8739ae039 {
    static get DRAW_MODE() {
        return $71650ad4c5341938$export$7bd2e4b5b3cb4007;
    }
    constructor(){
        let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        const { id: id = (0, $757dc76705f498e6$export$e2a22331486dcca0)("geometry") , drawMode: drawMode = $71650ad4c5341938$export$7bd2e4b5b3cb4007.TRIANGLES , attributes: attributes = {} , indices: indices = null , vertexCount: vertexCount = null  } = props;
        this.id = id;
        this.drawMode = drawMode | 0;
        this.attributes = {};
        this.userData = {};
        this._setAttributes(attributes, indices);
        this.vertexCount = vertexCount || this._calculateVertexCount(this.attributes, this.indices);
    }
    get mode() {
        return this.drawMode;
    }
    getVertexCount() {
        return this.vertexCount;
    }
    getAttributes() {
        return this.indices ? {
            indices: this.indices,
            ...this.attributes
        } : this.attributes;
    }
    _print(attributeName) {
        return "Geometry ".concat(this.id, " attribute ").concat(attributeName);
    }
    _setAttributes(attributes, indices) {
        if (indices) this.indices = ArrayBuffer.isView(indices) ? {
            value: indices,
            size: 1
        } : indices;
        for(const attributeName in attributes){
            let attribute = attributes[attributeName];
            attribute = ArrayBuffer.isView(attribute) ? {
                value: attribute
            } : attribute;
            (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(ArrayBuffer.isView(attribute.value), "".concat(this._print(attributeName), ": must be typed array or object with value as typed array"));
            if ((attributeName === "POSITION" || attributeName === "positions") && !attribute.size) attribute.size = 3;
            if (attributeName === "indices") {
                (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(!this.indices);
                this.indices = attribute;
            } else this.attributes[attributeName] = attribute;
        }
        if (this.indices && this.indices.isIndexed !== undefined) {
            this.indices = Object.assign({}, this.indices);
            delete this.indices.isIndexed;
        }
        return this;
    }
    _calculateVertexCount(attributes, indices) {
        if (indices) return indices.value.length;
        let vertexCount = Infinity;
        for(const attributeName in attributes){
            const attribute = attributes[attributeName];
            const { value: value , size: size , constant: constant  } = attribute;
            if (!constant && value && size >= 1) vertexCount = Math.min(vertexCount, value.length / size);
        }
        (0, $fc8ccbf4aa55ce20$export$a7a9523472993e97)(Number.isFinite(vertexCount));
        return vertexCount;
    }
}

let $bc7bc101e53b8e33$var$channelHandles = 1;
let $bc7bc101e53b8e33$var$animationHandles = 1;
class $bc7bc101e53b8e33$export$e6a97ba2cae5bb94 {
    constructor(){
        this.time = 0;
        this.channels = new Map();
        this.animations = new Map();
        this.playing = false;
        this.lastEngineTime = -1;
    }
    addChannel(props) {
        const { delay: delay = 0 , duration: duration = Number.POSITIVE_INFINITY , rate: rate = 1 , repeat: repeat = 1  } = props;
        const handle = $bc7bc101e53b8e33$var$channelHandles++;
        const channel = {
            time: 0,
            delay: delay,
            duration: duration,
            rate: rate,
            repeat: repeat
        };
        this._setChannelTime(channel, this.time);
        this.channels.set(handle, channel);
        return handle;
    }
    removeChannel(handle) {
        this.channels.delete(handle);
        for (const [animationHandle, animation] of this.animations)if (animation.channel === handle) this.detachAnimation(animationHandle);
    }
    isFinished(handle) {
        const channel = this.channels.get(handle);
        if (channel === undefined) return false;
        return this.time >= channel.delay + channel.duration * channel.repeat;
    }
    getTime(handle) {
        if (handle === undefined) return this.time;
        const channel = this.channels.get(handle);
        if (channel === undefined) return -1;
        return channel.time;
    }
    setTime(time) {
        this.time = Math.max(0, time);
        const channels = this.channels.values();
        for (const channel of channels)this._setChannelTime(channel, this.time);
        const animations = this.animations.values();
        for (const animationData of animations){
            const { animation: animation , channel: channel  } = animationData;
            animation.setTime(this.getTime(channel));
        }
    }
    play() {
        this.playing = true;
    }
    pause() {
        this.playing = false;
        this.lastEngineTime = -1;
    }
    reset() {
        this.setTime(0);
    }
    attachAnimation(animation, channelHandle) {
        const animationHandle = $bc7bc101e53b8e33$var$animationHandles++;
        this.animations.set(animationHandle, {
            animation: animation,
            channel: channelHandle
        });
        animation.setTime(this.getTime(channelHandle));
        return animationHandle;
    }
    detachAnimation(handle) {
        this.animations.delete(handle);
    }
    update(engineTime) {
        if (this.playing) {
            if (this.lastEngineTime === -1) this.lastEngineTime = engineTime;
            this.setTime(this.time + (engineTime - this.lastEngineTime));
            this.lastEngineTime = engineTime;
        }
    }
    _setChannelTime(channel, time) {
        const offsetTime = time - channel.delay;
        const totalDuration = channel.duration * channel.repeat;
        if (offsetTime >= totalDuration) channel.time = channel.duration * channel.rate;
        else {
            channel.time = Math.max(0, offsetTime) % channel.duration;
            channel.time *= channel.rate;
        }
    }
}






const $b87e42640c31b733$var$defines = "#define SMOOTH_EDGE_RADIUS 0.5";
const $b87e42640c31b733$var$vs = "\n".concat($b87e42640c31b733$var$defines, "\n\nstruct VertexGeometry {\n  vec4 position;\n  vec3 worldPosition;\n  vec3 worldPositionAlt;\n  vec3 normal;\n  vec2 uv;\n  vec3 pickingColor;\n} geometry = VertexGeometry(\n  vec4(0.0, 0.0, 1.0, 0.0),\n  vec3(0.0),\n  vec3(0.0),\n  vec3(0.0),\n  vec2(0.0),\n  vec3(0.0)\n);\n");
const $b87e42640c31b733$var$fs = "\n".concat($b87e42640c31b733$var$defines, "\n\nstruct FragmentGeometry {\n  vec2 uv;\n} geometry;\n\nfloat smoothedge(float edge, float x) {\n  return smoothstep(edge - SMOOTH_EDGE_RADIUS, edge + SMOOTH_EDGE_RADIUS, x);\n}\n");
var $b87e42640c31b733$export$2e2bcd8739ae039 = {
    name: "geometry",
    vs: $b87e42640c31b733$var$vs,
    fs: $b87e42640c31b733$var$fs
};



var $146cba582e8c799f$export$2e2bcd8739ae039 = new (0, $88fdfccabe5e323d$export$2e2bcd8739ae039)({
    id: "deck"
});


const $b42a5b9aa3b1a41f$export$e4ccd0285368e485 = {
    DEFAULT: -1,
    LNGLAT: 1,
    METER_OFFSETS: 2,
    LNGLAT_OFFSETS: 3,
    CARTESIAN: 0
};
Object.defineProperty($b42a5b9aa3b1a41f$export$e4ccd0285368e485, "IDENTITY", {
    get: ()=>{
        (0, $146cba582e8c799f$export$2e2bcd8739ae039).deprecated("COORDINATE_SYSTEM.IDENTITY", "COORDINATE_SYSTEM.CARTESIAN")();
        return 0;
    }
});
const $b42a5b9aa3b1a41f$export$3697aaebd269a548 = {
    WEB_MERCATOR: 1,
    GLOBE: 2,
    WEB_MERCATOR_AUTO_OFFSET: 4,
    IDENTITY: 0
};
const $b42a5b9aa3b1a41f$export$97361b7a0c542045 = {
    common: 0,
    meters: 1,
    pixels: 2
};
const $b42a5b9aa3b1a41f$export$fa3d5b535a2458a1 = {
    click: {
        handler: "onClick"
    },
    panstart: {
        handler: "onDragStart"
    },
    panmove: {
        handler: "onDrag"
    },
    panend: {
        handler: "onDragEnd"
    }
};
const $b42a5b9aa3b1a41f$export$b56168d831461ce2 = {
    DRAW: "draw",
    MASK: "mask"
};


const $b243d162a86ca83c$var$COORDINATE_SYSTEM_GLSL_CONSTANTS = Object.keys((0, $b42a5b9aa3b1a41f$export$e4ccd0285368e485)).map((key)=>"const int COORDINATE_SYSTEM_".concat(key, " = ").concat((0, $b42a5b9aa3b1a41f$export$e4ccd0285368e485)[key], ";")).join("");
const $b243d162a86ca83c$var$PROJECTION_MODE_GLSL_CONSTANTS = Object.keys((0, $b42a5b9aa3b1a41f$export$3697aaebd269a548)).map((key)=>"const int PROJECTION_MODE_".concat(key, " = ").concat((0, $b42a5b9aa3b1a41f$export$3697aaebd269a548)[key], ";")).join("");
const $b243d162a86ca83c$var$UNIT_GLSL_CONSTANTS = Object.keys((0, $b42a5b9aa3b1a41f$export$97361b7a0c542045)).map((key)=>"const int UNIT_".concat(key.toUpperCase(), " = ").concat((0, $b42a5b9aa3b1a41f$export$97361b7a0c542045)[key], ";")).join("");
var $b243d162a86ca83c$export$2e2bcd8739ae039 = "".concat($b243d162a86ca83c$var$COORDINATE_SYSTEM_GLSL_CONSTANTS, "\n").concat($b243d162a86ca83c$var$PROJECTION_MODE_GLSL_CONSTANTS, "\n").concat($b243d162a86ca83c$var$UNIT_GLSL_CONSTANTS, '\n\nuniform int project_uCoordinateSystem;\nuniform int project_uProjectionMode;\nuniform float project_uScale;\nuniform bool project_uWrapLongitude;\nuniform vec3 project_uCommonUnitsPerMeter;\nuniform vec3 project_uCommonUnitsPerWorldUnit;\nuniform vec3 project_uCommonUnitsPerWorldUnit2;\nuniform vec4 project_uCenter;\nuniform mat4 project_uModelMatrix;\nuniform mat4 project_uViewProjectionMatrix;\nuniform vec2 project_uViewportSize;\nuniform float project_uDevicePixelRatio;\nuniform float project_uFocalDistance;\nuniform vec3 project_uCameraPosition;\nuniform vec3 project_uCoordinateOrigin;\nuniform vec3 project_uCommonOrigin;\nuniform bool project_uPseudoMeters;\n\nconst float TILE_SIZE = 512.0;\nconst float PI = 3.1415926536;\nconst float WORLD_SCALE = TILE_SIZE / (PI * 2.0);\nconst vec3 ZERO_64_LOW = vec3(0.0);\nconst float EARTH_RADIUS = 6370972.0; // meters\nconst float GLOBE_RADIUS = 256.0;\n\n// returns an adjustment factor for uCommonUnitsPerMeter\nfloat project_size() {\n  if (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR &&\n    project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT &&\n    project_uPseudoMeters == false) {\n\n    // uCommonUnitsPerMeter in low-zoom Web Mercator is non-linear\n    // Adjust by 1 / cos(latitude)\n    // If geometry.position (vertex in common space) is populated, use it\n    // Otherwise use geometry.worldPosition (anchor in world space)\n    \n    if (geometry.position.w == 0.0) {\n      float y = clamp(geometry.worldPosition.y, -89.9, 89.9);\n      return 1.0 / cos(radians(y));\n    }\n\n    // latitude from common y: 2.0 * (atan(exp(y / TILE_SIZE * 2.0 * PI - PI)) - PI / 4.0)\n    // Taylor series of 1 / cos(latitude)\n    // Max error < 0.003\n  \n    float y = geometry.position.y / TILE_SIZE * 2.0 - 1.0;\n    float y2 = y * y;\n    float y4 = y2 * y2;\n    float y6 = y4 * y2;\n    return 1.0 + 4.9348 * y2 + 4.0587 * y4 + 1.5642 * y6;\n  }\n  return 1.0;\n}\n//\n// Scaling offsets - scales meters to "world distance"\n// Note the scalar version of project_size is for scaling the z component only\n//\nfloat project_size(float meters) {\n  return meters * project_uCommonUnitsPerMeter.z * project_size();\n}\n\nvec2 project_size(vec2 meters) {\n  return meters * project_uCommonUnitsPerMeter.xy * project_size();\n}\n\nvec3 project_size(vec3 meters) {\n  return meters * project_uCommonUnitsPerMeter * project_size();\n}\n\nvec4 project_size(vec4 meters) {\n  return vec4(meters.xyz * project_uCommonUnitsPerMeter, meters.w);\n}\n\n// Get rotation matrix that aligns the z axis with the given up vector\n// Find 3 unit vectors ux, uy, uz that are perpendicular to each other and uz == up\nmat3 project_get_orientation_matrix(vec3 up) {\n  vec3 uz = normalize(up);\n  // Tangent on XY plane\n  vec3 ux = abs(uz.z) == 1.0 ? vec3(1.0, 0.0, 0.0) : normalize(vec3(uz.y, -uz.x, 0));\n  vec3 uy = cross(uz, ux);\n  return mat3(ux, uy, uz);\n}\n\nbool project_needs_rotation(vec3 commonPosition, out mat3 transform) {\n  if (project_uProjectionMode == PROJECTION_MODE_GLOBE) {\n    transform = project_get_orientation_matrix(commonPosition);\n    return true;\n  }\n  return false;\n}\n\n//\n// Projecting normal - transform deltas from current coordinate system to\n// normals in the worldspace\n//\nvec3 project_normal(vec3 vector) {\n  // Apply model matrix\n  vec4 normal_modelspace = project_uModelMatrix * vec4(vector, 0.0);\n  vec3 n = normalize(normal_modelspace.xyz * project_uCommonUnitsPerMeter);\n  mat3 rotation;\n  if (project_needs_rotation(geometry.position.xyz, rotation)) {\n    n = rotation * n;\n  }\n  return n;\n}\n\nvec4 project_offset_(vec4 offset) {\n  float dy = offset.y;\n  vec3 commonUnitsPerWorldUnit = project_uCommonUnitsPerWorldUnit + project_uCommonUnitsPerWorldUnit2 * dy;\n  return vec4(offset.xyz * commonUnitsPerWorldUnit, offset.w);\n}\n\n//\n// Projecting positions - non-linear projection: lnglats => unit tile [0-1, 0-1]\n//\nvec2 project_mercator_(vec2 lnglat) {\n  float x = lnglat.x;\n  if (project_uWrapLongitude) {\n    x = mod(x + 180., 360.0) - 180.;\n  }\n  float y = clamp(lnglat.y, -89.9, 89.9);\n  return vec2(\n    radians(x) + PI,\n    PI + log(tan_fp32(PI * 0.25 + radians(y) * 0.5))\n  ) * WORLD_SCALE;\n}\n\nvec3 project_globe_(vec3 lnglatz) {\n  float lambda = radians(lnglatz.x);\n  float phi = radians(lnglatz.y);\n  float cosPhi = cos(phi);\n  float D = (lnglatz.z / EARTH_RADIUS + 1.0) * GLOBE_RADIUS;\n\n  return vec3(\n    sin(lambda) * cosPhi,\n    -cos(lambda) * cosPhi,\n    sin(phi)\n  ) * D;\n}\n\n//\n// Projects positions (defined by project_uCoordinateSystem) to common space (defined by project_uProjectionMode)\n//\nvec4 project_position(vec4 position, vec3 position64Low) {\n  vec4 position_world = project_uModelMatrix * position;\n\n  // Work around for a Mac+NVIDIA bug https://github.com/visgl/deck.gl/issues/4145\n  if (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR) {\n    if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT) {\n      return vec4(\n        project_mercator_(position_world.xy),\n        project_size(position_world.z),\n        position_world.w\n      );\n    }\n    if (project_uCoordinateSystem == COORDINATE_SYSTEM_CARTESIAN) {\n      position_world.xyz += project_uCoordinateOrigin;\n    }\n  }\n  if (project_uProjectionMode == PROJECTION_MODE_GLOBE) {\n    if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT) {\n      return vec4(\n        project_globe_(position_world.xyz),\n        position_world.w\n      );\n    }\n  }\n  if (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET) {\n    if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT) {\n      if (abs(position_world.y - project_uCoordinateOrigin.y) > 0.25) {\n        // Too far from the projection center for offset mode to be accurate\n        // Only use high parts\n        return vec4(\n          project_mercator_(position_world.xy) - project_uCommonOrigin.xy,\n          project_size(position_world.z),\n          position_world.w\n        );\n      }\n    }\n  }\n  if (project_uProjectionMode == PROJECTION_MODE_IDENTITY ||\n    (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET &&\n    (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT ||\n     project_uCoordinateSystem == COORDINATE_SYSTEM_CARTESIAN))) {\n    // Subtract high part of 64 bit value. Convert remainder to float32, preserving precision.\n    position_world.xyz -= project_uCoordinateOrigin;\n  }\n\n  // Translation is already added to the high parts\n  return project_offset_(position_world + project_uModelMatrix * vec4(position64Low, 0.0));\n}\n\nvec4 project_position(vec4 position) {\n  return project_position(position, ZERO_64_LOW);\n}\n\nvec3 project_position(vec3 position, vec3 position64Low) {\n  vec4 projected_position = project_position(vec4(position, 1.0), position64Low);\n  return projected_position.xyz;\n}\n\nvec3 project_position(vec3 position) {\n  vec4 projected_position = project_position(vec4(position, 1.0), ZERO_64_LOW);\n  return projected_position.xyz;\n}\n\nvec2 project_position(vec2 position) {\n  vec4 projected_position = project_position(vec4(position, 0.0, 1.0), ZERO_64_LOW);\n  return projected_position.xy;\n}\n\nvec4 project_common_position_to_clipspace(vec4 position, mat4 viewProjectionMatrix, vec4 center) {\n  return viewProjectionMatrix * position + center;\n}\n\n//\n// Projects from common space coordinates to clip space.\n// Uses project_uViewProjectionMatrix\n//\nvec4 project_common_position_to_clipspace(vec4 position) {\n  return project_common_position_to_clipspace(position, project_uViewProjectionMatrix, project_uCenter);\n}\n\n// Returns a clip space offset that corresponds to a given number of screen pixels\nvec2 project_pixel_size_to_clipspace(vec2 pixels) {\n  vec2 offset = pixels / project_uViewportSize * project_uDevicePixelRatio * 2.0;\n  return offset * project_uFocalDistance;\n}\n\nfloat project_size_to_pixel(float meters) {\n  return project_size(meters) * project_uScale;\n}\nfloat project_size_to_pixel(float size, int unit) {\n  if (unit == UNIT_METERS) return project_size_to_pixel(size);\n  if (unit == UNIT_COMMON) return size * project_uScale;\n  // UNIT_PIXELS\n  return size;\n}\nfloat project_pixel_size(float pixels) {\n  return pixels / project_uScale;\n}\nvec2 project_pixel_size(vec2 pixels) {\n  return pixels / project_uScale;\n}\n');


var $90626a8105199b14$export$fd293b15f47e270 = 0.000001;
var $90626a8105199b14$export$b67359430d3b1b2 = typeof Float32Array !== "undefined" ? Float32Array : Array;
var $90626a8105199b14$export$5ada478c8a628231 = Math.random;
function $90626a8105199b14$export$cb2c0eb57f5e532c(type) {
    $90626a8105199b14$export$b67359430d3b1b2 = type;
}
var $90626a8105199b14$var$degree = Math.PI / 180;
function $90626a8105199b14$export$408b8ee5959eefd5(a) {
    return a * $90626a8105199b14$var$degree;
}
function $90626a8105199b14$export$e9bab7fafb253603(a, b) {
    return Math.abs(a - b) <= $90626a8105199b14$export$fd293b15f47e270 * Math.max(1.0, Math.abs(a), Math.abs(b));
}
if (!Math.hypot) Math.hypot = function() {
    var y = 0, i = arguments.length;
    while(i--)y += arguments[i] * arguments[i];
    return Math.sqrt(y);
};


function $46ec5f9ed0e75076$export$185802fd694ee1f5() {
    var out = new $90626a8105199b14$export$b67359430d3b1b2(16);
    if ($90626a8105199b14$export$b67359430d3b1b2 != Float32Array) {
        out[1] = 0;
        out[2] = 0;
        out[3] = 0;
        out[4] = 0;
        out[6] = 0;
        out[7] = 0;
        out[8] = 0;
        out[9] = 0;
        out[11] = 0;
        out[12] = 0;
        out[13] = 0;
        out[14] = 0;
    }
    out[0] = 1;
    out[5] = 1;
    out[10] = 1;
    out[15] = 1;
    return out;
}
function $46ec5f9ed0e75076$export$9cd59f9826255e47(a) {
    var out = new $90626a8105199b14$export$b67359430d3b1b2(16);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
}
function $46ec5f9ed0e75076$export$784d13d8ee351f07(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
}
function $46ec5f9ed0e75076$export$a82be99ed2a44a7d(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
    var out = new $90626a8105199b14$export$b67359430d3b1b2(16);
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m03;
    out[4] = m10;
    out[5] = m11;
    out[6] = m12;
    out[7] = m13;
    out[8] = m20;
    out[9] = m21;
    out[10] = m22;
    out[11] = m23;
    out[12] = m30;
    out[13] = m31;
    out[14] = m32;
    out[15] = m33;
    return out;
}
function $46ec5f9ed0e75076$export$adaa4cf7ef1b65be(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m03;
    out[4] = m10;
    out[5] = m11;
    out[6] = m12;
    out[7] = m13;
    out[8] = m20;
    out[9] = m21;
    out[10] = m22;
    out[11] = m23;
    out[12] = m30;
    out[13] = m31;
    out[14] = m32;
    out[15] = m33;
    return out;
}
function $46ec5f9ed0e75076$export$f0954fd7d5368655(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}
function $46ec5f9ed0e75076$export$9cb09a71b7d66923(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
        var a01 = a[1], a02 = a[2], a03 = a[3];
        var a12 = a[6], a13 = a[7];
        var a23 = a[11];
        out[1] = a[4];
        out[2] = a[8];
        out[3] = a[12];
        out[4] = a01;
        out[6] = a[9];
        out[7] = a[13];
        out[8] = a02;
        out[9] = a12;
        out[11] = a[14];
        out[12] = a03;
        out[13] = a13;
        out[14] = a23;
    } else {
        out[0] = a[0];
        out[1] = a[4];
        out[2] = a[8];
        out[3] = a[12];
        out[4] = a[1];
        out[5] = a[5];
        out[6] = a[9];
        out[7] = a[13];
        out[8] = a[2];
        out[9] = a[6];
        out[10] = a[10];
        out[11] = a[14];
        out[12] = a[3];
        out[13] = a[7];
        out[14] = a[11];
        out[15] = a[15];
    }
    return out;
}
function $46ec5f9ed0e75076$export$6897c284b6f9f4dc(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
    var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
    var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
    var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
    var b00 = a00 * a11 - a01 * a10;
    var b01 = a00 * a12 - a02 * a10;
    var b02 = a00 * a13 - a03 * a10;
    var b03 = a01 * a12 - a02 * a11;
    var b04 = a01 * a13 - a03 * a11;
    var b05 = a02 * a13 - a03 * a12;
    var b06 = a20 * a31 - a21 * a30;
    var b07 = a20 * a32 - a22 * a30;
    var b08 = a20 * a33 - a23 * a30;
    var b09 = a21 * a32 - a22 * a31;
    var b10 = a21 * a33 - a23 * a31;
    var b11 = a22 * a33 - a23 * a32; // Calculate the determinant
    var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
    if (!det) return null;
    det = 1.0 / det;
    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
    return out;
}
function $46ec5f9ed0e75076$export$33f3c024b4ae00a1(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
    var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
    var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
    var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
    out[0] = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);
    out[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
    out[2] = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);
    out[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
    out[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
    out[5] = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);
    out[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
    out[7] = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);
    out[8] = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);
    out[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
    out[10] = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);
    out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
    out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
    out[13] = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);
    out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
    out[15] = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);
    return out;
}
function $46ec5f9ed0e75076$export$a04698f914c55ed9(a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
    var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
    var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
    var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
    var b00 = a00 * a11 - a01 * a10;
    var b01 = a00 * a12 - a02 * a10;
    var b02 = a00 * a13 - a03 * a10;
    var b03 = a01 * a12 - a02 * a11;
    var b04 = a01 * a13 - a03 * a11;
    var b05 = a02 * a13 - a03 * a12;
    var b06 = a20 * a31 - a21 * a30;
    var b07 = a20 * a32 - a22 * a30;
    var b08 = a20 * a33 - a23 * a30;
    var b09 = a21 * a32 - a22 * a31;
    var b10 = a21 * a33 - a23 * a31;
    var b11 = a22 * a33 - a23 * a32; // Calculate the determinant
    return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
}
function $46ec5f9ed0e75076$export$2060d2db72cce88f(out, a, b) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
    var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
    var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
    var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15]; // Cache only the current line of the second matrix
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[4];
    b1 = b[5];
    b2 = b[6];
    b3 = b[7];
    out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[8];
    b1 = b[9];
    b2 = b[10];
    b3 = b[11];
    out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[12];
    b1 = b[13];
    b2 = b[14];
    b3 = b[15];
    out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    return out;
}
function $46ec5f9ed0e75076$export$d73ee8ef04f5226a(out, a, v) {
    var x = v[0], y = v[1], z = v[2];
    var a00, a01, a02, a03;
    var a10, a11, a12, a13;
    var a20, a21, a22, a23;
    if (a === out) {
        out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
        out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
        out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
        out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
    } else {
        a00 = a[0];
        a01 = a[1];
        a02 = a[2];
        a03 = a[3];
        a10 = a[4];
        a11 = a[5];
        a12 = a[6];
        a13 = a[7];
        a20 = a[8];
        a21 = a[9];
        a22 = a[10];
        a23 = a[11];
        out[0] = a00;
        out[1] = a01;
        out[2] = a02;
        out[3] = a03;
        out[4] = a10;
        out[5] = a11;
        out[6] = a12;
        out[7] = a13;
        out[8] = a20;
        out[9] = a21;
        out[10] = a22;
        out[11] = a23;
        out[12] = a00 * x + a10 * y + a20 * z + a[12];
        out[13] = a01 * x + a11 * y + a21 * z + a[13];
        out[14] = a02 * x + a12 * y + a22 * z + a[14];
        out[15] = a03 * x + a13 * y + a23 * z + a[15];
    }
    return out;
}
function $46ec5f9ed0e75076$export$dcdf75081b88279d(out, a, v) {
    var x = v[0], y = v[1], z = v[2];
    out[0] = a[0] * x;
    out[1] = a[1] * x;
    out[2] = a[2] * x;
    out[3] = a[3] * x;
    out[4] = a[4] * y;
    out[5] = a[5] * y;
    out[6] = a[6] * y;
    out[7] = a[7] * y;
    out[8] = a[8] * z;
    out[9] = a[9] * z;
    out[10] = a[10] * z;
    out[11] = a[11] * z;
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
}
function $46ec5f9ed0e75076$export$bb628a54ab399bc9(out, a, rad, axis) {
    var x = axis[0], y = axis[1], z = axis[2];
    var len = Math.hypot(x, y, z);
    var s, c, t;
    var a00, a01, a02, a03;
    var a10, a11, a12, a13;
    var a20, a21, a22, a23;
    var b00, b01, b02;
    var b10, b11, b12;
    var b20, b21, b22;
    if (len < $90626a8105199b14$export$fd293b15f47e270) return null;
    len = 1 / len;
    x *= len;
    y *= len;
    z *= len;
    s = Math.sin(rad);
    c = Math.cos(rad);
    t = 1 - c;
    a00 = a[0];
    a01 = a[1];
    a02 = a[2];
    a03 = a[3];
    a10 = a[4];
    a11 = a[5];
    a12 = a[6];
    a13 = a[7];
    a20 = a[8];
    a21 = a[9];
    a22 = a[10];
    a23 = a[11]; // Construct the elements of the rotation matrix
    b00 = x * x * t + c;
    b01 = y * x * t + z * s;
    b02 = z * x * t - y * s;
    b10 = x * y * t - z * s;
    b11 = y * y * t + c;
    b12 = z * y * t + x * s;
    b20 = x * z * t + y * s;
    b21 = y * z * t - x * s;
    b22 = z * z * t + c; // Perform rotation-specific matrix multiplication
    out[0] = a00 * b00 + a10 * b01 + a20 * b02;
    out[1] = a01 * b00 + a11 * b01 + a21 * b02;
    out[2] = a02 * b00 + a12 * b01 + a22 * b02;
    out[3] = a03 * b00 + a13 * b01 + a23 * b02;
    out[4] = a00 * b10 + a10 * b11 + a20 * b12;
    out[5] = a01 * b10 + a11 * b11 + a21 * b12;
    out[6] = a02 * b10 + a12 * b11 + a22 * b12;
    out[7] = a03 * b10 + a13 * b11 + a23 * b12;
    out[8] = a00 * b20 + a10 * b21 + a20 * b22;
    out[9] = a01 * b20 + a11 * b21 + a21 * b22;
    out[10] = a02 * b20 + a12 * b21 + a22 * b22;
    out[11] = a03 * b20 + a13 * b21 + a23 * b22;
    if (a !== out) {
        // If the source and destination differ, copy the unchanged last row
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }
    return out;
}
function $46ec5f9ed0e75076$export$a59c8716592e09af(out, a, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    var a10 = a[4];
    var a11 = a[5];
    var a12 = a[6];
    var a13 = a[7];
    var a20 = a[8];
    var a21 = a[9];
    var a22 = a[10];
    var a23 = a[11];
    if (a !== out) {
        // If the source and destination differ, copy the unchanged rows
        out[0] = a[0];
        out[1] = a[1];
        out[2] = a[2];
        out[3] = a[3];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    } // Perform axis-specific matrix multiplication
    out[4] = a10 * c + a20 * s;
    out[5] = a11 * c + a21 * s;
    out[6] = a12 * c + a22 * s;
    out[7] = a13 * c + a23 * s;
    out[8] = a20 * c - a10 * s;
    out[9] = a21 * c - a11 * s;
    out[10] = a22 * c - a12 * s;
    out[11] = a23 * c - a13 * s;
    return out;
}
function $46ec5f9ed0e75076$export$cf71e4d4ca4d1cfd(out, a, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    var a00 = a[0];
    var a01 = a[1];
    var a02 = a[2];
    var a03 = a[3];
    var a20 = a[8];
    var a21 = a[9];
    var a22 = a[10];
    var a23 = a[11];
    if (a !== out) {
        // If the source and destination differ, copy the unchanged rows
        out[4] = a[4];
        out[5] = a[5];
        out[6] = a[6];
        out[7] = a[7];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    } // Perform axis-specific matrix multiplication
    out[0] = a00 * c - a20 * s;
    out[1] = a01 * c - a21 * s;
    out[2] = a02 * c - a22 * s;
    out[3] = a03 * c - a23 * s;
    out[8] = a00 * s + a20 * c;
    out[9] = a01 * s + a21 * c;
    out[10] = a02 * s + a22 * c;
    out[11] = a03 * s + a23 * c;
    return out;
}
function $46ec5f9ed0e75076$export$ea6eae3365de5b9c(out, a, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    var a00 = a[0];
    var a01 = a[1];
    var a02 = a[2];
    var a03 = a[3];
    var a10 = a[4];
    var a11 = a[5];
    var a12 = a[6];
    var a13 = a[7];
    if (a !== out) {
        // If the source and destination differ, copy the unchanged last row
        out[8] = a[8];
        out[9] = a[9];
        out[10] = a[10];
        out[11] = a[11];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    } // Perform axis-specific matrix multiplication
    out[0] = a00 * c + a10 * s;
    out[1] = a01 * c + a11 * s;
    out[2] = a02 * c + a12 * s;
    out[3] = a03 * c + a13 * s;
    out[4] = a10 * c - a00 * s;
    out[5] = a11 * c - a01 * s;
    out[6] = a12 * c - a02 * s;
    out[7] = a13 * c - a03 * s;
    return out;
}
function $46ec5f9ed0e75076$export$bc9e79e74e9fddf6(out, v) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    return out;
}
function $46ec5f9ed0e75076$export$832ca188ffb1955d(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = v[1];
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = v[2];
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}
function $46ec5f9ed0e75076$export$926fc125ff3c666c(out, rad, axis) {
    var x = axis[0], y = axis[1], z = axis[2];
    var len = Math.hypot(x, y, z);
    var s, c, t;
    if (len < $90626a8105199b14$export$fd293b15f47e270) return null;
    len = 1 / len;
    x *= len;
    y *= len;
    z *= len;
    s = Math.sin(rad);
    c = Math.cos(rad);
    t = 1 - c; // Perform rotation-specific matrix multiplication
    out[0] = x * x * t + c;
    out[1] = y * x * t + z * s;
    out[2] = z * x * t - y * s;
    out[3] = 0;
    out[4] = x * y * t - z * s;
    out[5] = y * y * t + c;
    out[6] = z * y * t + x * s;
    out[7] = 0;
    out[8] = x * z * t + y * s;
    out[9] = y * z * t - x * s;
    out[10] = z * z * t + c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}
function $46ec5f9ed0e75076$export$dd47cc2f828c32ef(out, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad); // Perform axis-specific matrix multiplication
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = c;
    out[6] = s;
    out[7] = 0;
    out[8] = 0;
    out[9] = -s;
    out[10] = c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}
function $46ec5f9ed0e75076$export$7dc997d67d2b7f33(out, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad); // Perform axis-specific matrix multiplication
    out[0] = c;
    out[1] = 0;
    out[2] = -s;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = s;
    out[9] = 0;
    out[10] = c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}
function $46ec5f9ed0e75076$export$ad5ddaedc8f405df(out, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad); // Perform axis-specific matrix multiplication
    out[0] = c;
    out[1] = s;
    out[2] = 0;
    out[3] = 0;
    out[4] = -s;
    out[5] = c;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}
function $46ec5f9ed0e75076$export$9545ac307f2a256b(out, q, v) {
    // Quaternion math
    var x = q[0], y = q[1], z = q[2], w = q[3];
    var x2 = x + x;
    var y2 = y + y;
    var z2 = z + z;
    var xx = x * x2;
    var xy = x * y2;
    var xz = x * z2;
    var yy = y * y2;
    var yz = y * z2;
    var zz = z * z2;
    var wx = w * x2;
    var wy = w * y2;
    var wz = w * z2;
    out[0] = 1 - (yy + zz);
    out[1] = xy + wz;
    out[2] = xz - wy;
    out[3] = 0;
    out[4] = xy - wz;
    out[5] = 1 - (xx + zz);
    out[6] = yz + wx;
    out[7] = 0;
    out[8] = xz + wy;
    out[9] = yz - wx;
    out[10] = 1 - (xx + yy);
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    return out;
}
function $46ec5f9ed0e75076$export$ff497f2be31cc6a(out, a) {
    var translation = new $90626a8105199b14$export$b67359430d3b1b2(3);
    var bx = -a[0], by = -a[1], bz = -a[2], bw = a[3], ax = a[4], ay = a[5], az = a[6], aw = a[7];
    var magnitude = bx * bx + by * by + bz * bz + bw * bw; //Only scale if it makes sense
    if (magnitude > 0) {
        translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;
        translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;
        translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;
    } else {
        translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
        translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
        translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
    }
    $46ec5f9ed0e75076$export$9545ac307f2a256b(out, a, translation);
    return out;
}
function $46ec5f9ed0e75076$export$202e99f82f7f0395(out, mat) {
    out[0] = mat[12];
    out[1] = mat[13];
    out[2] = mat[14];
    return out;
}
function $46ec5f9ed0e75076$export$71dc54d92bd04b57(out, mat) {
    var m11 = mat[0];
    var m12 = mat[1];
    var m13 = mat[2];
    var m21 = mat[4];
    var m22 = mat[5];
    var m23 = mat[6];
    var m31 = mat[8];
    var m32 = mat[9];
    var m33 = mat[10];
    out[0] = Math.hypot(m11, m12, m13);
    out[1] = Math.hypot(m21, m22, m23);
    out[2] = Math.hypot(m31, m32, m33);
    return out;
}
function $46ec5f9ed0e75076$export$df3937d3b537df0a(out, mat) {
    var scaling = new $90626a8105199b14$export$b67359430d3b1b2(3);
    $46ec5f9ed0e75076$export$71dc54d92bd04b57(scaling, mat);
    var is1 = 1 / scaling[0];
    var is2 = 1 / scaling[1];
    var is3 = 1 / scaling[2];
    var sm11 = mat[0] * is1;
    var sm12 = mat[1] * is2;
    var sm13 = mat[2] * is3;
    var sm21 = mat[4] * is1;
    var sm22 = mat[5] * is2;
    var sm23 = mat[6] * is3;
    var sm31 = mat[8] * is1;
    var sm32 = mat[9] * is2;
    var sm33 = mat[10] * is3;
    var trace = sm11 + sm22 + sm33;
    var S = 0;
    if (trace > 0) {
        S = Math.sqrt(trace + 1.0) * 2;
        out[3] = 0.25 * S;
        out[0] = (sm23 - sm32) / S;
        out[1] = (sm31 - sm13) / S;
        out[2] = (sm12 - sm21) / S;
    } else if (sm11 > sm22 && sm11 > sm33) {
        S = Math.sqrt(1.0 + sm11 - sm22 - sm33) * 2;
        out[3] = (sm23 - sm32) / S;
        out[0] = 0.25 * S;
        out[1] = (sm12 + sm21) / S;
        out[2] = (sm31 + sm13) / S;
    } else if (sm22 > sm33) {
        S = Math.sqrt(1.0 + sm22 - sm11 - sm33) * 2;
        out[3] = (sm31 - sm13) / S;
        out[0] = (sm12 + sm21) / S;
        out[1] = 0.25 * S;
        out[2] = (sm23 + sm32) / S;
    } else {
        S = Math.sqrt(1.0 + sm33 - sm11 - sm22) * 2;
        out[3] = (sm12 - sm21) / S;
        out[0] = (sm31 + sm13) / S;
        out[1] = (sm23 + sm32) / S;
        out[2] = 0.25 * S;
    }
    return out;
}
function $46ec5f9ed0e75076$export$ddf9c55c9f2be172(out, q, v, s) {
    // Quaternion math
    var x = q[0], y = q[1], z = q[2], w = q[3];
    var x2 = x + x;
    var y2 = y + y;
    var z2 = z + z;
    var xx = x * x2;
    var xy = x * y2;
    var xz = x * z2;
    var yy = y * y2;
    var yz = y * z2;
    var zz = z * z2;
    var wx = w * x2;
    var wy = w * y2;
    var wz = w * z2;
    var sx = s[0];
    var sy = s[1];
    var sz = s[2];
    out[0] = (1 - (yy + zz)) * sx;
    out[1] = (xy + wz) * sx;
    out[2] = (xz - wy) * sx;
    out[3] = 0;
    out[4] = (xy - wz) * sy;
    out[5] = (1 - (xx + zz)) * sy;
    out[6] = (yz + wx) * sy;
    out[7] = 0;
    out[8] = (xz + wy) * sz;
    out[9] = (yz - wx) * sz;
    out[10] = (1 - (xx + yy)) * sz;
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    return out;
}
function $46ec5f9ed0e75076$export$1def1f860edc4b1f(out, q, v, s, o) {
    // Quaternion math
    var x = q[0], y = q[1], z = q[2], w = q[3];
    var x2 = x + x;
    var y2 = y + y;
    var z2 = z + z;
    var xx = x * x2;
    var xy = x * y2;
    var xz = x * z2;
    var yy = y * y2;
    var yz = y * z2;
    var zz = z * z2;
    var wx = w * x2;
    var wy = w * y2;
    var wz = w * z2;
    var sx = s[0];
    var sy = s[1];
    var sz = s[2];
    var ox = o[0];
    var oy = o[1];
    var oz = o[2];
    var out0 = (1 - (yy + zz)) * sx;
    var out1 = (xy + wz) * sx;
    var out2 = (xz - wy) * sx;
    var out4 = (xy - wz) * sy;
    var out5 = (1 - (xx + zz)) * sy;
    var out6 = (yz + wx) * sy;
    var out8 = (xz + wy) * sz;
    var out9 = (yz - wx) * sz;
    var out10 = (1 - (xx + yy)) * sz;
    out[0] = out0;
    out[1] = out1;
    out[2] = out2;
    out[3] = 0;
    out[4] = out4;
    out[5] = out5;
    out[6] = out6;
    out[7] = 0;
    out[8] = out8;
    out[9] = out9;
    out[10] = out10;
    out[11] = 0;
    out[12] = v[0] + ox - (out0 * ox + out4 * oy + out8 * oz);
    out[13] = v[1] + oy - (out1 * ox + out5 * oy + out9 * oz);
    out[14] = v[2] + oz - (out2 * ox + out6 * oy + out10 * oz);
    out[15] = 1;
    return out;
}
function $46ec5f9ed0e75076$export$2ff2bbe382249af7(out, q) {
    var x = q[0], y = q[1], z = q[2], w = q[3];
    var x2 = x + x;
    var y2 = y + y;
    var z2 = z + z;
    var xx = x * x2;
    var yx = y * x2;
    var yy = y * y2;
    var zx = z * x2;
    var zy = z * y2;
    var zz = z * z2;
    var wx = w * x2;
    var wy = w * y2;
    var wz = w * z2;
    out[0] = 1 - yy - zz;
    out[1] = yx + wz;
    out[2] = zx - wy;
    out[3] = 0;
    out[4] = yx - wz;
    out[5] = 1 - xx - zz;
    out[6] = zy + wx;
    out[7] = 0;
    out[8] = zx + wy;
    out[9] = zy - wx;
    out[10] = 1 - xx - yy;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}
function $46ec5f9ed0e75076$export$89b5708c387cac6c(out, left, right, bottom, top, near, far) {
    var rl = 1 / (right - left);
    var tb = 1 / (top - bottom);
    var nf = 1 / (near - far);
    out[0] = near * 2 * rl;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = near * 2 * tb;
    out[6] = 0;
    out[7] = 0;
    out[8] = (right + left) * rl;
    out[9] = (top + bottom) * tb;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = far * near * 2 * nf;
    out[15] = 0;
    return out;
}
function $46ec5f9ed0e75076$export$4cf19729ec9a96b8(out, fovy, aspect, near, far) {
    var f = 1.0 / Math.tan(fovy / 2), nf;
    out[0] = f / aspect;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = f;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[15] = 0;
    if (far != null && far !== Infinity) {
        nf = 1 / (near - far);
        out[10] = (far + near) * nf;
        out[14] = 2 * far * near * nf;
    } else {
        out[10] = -1;
        out[14] = -2 * near;
    }
    return out;
}
var $46ec5f9ed0e75076$export$541149539f3a4684 = $46ec5f9ed0e75076$export$4cf19729ec9a96b8;
function $46ec5f9ed0e75076$export$294bba99a6af0c0c(out, fovy, aspect, near, far) {
    var f = 1.0 / Math.tan(fovy / 2), nf;
    out[0] = f / aspect;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = f;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[15] = 0;
    if (far != null && far !== Infinity) {
        nf = 1 / (near - far);
        out[10] = far * nf;
        out[14] = far * near * nf;
    } else {
        out[10] = -1;
        out[14] = -near;
    }
    return out;
}
function $46ec5f9ed0e75076$export$58ae211c788e338f(out, fov, near, far) {
    var upTan = Math.tan(fov.upDegrees * Math.PI / 180.0);
    var downTan = Math.tan(fov.downDegrees * Math.PI / 180.0);
    var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180.0);
    var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180.0);
    var xScale = 2.0 / (leftTan + rightTan);
    var yScale = 2.0 / (upTan + downTan);
    out[0] = xScale;
    out[1] = 0.0;
    out[2] = 0.0;
    out[3] = 0.0;
    out[4] = 0.0;
    out[5] = yScale;
    out[6] = 0.0;
    out[7] = 0.0;
    out[8] = -((leftTan - rightTan) * xScale * 0.5);
    out[9] = (upTan - downTan) * yScale * 0.5;
    out[10] = far / (near - far);
    out[11] = -1;
    out[12] = 0.0;
    out[13] = 0.0;
    out[14] = far * near / (near - far);
    out[15] = 0.0;
    return out;
}
function $46ec5f9ed0e75076$export$c5f65ef3eb668f27(out, left, right, bottom, top, near, far) {
    var lr = 1 / (left - right);
    var bt = 1 / (bottom - top);
    var nf = 1 / (near - far);
    out[0] = -2 * lr;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = -2 * bt;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 2 * nf;
    out[11] = 0;
    out[12] = (left + right) * lr;
    out[13] = (top + bottom) * bt;
    out[14] = (far + near) * nf;
    out[15] = 1;
    return out;
}
var $46ec5f9ed0e75076$export$4f2167e613cfc87b = $46ec5f9ed0e75076$export$c5f65ef3eb668f27;
function $46ec5f9ed0e75076$export$b1d31ea7b4d854e(out, left, right, bottom, top, near, far) {
    var lr = 1 / (left - right);
    var bt = 1 / (bottom - top);
    var nf = 1 / (near - far);
    out[0] = -2 * lr;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = -2 * bt;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = nf;
    out[11] = 0;
    out[12] = (left + right) * lr;
    out[13] = (top + bottom) * bt;
    out[14] = near * nf;
    out[15] = 1;
    return out;
}
function $46ec5f9ed0e75076$export$d924e14fd6d9aa66(out, eye, center, up) {
    var x0, x1, x2, y0, y1, y2, z0, z1, z2, len;
    var eyex = eye[0];
    var eyey = eye[1];
    var eyez = eye[2];
    var upx = up[0];
    var upy = up[1];
    var upz = up[2];
    var centerx = center[0];
    var centery = center[1];
    var centerz = center[2];
    if (Math.abs(eyex - centerx) < $90626a8105199b14$export$fd293b15f47e270 && Math.abs(eyey - centery) < $90626a8105199b14$export$fd293b15f47e270 && Math.abs(eyez - centerz) < $90626a8105199b14$export$fd293b15f47e270) return $46ec5f9ed0e75076$export$f0954fd7d5368655(out);
    z0 = eyex - centerx;
    z1 = eyey - centery;
    z2 = eyez - centerz;
    len = 1 / Math.hypot(z0, z1, z2);
    z0 *= len;
    z1 *= len;
    z2 *= len;
    x0 = upy * z2 - upz * z1;
    x1 = upz * z0 - upx * z2;
    x2 = upx * z1 - upy * z0;
    len = Math.hypot(x0, x1, x2);
    if (!len) {
        x0 = 0;
        x1 = 0;
        x2 = 0;
    } else {
        len = 1 / len;
        x0 *= len;
        x1 *= len;
        x2 *= len;
    }
    y0 = z1 * x2 - z2 * x1;
    y1 = z2 * x0 - z0 * x2;
    y2 = z0 * x1 - z1 * x0;
    len = Math.hypot(y0, y1, y2);
    if (!len) {
        y0 = 0;
        y1 = 0;
        y2 = 0;
    } else {
        len = 1 / len;
        y0 *= len;
        y1 *= len;
        y2 *= len;
    }
    out[0] = x0;
    out[1] = y0;
    out[2] = z0;
    out[3] = 0;
    out[4] = x1;
    out[5] = y1;
    out[6] = z1;
    out[7] = 0;
    out[8] = x2;
    out[9] = y2;
    out[10] = z2;
    out[11] = 0;
    out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
    out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
    out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
    out[15] = 1;
    return out;
}
function $46ec5f9ed0e75076$export$aa67782f4dc9e52c(out, eye, target, up) {
    var eyex = eye[0], eyey = eye[1], eyez = eye[2], upx = up[0], upy = up[1], upz = up[2];
    var z0 = eyex - target[0], z1 = eyey - target[1], z2 = eyez - target[2];
    var len = z0 * z0 + z1 * z1 + z2 * z2;
    if (len > 0) {
        len = 1 / Math.sqrt(len);
        z0 *= len;
        z1 *= len;
        z2 *= len;
    }
    var x0 = upy * z2 - upz * z1, x1 = upz * z0 - upx * z2, x2 = upx * z1 - upy * z0;
    len = x0 * x0 + x1 * x1 + x2 * x2;
    if (len > 0) {
        len = 1 / Math.sqrt(len);
        x0 *= len;
        x1 *= len;
        x2 *= len;
    }
    out[0] = x0;
    out[1] = x1;
    out[2] = x2;
    out[3] = 0;
    out[4] = z1 * x2 - z2 * x1;
    out[5] = z2 * x0 - z0 * x2;
    out[6] = z0 * x1 - z1 * x0;
    out[7] = 0;
    out[8] = z0;
    out[9] = z1;
    out[10] = z2;
    out[11] = 0;
    out[12] = eyex;
    out[13] = eyey;
    out[14] = eyez;
    out[15] = 1;
    return out;
}
function $46ec5f9ed0e75076$export$42d51816ce590c93(a) {
    return "mat4(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ", " + a[9] + ", " + a[10] + ", " + a[11] + ", " + a[12] + ", " + a[13] + ", " + a[14] + ", " + a[15] + ")";
}
function $46ec5f9ed0e75076$export$326827e8268e9cdb(a) {
    return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]);
}
function $46ec5f9ed0e75076$export$e16d8520af44a096(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    out[4] = a[4] + b[4];
    out[5] = a[5] + b[5];
    out[6] = a[6] + b[6];
    out[7] = a[7] + b[7];
    out[8] = a[8] + b[8];
    out[9] = a[9] + b[9];
    out[10] = a[10] + b[10];
    out[11] = a[11] + b[11];
    out[12] = a[12] + b[12];
    out[13] = a[13] + b[13];
    out[14] = a[14] + b[14];
    out[15] = a[15] + b[15];
    return out;
}
function $46ec5f9ed0e75076$export$4e2d2ead65e5f7e3(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    out[4] = a[4] - b[4];
    out[5] = a[5] - b[5];
    out[6] = a[6] - b[6];
    out[7] = a[7] - b[7];
    out[8] = a[8] - b[8];
    out[9] = a[9] - b[9];
    out[10] = a[10] - b[10];
    out[11] = a[11] - b[11];
    out[12] = a[12] - b[12];
    out[13] = a[13] - b[13];
    out[14] = a[14] - b[14];
    out[15] = a[15] - b[15];
    return out;
}
function $46ec5f9ed0e75076$export$c697bed75648cdb7(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    out[4] = a[4] * b;
    out[5] = a[5] * b;
    out[6] = a[6] * b;
    out[7] = a[7] * b;
    out[8] = a[8] * b;
    out[9] = a[9] * b;
    out[10] = a[10] * b;
    out[11] = a[11] * b;
    out[12] = a[12] * b;
    out[13] = a[13] * b;
    out[14] = a[14] * b;
    out[15] = a[15] * b;
    return out;
}
function $46ec5f9ed0e75076$export$553579f63bdd7137(out, a, b, scale1) {
    out[0] = a[0] + b[0] * scale1;
    out[1] = a[1] + b[1] * scale1;
    out[2] = a[2] + b[2] * scale1;
    out[3] = a[3] + b[3] * scale1;
    out[4] = a[4] + b[4] * scale1;
    out[5] = a[5] + b[5] * scale1;
    out[6] = a[6] + b[6] * scale1;
    out[7] = a[7] + b[7] * scale1;
    out[8] = a[8] + b[8] * scale1;
    out[9] = a[9] + b[9] * scale1;
    out[10] = a[10] + b[10] * scale1;
    out[11] = a[11] + b[11] * scale1;
    out[12] = a[12] + b[12] * scale1;
    out[13] = a[13] + b[13] * scale1;
    out[14] = a[14] + b[14] * scale1;
    out[15] = a[15] + b[15] * scale1;
    return out;
}
function $46ec5f9ed0e75076$export$f2599a5cf1109d8(a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] && a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];
}
function $46ec5f9ed0e75076$export$e9bab7fafb253603(a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
    var a4 = a[4], a5 = a[5], a6 = a[6], a7 = a[7];
    var a8 = a[8], a9 = a[9], a10 = a[10], a11 = a[11];
    var a12 = a[12], a13 = a[13], a14 = a[14], a15 = a[15];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    var b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7];
    var b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11];
    var b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
    return Math.abs(a0 - b0) <= $90626a8105199b14$export$fd293b15f47e270 * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= $90626a8105199b14$export$fd293b15f47e270 * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= $90626a8105199b14$export$fd293b15f47e270 * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= $90626a8105199b14$export$fd293b15f47e270 * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= $90626a8105199b14$export$fd293b15f47e270 * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= $90626a8105199b14$export$fd293b15f47e270 * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= $90626a8105199b14$export$fd293b15f47e270 * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= $90626a8105199b14$export$fd293b15f47e270 * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= $90626a8105199b14$export$fd293b15f47e270 * Math.max(1.0, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= $90626a8105199b14$export$fd293b15f47e270 * Math.max(1.0, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= $90626a8105199b14$export$fd293b15f47e270 * Math.max(1.0, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= $90626a8105199b14$export$fd293b15f47e270 * Math.max(1.0, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= $90626a8105199b14$export$fd293b15f47e270 * Math.max(1.0, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= $90626a8105199b14$export$fd293b15f47e270 * Math.max(1.0, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= $90626a8105199b14$export$fd293b15f47e270 * Math.max(1.0, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= $90626a8105199b14$export$fd293b15f47e270 * Math.max(1.0, Math.abs(a15), Math.abs(b15));
}
var $46ec5f9ed0e75076$export$6e3a27864ab166fe = $46ec5f9ed0e75076$export$2060d2db72cce88f;
var $46ec5f9ed0e75076$export$f93b5905241a7cca = $46ec5f9ed0e75076$export$4e2d2ead65e5f7e3;



function $bd1e837fe7e33410$export$185802fd694ee1f5() {
    var out = new $90626a8105199b14$export$b67359430d3b1b2(4);
    if ($90626a8105199b14$export$b67359430d3b1b2 != Float32Array) {
        out[0] = 0;
        out[1] = 0;
        out[2] = 0;
        out[3] = 0;
    }
    return out;
}
function $bd1e837fe7e33410$export$9cd59f9826255e47(a) {
    var out = new $90626a8105199b14$export$b67359430d3b1b2(4);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
}
function $bd1e837fe7e33410$export$a82be99ed2a44a7d(x, y, z, w) {
    var out = new $90626a8105199b14$export$b67359430d3b1b2(4);
    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = w;
    return out;
}
function $bd1e837fe7e33410$export$784d13d8ee351f07(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
}
function $bd1e837fe7e33410$export$adaa4cf7ef1b65be(out, x, y, z, w) {
    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = w;
    return out;
}
function $bd1e837fe7e33410$export$e16d8520af44a096(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    return out;
}
function $bd1e837fe7e33410$export$4e2d2ead65e5f7e3(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    return out;
}
function $bd1e837fe7e33410$export$2060d2db72cce88f(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    out[2] = a[2] * b[2];
    out[3] = a[3] * b[3];
    return out;
}
function $bd1e837fe7e33410$export$cd007d971a5a2143(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    out[2] = a[2] / b[2];
    out[3] = a[3] / b[3];
    return out;
}
function $bd1e837fe7e33410$export$803ce6b71a0a94b2(out, a) {
    out[0] = Math.ceil(a[0]);
    out[1] = Math.ceil(a[1]);
    out[2] = Math.ceil(a[2]);
    out[3] = Math.ceil(a[3]);
    return out;
}
function $bd1e837fe7e33410$export$a3fe094919f356fd(out, a) {
    out[0] = Math.floor(a[0]);
    out[1] = Math.floor(a[1]);
    out[2] = Math.floor(a[2]);
    out[3] = Math.floor(a[3]);
    return out;
}
function $bd1e837fe7e33410$export$96ec731ed4dcb222(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    out[2] = Math.min(a[2], b[2]);
    out[3] = Math.min(a[3], b[3]);
    return out;
}
function $bd1e837fe7e33410$export$8960430cfd85939f(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    out[2] = Math.max(a[2], b[2]);
    out[3] = Math.max(a[3], b[3]);
    return out;
}
function $bd1e837fe7e33410$export$2077e0241d6afd3c(out, a) {
    out[0] = Math.round(a[0]);
    out[1] = Math.round(a[1]);
    out[2] = Math.round(a[2]);
    out[3] = Math.round(a[3]);
    return out;
}
function $bd1e837fe7e33410$export$dcdf75081b88279d(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    return out;
}
function $bd1e837fe7e33410$export$19cedf1da84ba854(out, a, b, scale1) {
    out[0] = a[0] + b[0] * scale1;
    out[1] = a[1] + b[1] * scale1;
    out[2] = a[2] + b[2] * scale1;
    out[3] = a[3] + b[3] * scale1;
    return out;
}
function $bd1e837fe7e33410$export$9f17032d917177de(a, b) {
    var x = b[0] - a[0];
    var y = b[1] - a[1];
    var z = b[2] - a[2];
    var w = b[3] - a[3];
    return Math.hypot(x, y, z, w);
}
function $bd1e837fe7e33410$export$88e6ebb4fe54f538(a, b) {
    var x = b[0] - a[0];
    var y = b[1] - a[1];
    var z = b[2] - a[2];
    var w = b[3] - a[3];
    return x * x + y * y + z * z + w * w;
}
function $bd1e837fe7e33410$export$f24224f1c91d8156(a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    var w = a[3];
    return Math.hypot(x, y, z, w);
}
function $bd1e837fe7e33410$export$ab44e1323ffc8376(a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    var w = a[3];
    return x * x + y * y + z * z + w * w;
}
function $bd1e837fe7e33410$export$aef51622e549b8b0(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] = -a[3];
    return out;
}
function $bd1e837fe7e33410$export$70ae2c07e401031b(out, a) {
    out[0] = 1.0 / a[0];
    out[1] = 1.0 / a[1];
    out[2] = 1.0 / a[2];
    out[3] = 1.0 / a[3];
    return out;
}
function $bd1e837fe7e33410$export$a3295358bff77e(out, a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    var w = a[3];
    var len1 = x * x + y * y + z * z + w * w;
    if (len1 > 0) len1 = 1 / Math.sqrt(len1);
    out[0] = x * len1;
    out[1] = y * len1;
    out[2] = z * len1;
    out[3] = w * len1;
    return out;
}
function $bd1e837fe7e33410$export$94132a0e348806d4(a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
}
function $bd1e837fe7e33410$export$bb646b20bb93d339(out, u, v, w) {
    var A = v[0] * w[1] - v[1] * w[0], B = v[0] * w[2] - v[2] * w[0], C = v[0] * w[3] - v[3] * w[0], D = v[1] * w[2] - v[2] * w[1], E = v[1] * w[3] - v[3] * w[1], F = v[2] * w[3] - v[3] * w[2];
    var G = u[0];
    var H = u[1];
    var I = u[2];
    var J = u[3];
    out[0] = H * F - I * E + J * D;
    out[1] = -(G * F) + I * C - J * B;
    out[2] = G * E - H * C + J * A;
    out[3] = -(G * D) + H * B - I * A;
    return out;
}
function $bd1e837fe7e33410$export$3a89f8d6f6bf6c9f(out, a, b, t) {
    var ax = a[0];
    var ay = a[1];
    var az = a[2];
    var aw = a[3];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    out[2] = az + t * (b[2] - az);
    out[3] = aw + t * (b[3] - aw);
    return out;
}
function $bd1e837fe7e33410$export$4385e60b38654f68(out, scale2) {
    scale2 = scale2 || 1.0; // Marsaglia, George. Choosing a Point from the Surface of a
    // Sphere. Ann. Math. Statist. 43 (1972), no. 2, 645--646.
    // http://projecteuclid.org/euclid.aoms/1177692644;
    var v1, v2, v3, v4;
    var s1, s2;
    do {
        v1 = $90626a8105199b14$export$5ada478c8a628231() * 2 - 1;
        v2 = $90626a8105199b14$export$5ada478c8a628231() * 2 - 1;
        s1 = v1 * v1 + v2 * v2;
    }while (s1 >= 1);
    do {
        v3 = $90626a8105199b14$export$5ada478c8a628231() * 2 - 1;
        v4 = $90626a8105199b14$export$5ada478c8a628231() * 2 - 1;
        s2 = v3 * v3 + v4 * v4;
    }while (s2 >= 1);
    var d = Math.sqrt((1 - s1) / s2);
    out[0] = scale2 * v1;
    out[1] = scale2 * v2;
    out[2] = scale2 * v3 * d;
    out[3] = scale2 * v4 * d;
    return out;
}
function $bd1e837fe7e33410$export$5ffbd13800309d59(out, a, m) {
    var x = a[0], y = a[1], z = a[2], w = a[3];
    out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
    out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
    out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
    out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
    return out;
}
function $bd1e837fe7e33410$export$c32adef9e939ce85(out, a, q) {
    var x = a[0], y = a[1], z = a[2];
    var qx = q[0], qy = q[1], qz = q[2], qw = q[3]; // calculate quat * vec
    var ix = qw * x + qy * z - qz * y;
    var iy = qw * y + qz * x - qx * z;
    var iz = qw * z + qx * y - qy * x;
    var iw = -qx * x - qy * y - qz * z; // calculate result * inverse quat
    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    out[3] = a[3];
    return out;
}
function $bd1e837fe7e33410$export$7f9972325ebfd559(out) {
    out[0] = 0.0;
    out[1] = 0.0;
    out[2] = 0.0;
    out[3] = 0.0;
    return out;
}
function $bd1e837fe7e33410$export$42d51816ce590c93(a) {
    return "vec4(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")";
}
function $bd1e837fe7e33410$export$f2599a5cf1109d8(a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
}
function $bd1e837fe7e33410$export$e9bab7fafb253603(a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    return Math.abs(a0 - b0) <= $90626a8105199b14$export$fd293b15f47e270 * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= $90626a8105199b14$export$fd293b15f47e270 * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= $90626a8105199b14$export$fd293b15f47e270 * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= $90626a8105199b14$export$fd293b15f47e270 * Math.max(1.0, Math.abs(a3), Math.abs(b3));
}
var $bd1e837fe7e33410$export$f93b5905241a7cca = $bd1e837fe7e33410$export$4e2d2ead65e5f7e3;
var $bd1e837fe7e33410$export$6e3a27864ab166fe = $bd1e837fe7e33410$export$2060d2db72cce88f;
var $bd1e837fe7e33410$export$159d9494db57879b = $bd1e837fe7e33410$export$cd007d971a5a2143;
var $bd1e837fe7e33410$export$6c4a311cc157c764 = $bd1e837fe7e33410$export$9f17032d917177de;
var $bd1e837fe7e33410$export$2422cd6c492a8b3a = $bd1e837fe7e33410$export$88e6ebb4fe54f538;
var $bd1e837fe7e33410$export$fc1400facf92c78 = $bd1e837fe7e33410$export$f24224f1c91d8156;
var $bd1e837fe7e33410$export$99d8dd3f32a3435 = $bd1e837fe7e33410$export$ab44e1323ffc8376;
var $bd1e837fe7e33410$export$4b80e395e36b5a56 = function() {
    var vec = $bd1e837fe7e33410$export$185802fd694ee1f5();
    return function(a, stride, offset, count, fn, arg) {
        var i, l;
        if (!stride) stride = 4;
        if (!offset) offset = 0;
        if (count) l = Math.min(count * stride + offset, a.length);
        else l = a.length;
        for(i = offset; i < l; i += stride){
            vec[0] = a[i];
            vec[1] = a[i + 1];
            vec[2] = a[i + 2];
            vec[3] = a[i + 3];
            fn(vec, vec, arg);
            a[i] = vec[0];
            a[i + 1] = vec[1];
            a[i + 2] = vec[2];
            a[i + 3] = vec[3];
        }
        return a;
    };
}();



function $1ccdae01919b6bce$var$isEqual(a, b) {
    if (a === b) return true;
    if (Array.isArray(a)) {
        const len = a.length;
        if (!b || b.length !== len) return false;
        for(let i = 0; i < len; i++){
            if (a[i] !== b[i]) return false;
        }
        return true;
    }
    return false;
}
function $1ccdae01919b6bce$export$2e2bcd8739ae039(compute) {
    let cachedArgs = {};
    let cachedResult;
    return (args)=>{
        for(const key in args)if (!$1ccdae01919b6bce$var$isEqual(args[key], cachedArgs[key])) {
            cachedResult = compute(args);
            cachedArgs = args;
            break;
        }
        return cachedResult;
    };
}


const $072d6f1b352f2883$var$ZERO_VECTOR = [
    0,
    0,
    0,
    0
];
const $072d6f1b352f2883$var$VECTOR_TO_POINT_MATRIX = [
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    0
];
const $072d6f1b352f2883$var$IDENTITY_MATRIX = [
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    1
];
const $072d6f1b352f2883$var$DEFAULT_PIXELS_PER_UNIT2 = [
    0,
    0,
    0
];
const $072d6f1b352f2883$var$DEFAULT_COORDINATE_ORIGIN = [
    0,
    0,
    0
];
const $072d6f1b352f2883$var$getMemoizedViewportUniforms = (0, $1ccdae01919b6bce$export$2e2bcd8739ae039)($072d6f1b352f2883$var$calculateViewportUniforms);
function $072d6f1b352f2883$export$20f9eb1a42fcd22d(viewport, coordinateSystem, coordinateOrigin = $072d6f1b352f2883$var$DEFAULT_COORDINATE_ORIGIN) {
    if (coordinateOrigin.length < 3) coordinateOrigin = [
        coordinateOrigin[0],
        coordinateOrigin[1],
        0
    ];
    let shaderCoordinateOrigin = coordinateOrigin;
    let geospatialOrigin;
    let offsetMode = true;
    if (coordinateSystem === (0, $b42a5b9aa3b1a41f$export$e4ccd0285368e485).LNGLAT_OFFSETS || coordinateSystem === (0, $b42a5b9aa3b1a41f$export$e4ccd0285368e485).METER_OFFSETS) geospatialOrigin = coordinateOrigin;
    else geospatialOrigin = viewport.isGeospatial ? [
        Math.fround(viewport.longitude),
        Math.fround(viewport.latitude),
        0
    ] : null;
    switch(viewport.projectionMode){
        case (0, $b42a5b9aa3b1a41f$export$3697aaebd269a548).WEB_MERCATOR:
            if (coordinateSystem === (0, $b42a5b9aa3b1a41f$export$e4ccd0285368e485).LNGLAT || coordinateSystem === (0, $b42a5b9aa3b1a41f$export$e4ccd0285368e485).CARTESIAN) {
                geospatialOrigin = [
                    0,
                    0,
                    0
                ];
                offsetMode = false;
            }
            break;
        case (0, $b42a5b9aa3b1a41f$export$3697aaebd269a548).WEB_MERCATOR_AUTO_OFFSET:
            if (coordinateSystem === (0, $b42a5b9aa3b1a41f$export$e4ccd0285368e485).LNGLAT) shaderCoordinateOrigin = geospatialOrigin;
            else if (coordinateSystem === (0, $b42a5b9aa3b1a41f$export$e4ccd0285368e485).CARTESIAN) {
                shaderCoordinateOrigin = [
                    Math.fround(viewport.center[0]),
                    Math.fround(viewport.center[1]),
                    0
                ];
                geospatialOrigin = viewport.unprojectPosition(shaderCoordinateOrigin);
                shaderCoordinateOrigin[0] -= coordinateOrigin[0];
                shaderCoordinateOrigin[1] -= coordinateOrigin[1];
                shaderCoordinateOrigin[2] -= coordinateOrigin[2];
            }
            break;
        case (0, $b42a5b9aa3b1a41f$export$3697aaebd269a548).IDENTITY:
            shaderCoordinateOrigin = viewport.position.map(Math.fround);
            shaderCoordinateOrigin[2] = shaderCoordinateOrigin[2] || 0;
            break;
        case (0, $b42a5b9aa3b1a41f$export$3697aaebd269a548).GLOBE:
            offsetMode = false;
            geospatialOrigin = null;
            break;
        default:
            offsetMode = false;
    }
    return {
        geospatialOrigin: geospatialOrigin,
        shaderCoordinateOrigin: shaderCoordinateOrigin,
        offsetMode: offsetMode
    };
}
function $072d6f1b352f2883$var$calculateMatrixAndOffset(viewport, coordinateSystem, coordinateOrigin) {
    const { viewMatrixUncentered: viewMatrixUncentered , projectionMatrix: projectionMatrix  } = viewport;
    let { viewMatrix: viewMatrix , viewProjectionMatrix: viewProjectionMatrix  } = viewport;
    let projectionCenter = $072d6f1b352f2883$var$ZERO_VECTOR;
    let originCommon = $072d6f1b352f2883$var$ZERO_VECTOR;
    let cameraPosCommon = viewport.cameraPosition;
    const { geospatialOrigin: geospatialOrigin , shaderCoordinateOrigin: shaderCoordinateOrigin , offsetMode: offsetMode  } = $072d6f1b352f2883$export$20f9eb1a42fcd22d(viewport, coordinateSystem, coordinateOrigin);
    if (offsetMode) {
        originCommon = viewport.projectPosition(geospatialOrigin || shaderCoordinateOrigin);
        cameraPosCommon = [
            cameraPosCommon[0] - originCommon[0],
            cameraPosCommon[1] - originCommon[1],
            cameraPosCommon[2] - originCommon[2]
        ];
        originCommon[3] = 1;
        projectionCenter = $bd1e837fe7e33410$export$5ffbd13800309d59([], originCommon, viewProjectionMatrix);
        viewMatrix = viewMatrixUncentered || viewMatrix;
        viewProjectionMatrix = $46ec5f9ed0e75076$export$2060d2db72cce88f([], projectionMatrix, viewMatrix);
        viewProjectionMatrix = $46ec5f9ed0e75076$export$2060d2db72cce88f([], viewProjectionMatrix, $072d6f1b352f2883$var$VECTOR_TO_POINT_MATRIX);
    }
    return {
        viewMatrix: viewMatrix,
        viewProjectionMatrix: viewProjectionMatrix,
        projectionCenter: projectionCenter,
        originCommon: originCommon,
        cameraPosCommon: cameraPosCommon,
        shaderCoordinateOrigin: shaderCoordinateOrigin,
        geospatialOrigin: geospatialOrigin
    };
}
function $072d6f1b352f2883$export$31173c1846951f93({ viewport: viewport , devicePixelRatio: devicePixelRatio = 1 , modelMatrix: modelMatrix = null , coordinateSystem: coordinateSystem = (0, $b42a5b9aa3b1a41f$export$e4ccd0285368e485).DEFAULT , coordinateOrigin: coordinateOrigin = $072d6f1b352f2883$var$DEFAULT_COORDINATE_ORIGIN , autoWrapLongitude: autoWrapLongitude = false  }) {
    if (coordinateSystem === (0, $b42a5b9aa3b1a41f$export$e4ccd0285368e485).DEFAULT) coordinateSystem = viewport.isGeospatial ? (0, $b42a5b9aa3b1a41f$export$e4ccd0285368e485).LNGLAT : (0, $b42a5b9aa3b1a41f$export$e4ccd0285368e485).CARTESIAN;
    const uniforms = $072d6f1b352f2883$var$getMemoizedViewportUniforms({
        viewport: viewport,
        devicePixelRatio: devicePixelRatio,
        coordinateSystem: coordinateSystem,
        coordinateOrigin: coordinateOrigin
    });
    uniforms.project_uWrapLongitude = autoWrapLongitude;
    uniforms.project_uModelMatrix = modelMatrix || $072d6f1b352f2883$var$IDENTITY_MATRIX;
    return uniforms;
}
function $072d6f1b352f2883$var$calculateViewportUniforms({ viewport: viewport , devicePixelRatio: devicePixelRatio , coordinateSystem: coordinateSystem , coordinateOrigin: coordinateOrigin  }) {
    const { projectionCenter: projectionCenter , viewProjectionMatrix: viewProjectionMatrix , originCommon: originCommon , cameraPosCommon: cameraPosCommon , shaderCoordinateOrigin: shaderCoordinateOrigin , geospatialOrigin: geospatialOrigin  } = $072d6f1b352f2883$var$calculateMatrixAndOffset(viewport, coordinateSystem, coordinateOrigin);
    const distanceScales = viewport.getDistanceScales();
    const viewportSize = [
        viewport.width * devicePixelRatio,
        viewport.height * devicePixelRatio
    ];
    const focalDistance = $bd1e837fe7e33410$export$5ffbd13800309d59([], [
        0,
        0,
        -viewport.focalDistance,
        1
    ], viewport.projectionMatrix)[3] || 1;
    const uniforms = {
        project_uCoordinateSystem: coordinateSystem,
        project_uProjectionMode: viewport.projectionMode,
        project_uCoordinateOrigin: shaderCoordinateOrigin,
        project_uCommonOrigin: originCommon.slice(0, 3),
        project_uCenter: projectionCenter,
        project_uPseudoMeters: Boolean(viewport._pseudoMeters),
        project_uViewportSize: viewportSize,
        project_uDevicePixelRatio: devicePixelRatio,
        project_uFocalDistance: focalDistance,
        project_uCommonUnitsPerMeter: distanceScales.unitsPerMeter,
        project_uCommonUnitsPerWorldUnit: distanceScales.unitsPerMeter,
        project_uCommonUnitsPerWorldUnit2: $072d6f1b352f2883$var$DEFAULT_PIXELS_PER_UNIT2,
        project_uScale: viewport.scale,
        project_uWrapLongitude: false,
        project_uViewProjectionMatrix: viewProjectionMatrix,
        project_uModelMatrix: $072d6f1b352f2883$var$IDENTITY_MATRIX,
        project_uCameraPosition: cameraPosCommon
    };
    if (geospatialOrigin) {
        const distanceScalesAtOrigin = viewport.getDistanceScales(geospatialOrigin);
        switch(coordinateSystem){
            case (0, $b42a5b9aa3b1a41f$export$e4ccd0285368e485).METER_OFFSETS:
                uniforms.project_uCommonUnitsPerWorldUnit = distanceScalesAtOrigin.unitsPerMeter;
                uniforms.project_uCommonUnitsPerWorldUnit2 = distanceScalesAtOrigin.unitsPerMeter2;
                break;
            case (0, $b42a5b9aa3b1a41f$export$e4ccd0285368e485).LNGLAT:
            case (0, $b42a5b9aa3b1a41f$export$e4ccd0285368e485).LNGLAT_OFFSETS:
                if (!viewport._pseudoMeters) uniforms.project_uCommonUnitsPerMeter = distanceScalesAtOrigin.unitsPerMeter;
                uniforms.project_uCommonUnitsPerWorldUnit = distanceScalesAtOrigin.unitsPerDegree;
                uniforms.project_uCommonUnitsPerWorldUnit2 = distanceScalesAtOrigin.unitsPerDegree2;
                break;
            case (0, $b42a5b9aa3b1a41f$export$e4ccd0285368e485).CARTESIAN:
                uniforms.project_uCommonUnitsPerWorldUnit = [
                    1,
                    1,
                    distanceScalesAtOrigin.unitsPerMeter[2]
                ];
                uniforms.project_uCommonUnitsPerWorldUnit2 = [
                    0,
                    0,
                    distanceScalesAtOrigin.unitsPerMeter2[2]
                ];
                break;
            default:
                break;
        }
    }
    return uniforms;
}


const $669f9ad1259ddfee$var$INITIAL_MODULE_OPTIONS = {};
function $669f9ad1259ddfee$var$getUniforms(opts = $669f9ad1259ddfee$var$INITIAL_MODULE_OPTIONS) {
    if ("viewport" in opts) return (0, $072d6f1b352f2883$export$31173c1846951f93)(opts);
    return {};
}
var $669f9ad1259ddfee$export$2e2bcd8739ae039 = {
    name: "project",
    dependencies: [
        (0, $65fa5645ea84a164$export$d4bf4ab3180407a1),
        (0, $b87e42640c31b733$export$2e2bcd8739ae039)
    ],
    vs: (0, $b243d162a86ca83c$export$2e2bcd8739ae039),
    getUniforms: $669f9ad1259ddfee$var$getUniforms
};



const $fbfc65ad8db06720$var$vs = "\nvec4 project_position_to_clipspace(\n  vec3 position, vec3 position64Low, vec3 offset, out vec4 commonPosition\n) {\n  vec3 projectedPosition = project_position(position, position64Low);\n  mat3 rotation;\n  if (project_needs_rotation(projectedPosition, rotation)) {\n    // offset is specified as ENU\n    // when in globe projection, rotate offset so that the ground alighs with the surface of the globe\n    offset = rotation * offset;\n  }\n  commonPosition = vec4(projectedPosition + offset, 1.0);\n  return project_common_position_to_clipspace(commonPosition);\n}\n\nvec4 project_position_to_clipspace(\n  vec3 position, vec3 position64Low, vec3 offset\n) {\n  vec4 commonPosition;\n  return project_position_to_clipspace(position, position64Low, offset, commonPosition);\n}\n";
var $fbfc65ad8db06720$export$2e2bcd8739ae039 = {
    name: "project32",
    dependencies: [
        (0, $669f9ad1259ddfee$export$2e2bcd8739ae039)
    ],
    vs: $fbfc65ad8db06720$var$vs
};




var $1c9ba1aa9caca970$export$2e2bcd8739ae039 = {
    inject: {
        "vs:DECKGL_FILTER_GL_POSITION": "\n    // for picking depth values\n    picking_setPickingAttribute(position.z / position.w);\n  ",
        "vs:DECKGL_FILTER_COLOR": "\n  picking_setPickingColor(geometry.pickingColor);\n  ",
        "fs:DECKGL_FILTER_COLOR": {
            order: 99,
            injection: "\n  // use highlight color if this fragment belongs to the selected object.\n  color = picking_filterHighlightColor(color);\n\n  // use picking color if rendering to picking FBO.\n  color = picking_filterPickingColor(color);\n    "
        }
    },
    ...(0, $7e9d081b840cbf62$export$1f1790962c6071cf)
};


const $c6e8420d48e336f1$var$DEFAULT_MODULES = [
    (0, $669f9ad1259ddfee$export$2e2bcd8739ae039)
];
const $c6e8420d48e336f1$var$SHADER_HOOKS = [
    "vs:DECKGL_FILTER_SIZE(inout vec3 size, VertexGeometry geometry)",
    "vs:DECKGL_FILTER_GL_POSITION(inout vec4 position, VertexGeometry geometry)",
    "vs:DECKGL_FILTER_COLOR(inout vec4 color, VertexGeometry geometry)",
    "fs:DECKGL_FILTER_COLOR(inout vec4 color, FragmentGeometry geometry)"
];
function $c6e8420d48e336f1$export$249fec8be25f60d5(gl) {
    const programManager = (0, $389aec4f13e2bfb5$export$2e2bcd8739ae039).getDefaultProgramManager(gl);
    for (const shaderModule of $c6e8420d48e336f1$var$DEFAULT_MODULES)programManager.addDefaultModule(shaderModule);
    for (const shaderHook of $c6e8420d48e336f1$var$SHADER_HOOKS)programManager.addShaderHook(shaderHook);
    return programManager;
}




const $434611e3e90ee53e$export$2cb9787dd463cbf4 = {
    NO_STATE: "Awaiting state",
    MATCHED: "Matched. State transferred from previous layer",
    INITIALIZED: "Initialized",
    AWAITING_GC: "Discarded. Awaiting garbage collection",
    AWAITING_FINALIZATION: "No longer matched. Awaiting garbage collection",
    FINALIZED: "Finalized! Awaiting garbage collection"
};
const $434611e3e90ee53e$export$47f4402f338dd1fc = Symbol.for("component");
const $434611e3e90ee53e$export$23f7c42255df7b05 = Symbol.for("asyncPropDefaults");
const $434611e3e90ee53e$export$c313d789070da88c = Symbol.for("asyncPropOriginal");
const $434611e3e90ee53e$export$40aefa3472633071 = Symbol.for("asyncPropResolved");





let $e34c41f170d77ab6$var$loggers = {};
function $e34c41f170d77ab6$export$6503ec6e8aabbaf(handlers) {
    $e34c41f170d77ab6$var$loggers = handlers;
}
function $e34c41f170d77ab6$export$2e2bcd8739ae039(eventType, arg1, arg2, arg3) {
    if ((0, $146cba582e8c799f$export$2e2bcd8739ae039).level > 0 && $e34c41f170d77ab6$var$loggers[eventType]) $e34c41f170d77ab6$var$loggers[eventType].call(null, arg1, arg2, arg3);
}


function $755f3c37a143f46e$export$bffa455ba8c619a6(array, filter = ()=>true) {
    if (!Array.isArray(array)) return filter(array) ? [
        array
    ] : [];
    return $755f3c37a143f46e$var$flattenArray(array, filter, []);
}
function $755f3c37a143f46e$var$flattenArray(array, filter, result) {
    let index = -1;
    while(++index < array.length){
        const value = array[index];
        if (Array.isArray(value)) $755f3c37a143f46e$var$flattenArray(value, filter, result);
        else if (filter(value)) result.push(value);
    }
    return result;
}
function $755f3c37a143f46e$export$57295b69bf9c5d15({ target: target , source: source , start: start = 0 , count: count = 1  }) {
    const length = source.length;
    const total = count * length;
    let copied = 0;
    for(let i = start; copied < length; copied++)target[i++] = source[copied];
    while(copied < total)if (copied < total - copied) {
        target.copyWithin(start + copied, start, start + copied);
        copied *= 2;
    } else {
        target.copyWithin(start + copied, start, start + total - copied);
        copied = total;
    }
    return target;
}





var $51a006089e505849$exports = {};

$parcel$export($51a006089e505849$exports, "filename", () => $51a006089e505849$export$f9107b66120eb036);
$parcel$export($51a006089e505849$exports, "dirname", () => $51a006089e505849$export$7f7b8152cc673abe);
$parcel$export($51a006089e505849$exports, "join", () => $51a006089e505849$export$f7e2c8231c57a8bd);
function $51a006089e505849$export$f9107b66120eb036(url) {
    const slashIndex = url && url.lastIndexOf("/");
    return slashIndex >= 0 ? url.substr(slashIndex + 1) : "";
}
function $51a006089e505849$export$7f7b8152cc673abe(url) {
    const slashIndex = url && url.lastIndexOf("/");
    return slashIndex >= 0 ? url.substr(0, slashIndex) : "";
}
function $51a006089e505849$export$f7e2c8231c57a8bd(...parts) {
    const separator = "/";
    parts = parts.map((part, index)=>{
        if (index) part = part.replace(new RegExp("^".concat(separator)), "");
        if (index !== parts.length - 1) part = part.replace(new RegExp("".concat(separator, "$")), "");
        return part;
    });
    return parts.join(separator);
}

function $e2d3345494943a51$export$a7a9523472993e97(condition, message) {
    if (!condition) throw new Error(message || "loader assertion failed.");
}


const $4684b3280a916bc3$var$globals = {
    self: typeof self !== "undefined" && self,
    window: typeof window !== "undefined" && window,
    global: typeof $parcel$global !== "undefined" && $parcel$global,
    document: typeof document !== "undefined" && document
};
const $4684b3280a916bc3$export$82c2e460fb230c2a = $4684b3280a916bc3$var$globals.self || $4684b3280a916bc3$var$globals.window || $4684b3280a916bc3$var$globals.global || {};
const $4684b3280a916bc3$export$8291e5b88f90ce4 = $4684b3280a916bc3$var$globals.window || $4684b3280a916bc3$var$globals.self || $4684b3280a916bc3$var$globals.global || {};
const $4684b3280a916bc3$export$90b4d2ff6acb88af = $4684b3280a916bc3$var$globals.global || $4684b3280a916bc3$var$globals.self || $4684b3280a916bc3$var$globals.window || {};
const $4684b3280a916bc3$export$5a7bfc01df82fcd1 = $4684b3280a916bc3$var$globals.document || {};
const $4684b3280a916bc3$export$4e09c449d6c407f7 = Boolean(typeof $7jljs$process !== "object" || String($7jljs$process) !== "[object process]" || true);
const $4684b3280a916bc3$export$3c901a5f01941a06 = typeof importScripts === "function";
const $4684b3280a916bc3$var$matches = typeof $7jljs$process !== "undefined" && $7jljs$process.version && /v([0-9]*)/.exec($7jljs$process.version);
const $4684b3280a916bc3$export$168db21d314844a8 = $4684b3280a916bc3$var$matches && parseFloat($4684b3280a916bc3$var$matches[1]) || 0;

const $1481083a7d4a8836$var$DEFAULT_VERSION = "latest";
const $1481083a7d4a8836$export$a4ad2735b021c132 = "3.2.5";

function $621b2e4491178cd2$export$a7a9523472993e97(condition, message) {
    if (!condition) throw new Error(message || "loaders.gl assertion failed.");
}


const $9f49355659a4ee10$var$globals = {
    self: typeof self !== "undefined" && self,
    window: typeof window !== "undefined" && window,
    global: typeof $parcel$global !== "undefined" && $parcel$global,
    document: typeof document !== "undefined" && document
};
const $9f49355659a4ee10$export$82c2e460fb230c2a = $9f49355659a4ee10$var$globals.self || $9f49355659a4ee10$var$globals.window || $9f49355659a4ee10$var$globals.global || {};
const $9f49355659a4ee10$export$8291e5b88f90ce4 = $9f49355659a4ee10$var$globals.window || $9f49355659a4ee10$var$globals.self || $9f49355659a4ee10$var$globals.global || {};
const $9f49355659a4ee10$export$90b4d2ff6acb88af = $9f49355659a4ee10$var$globals.global || $9f49355659a4ee10$var$globals.self || $9f49355659a4ee10$var$globals.window || {};
const $9f49355659a4ee10$export$5a7bfc01df82fcd1 = $9f49355659a4ee10$var$globals.document || {};
const $9f49355659a4ee10$export$4e09c449d6c407f7 = typeof $7jljs$process !== "object" || String($7jljs$process) !== "[object process]" || true;
const $9f49355659a4ee10$export$3c901a5f01941a06 = typeof importScripts === "function";
const $9f49355659a4ee10$export$d0a8044dce8ff2fc = typeof window !== "undefined" && typeof window.orientation !== "undefined";
const $9f49355659a4ee10$var$matches = typeof $7jljs$process !== "undefined" && $7jljs$process.version && /v([0-9]*)/.exec($7jljs$process.version);
const $9f49355659a4ee10$export$168db21d314844a8 = $9f49355659a4ee10$var$matches && parseFloat($9f49355659a4ee10$var$matches[1]) || 0;





class $6ea85628f397e045$export$5ff70a18b7b7760a {
}
const $6ea85628f397e045$export$cf4063c86d516c29 = null;





const $5b51d9ab3b26ead8$var$workerURLCache = new Map();
function $5b51d9ab3b26ead8$export$fb15ef3d6a383f22(props) {
    (0, $621b2e4491178cd2$export$a7a9523472993e97)(props.source && !props.url || !props.source && props.url);
    let workerURL = $5b51d9ab3b26ead8$var$workerURLCache.get(props.source || props.url);
    if (!workerURL) {
        if (props.url) {
            workerURL = $5b51d9ab3b26ead8$var$getLoadableWorkerURLFromURL(props.url);
            $5b51d9ab3b26ead8$var$workerURLCache.set(props.url, workerURL);
        }
        if (props.source) {
            workerURL = $5b51d9ab3b26ead8$var$getLoadableWorkerURLFromSource(props.source);
            $5b51d9ab3b26ead8$var$workerURLCache.set(props.source, workerURL);
        }
    }
    (0, $621b2e4491178cd2$export$a7a9523472993e97)(workerURL);
    return workerURL;
}
function $5b51d9ab3b26ead8$var$getLoadableWorkerURLFromURL(url) {
    if (!url.startsWith("http")) return url;
    const workerSource = $5b51d9ab3b26ead8$var$buildScriptSource(url);
    return $5b51d9ab3b26ead8$var$getLoadableWorkerURLFromSource(workerSource);
}
function $5b51d9ab3b26ead8$var$getLoadableWorkerURLFromSource(workerSource) {
    const blob = new Blob([
        workerSource
    ], {
        type: "application/javascript"
    });
    return URL.createObjectURL(blob);
}
function $5b51d9ab3b26ead8$var$buildScriptSource(workerUrl) {
    return "try {\n  importScripts('".concat(workerUrl, "');\n} catch (error) {\n  console.error(error);\n  throw error;\n}");
}


function $a9fcc58052559e9e$export$6464150b0a96b310(object, recursive = true, transfers) {
    const transfersSet = transfers || new Set();
    if (!object) ;
    else if ($a9fcc58052559e9e$var$isTransferable(object)) transfersSet.add(object);
    else if ($a9fcc58052559e9e$var$isTransferable(object.buffer)) transfersSet.add(object.buffer);
    else if (ArrayBuffer.isView(object)) ;
    else if (recursive && typeof object === "object") for(const key in object)$a9fcc58052559e9e$export$6464150b0a96b310(object[key], recursive, transfersSet);
    return transfers === undefined ? Array.from(transfersSet) : [];
}
function $a9fcc58052559e9e$var$isTransferable(object) {
    if (!object) return false;
    if (object instanceof ArrayBuffer) return true;
    if (typeof MessagePort !== "undefined" && object instanceof MessagePort) return true;
    if (typeof ImageBitmap !== "undefined" && object instanceof ImageBitmap) return true;
    if (typeof OffscreenCanvas !== "undefined" && object instanceof OffscreenCanvas) return true;
    return false;
}


const $d527c87c76e6f620$var$NOOP = ()=>{};
class $d527c87c76e6f620$export$2e2bcd8739ae039 {
    static isSupported() {
        return typeof Worker !== "undefined" && (0, $9f49355659a4ee10$export$4e09c449d6c407f7) || true;
    }
    constructor(props){
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "name", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "source", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "url", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "terminated", false);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "worker", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "onMessage", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "onError", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_loadableURL", "");
        const { name: name , source: source , url: url  } = props;
        (0, $621b2e4491178cd2$export$a7a9523472993e97)(source || url);
        this.name = name;
        this.source = source;
        this.url = url;
        this.onMessage = $d527c87c76e6f620$var$NOOP;
        this.onError = (error)=>console.log(error);
        this.worker = (0, $9f49355659a4ee10$export$4e09c449d6c407f7) ? this._createBrowserWorker() : this._createNodeWorker();
    }
    destroy() {
        this.onMessage = $d527c87c76e6f620$var$NOOP;
        this.onError = $d527c87c76e6f620$var$NOOP;
        this.worker.terminate();
        this.terminated = true;
    }
    get isRunning() {
        return Boolean(this.onMessage);
    }
    postMessage(data, transferList) {
        transferList = transferList || (0, $a9fcc58052559e9e$export$6464150b0a96b310)(data);
        this.worker.postMessage(data, transferList);
    }
    _getErrorFromErrorEvent(event) {
        let message = "Failed to load ";
        message += "worker ".concat(this.name, " from ").concat(this.url, ". ");
        if (event.message) message += "".concat(event.message, " in ");
        if (event.lineno) message += ":".concat(event.lineno, ":").concat(event.colno);
        return new Error(message);
    }
    _createBrowserWorker() {
        this._loadableURL = (0, $5b51d9ab3b26ead8$export$fb15ef3d6a383f22)({
            source: this.source,
            url: this.url
        });
        const worker = new Worker(this._loadableURL, {
            name: this.name
        });
        worker.onmessage = (event)=>{
            if (!event.data) this.onError(new Error("No data received"));
            else this.onMessage(event.data);
        };
        worker.onerror = (error)=>{
            this.onError(this._getErrorFromErrorEvent(error));
            this.terminated = true;
        };
        worker.onmessageerror = (event)=>console.error(event);
        return worker;
    }
    _createNodeWorker() {
        let worker;
        if (this.url) {
            const absolute = this.url.includes(":/") || this.url.startsWith("/");
            const url = absolute ? this.url : "./".concat(this.url);
            worker = new (0, $6ea85628f397e045$export$5ff70a18b7b7760a)(url, {
                eval: false
            });
        } else if (this.source) worker = new (0, $6ea85628f397e045$export$5ff70a18b7b7760a)(this.source, {
            eval: true
        });
        else throw new Error("no worker");
        worker.on("message", (data)=>{
            this.onMessage(data);
        });
        worker.on("error", (error)=>{
            this.onError(error);
        });
        worker.on("exit", (code)=>{});
        return worker;
    }
}




class $b84e2d4d6c6f643a$export$2e2bcd8739ae039 {
    constructor(jobName, workerThread){
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "name", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "workerThread", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "isRunning", true);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "result", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_resolve", ()=>{});
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_reject", ()=>{});
        this.name = jobName;
        this.workerThread = workerThread;
        this.result = new Promise((resolve, reject)=>{
            this._resolve = resolve;
            this._reject = reject;
        });
    }
    postMessage(type, payload) {
        this.workerThread.postMessage({
            source: "loaders.gl",
            type: type,
            payload: payload
        });
    }
    done(value) {
        (0, $621b2e4491178cd2$export$a7a9523472993e97)(this.isRunning);
        this.isRunning = false;
        this._resolve(value);
    }
    error(error) {
        (0, $621b2e4491178cd2$export$a7a9523472993e97)(this.isRunning);
        this.isRunning = false;
        this._reject(error);
    }
}


class $ac896f592bed4531$export$2e2bcd8739ae039 {
    static isSupported() {
        return (0, $d527c87c76e6f620$export$2e2bcd8739ae039).isSupported();
    }
    constructor(props){
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "name", "unnamed");
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "source", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "url", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "maxConcurrency", 1);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "maxMobileConcurrency", 1);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "onDebug", ()=>{});
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "reuseWorkers", true);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "props", {});
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "jobQueue", []);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "idleQueue", []);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "count", 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "isDestroyed", false);
        this.source = props.source;
        this.url = props.url;
        this.setProps(props);
    }
    destroy() {
        this.idleQueue.forEach((worker)=>worker.destroy());
        this.isDestroyed = true;
    }
    setProps(props) {
        this.props = {
            ...this.props,
            ...props
        };
        if (props.name !== undefined) this.name = props.name;
        if (props.maxConcurrency !== undefined) this.maxConcurrency = props.maxConcurrency;
        if (props.maxMobileConcurrency !== undefined) this.maxMobileConcurrency = props.maxMobileConcurrency;
        if (props.reuseWorkers !== undefined) this.reuseWorkers = props.reuseWorkers;
        if (props.onDebug !== undefined) this.onDebug = props.onDebug;
    }
    async startJob(name, onMessage = (job, type, data)=>job.done(data), onError = (job, error)=>job.error(error)) {
        const startPromise = new Promise((onStart)=>{
            this.jobQueue.push({
                name: name,
                onMessage: onMessage,
                onError: onError,
                onStart: onStart
            });
            return this;
        });
        this._startQueuedJob();
        return await startPromise;
    }
    async _startQueuedJob() {
        if (!this.jobQueue.length) return;
        const workerThread = this._getAvailableWorker();
        if (!workerThread) return;
        const queuedJob = this.jobQueue.shift();
        if (queuedJob) {
            this.onDebug({
                message: "Starting job",
                name: queuedJob.name,
                workerThread: workerThread,
                backlog: this.jobQueue.length
            });
            const job = new (0, $b84e2d4d6c6f643a$export$2e2bcd8739ae039)(queuedJob.name, workerThread);
            workerThread.onMessage = (data)=>queuedJob.onMessage(job, data.type, data.payload);
            workerThread.onError = (error)=>queuedJob.onError(job, error);
            queuedJob.onStart(job);
            try {
                await job.result;
            } finally{
                this.returnWorkerToQueue(workerThread);
            }
        }
    }
    returnWorkerToQueue(worker) {
        const shouldDestroyWorker = this.isDestroyed || !this.reuseWorkers || this.count > this._getMaxConcurrency();
        if (shouldDestroyWorker) {
            worker.destroy();
            this.count--;
        } else this.idleQueue.push(worker);
        if (!this.isDestroyed) this._startQueuedJob();
    }
    _getAvailableWorker() {
        if (this.idleQueue.length > 0) return this.idleQueue.shift() || null;
        if (this.count < this._getMaxConcurrency()) {
            this.count++;
            const name = "".concat(this.name.toLowerCase(), " (#").concat(this.count, " of ").concat(this.maxConcurrency, ")");
            return new (0, $d527c87c76e6f620$export$2e2bcd8739ae039)({
                name: name,
                source: this.source,
                url: this.url
            });
        }
        return null;
    }
    _getMaxConcurrency() {
        return (0, $9f49355659a4ee10$export$d0a8044dce8ff2fc) ? this.maxMobileConcurrency : this.maxConcurrency;
    }
}



const $c6217487f316a31d$var$DEFAULT_PROPS = {
    maxConcurrency: 3,
    maxMobileConcurrency: 1,
    reuseWorkers: true,
    onDebug: ()=>{}
};
class $c6217487f316a31d$export$2e2bcd8739ae039 {
    static isSupported() {
        return (0, $d527c87c76e6f620$export$2e2bcd8739ae039).isSupported();
    }
    static getWorkerFarm(props = {}) {
        $c6217487f316a31d$export$2e2bcd8739ae039._workerFarm = $c6217487f316a31d$export$2e2bcd8739ae039._workerFarm || new $c6217487f316a31d$export$2e2bcd8739ae039({});
        $c6217487f316a31d$export$2e2bcd8739ae039._workerFarm.setProps(props);
        return $c6217487f316a31d$export$2e2bcd8739ae039._workerFarm;
    }
    constructor(props){
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "props", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "workerPools", new Map());
        this.props = {
            ...$c6217487f316a31d$var$DEFAULT_PROPS
        };
        this.setProps(props);
        this.workerPools = new Map();
    }
    destroy() {
        for (const workerPool of this.workerPools.values())workerPool.destroy();
        this.workerPools = new Map();
    }
    setProps(props) {
        this.props = {
            ...this.props,
            ...props
        };
        for (const workerPool of this.workerPools.values())workerPool.setProps(this._getWorkerPoolProps());
    }
    getWorkerPool(options) {
        const { name: name , source: source , url: url  } = options;
        let workerPool = this.workerPools.get(name);
        if (!workerPool) {
            workerPool = new (0, $ac896f592bed4531$export$2e2bcd8739ae039)({
                name: name,
                source: source,
                url: url
            });
            workerPool.setProps(this._getWorkerPoolProps());
            this.workerPools.set(name, workerPool);
        }
        return workerPool;
    }
    _getWorkerPoolProps() {
        return {
            maxConcurrency: this.props.maxConcurrency,
            maxMobileConcurrency: this.props.maxMobileConcurrency,
            reuseWorkers: this.props.reuseWorkers,
            onDebug: this.props.onDebug
        };
    }
}
(0, $037483d1fb5deac8$export$2e2bcd8739ae039)($c6217487f316a31d$export$2e2bcd8739ae039, "_workerFarm", void 0);



const $71956df2729c708f$var$NPM_TAG = "latest";
const $71956df2729c708f$var$VERSION = "3.2.5";
function $71956df2729c708f$export$72db835c4de3b02e(worker) {
    const warning = worker.version !== $71956df2729c708f$var$VERSION ? " (worker-utils@".concat($71956df2729c708f$var$VERSION, ")") : "";
    return "".concat(worker.name, "@").concat(worker.version).concat(warning);
}
function $71956df2729c708f$export$959914ac3383a118(worker, options = {}) {
    const workerOptions = options[worker.id] || {};
    const workerFile = "".concat(worker.id, "-worker.js");
    let url = workerOptions.workerUrl;
    if (!url && worker.id === "compression") url = options.workerUrl;
    if (options._workerType === "test") url = "modules/".concat(worker.module, "/dist/").concat(workerFile);
    if (!url) {
        let version = worker.version;
        if (version === "latest") version = $71956df2729c708f$var$NPM_TAG;
        const versionTag = version ? "@".concat(version) : "";
        url = "https://unpkg.com/@loaders.gl/".concat(worker.module).concat(versionTag, "/dist/").concat(workerFile);
    }
    (0, $621b2e4491178cd2$export$a7a9523472993e97)(url);
    return url;
}



function $13f60cf71bdb7bc2$export$95e2ee179a5692d5(worker, coreVersion = (0, $1481083a7d4a8836$export$a4ad2735b021c132)) {
    (0, $621b2e4491178cd2$export$a7a9523472993e97)(worker, "no worker provided");
    const workerVersion = worker.version;
    if (!coreVersion || !workerVersion) return false;
    return true;
}
function $13f60cf71bdb7bc2$var$parseVersion(version) {
    const parts = version.split(".").map(Number);
    return {
        major: parts[0],
        minor: parts[1]
    };
}




function $cc2b304bc5bea5e3$export$d28453530d9dde76(loader, options) {
    if (!(0, $c6217487f316a31d$export$2e2bcd8739ae039).isSupported()) return false;
    if (!(0, $9f49355659a4ee10$export$4e09c449d6c407f7) && !(options !== null && options !== void 0 && options._nodeWorkers)) return false;
    return loader.worker && (options === null || options === void 0 ? void 0 : options.worker);
}
async function $cc2b304bc5bea5e3$export$5fc1ede2a33af3b1(loader, data, options, context, parseOnMainThread) {
    const name = loader.id;
    const url = (0, $71956df2729c708f$export$959914ac3383a118)(loader, options);
    const workerFarm = (0, $c6217487f316a31d$export$2e2bcd8739ae039).getWorkerFarm(options);
    const workerPool = workerFarm.getWorkerPool({
        name: name,
        url: url
    });
    options = JSON.parse(JSON.stringify(options));
    context = JSON.parse(JSON.stringify(context || {}));
    const job = await workerPool.startJob("process-on-worker", $cc2b304bc5bea5e3$var$onMessage.bind(null, parseOnMainThread));
    job.postMessage("process", {
        input: data,
        options: options,
        context: context
    });
    const result = await job.result;
    return await result.result;
}
async function $cc2b304bc5bea5e3$var$onMessage(parseOnMainThread, job, type, payload) {
    switch(type){
        case "done":
            job.done(payload);
            break;
        case "error":
            job.error(new Error(payload.error));
            break;
        case "process":
            const { id: id , input: input , options: options  } = payload;
            try {
                const result = await parseOnMainThread(input, options);
                job.postMessage("done", {
                    id: id,
                    result: result
                });
            } catch (error) {
                const message = error instanceof Error ? error.message : "unknown error";
                job.postMessage("error", {
                    id: id,
                    error: message
                });
            }
            break;
        default:
            console.warn("parse-with-worker unknown message ".concat(type));
    }
}


var $9aLFZ = parcelRequire("9aLFZ");
function $349321a255d0af9f$export$a7884ebc965f8f54(value) {
    return value && typeof value === "object" && value.isBuffer;
}
function $349321a255d0af9f$export$fc336dbfaf62f18f(data) {
    return $9aLFZ.toBuffer ? $9aLFZ.toBuffer(data) : data;
}
function $349321a255d0af9f$export$1a478f4dd664a01f(buffer) {
    if ($349321a255d0af9f$export$a7884ebc965f8f54(buffer)) {
        const typedArray = new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.length);
        return typedArray.slice().buffer;
    }
    return buffer;
}


function $30754a9468a958e5$export$8b22b05f429b130c(data) {
    if ((0, $349321a255d0af9f$export$a7884ebc965f8f54)(data)) return (0, $349321a255d0af9f$export$1a478f4dd664a01f)(data);
    if (data instanceof ArrayBuffer) return data;
    if (ArrayBuffer.isView(data)) {
        if (data.byteOffset === 0 && data.byteLength === data.buffer.byteLength) return data.buffer;
        return data.buffer.slice(data.byteOffset, data.byteOffset + data.byteLength);
    }
    if (typeof data === "string") {
        const text = data;
        const uint8Array = new TextEncoder().encode(text);
        return uint8Array.buffer;
    }
    if (data && typeof data === "object" && data._toArrayBuffer) return data._toArrayBuffer();
    throw new Error("toArrayBuffer");
}
function $30754a9468a958e5$export$a21c1249ab709443(arrayBuffer1, arrayBuffer2, byteLength) {
    byteLength = byteLength || arrayBuffer1.byteLength;
    if (arrayBuffer1.byteLength < byteLength || arrayBuffer2.byteLength < byteLength) return false;
    const array1 = new Uint8Array(arrayBuffer1);
    const array2 = new Uint8Array(arrayBuffer2);
    for(let i = 0; i < array1.length; ++i){
        if (array1[i] !== array2[i]) return false;
    }
    return true;
}
function $30754a9468a958e5$export$9a3e9c78eb778da8(...sources) {
    const sourceArrays = sources.map((source2)=>source2 instanceof ArrayBuffer ? new Uint8Array(source2) : source2);
    const byteLength = sourceArrays.reduce((length, typedArray)=>length + typedArray.byteLength, 0);
    const result = new Uint8Array(byteLength);
    let offset = 0;
    for (const sourceArray of sourceArrays){
        result.set(sourceArray, offset);
        offset += sourceArray.byteLength;
    }
    return result.buffer;
}
function $30754a9468a958e5$export$b9f790e5e2031778(...typedArrays) {
    const arrays = typedArrays;
    const TypedArrayConstructor = arrays && arrays.length > 1 && arrays[0].constructor || null;
    if (!TypedArrayConstructor) throw new Error('"concatenateTypedArrays" - incorrect quantity of arguments or arguments have incompatible data types');
    const sumLength = arrays.reduce((acc, value)=>acc + value.length, 0);
    const result = new TypedArrayConstructor(sumLength);
    let offset = 0;
    for (const array of arrays){
        result.set(array, offset);
        offset += array.length;
    }
    return result;
}
function $30754a9468a958e5$export$1c6babfc8b593386(arrayBuffer, byteOffset, byteLength) {
    const subArray = byteLength !== undefined ? new Uint8Array(arrayBuffer).subarray(byteOffset, byteOffset + byteLength) : new Uint8Array(arrayBuffer).subarray(byteOffset);
    const arrayCopy = new Uint8Array(subArray);
    return arrayCopy.buffer;
}


async function $19f06be37636b89d$export$4b80e395e36b5a56(iterator, visitor) {
    while(true){
        const { done: done , value: value  } = await iterator.next();
        if (done) {
            iterator.return();
            return;
        }
        const cancel = visitor(value);
        if (cancel) return;
    }
}
async function $19f06be37636b89d$export$b56e0390cdc1b1ca(asyncIterator) {
    const arrayBuffers = [];
    for await (const chunk of asyncIterator)arrayBuffers.push(chunk);
    return (0, $30754a9468a958e5$export$9a3e9c78eb778da8)(...arrayBuffers);
}
async function $19f06be37636b89d$export$8a08e0b4be2e1c13(asyncIterator) {
    const strings = [];
    for await (const chunk of asyncIterator)strings.push(chunk);
    return strings.join("");
}

let $525404fe6adfd5a1$var$pathPrefix = "";
const $525404fe6adfd5a1$var$fileAliases = {};
function $525404fe6adfd5a1$export$fa7cbeea6a0f8cd3(prefix) {
    $525404fe6adfd5a1$var$pathPrefix = prefix;
}
function $525404fe6adfd5a1$export$e21ff368c7512d8e() {
    return $525404fe6adfd5a1$var$pathPrefix;
}
function $525404fe6adfd5a1$export$65b32f70101f5674(aliases) {
    Object.assign($525404fe6adfd5a1$var$fileAliases, aliases);
}
function $525404fe6adfd5a1$export$b09f2ff0bbcb43c7(filename) {
    for(const alias in $525404fe6adfd5a1$var$fileAliases)if (filename.startsWith(alias)) {
        const replacement = $525404fe6adfd5a1$var$fileAliases[alias];
        filename = filename.replace(alias, replacement);
    }
    if (!filename.startsWith("http://") && !filename.startsWith("https://")) filename = "".concat($525404fe6adfd5a1$var$pathPrefix).concat(filename);
    return filename;
}



function $864167f4ef613baf$export$2db07da082dd07a7(loader) {
    var _loader;
    if (!loader) return false;
    if (Array.isArray(loader)) loader = loader[0];
    const hasExtensions = Array.isArray((_loader = loader) === null || _loader === void 0 ? void 0 : _loader.extensions);
    return hasExtensions;
}
function $864167f4ef613baf$export$a19b0af95f3585f1(loader) {
    var _loader2, _loader3;
    (0, $e2d3345494943a51$export$a7a9523472993e97)(loader, "null loader");
    (0, $e2d3345494943a51$export$a7a9523472993e97)($864167f4ef613baf$export$2db07da082dd07a7(loader), "invalid loader");
    let options;
    if (Array.isArray(loader)) {
        options = loader[1];
        loader = loader[0];
        loader = {
            ...loader,
            options: {
                ...loader.options,
                ...options
            }
        };
    }
    if ((_loader2 = loader) !== null && _loader2 !== void 0 && _loader2.parseTextSync || (_loader3 = loader) !== null && _loader3 !== void 0 && _loader3.parseText) loader.text = true;
    if (!loader.text) loader.binary = true;
    return loader;
}


const $3a21fafe29106685$var$isBoolean = (x)=>typeof x === "boolean";
const $3a21fafe29106685$var$isFunction = (x)=>typeof x === "function";
const $3a21fafe29106685$export$a6cdc56e425d0d0a = (x)=>x !== null && typeof x === "object";
const $3a21fafe29106685$export$e219791d2b49856 = (x)=>$3a21fafe29106685$export$a6cdc56e425d0d0a(x) && x.constructor === ({}).constructor;
const $3a21fafe29106685$export$4369c812aac99591 = (x)=>$3a21fafe29106685$export$a6cdc56e425d0d0a(x) && $3a21fafe29106685$var$isFunction(x.then);
const $3a21fafe29106685$export$9652023d9040757 = (x)=>x && typeof x[Symbol.iterator] === "function";
const $3a21fafe29106685$export$edb10ab8dd75a915 = (x)=>x && typeof x[Symbol.asyncIterator] === "function";
const $3a21fafe29106685$export$50db6e277db66ea0 = (x)=>x && $3a21fafe29106685$var$isFunction(x.next);
const $3a21fafe29106685$export$3f1eb41d9a6a6a27 = (x)=>typeof Response !== "undefined" && x instanceof Response || x && x.arrayBuffer && x.text && x.json;
const $3a21fafe29106685$export$be78b3111c50efdd = (x)=>typeof File !== "undefined" && x instanceof File;
const $3a21fafe29106685$export$5bcd6e94ed871c88 = (x)=>typeof Blob !== "undefined" && x instanceof Blob;
const $3a21fafe29106685$export$a7884ebc965f8f54 = (x)=>x && typeof x === "object" && x.isBuffer;
const $3a21fafe29106685$export$5536d41d90245d51 = (x)=>$3a21fafe29106685$export$a6cdc56e425d0d0a(x) && $3a21fafe29106685$var$isFunction(x.abort) && $3a21fafe29106685$var$isFunction(x.getWriter);
const $3a21fafe29106685$export$f8bb1f6b773199b7 = (x)=>typeof ReadableStream !== "undefined" && x instanceof ReadableStream || $3a21fafe29106685$export$a6cdc56e425d0d0a(x) && $3a21fafe29106685$var$isFunction(x.tee) && $3a21fafe29106685$var$isFunction(x.cancel) && $3a21fafe29106685$var$isFunction(x.getReader);
const $3a21fafe29106685$export$eec1f46c8eef21a4 = (x)=>$3a21fafe29106685$export$a6cdc56e425d0d0a(x) && $3a21fafe29106685$var$isFunction(x.end) && $3a21fafe29106685$var$isFunction(x.write) && $3a21fafe29106685$var$isBoolean(x.writable);
const $3a21fafe29106685$export$2940183a2d5db90f = (x)=>$3a21fafe29106685$export$a6cdc56e425d0d0a(x) && $3a21fafe29106685$var$isFunction(x.read) && $3a21fafe29106685$var$isFunction(x.pipe) && $3a21fafe29106685$var$isBoolean(x.readable);
const $3a21fafe29106685$export$ac613ff475b69d05 = (x)=>$3a21fafe29106685$export$f8bb1f6b773199b7(x) || $3a21fafe29106685$export$2940183a2d5db90f(x);
const $3a21fafe29106685$export$b58a61c52edb4f66 = (x)=>$3a21fafe29106685$export$5536d41d90245d51(x) || $3a21fafe29106685$export$eec1f46c8eef21a4(x);





const $b41e48408a03be18$var$DATA_URL_PATTERN = /^data:([-\w.]+\/[-\w.+]+)(;|,)/;
const $b41e48408a03be18$var$MIME_TYPE_PATTERN = /^([-\w.]+\/[-\w.+]+)/;
function $b41e48408a03be18$export$85e6adb445fa3ef0(mimeString) {
    const matches = $b41e48408a03be18$var$MIME_TYPE_PATTERN.exec(mimeString);
    if (matches) return matches[1];
    return mimeString;
}
function $b41e48408a03be18$export$a8aa3005f5e6c533(url) {
    const matches = $b41e48408a03be18$var$DATA_URL_PATTERN.exec(url);
    if (matches) return matches[1];
    return "";
}


const $68f5dc4489466520$var$QUERY_STRING_PATTERN = /\?.*/;
function $68f5dc4489466520$export$62b93576035b31a0(resource) {
    if ((0, $3a21fafe29106685$export$3f1eb41d9a6a6a27)(resource)) {
        const url = $68f5dc4489466520$var$stripQueryString(resource.url || "");
        const contentTypeHeader = resource.headers.get("content-type") || "";
        return {
            url: url,
            type: (0, $b41e48408a03be18$export$85e6adb445fa3ef0)(contentTypeHeader) || (0, $b41e48408a03be18$export$a8aa3005f5e6c533)(url)
        };
    }
    if ((0, $3a21fafe29106685$export$5bcd6e94ed871c88)(resource)) return {
        url: $68f5dc4489466520$var$stripQueryString(resource.name || ""),
        type: resource.type || ""
    };
    if (typeof resource === "string") return {
        url: $68f5dc4489466520$var$stripQueryString(resource),
        type: (0, $b41e48408a03be18$export$a8aa3005f5e6c533)(resource)
    };
    return {
        url: "",
        type: ""
    };
}
function $68f5dc4489466520$export$795ad0074e2d4d36(resource) {
    if ((0, $3a21fafe29106685$export$3f1eb41d9a6a6a27)(resource)) return resource.headers["content-length"] || -1;
    if ((0, $3a21fafe29106685$export$5bcd6e94ed871c88)(resource)) return resource.size;
    if (typeof resource === "string") return resource.length;
    if (resource instanceof ArrayBuffer) return resource.byteLength;
    if (ArrayBuffer.isView(resource)) return resource.byteLength;
    return -1;
}
function $68f5dc4489466520$var$stripQueryString(url) {
    return url.replace($68f5dc4489466520$var$QUERY_STRING_PATTERN, "");
}


async function $f09c61773fd1de7c$export$16d84ad959da5112(resource) {
    if ((0, $3a21fafe29106685$export$3f1eb41d9a6a6a27)(resource)) return resource;
    const headers = {};
    const contentLength = (0, $68f5dc4489466520$export$795ad0074e2d4d36)(resource);
    if (contentLength >= 0) headers["content-length"] = String(contentLength);
    const { url: url , type: type  } = (0, $68f5dc4489466520$export$62b93576035b31a0)(resource);
    if (type) headers["content-type"] = type;
    const initialDataUrl = await $f09c61773fd1de7c$var$getInitialDataUrl(resource);
    if (initialDataUrl) headers["x-first-bytes"] = initialDataUrl;
    if (typeof resource === "string") resource = new TextEncoder().encode(resource);
    const response = new Response(resource, {
        headers: headers
    });
    Object.defineProperty(response, "url", {
        value: url
    });
    return response;
}
async function $f09c61773fd1de7c$export$5db0ad607ce3410b(response) {
    if (!response.ok) {
        const message = await $f09c61773fd1de7c$var$getResponseError(response);
        throw new Error(message);
    }
}
function $f09c61773fd1de7c$export$ef46f094beca181f(response) {
    if (!response.ok) {
        let message = "".concat(response.status, " ").concat(response.statusText);
        message = message.length > 60 ? "".concat(message.slice(0, 60), "...") : message;
        throw new Error(message);
    }
}
async function $f09c61773fd1de7c$var$getResponseError(response) {
    let message = "Failed to fetch resource ".concat(response.url, " (").concat(response.status, "): ");
    try {
        const contentType = response.headers.get("Content-Type");
        let text = response.statusText;
        if (contentType.includes("application/json")) text += " ".concat(await response.text());
        message += text;
        message = message.length > 60 ? "".concat(message.slice(0, 60), "...") : message;
    } catch (error) {}
    return message;
}
async function $f09c61773fd1de7c$var$getInitialDataUrl(resource) {
    const INITIAL_DATA_LENGTH = 5;
    if (typeof resource === "string") return "data:,".concat(resource.slice(0, INITIAL_DATA_LENGTH));
    if (resource instanceof Blob) {
        const blobSlice = resource.slice(0, 5);
        return await new Promise((resolve)=>{
            const reader = new FileReader();
            reader.onload = (event)=>{
                var _event$target;
                return resolve(event === null || event === void 0 ? void 0 : (_event$target = event.target) === null || _event$target === void 0 ? void 0 : _event$target.result);
            };
            reader.readAsDataURL(blobSlice);
        });
    }
    if (resource instanceof ArrayBuffer) {
        const slice = resource.slice(0, INITIAL_DATA_LENGTH);
        const base64 = $f09c61773fd1de7c$var$arrayBufferToBase64(slice);
        return "data:base64,".concat(base64);
    }
    return null;
}
function $f09c61773fd1de7c$var$arrayBufferToBase64(buffer) {
    let binary = "";
    const bytes = new Uint8Array(buffer);
    for(let i = 0; i < bytes.byteLength; i++)binary += String.fromCharCode(bytes[i]);
    return btoa(binary);
}


async function $3ab0c823d83f8bfb$export$d965bcb23f9d06c5(url, options) {
    if (typeof url === "string") {
        url = (0, $525404fe6adfd5a1$export$b09f2ff0bbcb43c7)(url);
        let fetchOptions = options;
        if (options !== null && options !== void 0 && options.fetch && typeof (options === null || options === void 0 ? void 0 : options.fetch) !== "function") fetchOptions = options.fetch;
        return await fetch(url, fetchOptions);
    }
    return await (0, $f09c61773fd1de7c$export$16d84ad959da5112)(url);
}





const $d0c51c6a82298d65$export$775acaacb88283c4 = new (0, $88fdfccabe5e323d$export$2e2bcd8739ae039)({
    id: "loaders.gl"
});
class $d0c51c6a82298d65$export$c8151b0a106d0aae {
    log() {
        return ()=>{};
    }
    info() {
        return ()=>{};
    }
    warn() {
        return ()=>{};
    }
    error() {
        return ()=>{};
    }
}
class $d0c51c6a82298d65$export$b0d7de77e5ad708 {
    constructor(){
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "console", void 0);
        this.console = console;
    }
    log(...args) {
        return this.console.log.bind(this.console, ...args);
    }
    info(...args) {
        return this.console.info.bind(this.console, ...args);
    }
    warn(...args) {
        return this.console.warn.bind(this.console, ...args);
    }
    error(...args) {
        return this.console.error.bind(this.console, ...args);
    }
}




const $64ef6e1fbc380c0a$export$9e68d151f40453e2 = {
    fetch: null,
    mimeType: undefined,
    nothrow: false,
    log: new (0, $d0c51c6a82298d65$export$b0d7de77e5ad708)(),
    CDN: "https://unpkg.com/@loaders.gl",
    worker: true,
    maxConcurrency: 3,
    maxMobileConcurrency: 1,
    reuseWorkers: (0, $4684b3280a916bc3$export$4e09c449d6c407f7),
    _nodeWorkers: false,
    _workerType: "",
    limit: 0,
    _limitMB: 0,
    batchSize: "auto",
    batchDebounceMs: 0,
    metadata: false,
    transforms: []
};
const $64ef6e1fbc380c0a$export$1bd820ce6d516afc = {
    throws: "nothrow",
    dataType: "(no longer used)",
    uri: "baseUri",
    method: "fetch.method",
    headers: "fetch.headers",
    body: "fetch.body",
    mode: "fetch.mode",
    credentials: "fetch.credentials",
    cache: "fetch.cache",
    redirect: "fetch.redirect",
    referrer: "fetch.referrer",
    referrerPolicy: "fetch.referrerPolicy",
    integrity: "fetch.integrity",
    keepalive: "fetch.keepalive",
    signal: "fetch.signal"
};


function $655ea8d161058ae9$export$2a5c5f9d1a96dd63() {
    globalThis.loaders = globalThis.loaders || {};
    const { loaders: loaders  } = globalThis;
    loaders._state = loaders._state || {};
    return loaders._state;
}
const $655ea8d161058ae9$export$6b0f80053d2682ea = ()=>{
    const state = $655ea8d161058ae9$export$2a5c5f9d1a96dd63();
    state.globalOptions = state.globalOptions || {
        ...(0, $64ef6e1fbc380c0a$export$9e68d151f40453e2)
    };
    return state.globalOptions;
};
function $655ea8d161058ae9$export$545eb931aeddfa08(options) {
    const state = $655ea8d161058ae9$export$2a5c5f9d1a96dd63();
    const globalOptions = $655ea8d161058ae9$export$6b0f80053d2682ea();
    state.globalOptions = $655ea8d161058ae9$var$normalizeOptionsInternal(globalOptions, options);
}
function $655ea8d161058ae9$export$eb806c0b85b62f7a(options, loader, loaders, url) {
    loaders = loaders || [];
    loaders = Array.isArray(loaders) ? loaders : [
        loaders
    ];
    $655ea8d161058ae9$var$validateOptions(options, loaders);
    return $655ea8d161058ae9$var$normalizeOptionsInternal(loader, options, url);
}
function $655ea8d161058ae9$export$9b973e0eff85009f(options, context) {
    const globalOptions = $655ea8d161058ae9$export$6b0f80053d2682ea();
    const fetchOptions = options || globalOptions;
    if (typeof fetchOptions.fetch === "function") return fetchOptions.fetch;
    if ((0, $3a21fafe29106685$export$a6cdc56e425d0d0a)(fetchOptions.fetch)) return (url)=>(0, $3ab0c823d83f8bfb$export$d965bcb23f9d06c5)(url, fetchOptions);
    if (context !== null && context !== void 0 && context.fetch) return context === null || context === void 0 ? void 0 : context.fetch;
    return 0, $3ab0c823d83f8bfb$export$d965bcb23f9d06c5;
}
function $655ea8d161058ae9$var$validateOptions(options, loaders) {
    $655ea8d161058ae9$var$validateOptionsObject(options, null, (0, $64ef6e1fbc380c0a$export$9e68d151f40453e2), (0, $64ef6e1fbc380c0a$export$1bd820ce6d516afc), loaders);
    for (const loader of loaders){
        const idOptions = options && options[loader.id] || {};
        const loaderOptions = loader.options && loader.options[loader.id] || {};
        const deprecatedOptions = loader.deprecatedOptions && loader.deprecatedOptions[loader.id] || {};
        $655ea8d161058ae9$var$validateOptionsObject(idOptions, loader.id, loaderOptions, deprecatedOptions, loaders);
    }
}
function $655ea8d161058ae9$var$validateOptionsObject(options, id, defaultOptions, deprecatedOptions, loaders) {
    const loaderName = id || "Top level";
    const prefix = id ? "".concat(id, ".") : "";
    for(const key in options){
        const isSubOptions = !id && (0, $3a21fafe29106685$export$a6cdc56e425d0d0a)(options[key]);
        const isBaseUriOption = key === "baseUri" && !id;
        const isWorkerUrlOption = key === "workerUrl" && id;
        if (!(key in defaultOptions) && !isBaseUriOption && !isWorkerUrlOption) {
            if (key in deprecatedOptions) (0, $d0c51c6a82298d65$export$775acaacb88283c4).warn("".concat(loaderName, " loader option '").concat(prefix).concat(key, "' no longer supported, use '").concat(deprecatedOptions[key], "'"))();
            else if (!isSubOptions) {
                const suggestion = $655ea8d161058ae9$var$findSimilarOption(key, loaders);
                (0, $d0c51c6a82298d65$export$775acaacb88283c4).warn("".concat(loaderName, " loader option '").concat(prefix).concat(key, "' not recognized. ").concat(suggestion))();
            }
        }
    }
}
function $655ea8d161058ae9$var$findSimilarOption(optionKey, loaders) {
    const lowerCaseOptionKey = optionKey.toLowerCase();
    let bestSuggestion = "";
    for (const loader of loaders)for(const key in loader.options){
        if (optionKey === key) return "Did you mean '".concat(loader.id, ".").concat(key, "'?");
        const lowerCaseKey = key.toLowerCase();
        const isPartialMatch = lowerCaseOptionKey.startsWith(lowerCaseKey) || lowerCaseKey.startsWith(lowerCaseOptionKey);
        if (isPartialMatch) bestSuggestion = bestSuggestion || "Did you mean '".concat(loader.id, ".").concat(key, "'?");
    }
    return bestSuggestion;
}
function $655ea8d161058ae9$var$normalizeOptionsInternal(loader, options, url) {
    const loaderDefaultOptions = loader.options || {};
    const mergedOptions = {
        ...loaderDefaultOptions
    };
    $655ea8d161058ae9$var$addUrlOptions(mergedOptions, url);
    if (mergedOptions.log === null) mergedOptions.log = new (0, $d0c51c6a82298d65$export$c8151b0a106d0aae)();
    $655ea8d161058ae9$var$mergeNestedFields(mergedOptions, $655ea8d161058ae9$export$6b0f80053d2682ea());
    $655ea8d161058ae9$var$mergeNestedFields(mergedOptions, options);
    return mergedOptions;
}
function $655ea8d161058ae9$var$mergeNestedFields(mergedOptions, options) {
    for(const key in options)if (key in options) {
        const value = options[key];
        if ((0, $3a21fafe29106685$export$e219791d2b49856)(value) && (0, $3a21fafe29106685$export$e219791d2b49856)(mergedOptions[key])) mergedOptions[key] = {
            ...mergedOptions[key],
            ...options[key]
        };
        else mergedOptions[key] = options[key];
    }
}
function $655ea8d161058ae9$var$addUrlOptions(options, url) {
    if (url && !("baseUri" in options)) options.baseUri = url;
}


const $74a7778b58c84a5d$var$getGlobalLoaderRegistry = ()=>{
    const state = (0, $655ea8d161058ae9$export$2a5c5f9d1a96dd63)();
    state.loaderRegistry = state.loaderRegistry || [];
    return state.loaderRegistry;
};
function $74a7778b58c84a5d$export$74069a1a10fa28e5(loaders) {
    const loaderRegistry = $74a7778b58c84a5d$var$getGlobalLoaderRegistry();
    loaders = Array.isArray(loaders) ? loaders : [
        loaders
    ];
    for (const loader of loaders){
        const normalizedLoader = (0, $864167f4ef613baf$export$a19b0af95f3585f1)(loader);
        if (!loaderRegistry.find((registeredLoader)=>normalizedLoader === registeredLoader)) loaderRegistry.unshift(normalizedLoader);
    }
}
function $74a7778b58c84a5d$export$8fa02447f82aef84() {
    return $74a7778b58c84a5d$var$getGlobalLoaderRegistry();
}
function $74a7778b58c84a5d$export$a20f34177d9a64c6() {
    const state = (0, $655ea8d161058ae9$export$2a5c5f9d1a96dd63)();
    state.loaderRegistry = [];
}











const $97bf60a30d8bcc31$var$DEFAULT_CHUNK_SIZE = 262144;
function* $97bf60a30d8bcc31$export$c51500126ec60dd4(string, options) {
    const chunkSize = (options === null || options === void 0 ? void 0 : options.chunkSize) || $97bf60a30d8bcc31$var$DEFAULT_CHUNK_SIZE;
    let offset = 0;
    const textEncoder = new TextEncoder();
    while(offset < string.length){
        const chunkLength = Math.min(string.length - offset, chunkSize);
        const chunk = string.slice(offset, offset + chunkLength);
        offset += chunkLength;
        yield textEncoder.encode(chunk);
    }
}


const $e0c0a5a683a20b00$var$DEFAULT_CHUNK_SIZE = 262144;
function* $e0c0a5a683a20b00$export$257e4501e13446d3(arrayBuffer, options = {}) {
    const { chunkSize: chunkSize = $e0c0a5a683a20b00$var$DEFAULT_CHUNK_SIZE  } = options;
    let byteOffset = 0;
    while(byteOffset < arrayBuffer.byteLength){
        const chunkByteLength = Math.min(arrayBuffer.byteLength - byteOffset, chunkSize);
        const chunk = new ArrayBuffer(chunkByteLength);
        const sourceArray = new Uint8Array(arrayBuffer, byteOffset, chunkByteLength);
        const chunkArray = new Uint8Array(chunk);
        chunkArray.set(sourceArray);
        byteOffset += chunkByteLength;
        yield chunk;
    }
}


const $765b79490cb41f16$var$DEFAULT_CHUNK_SIZE = 1048576;
async function* $765b79490cb41f16$export$97cfd032a0f445d2(blob, options) {
    const chunkSize = (options === null || options === void 0 ? void 0 : options.chunkSize) || $765b79490cb41f16$var$DEFAULT_CHUNK_SIZE;
    let offset = 0;
    while(offset < blob.size){
        const end = offset + chunkSize;
        const chunk = await blob.slice(offset, end).arrayBuffer();
        offset = end;
        yield chunk;
    }
}



function $c1b9a61d0199985f$export$80460602c027534f(stream, options) {
    return (0, $4684b3280a916bc3$export$4e09c449d6c407f7) ? $c1b9a61d0199985f$var$makeBrowserStreamIterator(stream, options) : $c1b9a61d0199985f$var$makeNodeStreamIterator(stream, options);
}
async function* $c1b9a61d0199985f$var$makeBrowserStreamIterator(stream, options) {
    const reader = stream.getReader();
    let nextBatchPromise;
    try {
        while(true){
            const currentBatchPromise = nextBatchPromise || reader.read();
            if (options !== null && options !== void 0 && options._streamReadAhead) nextBatchPromise = reader.read();
            const { done: done , value: value  } = await currentBatchPromise;
            if (done) return;
            yield (0, $30754a9468a958e5$export$8b22b05f429b130c)(value);
        }
    } catch (error) {
        reader.releaseLock();
    }
}
async function* $c1b9a61d0199985f$var$makeNodeStreamIterator(stream, options) {
    for await (const chunk of stream)yield (0, $30754a9468a958e5$export$8b22b05f429b130c)(chunk);
}



function $1a6cbf7309e5e0a9$export$81c40ebfe660d3ca(data, options) {
    if (typeof data === "string") return (0, $97bf60a30d8bcc31$export$c51500126ec60dd4)(data, options);
    if (data instanceof ArrayBuffer) return (0, $e0c0a5a683a20b00$export$257e4501e13446d3)(data, options);
    if ((0, $3a21fafe29106685$export$5bcd6e94ed871c88)(data)) return (0, $765b79490cb41f16$export$97cfd032a0f445d2)(data, options);
    if ((0, $3a21fafe29106685$export$ac613ff475b69d05)(data)) return (0, $c1b9a61d0199985f$export$80460602c027534f)(data, options);
    if ((0, $3a21fafe29106685$export$3f1eb41d9a6a6a27)(data)) {
        const response = data;
        return (0, $c1b9a61d0199985f$export$80460602c027534f)(response.body, options);
    }
    throw new Error("makeIterator");
}



const $d0125102dd389479$var$ERR_DATA = "Cannot convert supplied data type";
function $d0125102dd389479$export$1bdaa95e029beec8(data, loader, options) {
    if (loader.text && typeof data === "string") return data;
    if ((0, $3a21fafe29106685$export$a7884ebc965f8f54)(data)) data = data.buffer;
    if (data instanceof ArrayBuffer) {
        const arrayBuffer = data;
        if (loader.text && !loader.binary) {
            const textDecoder = new TextDecoder("utf8");
            return textDecoder.decode(arrayBuffer);
        }
        return arrayBuffer;
    }
    if (ArrayBuffer.isView(data)) {
        if (loader.text && !loader.binary) {
            const textDecoder = new TextDecoder("utf8");
            return textDecoder.decode(data);
        }
        let arrayBuffer = data.buffer;
        const byteLength = data.byteLength || data.length;
        if (data.byteOffset !== 0 || byteLength !== arrayBuffer.byteLength) arrayBuffer = arrayBuffer.slice(data.byteOffset, data.byteOffset + byteLength);
        return arrayBuffer;
    }
    throw new Error($d0125102dd389479$var$ERR_DATA);
}
async function $d0125102dd389479$export$8f911a3af008501e(data, loader, options) {
    const isArrayBuffer = data instanceof ArrayBuffer || ArrayBuffer.isView(data);
    if (typeof data === "string" || isArrayBuffer) return $d0125102dd389479$export$1bdaa95e029beec8(data, loader, options);
    if ((0, $3a21fafe29106685$export$5bcd6e94ed871c88)(data)) data = await (0, $f09c61773fd1de7c$export$16d84ad959da5112)(data);
    if ((0, $3a21fafe29106685$export$3f1eb41d9a6a6a27)(data)) {
        const response = data;
        await (0, $f09c61773fd1de7c$export$5db0ad607ce3410b)(response);
        return loader.binary ? await response.arrayBuffer() : await response.text();
    }
    if ((0, $3a21fafe29106685$export$ac613ff475b69d05)(data)) data = (0, $1a6cbf7309e5e0a9$export$81c40ebfe660d3ca)(data, options);
    if ((0, $3a21fafe29106685$export$9652023d9040757)(data) || (0, $3a21fafe29106685$export$edb10ab8dd75a915)(data)) return (0, $19f06be37636b89d$export$b56e0390cdc1b1ca)(data);
    throw new Error($d0125102dd389479$var$ERR_DATA);
}
async function $d0125102dd389479$export$439b9c71d78e9e91(data, options) {
    if ((0, $3a21fafe29106685$export$50db6e277db66ea0)(data)) return data;
    if ((0, $3a21fafe29106685$export$3f1eb41d9a6a6a27)(data)) {
        const response = data;
        await (0, $f09c61773fd1de7c$export$5db0ad607ce3410b)(response);
        const body = await response.body;
        return (0, $1a6cbf7309e5e0a9$export$81c40ebfe660d3ca)(body, options);
    }
    if ((0, $3a21fafe29106685$export$5bcd6e94ed871c88)(data) || (0, $3a21fafe29106685$export$ac613ff475b69d05)(data)) return (0, $1a6cbf7309e5e0a9$export$81c40ebfe660d3ca)(data, options);
    if ((0, $3a21fafe29106685$export$edb10ab8dd75a915)(data)) return data[Symbol.asyncIterator]();
    return $d0125102dd389479$var$getIterableFromData(data);
}
async function $d0125102dd389479$export$fcaec59c9cf8d502(data) {
    if ((0, $3a21fafe29106685$export$ac613ff475b69d05)(data)) return data;
    if ((0, $3a21fafe29106685$export$3f1eb41d9a6a6a27)(data)) return data.body;
    const response = await (0, $f09c61773fd1de7c$export$16d84ad959da5112)(data);
    return response.body;
}
function $d0125102dd389479$var$getIterableFromData(data) {
    if (ArrayBuffer.isView(data)) return function* oneChunk() {
        yield data.buffer;
    }();
    if (data instanceof ArrayBuffer) return function* oneChunk() {
        yield data;
    }();
    if ((0, $3a21fafe29106685$export$50db6e277db66ea0)(data)) return data;
    if ((0, $3a21fafe29106685$export$9652023d9040757)(data)) return data[Symbol.iterator]();
    throw new Error($d0125102dd389479$var$ERR_DATA);
}



function $45f3edb3159ef0c0$export$c9fdcdb31d4bf289(context, options, previousContext = null) {
    if (previousContext) return previousContext;
    const resolvedContext = {
        fetch: (0, $655ea8d161058ae9$export$9b973e0eff85009f)(options, context),
        ...context
    };
    if (!Array.isArray(resolvedContext.loaders)) resolvedContext.loaders = null;
    return resolvedContext;
}
function $45f3edb3159ef0c0$export$f7bef68ca326d506(loaders, context) {
    if (!context && loaders && !Array.isArray(loaders)) return loaders;
    let candidateLoaders;
    if (loaders) candidateLoaders = Array.isArray(loaders) ? loaders : [
        loaders
    ];
    if (context && context.loaders) {
        const contextLoaders = Array.isArray(context.loaders) ? context.loaders : [
            context.loaders
        ];
        candidateLoaders = candidateLoaders ? [
            ...candidateLoaders,
            ...contextLoaders
        ] : contextLoaders;
    }
    return candidateLoaders && candidateLoaders.length ? candidateLoaders : null;
}






const $31bbe266be23eade$export$bef1f36f5486a6a3 = new (0, $88fdfccabe5e323d$export$2e2bcd8739ae039)({
    id: "loaders.gl"
});





const $2476546eb8404fd7$var$EXT_PATTERN = /\.([^.]+)$/;
async function $2476546eb8404fd7$export$c633f22f376a9a73(data, loaders = [], options, context) {
    if (!$2476546eb8404fd7$var$validHTTPResponse(data)) return null;
    let loader = $2476546eb8404fd7$export$27c49426aa5beb44(data, loaders, {
        ...options,
        nothrow: true
    }, context);
    if (loader) return loader;
    if ((0, $3a21fafe29106685$export$5bcd6e94ed871c88)(data)) {
        data = await data.slice(0, 10).arrayBuffer();
        loader = $2476546eb8404fd7$export$27c49426aa5beb44(data, loaders, options, context);
    }
    if (!loader && !(options !== null && options !== void 0 && options.nothrow)) throw new Error($2476546eb8404fd7$var$getNoValidLoaderMessage(data));
    return loader;
}
function $2476546eb8404fd7$export$27c49426aa5beb44(data, loaders = [], options, context) {
    if (!$2476546eb8404fd7$var$validHTTPResponse(data)) return null;
    if (loaders && !Array.isArray(loaders)) return (0, $864167f4ef613baf$export$a19b0af95f3585f1)(loaders);
    let candidateLoaders = [];
    if (loaders) candidateLoaders = candidateLoaders.concat(loaders);
    if (!(options !== null && options !== void 0 && options.ignoreRegisteredLoaders)) candidateLoaders.push(...(0, $74a7778b58c84a5d$export$8fa02447f82aef84)());
    $2476546eb8404fd7$var$normalizeLoaders(candidateLoaders);
    const loader = $2476546eb8404fd7$var$selectLoaderInternal(data, candidateLoaders, options, context);
    if (!loader && !(options !== null && options !== void 0 && options.nothrow)) throw new Error($2476546eb8404fd7$var$getNoValidLoaderMessage(data));
    return loader;
}
function $2476546eb8404fd7$var$selectLoaderInternal(data, loaders, options, context) {
    const { url: url , type: type  } = (0, $68f5dc4489466520$export$62b93576035b31a0)(data);
    const testUrl = url || (context === null || context === void 0 ? void 0 : context.url);
    let loader = null;
    let reason = "";
    if (options !== null && options !== void 0 && options.mimeType) {
        loader = $2476546eb8404fd7$var$findLoaderByMIMEType(loaders, options === null || options === void 0 ? void 0 : options.mimeType);
        reason = "match forced by supplied MIME type ".concat(options === null || options === void 0 ? void 0 : options.mimeType);
    }
    loader = loader || $2476546eb8404fd7$var$findLoaderByUrl(loaders, testUrl);
    reason = reason || (loader ? "matched url ".concat(testUrl) : "");
    loader = loader || $2476546eb8404fd7$var$findLoaderByMIMEType(loaders, type);
    reason = reason || (loader ? "matched MIME type ".concat(type) : "");
    loader = loader || $2476546eb8404fd7$var$findLoaderByInitialBytes(loaders, data);
    reason = reason || (loader ? "matched initial data ".concat($2476546eb8404fd7$var$getFirstCharacters(data)) : "");
    loader = loader || $2476546eb8404fd7$var$findLoaderByMIMEType(loaders, options === null || options === void 0 ? void 0 : options.fallbackMimeType);
    reason = reason || (loader ? "matched fallback MIME type ".concat(type) : "");
    if (reason) {
        var _loader;
        (0, $31bbe266be23eade$export$bef1f36f5486a6a3).log(1, "selectLoader selected ".concat((_loader = loader) === null || _loader === void 0 ? void 0 : _loader.name, ": ").concat(reason, "."));
    }
    return loader;
}
function $2476546eb8404fd7$var$validHTTPResponse(data) {
    if (data instanceof Response) {
        if (data.status === 204) return false;
    }
    return true;
}
function $2476546eb8404fd7$var$getNoValidLoaderMessage(data) {
    const { url: url , type: type  } = (0, $68f5dc4489466520$export$62b93576035b31a0)(data);
    let message = "No valid loader found (";
    message += url ? "".concat((0, $51a006089e505849$exports).filename(url), ", ") : "no url provided, ";
    message += "MIME type: ".concat(type ? '"'.concat(type, '"') : "not provided", ", ");
    const firstCharacters = data ? $2476546eb8404fd7$var$getFirstCharacters(data) : "";
    message += firstCharacters ? ' first bytes: "'.concat(firstCharacters, '"') : "first bytes: not available";
    message += ")";
    return message;
}
function $2476546eb8404fd7$var$normalizeLoaders(loaders) {
    for (const loader of loaders)(0, $864167f4ef613baf$export$a19b0af95f3585f1)(loader);
}
function $2476546eb8404fd7$var$findLoaderByUrl(loaders, url) {
    const match = url && $2476546eb8404fd7$var$EXT_PATTERN.exec(url);
    const extension = match && match[1];
    return extension ? $2476546eb8404fd7$var$findLoaderByExtension(loaders, extension) : null;
}
function $2476546eb8404fd7$var$findLoaderByExtension(loaders, extension) {
    extension = extension.toLowerCase();
    for (const loader of loaders)for (const loaderExtension of loader.extensions){
        if (loaderExtension.toLowerCase() === extension) return loader;
    }
    return null;
}
function $2476546eb8404fd7$var$findLoaderByMIMEType(loaders, mimeType) {
    for (const loader of loaders){
        if (loader.mimeTypes && loader.mimeTypes.includes(mimeType)) return loader;
        if (mimeType === "application/x.".concat(loader.id)) return loader;
    }
    return null;
}
function $2476546eb8404fd7$var$findLoaderByInitialBytes(loaders, data) {
    if (!data) return null;
    for (const loader of loaders){
        if (typeof data === "string") {
            if ($2476546eb8404fd7$var$testDataAgainstText(data, loader)) return loader;
        } else if (ArrayBuffer.isView(data)) {
            if ($2476546eb8404fd7$var$testDataAgainstBinary(data.buffer, data.byteOffset, loader)) return loader;
        } else if (data instanceof ArrayBuffer) {
            const byteOffset = 0;
            if ($2476546eb8404fd7$var$testDataAgainstBinary(data, byteOffset, loader)) return loader;
        }
    }
    return null;
}
function $2476546eb8404fd7$var$testDataAgainstText(data, loader) {
    if (loader.testText) return loader.testText(data);
    const tests = Array.isArray(loader.tests) ? loader.tests : [
        loader.tests
    ];
    return tests.some((test)=>data.startsWith(test));
}
function $2476546eb8404fd7$var$testDataAgainstBinary(data, byteOffset, loader) {
    const tests = Array.isArray(loader.tests) ? loader.tests : [
        loader.tests
    ];
    return tests.some((test)=>$2476546eb8404fd7$var$testBinary(data, byteOffset, loader, test));
}
function $2476546eb8404fd7$var$testBinary(data, byteOffset, loader, test) {
    if (test instanceof ArrayBuffer) return (0, $30754a9468a958e5$export$a21c1249ab709443)(test, data, test.byteLength);
    switch(typeof test){
        case "function":
            return test(data, loader);
        case "string":
            const magic = $2476546eb8404fd7$var$getMagicString(data, byteOffset, test.length);
            return test === magic;
        default:
            return false;
    }
}
function $2476546eb8404fd7$var$getFirstCharacters(data, length = 5) {
    if (typeof data === "string") return data.slice(0, length);
    else if (ArrayBuffer.isView(data)) return $2476546eb8404fd7$var$getMagicString(data.buffer, data.byteOffset, length);
    else if (data instanceof ArrayBuffer) {
        const byteOffset = 0;
        return $2476546eb8404fd7$var$getMagicString(data, byteOffset, length);
    }
    return "";
}
function $2476546eb8404fd7$var$getMagicString(arrayBuffer, byteOffset, length) {
    if (arrayBuffer.byteLength < byteOffset + length) return "";
    const dataView = new DataView(arrayBuffer);
    let magic = "";
    for(let i = 0; i < length; i++)magic += String.fromCharCode(dataView.getUint8(byteOffset + i));
    return magic;
}


async function $5e2763efee34aaaa$export$98e6a39c04603d36(data, loaders, options, context) {
    (0, $621b2e4491178cd2$export$a7a9523472993e97)(!context || typeof context === "object");
    if (loaders && !Array.isArray(loaders) && !(0, $864167f4ef613baf$export$2db07da082dd07a7)(loaders)) {
        context = undefined;
        options = loaders;
        loaders = undefined;
    }
    data = await data;
    options = options || {};
    const { url: url  } = (0, $68f5dc4489466520$export$62b93576035b31a0)(data);
    const typedLoaders = loaders;
    const candidateLoaders = (0, $45f3edb3159ef0c0$export$f7bef68ca326d506)(typedLoaders, context);
    const loader = await (0, $2476546eb8404fd7$export$c633f22f376a9a73)(data, candidateLoaders, options);
    if (!loader) return null;
    options = (0, $655ea8d161058ae9$export$eb806c0b85b62f7a)(options, loader, candidateLoaders, url);
    context = (0, $45f3edb3159ef0c0$export$c9fdcdb31d4bf289)({
        url: url,
        parse: $5e2763efee34aaaa$export$98e6a39c04603d36,
        loaders: candidateLoaders
    }, options, context);
    return await $5e2763efee34aaaa$var$parseWithLoader(loader, data, options, context);
}
async function $5e2763efee34aaaa$var$parseWithLoader(loader, data, options, context) {
    (0, $13f60cf71bdb7bc2$export$95e2ee179a5692d5)(loader);
    if ((0, $3a21fafe29106685$export$3f1eb41d9a6a6a27)(data)) {
        const response = data;
        const { ok: ok , redirected: redirected , status: status , statusText: statusText , type: type , url: url  } = response;
        const headers = Object.fromEntries(response.headers.entries());
        context.response = {
            headers: headers,
            ok: ok,
            redirected: redirected,
            status: status,
            statusText: statusText,
            type: type,
            url: url
        };
    }
    data = await (0, $d0125102dd389479$export$8f911a3af008501e)(data, loader, options);
    if (loader.parseTextSync && typeof data === "string") {
        options.dataType = "text";
        return loader.parseTextSync(data, options, context, loader);
    }
    if ((0, $cc2b304bc5bea5e3$export$d28453530d9dde76)(loader, options)) return await (0, $cc2b304bc5bea5e3$export$5fc1ede2a33af3b1)(loader, data, options, context, $5e2763efee34aaaa$export$98e6a39c04603d36);
    if (loader.parseText && typeof data === "string") return await loader.parseText(data, options, context, loader);
    if (loader.parse) return await loader.parse(data, options, context, loader);
    (0, $621b2e4491178cd2$export$a7a9523472993e97)(!loader.parseSync);
    throw new Error("".concat(loader.id, " loader - no parser found and worker is disabled"));
}


async function $10b58f50fbeb8045$export$11e63f7b0f3d9900(url, loaders, options, context) {
    if (!Array.isArray(loaders) && !(0, $864167f4ef613baf$export$2db07da082dd07a7)(loaders)) {
        context = undefined;
        options = loaders;
        loaders = undefined;
    }
    const fetch = (0, $655ea8d161058ae9$export$9b973e0eff85009f)(options);
    let data = url;
    if (typeof url === "string") data = await fetch(url);
    if ((0, $3a21fafe29106685$export$5bcd6e94ed871c88)(url)) data = await fetch(url);
    return await (0, $5e2763efee34aaaa$export$98e6a39c04603d36)(data, loaders, options);
}



class $621d77364ac7bdec$export$2e2bcd8739ae039 {
    constructor(id, data, context){
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "id", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "context", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "isLoaded", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "persistent", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_loadCount", 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_subscribers", new Set());
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_data", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_loader", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_error", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_content", void 0);
        this.id = id;
        this.context = context;
        this.setData(data);
    }
    subscribe(consumer) {
        this._subscribers.add(consumer);
    }
    unsubscribe(consumer) {
        this._subscribers.delete(consumer);
    }
    inUse() {
        return this._subscribers.size > 0;
    }
    delete() {}
    getData() {
        return this.isLoaded ? this._error ? Promise.reject(this._error) : this._content : this._loader.then(()=>this.getData());
    }
    setData(data, forceUpdate) {
        if (data === this._data && !forceUpdate) return;
        this._data = data;
        const loadCount = ++this._loadCount;
        let loader = data;
        if (typeof data === "string") loader = (0, $10b58f50fbeb8045$export$11e63f7b0f3d9900)(data);
        if (loader instanceof Promise) {
            this.isLoaded = false;
            this._loader = loader.then((result)=>{
                if (this._loadCount === loadCount) {
                    this.isLoaded = true;
                    this._error = undefined;
                    this._content = result;
                }
            }).catch((error)=>{
                if (this._loadCount === loadCount) {
                    this.isLoaded = true;
                    this._error = error || true;
                }
            });
        } else {
            this.isLoaded = true;
            this._error = undefined;
            this._content = data;
        }
        for (const subscriber of this._subscribers)subscriber.onChange(this.getData());
    }
}


class $23cb722a95241d61$export$2e2bcd8739ae039 {
    constructor({ gl: gl , protocol: protocol  }){
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "protocol", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_context", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_resources", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_consumers", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_pruneRequest", void 0);
        this.protocol = protocol || "resource://";
        this._context = {
            gl: gl,
            resourceManager: this
        };
        this._resources = {};
        this._consumers = {};
        this._pruneRequest = null;
    }
    contains(resourceId) {
        if (resourceId.startsWith(this.protocol)) return true;
        return resourceId in this._resources;
    }
    add({ resourceId: resourceId , data: data , forceUpdate: forceUpdate = false , persistent: persistent = true  }) {
        let res = this._resources[resourceId];
        if (res) res.setData(data, forceUpdate);
        else {
            res = new (0, $621d77364ac7bdec$export$2e2bcd8739ae039)(resourceId, data, this._context);
            this._resources[resourceId] = res;
        }
        res.persistent = persistent;
    }
    remove(resourceId) {
        const res = this._resources[resourceId];
        if (res) {
            res.delete();
            delete this._resources[resourceId];
        }
    }
    unsubscribe({ consumerId: consumerId  }) {
        const consumer = this._consumers[consumerId];
        if (consumer) {
            for(const requestId in consumer){
                const request = consumer[requestId];
                const resource = this._resources[request.resourceId];
                if (resource) resource.unsubscribe(request);
            }
            delete this._consumers[consumerId];
            this.prune();
        }
    }
    subscribe({ resourceId: resourceId , onChange: onChange , consumerId: consumerId , requestId: requestId = "default"  }) {
        const { _resources: resources , protocol: protocol  } = this;
        if (resourceId.startsWith(protocol)) {
            resourceId = resourceId.replace(protocol, "");
            if (!resources[resourceId]) this.add({
                resourceId: resourceId,
                data: null,
                persistent: false
            });
        }
        const res = resources[resourceId];
        this._track(consumerId, requestId, res, onChange);
        if (res) return res.getData();
        return undefined;
    }
    prune() {
        if (!this._pruneRequest) this._pruneRequest = setTimeout(()=>this._prune(), 0);
    }
    finalize() {
        for(const key in this._resources)this._resources[key].delete();
    }
    _track(consumerId, requestId, resource, onChange) {
        const consumers = this._consumers;
        const consumer = consumers[consumerId] = consumers[consumerId] || {};
        const request = consumer[requestId] || {};
        const oldResource = request.resourceId && this._resources[request.resourceId];
        if (oldResource) {
            oldResource.unsubscribe(request);
            this.prune();
        }
        if (resource) {
            consumer[requestId] = request;
            request.onChange = onChange;
            request.resourceId = resource.id;
            resource.subscribe(request);
        }
    }
    _prune() {
        this._pruneRequest = null;
        for (const key of Object.keys(this._resources)){
            const res = this._resources[key];
            if (!res.persistent && !res.inUse()) {
                res.delete();
                delete this._resources[key];
            }
        }
    }
}





class $e0cd51e92519f55c$export$ae7911e6e34e8f38 {
    constructor(options = {}){
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_pool", []);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "opts", {
            overAlloc: 2,
            poolSize: 100
        });
        this.setOptions(options);
    }
    setOptions(options) {
        Object.assign(this.opts, options);
    }
    allocate(typedArray, count, { size: size = 1 , type: type , padding: padding = 0 , copy: copy = false , initialize: initialize = false , maxCount: maxCount  }) {
        const Type = type || typedArray && typedArray.constructor || Float32Array;
        const newSize = count * size + padding;
        if (ArrayBuffer.isView(typedArray)) {
            if (newSize <= typedArray.length) return typedArray;
            if (newSize * typedArray.BYTES_PER_ELEMENT <= typedArray.buffer.byteLength) return new Type(typedArray.buffer, 0, newSize);
        }
        let maxSize = Infinity;
        if (maxCount) maxSize = maxCount * size + padding;
        const newArray = this._allocate(Type, newSize, initialize, maxSize);
        if (typedArray && copy) newArray.set(typedArray);
        else if (!initialize) newArray.fill(0, 0, 4);
        this._release(typedArray);
        return newArray;
    }
    release(typedArray) {
        this._release(typedArray);
    }
    _allocate(Type, size, initialize, maxSize) {
        let sizeToAllocate = Math.max(Math.ceil(size * this.opts.overAlloc), 1);
        if (sizeToAllocate > maxSize) sizeToAllocate = maxSize;
        const pool = this._pool;
        const byteLength = Type.BYTES_PER_ELEMENT * sizeToAllocate;
        const i = pool.findIndex((b)=>b.byteLength >= byteLength);
        if (i >= 0) {
            const array = new Type(pool.splice(i, 1)[0], 0, sizeToAllocate);
            if (initialize) array.fill(0);
            return array;
        }
        return new Type(sizeToAllocate);
    }
    _release(typedArray) {
        if (!ArrayBuffer.isView(typedArray)) return;
        const pool = this._pool;
        const { buffer: buffer  } = typedArray;
        const { byteLength: byteLength  } = buffer;
        const i = pool.findIndex((b)=>b.byteLength >= byteLength);
        if (i < 0) pool.push(buffer);
        else if (i > 0 || pool.length < this.opts.poolSize) pool.splice(i, 0, buffer);
        if (pool.length > this.opts.poolSize) pool.shift();
    }
}
var $e0cd51e92519f55c$export$2e2bcd8739ae039 = new $e0cd51e92519f55c$export$ae7911e6e34e8f38();


function $357091e5c1a009be$export$2e2bcd8739ae039(condition, message) {
    if (!condition) throw new Error("math.gl assertion ".concat(message));
}


const $53a37c44451cea56$var$RADIANS_TO_DEGREES = 1 / Math.PI * 180;
const $53a37c44451cea56$var$DEGREES_TO_RADIANS = 1 / 180 * Math.PI;
const $53a37c44451cea56$export$e506a1d27d1eaa20 = {
    EPSILON: 1e-12,
    debug: false,
    precision: 4,
    printTypes: false,
    printDegrees: false,
    printRowMajor: true
};
function $53a37c44451cea56$export$8d21e34596265fa2(options) {
    for(const key in options){
        (0, $357091e5c1a009be$export$2e2bcd8739ae039)(key in $53a37c44451cea56$export$e506a1d27d1eaa20);
        $53a37c44451cea56$export$e506a1d27d1eaa20[key] = options[key];
    }
    return $53a37c44451cea56$export$e506a1d27d1eaa20;
}
function $53a37c44451cea56$export$7c4d25c0c3217d8c(value, { precision: precision = $53a37c44451cea56$export$e506a1d27d1eaa20.precision  } = {}) {
    value = $53a37c44451cea56$var$round(value);
    return "".concat(parseFloat(value.toPrecision(precision)));
}
function $53a37c44451cea56$export$43bee75e5e14138e(value) {
    return Array.isArray(value) || ArrayBuffer.isView(value) && !(value instanceof DataView);
}
function $53a37c44451cea56$export$9cd59f9826255e47(array) {
    return "clone" in array ? array.clone() : array.slice();
}
function $53a37c44451cea56$export$cba01ba138429a1d(degrees1) {
    return $53a37c44451cea56$export$8449e153fbd325fc(degrees1);
}
function $53a37c44451cea56$export$56cb859c01fa134d(radians1) {
    return $53a37c44451cea56$export$41fc368e1a942b97(radians1);
}
function $53a37c44451cea56$export$8449e153fbd325fc(degrees2, result) {
    return $53a37c44451cea56$var$map(degrees2, (degrees3)=>degrees3 * $53a37c44451cea56$var$DEGREES_TO_RADIANS, result);
}
function $53a37c44451cea56$export$41fc368e1a942b97(radians2, result) {
    return $53a37c44451cea56$var$map(radians2, (radians3)=>radians3 * $53a37c44451cea56$var$RADIANS_TO_DEGREES, result);
}
function $53a37c44451cea56$export$5de3937cb4b592ed(radians4, result) {
    return $53a37c44451cea56$var$map(radians4, (angle)=>Math.sin(angle), result);
}
function $53a37c44451cea56$export$50d414a77b60d802(radians5, result) {
    return $53a37c44451cea56$var$map(radians5, (angle)=>Math.cos(angle), result);
}
function $53a37c44451cea56$export$fcdd3b0b3246a325(radians6, result) {
    return $53a37c44451cea56$var$map(radians6, (angle)=>Math.tan(angle), result);
}
function $53a37c44451cea56$export$41726bdb1fc63f(radians7, result) {
    return $53a37c44451cea56$var$map(radians7, (angle)=>Math.asin(angle), result);
}
function $53a37c44451cea56$export$fd6306be3fde5b04(radians8, result) {
    return $53a37c44451cea56$var$map(radians8, (angle)=>Math.acos(angle), result);
}
function $53a37c44451cea56$export$628dc4eed22b0fbd(radians9, result) {
    return $53a37c44451cea56$var$map(radians9, (angle)=>Math.atan(angle), result);
}
function $53a37c44451cea56$export$7d15b64cf5a3a4c4(value1, min, max) {
    return $53a37c44451cea56$var$map(value1, (value)=>Math.max(min, Math.min(max, value)));
}
function $53a37c44451cea56$export$3a89f8d6f6bf6c9f(a, b, t) {
    if ($53a37c44451cea56$export$43bee75e5e14138e(a)) return a.map((ai, i)=>$53a37c44451cea56$export$3a89f8d6f6bf6c9f(ai, b[i], t));
    return t * b + (1 - t) * a;
}
function $53a37c44451cea56$export$e9bab7fafb253603(a, b, epsilon) {
    const oldEpsilon = $53a37c44451cea56$export$e506a1d27d1eaa20.EPSILON;
    if (epsilon) $53a37c44451cea56$export$e506a1d27d1eaa20.EPSILON = epsilon;
    try {
        if (a === b) return true;
        if ($53a37c44451cea56$export$43bee75e5e14138e(a) && $53a37c44451cea56$export$43bee75e5e14138e(b)) {
            if (a.length !== b.length) return false;
            for(let i = 0; i < a.length; ++i){
                if (!$53a37c44451cea56$export$e9bab7fafb253603(a[i], b[i])) return false;
            }
            return true;
        }
        if (a && a.equals) return a.equals(b);
        if (b && b.equals) return b.equals(a);
        if (typeof a === "number" && typeof b === "number") return Math.abs(a - b) <= $53a37c44451cea56$export$e506a1d27d1eaa20.EPSILON * Math.max(1, Math.abs(a), Math.abs(b));
        return false;
    } finally{
        $53a37c44451cea56$export$e506a1d27d1eaa20.EPSILON = oldEpsilon;
    }
}
function $53a37c44451cea56$export$f2599a5cf1109d8(a, b) {
    if (a === b) return true;
    if (a && typeof a === "object" && b && typeof b === "object") {
        if (a.constructor !== b.constructor) return false;
        if (a.exactEquals) return a.exactEquals(b);
    }
    if ($53a37c44451cea56$export$43bee75e5e14138e(a) && $53a37c44451cea56$export$43bee75e5e14138e(b)) {
        if (a.length !== b.length) return false;
        for(let i = 0; i < a.length; ++i){
            if (!$53a37c44451cea56$export$f2599a5cf1109d8(a[i], b[i])) return false;
        }
        return true;
    }
    return false;
}
function $53a37c44451cea56$export$33e486a830e586b3(epsilon, func) {
    const oldPrecision = $53a37c44451cea56$export$e506a1d27d1eaa20.EPSILON;
    $53a37c44451cea56$export$e506a1d27d1eaa20.EPSILON = epsilon;
    let value;
    try {
        value = func();
    } finally{
        $53a37c44451cea56$export$e506a1d27d1eaa20.EPSILON = oldPrecision;
    }
    return value;
}
function $53a37c44451cea56$var$round(value) {
    return Math.round(value / $53a37c44451cea56$export$e506a1d27d1eaa20.EPSILON) * $53a37c44451cea56$export$e506a1d27d1eaa20.EPSILON;
}
function $53a37c44451cea56$var$duplicateArray(array) {
    return array.clone ? array.clone() : new Array(array.length);
}
function $53a37c44451cea56$var$map(value, func, result) {
    if ($53a37c44451cea56$export$43bee75e5e14138e(value)) {
        const array = value;
        result = result || $53a37c44451cea56$var$duplicateArray(array);
        for(let i = 0; i < result.length && i < array.length; ++i)result[i] = func(value[i], i, result);
        return result;
    }
    return func(value);
}


function $99c41966f61b2e6e$var$_extendableBuiltin(cls) {
    function ExtendableBuiltin() {
        var instance = Reflect.construct(cls, Array.from(arguments));
        Object.setPrototypeOf(instance, Object.getPrototypeOf(this));
        return instance;
    }
    ExtendableBuiltin.prototype = Object.create(cls.prototype, {
        constructor: {
            value: cls,
            enumerable: false,
            writable: true,
            configurable: true
        }
    });
    if (Object.setPrototypeOf) Object.setPrototypeOf(ExtendableBuiltin, cls);
    else ExtendableBuiltin.__proto__ = cls;
    return ExtendableBuiltin;
}
class $99c41966f61b2e6e$export$2e2bcd8739ae039 extends $99c41966f61b2e6e$var$_extendableBuiltin(Array) {
    clone() {
        return new this.constructor().copy(this);
    }
    fromArray(array, offset = 0) {
        for(let i = 0; i < this.ELEMENTS; ++i)this[i] = array[i + offset];
        return this.check();
    }
    toArray(targetArray = [], offset = 0) {
        for(let i = 0; i < this.ELEMENTS; ++i)targetArray[offset + i] = this[i];
        return targetArray;
    }
    from(arrayOrObject) {
        return Array.isArray(arrayOrObject) ? this.copy(arrayOrObject) : this.fromObject(arrayOrObject);
    }
    to(arrayOrObject) {
        if (arrayOrObject === this) return this;
        return (0, $53a37c44451cea56$export$43bee75e5e14138e)(arrayOrObject) ? this.toArray(arrayOrObject) : this.toObject(arrayOrObject);
    }
    toTarget(target) {
        return target ? this.to(target) : this;
    }
    toFloat32Array() {
        return new Float32Array(this);
    }
    toString() {
        return this.formatString((0, $53a37c44451cea56$export$e506a1d27d1eaa20));
    }
    formatString(opts) {
        let string = "";
        for(let i = 0; i < this.ELEMENTS; ++i)string += (i > 0 ? ", " : "") + (0, $53a37c44451cea56$export$7c4d25c0c3217d8c)(this[i], opts);
        return "".concat(opts.printTypes ? this.constructor.name : "", "[").concat(string, "]");
    }
    equals(array) {
        if (!array || this.length !== array.length) return false;
        for(let i = 0; i < this.ELEMENTS; ++i){
            if (!(0, $53a37c44451cea56$export$e9bab7fafb253603)(this[i], array[i])) return false;
        }
        return true;
    }
    exactEquals(array) {
        if (!array || this.length !== array.length) return false;
        for(let i = 0; i < this.ELEMENTS; ++i){
            if (this[i] !== array[i]) return false;
        }
        return true;
    }
    negate() {
        for(let i = 0; i < this.ELEMENTS; ++i)this[i] = -this[i];
        return this.check();
    }
    lerp(a, b, t) {
        if (t === undefined) return this.lerp(this, a, b);
        for(let i = 0; i < this.ELEMENTS; ++i){
            const ai = a[i];
            this[i] = ai + t * (b[i] - ai);
        }
        return this.check();
    }
    min(vector) {
        for(let i = 0; i < this.ELEMENTS; ++i)this[i] = Math.min(vector[i], this[i]);
        return this.check();
    }
    max(vector) {
        for(let i = 0; i < this.ELEMENTS; ++i)this[i] = Math.max(vector[i], this[i]);
        return this.check();
    }
    clamp(minVector, maxVector) {
        for(let i = 0; i < this.ELEMENTS; ++i)this[i] = Math.min(Math.max(this[i], minVector[i]), maxVector[i]);
        return this.check();
    }
    add(...vectors) {
        for (const vector of vectors)for(let i = 0; i < this.ELEMENTS; ++i)this[i] += vector[i];
        return this.check();
    }
    subtract(...vectors) {
        for (const vector of vectors)for(let i = 0; i < this.ELEMENTS; ++i)this[i] -= vector[i];
        return this.check();
    }
    scale(scale) {
        if (typeof scale === "number") for(let i = 0; i < this.ELEMENTS; ++i)this[i] *= scale;
        else for(let i1 = 0; i1 < this.ELEMENTS && i1 < scale.length; ++i1)this[i1] *= scale[i1];
        return this.check();
    }
    multiplyByScalar(scalar) {
        for(let i = 0; i < this.ELEMENTS; ++i)this[i] *= scalar;
        return this.check();
    }
    check() {
        if ((0, $53a37c44451cea56$export$e506a1d27d1eaa20).debug && !this.validate()) throw new Error("math.gl: ".concat(this.constructor.name, " some fields set to invalid numbers'"));
        return this;
    }
    validate() {
        let valid = this.length === this.ELEMENTS;
        for(let i = 0; i < this.ELEMENTS; ++i)valid = valid && Number.isFinite(this[i]);
        return valid;
    }
    sub(a) {
        return this.subtract(a);
    }
    setScalar(a) {
        for(let i = 0; i < this.ELEMENTS; ++i)this[i] = a;
        return this.check();
    }
    addScalar(a) {
        for(let i = 0; i < this.ELEMENTS; ++i)this[i] += a;
        return this.check();
    }
    subScalar(a) {
        return this.addScalar(-a);
    }
    multiplyScalar(scalar) {
        for(let i = 0; i < this.ELEMENTS; ++i)this[i] *= scalar;
        return this.check();
    }
    divideScalar(a) {
        return this.multiplyByScalar(1 / a);
    }
    clampScalar(min, max) {
        for(let i = 0; i < this.ELEMENTS; ++i)this[i] = Math.min(Math.max(this[i], min), max);
        return this.check();
    }
    get elements() {
        return this;
    }
}



function $c362065f7b29175e$export$a1b6cd0c891cc7(v, length) {
    if (v.length !== length) return false;
    for(let i = 0; i < v.length; ++i){
        if (!Number.isFinite(v[i])) return false;
    }
    return true;
}
function $c362065f7b29175e$export$74ff82ccb88f9fb1(value) {
    if (!Number.isFinite(value)) throw new Error("Invalid number ".concat(value));
    return value;
}
function $c362065f7b29175e$export$3eb62eb6ef90f888(v, length, callerName = "") {
    if ((0, $53a37c44451cea56$export$e506a1d27d1eaa20).debug && !$c362065f7b29175e$export$a1b6cd0c891cc7(v, length)) throw new Error("math.gl: ".concat(callerName, " some fields set to invalid numbers'"));
    return v;
}
const $c362065f7b29175e$var$map = {};
function $c362065f7b29175e$export$cdd73fc4100a6ef4(method, version) {
    if (!$c362065f7b29175e$var$map[method]) {
        $c362065f7b29175e$var$map[method] = true;
        console.warn("".concat(method, " has been removed in version ").concat(version, ", see upgrade guide for more information"));
    }
}



class $b690e88cf380b7fe$export$2e2bcd8739ae039 extends (0, $99c41966f61b2e6e$export$2e2bcd8739ae039) {
    get x() {
        return this[0];
    }
    set x(value) {
        this[0] = (0, $c362065f7b29175e$export$74ff82ccb88f9fb1)(value);
    }
    get y() {
        return this[1];
    }
    set y(value) {
        this[1] = (0, $c362065f7b29175e$export$74ff82ccb88f9fb1)(value);
    }
    len() {
        return Math.sqrt(this.lengthSquared());
    }
    magnitude() {
        return this.len();
    }
    lengthSquared() {
        let length = 0;
        for(let i = 0; i < this.ELEMENTS; ++i)length += this[i] * this[i];
        return length;
    }
    magnitudeSquared() {
        return this.lengthSquared();
    }
    distance(mathArray) {
        return Math.sqrt(this.distanceSquared(mathArray));
    }
    distanceSquared(mathArray) {
        let length = 0;
        for(let i = 0; i < this.ELEMENTS; ++i){
            const dist = this[i] - mathArray[i];
            length += dist * dist;
        }
        return (0, $c362065f7b29175e$export$74ff82ccb88f9fb1)(length);
    }
    dot(mathArray) {
        let product = 0;
        for(let i = 0; i < this.ELEMENTS; ++i)product += this[i] * mathArray[i];
        return (0, $c362065f7b29175e$export$74ff82ccb88f9fb1)(product);
    }
    normalize() {
        const length = this.magnitude();
        if (length !== 0) for(let i = 0; i < this.ELEMENTS; ++i)this[i] /= length;
        return this.check();
    }
    multiply(...vectors) {
        for (const vector of vectors)for(let i = 0; i < this.ELEMENTS; ++i)this[i] *= vector[i];
        return this.check();
    }
    divide(...vectors) {
        for (const vector of vectors)for(let i = 0; i < this.ELEMENTS; ++i)this[i] /= vector[i];
        return this.check();
    }
    lengthSq() {
        return this.lengthSquared();
    }
    distanceTo(vector) {
        return this.distance(vector);
    }
    distanceToSquared(vector) {
        return this.distanceSquared(vector);
    }
    getComponent(i) {
        (0, $357091e5c1a009be$export$2e2bcd8739ae039)(i >= 0 && i < this.ELEMENTS, "index is out of range");
        return (0, $c362065f7b29175e$export$74ff82ccb88f9fb1)(this[i]);
    }
    setComponent(i, value) {
        (0, $357091e5c1a009be$export$2e2bcd8739ae039)(i >= 0 && i < this.ELEMENTS, "index is out of range");
        this[i] = value;
        return this.check();
    }
    addVectors(a, b) {
        return this.copy(a).add(b);
    }
    subVectors(a, b) {
        return this.copy(a).subtract(b);
    }
    multiplyVectors(a, b) {
        return this.copy(a).multiply(b);
    }
    addScaledVector(a, b) {
        return this.add(new this.constructor(a).multiplyScalar(b));
    }
}





function $68948bc2139893c7$export$185802fd694ee1f5() {
    var out = new $90626a8105199b14$export$b67359430d3b1b2(3);
    if ($90626a8105199b14$export$b67359430d3b1b2 != Float32Array) {
        out[0] = 0;
        out[1] = 0;
        out[2] = 0;
    }
    return out;
}
function $68948bc2139893c7$export$9cd59f9826255e47(a) {
    var out = new $90626a8105199b14$export$b67359430d3b1b2(3);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    return out;
}
function $68948bc2139893c7$export$f24224f1c91d8156(a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    return Math.hypot(x, y, z);
}
function $68948bc2139893c7$export$a82be99ed2a44a7d(x, y, z) {
    var out = new $90626a8105199b14$export$b67359430d3b1b2(3);
    out[0] = x;
    out[1] = y;
    out[2] = z;
    return out;
}
function $68948bc2139893c7$export$784d13d8ee351f07(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    return out;
}
function $68948bc2139893c7$export$adaa4cf7ef1b65be(out, x, y, z) {
    out[0] = x;
    out[1] = y;
    out[2] = z;
    return out;
}
function $68948bc2139893c7$export$e16d8520af44a096(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    return out;
}
function $68948bc2139893c7$export$4e2d2ead65e5f7e3(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    return out;
}
function $68948bc2139893c7$export$2060d2db72cce88f(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    out[2] = a[2] * b[2];
    return out;
}
function $68948bc2139893c7$export$cd007d971a5a2143(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    out[2] = a[2] / b[2];
    return out;
}
function $68948bc2139893c7$export$803ce6b71a0a94b2(out, a) {
    out[0] = Math.ceil(a[0]);
    out[1] = Math.ceil(a[1]);
    out[2] = Math.ceil(a[2]);
    return out;
}
function $68948bc2139893c7$export$a3fe094919f356fd(out, a) {
    out[0] = Math.floor(a[0]);
    out[1] = Math.floor(a[1]);
    out[2] = Math.floor(a[2]);
    return out;
}
function $68948bc2139893c7$export$96ec731ed4dcb222(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    out[2] = Math.min(a[2], b[2]);
    return out;
}
function $68948bc2139893c7$export$8960430cfd85939f(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    out[2] = Math.max(a[2], b[2]);
    return out;
}
function $68948bc2139893c7$export$2077e0241d6afd3c(out, a) {
    out[0] = Math.round(a[0]);
    out[1] = Math.round(a[1]);
    out[2] = Math.round(a[2]);
    return out;
}
function $68948bc2139893c7$export$dcdf75081b88279d(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    return out;
}
function $68948bc2139893c7$export$19cedf1da84ba854(out, a, b, scale1) {
    out[0] = a[0] + b[0] * scale1;
    out[1] = a[1] + b[1] * scale1;
    out[2] = a[2] + b[2] * scale1;
    return out;
}
function $68948bc2139893c7$export$9f17032d917177de(a, b) {
    var x = b[0] - a[0];
    var y = b[1] - a[1];
    var z = b[2] - a[2];
    return Math.hypot(x, y, z);
}
function $68948bc2139893c7$export$88e6ebb4fe54f538(a, b) {
    var x = b[0] - a[0];
    var y = b[1] - a[1];
    var z = b[2] - a[2];
    return x * x + y * y + z * z;
}
function $68948bc2139893c7$export$ab44e1323ffc8376(a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    return x * x + y * y + z * z;
}
function $68948bc2139893c7$export$aef51622e549b8b0(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    return out;
}
function $68948bc2139893c7$export$70ae2c07e401031b(out, a) {
    out[0] = 1.0 / a[0];
    out[1] = 1.0 / a[1];
    out[2] = 1.0 / a[2];
    return out;
}
function $68948bc2139893c7$export$a3295358bff77e(out, a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    var len1 = x * x + y * y + z * z;
    if (len1 > 0) //TODO: evaluate use of glm_invsqrt here?
    len1 = 1 / Math.sqrt(len1);
    out[0] = a[0] * len1;
    out[1] = a[1] * len1;
    out[2] = a[2] * len1;
    return out;
}
function $68948bc2139893c7$export$94132a0e348806d4(a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}
function $68948bc2139893c7$export$bb646b20bb93d339(out, a, b) {
    var ax = a[0], ay = a[1], az = a[2];
    var bx = b[0], by = b[1], bz = b[2];
    out[0] = ay * bz - az * by;
    out[1] = az * bx - ax * bz;
    out[2] = ax * by - ay * bx;
    return out;
}
function $68948bc2139893c7$export$3a89f8d6f6bf6c9f(out, a, b, t) {
    var ax = a[0];
    var ay = a[1];
    var az = a[2];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    out[2] = az + t * (b[2] - az);
    return out;
}
function $68948bc2139893c7$export$ae8865616f30561c(out, a, b, c, d, t) {
    var factorTimes2 = t * t;
    var factor1 = factorTimes2 * (2 * t - 3) + 1;
    var factor2 = factorTimes2 * (t - 2) + t;
    var factor3 = factorTimes2 * (t - 1);
    var factor4 = factorTimes2 * (3 - 2 * t);
    out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
    out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
    out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
    return out;
}
function $68948bc2139893c7$export$b9c5f84610baddaf(out, a, b, c, d, t) {
    var inverseFactor = 1 - t;
    var inverseFactorTimesTwo = inverseFactor * inverseFactor;
    var factorTimes2 = t * t;
    var factor1 = inverseFactorTimesTwo * inverseFactor;
    var factor2 = 3 * t * inverseFactorTimesTwo;
    var factor3 = 3 * factorTimes2 * inverseFactor;
    var factor4 = factorTimes2 * t;
    out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
    out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
    out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
    return out;
}
function $68948bc2139893c7$export$4385e60b38654f68(out, scale2) {
    scale2 = scale2 || 1.0;
    var r = $90626a8105199b14$export$5ada478c8a628231() * 2.0 * Math.PI;
    var z = $90626a8105199b14$export$5ada478c8a628231() * 2.0 - 1.0;
    var zScale = Math.sqrt(1.0 - z * z) * scale2;
    out[0] = Math.cos(r) * zScale;
    out[1] = Math.sin(r) * zScale;
    out[2] = z * scale2;
    return out;
}
function $68948bc2139893c7$export$5ffbd13800309d59(out, a, m) {
    var x = a[0], y = a[1], z = a[2];
    var w = m[3] * x + m[7] * y + m[11] * z + m[15];
    w = w || 1.0;
    out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
    out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
    out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
    return out;
}
function $68948bc2139893c7$export$f0bfa0a0024626ee(out, a, m) {
    var x = a[0], y = a[1], z = a[2];
    out[0] = x * m[0] + y * m[3] + z * m[6];
    out[1] = x * m[1] + y * m[4] + z * m[7];
    out[2] = x * m[2] + y * m[5] + z * m[8];
    return out;
}
function $68948bc2139893c7$export$c32adef9e939ce85(out, a, q) {
    // benchmarks: https://jsperf.com/quaternion-transform-vec3-implementations-fixed
    var qx = q[0], qy = q[1], qz = q[2], qw = q[3];
    var x = a[0], y = a[1], z = a[2]; // var qvec = [qx, qy, qz];
    // var uv = vec3.cross([], qvec, a);
    var uvx = qy * z - qz * y, uvy = qz * x - qx * z, uvz = qx * y - qy * x; // var uuv = vec3.cross([], qvec, uv);
    var uuvx = qy * uvz - qz * uvy, uuvy = qz * uvx - qx * uvz, uuvz = qx * uvy - qy * uvx; // vec3.scale(uv, uv, 2 * w);
    var w2 = qw * 2;
    uvx *= w2;
    uvy *= w2;
    uvz *= w2; // vec3.scale(uuv, uuv, 2);
    uuvx *= 2;
    uuvy *= 2;
    uuvz *= 2; // return vec3.add(out, a, vec3.add(out, uv, uuv));
    out[0] = x + uvx + uuvx;
    out[1] = y + uvy + uuvy;
    out[2] = z + uvz + uuvz;
    return out;
}
function $68948bc2139893c7$export$a59c8716592e09af(out, a, b, rad) {
    var p = [], r = []; //Translate point to the origin
    p[0] = a[0] - b[0];
    p[1] = a[1] - b[1];
    p[2] = a[2] - b[2]; //perform rotation
    r[0] = p[0];
    r[1] = p[1] * Math.cos(rad) - p[2] * Math.sin(rad);
    r[2] = p[1] * Math.sin(rad) + p[2] * Math.cos(rad); //translate to correct position
    out[0] = r[0] + b[0];
    out[1] = r[1] + b[1];
    out[2] = r[2] + b[2];
    return out;
}
function $68948bc2139893c7$export$cf71e4d4ca4d1cfd(out, a, b, rad) {
    var p = [], r = []; //Translate point to the origin
    p[0] = a[0] - b[0];
    p[1] = a[1] - b[1];
    p[2] = a[2] - b[2]; //perform rotation
    r[0] = p[2] * Math.sin(rad) + p[0] * Math.cos(rad);
    r[1] = p[1];
    r[2] = p[2] * Math.cos(rad) - p[0] * Math.sin(rad); //translate to correct position
    out[0] = r[0] + b[0];
    out[1] = r[1] + b[1];
    out[2] = r[2] + b[2];
    return out;
}
function $68948bc2139893c7$export$ea6eae3365de5b9c(out, a, b, rad) {
    var p = [], r = []; //Translate point to the origin
    p[0] = a[0] - b[0];
    p[1] = a[1] - b[1];
    p[2] = a[2] - b[2]; //perform rotation
    r[0] = p[0] * Math.cos(rad) - p[1] * Math.sin(rad);
    r[1] = p[0] * Math.sin(rad) + p[1] * Math.cos(rad);
    r[2] = p[2]; //translate to correct position
    out[0] = r[0] + b[0];
    out[1] = r[1] + b[1];
    out[2] = r[2] + b[2];
    return out;
}
function $68948bc2139893c7$export$944b09d2ad10b378(a, b) {
    var ax = a[0], ay = a[1], az = a[2], bx = b[0], by = b[1], bz = b[2], mag1 = Math.sqrt(ax * ax + ay * ay + az * az), mag2 = Math.sqrt(bx * bx + by * by + bz * bz), mag = mag1 * mag2, cosine = mag && $68948bc2139893c7$export$94132a0e348806d4(a, b) / mag;
    return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
function $68948bc2139893c7$export$7f9972325ebfd559(out) {
    out[0] = 0.0;
    out[1] = 0.0;
    out[2] = 0.0;
    return out;
}
function $68948bc2139893c7$export$42d51816ce590c93(a) {
    return "vec3(" + a[0] + ", " + a[1] + ", " + a[2] + ")";
}
function $68948bc2139893c7$export$f2599a5cf1109d8(a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
}
function $68948bc2139893c7$export$e9bab7fafb253603(a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2];
    var b0 = b[0], b1 = b[1], b2 = b[2];
    return Math.abs(a0 - b0) <= $90626a8105199b14$export$fd293b15f47e270 * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= $90626a8105199b14$export$fd293b15f47e270 * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= $90626a8105199b14$export$fd293b15f47e270 * Math.max(1.0, Math.abs(a2), Math.abs(b2));
}
var $68948bc2139893c7$export$f93b5905241a7cca = $68948bc2139893c7$export$4e2d2ead65e5f7e3;
var $68948bc2139893c7$export$6e3a27864ab166fe = $68948bc2139893c7$export$2060d2db72cce88f;
var $68948bc2139893c7$export$159d9494db57879b = $68948bc2139893c7$export$cd007d971a5a2143;
var $68948bc2139893c7$export$6c4a311cc157c764 = $68948bc2139893c7$export$9f17032d917177de;
var $68948bc2139893c7$export$2422cd6c492a8b3a = $68948bc2139893c7$export$88e6ebb4fe54f538;
var $68948bc2139893c7$export$fc1400facf92c78 = $68948bc2139893c7$export$f24224f1c91d8156;
var $68948bc2139893c7$export$99d8dd3f32a3435 = $68948bc2139893c7$export$ab44e1323ffc8376;
var $68948bc2139893c7$export$4b80e395e36b5a56 = function() {
    var vec = $68948bc2139893c7$export$185802fd694ee1f5();
    return function(a, stride, offset, count, fn, arg) {
        var i, l;
        if (!stride) stride = 3;
        if (!offset) offset = 0;
        if (count) l = Math.min(count * stride + offset, a.length);
        else l = a.length;
        for(i = offset; i < l; i += stride){
            vec[0] = a[i];
            vec[1] = a[i + 1];
            vec[2] = a[i + 2];
            fn(vec, vec, arg);
            a[i] = vec[0];
            a[i + 1] = vec[1];
            a[i + 2] = vec[2];
        }
        return a;
    };
}();


function $04a7f04ce3522ae0$export$9c22d6d462b57a6c(out, a, m) {
    const x = a[0];
    const y = a[1];
    const w = m[3] * x + m[7] * y || 1.0;
    out[0] = (m[0] * x + m[4] * y) / w;
    out[1] = (m[1] * x + m[5] * y) / w;
    return out;
}
function $04a7f04ce3522ae0$export$df62a5cc0f49271(out, a, m) {
    const x = a[0];
    const y = a[1];
    const z = a[2];
    const w = m[3] * x + m[7] * y + m[11] * z || 1.0;
    out[0] = (m[0] * x + m[4] * y + m[8] * z) / w;
    out[1] = (m[1] * x + m[5] * y + m[9] * z) / w;
    out[2] = (m[2] * x + m[6] * y + m[10] * z) / w;
    return out;
}
function $04a7f04ce3522ae0$export$1287c03b2c6fb6a5(out, a, m) {
    const x = a[0];
    const y = a[1];
    out[0] = m[0] * x + m[2] * y;
    out[1] = m[1] * x + m[3] * y;
    out[2] = a[2];
    return out;
}
function $04a7f04ce3522ae0$export$808cc2c9e882a204(out, a, m) {
    const x = a[0];
    const y = a[1];
    out[0] = m[0] * x + m[2] * y;
    out[1] = m[1] * x + m[3] * y;
    out[2] = a[2];
    out[3] = a[3];
    return out;
}
function $04a7f04ce3522ae0$export$bfe7f279eafb7f9b(out, a, m) {
    const x = a[0];
    const y = a[1];
    const z = a[2];
    out[0] = m[0] * x + m[3] * y + m[6] * z;
    out[1] = m[1] * x + m[4] * y + m[7] * z;
    out[2] = m[2] * x + m[5] * y + m[8] * z;
    out[3] = a[3];
    return out;
}


const $9c6695c39a874609$var$ORIGIN = [
    0,
    0,
    0
];
let $9c6695c39a874609$var$ZERO;
class $9c6695c39a874609$export$2e2bcd8739ae039 extends (0, $b690e88cf380b7fe$export$2e2bcd8739ae039) {
    static get ZERO() {
        if (!$9c6695c39a874609$var$ZERO) {
            $9c6695c39a874609$var$ZERO = new $9c6695c39a874609$export$2e2bcd8739ae039(0, 0, 0);
            Object.freeze($9c6695c39a874609$var$ZERO);
        }
        return $9c6695c39a874609$var$ZERO;
    }
    constructor(x = 0, y = 0, z = 0){
        super(-0, -0, -0);
        if (arguments.length === 1 && (0, $53a37c44451cea56$export$43bee75e5e14138e)(x)) this.copy(x);
        else {
            if ((0, $53a37c44451cea56$export$e506a1d27d1eaa20).debug) {
                (0, $c362065f7b29175e$export$74ff82ccb88f9fb1)(x);
                (0, $c362065f7b29175e$export$74ff82ccb88f9fb1)(y);
                (0, $c362065f7b29175e$export$74ff82ccb88f9fb1)(z);
            }
            this[0] = x;
            this[1] = y;
            this[2] = z;
        }
    }
    set(x, y, z) {
        this[0] = x;
        this[1] = y;
        this[2] = z;
        return this.check();
    }
    copy(array) {
        this[0] = array[0];
        this[1] = array[1];
        this[2] = array[2];
        return this.check();
    }
    fromObject(object) {
        if ((0, $53a37c44451cea56$export$e506a1d27d1eaa20).debug) {
            (0, $c362065f7b29175e$export$74ff82ccb88f9fb1)(object.x);
            (0, $c362065f7b29175e$export$74ff82ccb88f9fb1)(object.y);
            (0, $c362065f7b29175e$export$74ff82ccb88f9fb1)(object.z);
        }
        this[0] = object.x;
        this[1] = object.y;
        this[2] = object.z;
        return this.check();
    }
    toObject(object) {
        object.x = this[0];
        object.y = this[1];
        object.z = this[2];
        return object;
    }
    get ELEMENTS() {
        return 3;
    }
    get z() {
        return this[2];
    }
    set z(value) {
        this[2] = (0, $c362065f7b29175e$export$74ff82ccb88f9fb1)(value);
    }
    angle(vector) {
        return $68948bc2139893c7$export$944b09d2ad10b378(this, vector);
    }
    cross(vector) {
        $68948bc2139893c7$export$bb646b20bb93d339(this, this, vector);
        return this.check();
    }
    rotateX({ radians: radians , origin: origin = $9c6695c39a874609$var$ORIGIN  }) {
        $68948bc2139893c7$export$a59c8716592e09af(this, this, origin, radians);
        return this.check();
    }
    rotateY({ radians: radians , origin: origin = $9c6695c39a874609$var$ORIGIN  }) {
        $68948bc2139893c7$export$cf71e4d4ca4d1cfd(this, this, origin, radians);
        return this.check();
    }
    rotateZ({ radians: radians , origin: origin = $9c6695c39a874609$var$ORIGIN  }) {
        $68948bc2139893c7$export$ea6eae3365de5b9c(this, this, origin, radians);
        return this.check();
    }
    transform(matrix4) {
        return this.transformAsPoint(matrix4);
    }
    transformAsPoint(matrix4) {
        $68948bc2139893c7$export$5ffbd13800309d59(this, this, matrix4);
        return this.check();
    }
    transformAsVector(matrix4) {
        (0, $04a7f04ce3522ae0$export$df62a5cc0f49271)(this, this, matrix4);
        return this.check();
    }
    transformByMatrix3(matrix3) {
        $68948bc2139893c7$export$f0bfa0a0024626ee(this, this, matrix3);
        return this.check();
    }
    transformByMatrix2(matrix2) {
        (0, $04a7f04ce3522ae0$export$1287c03b2c6fb6a5)(this, this, matrix2);
        return this.check();
    }
    transformByQuaternion(quaternion) {
        $68948bc2139893c7$export$c32adef9e939ce85(this, this, quaternion);
        return this.check();
    }
}




class $cbe714f87587f435$export$2e2bcd8739ae039 extends (0, $99c41966f61b2e6e$export$2e2bcd8739ae039) {
    toString() {
        let string = "[";
        if ((0, $53a37c44451cea56$export$e506a1d27d1eaa20).printRowMajor) {
            string += "row-major:";
            for(let row = 0; row < this.RANK; ++row)for(let col = 0; col < this.RANK; ++col)string += " ".concat(this[col * this.RANK + row]);
        } else {
            string += "column-major:";
            for(let i = 0; i < this.ELEMENTS; ++i)string += " ".concat(this[i]);
        }
        string += "]";
        return string;
    }
    getElementIndex(row, col) {
        return col * this.RANK + row;
    }
    getElement(row, col) {
        return this[col * this.RANK + row];
    }
    setElement(row, col, value) {
        this[col * this.RANK + row] = (0, $c362065f7b29175e$export$74ff82ccb88f9fb1)(value);
        return this;
    }
    getColumn(columnIndex, result = new Array(this.RANK).fill(-0)) {
        const firstIndex = columnIndex * this.RANK;
        for(let i = 0; i < this.RANK; ++i)result[i] = this[firstIndex + i];
        return result;
    }
    setColumn(columnIndex, columnVector) {
        const firstIndex = columnIndex * this.RANK;
        for(let i = 0; i < this.RANK; ++i)this[firstIndex + i] = columnVector[i];
        return this;
    }
}






function $fceb3370258170b6$export$185802fd694ee1f5() {
    var out = new $90626a8105199b14$export$b67359430d3b1b2(2);
    if ($90626a8105199b14$export$b67359430d3b1b2 != Float32Array) {
        out[0] = 0;
        out[1] = 0;
    }
    return out;
}
function $fceb3370258170b6$export$9cd59f9826255e47(a) {
    var out = new $90626a8105199b14$export$b67359430d3b1b2(2);
    out[0] = a[0];
    out[1] = a[1];
    return out;
}
function $fceb3370258170b6$export$a82be99ed2a44a7d(x, y) {
    var out = new $90626a8105199b14$export$b67359430d3b1b2(2);
    out[0] = x;
    out[1] = y;
    return out;
}
function $fceb3370258170b6$export$784d13d8ee351f07(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    return out;
}
function $fceb3370258170b6$export$adaa4cf7ef1b65be(out, x, y) {
    out[0] = x;
    out[1] = y;
    return out;
}
function $fceb3370258170b6$export$e16d8520af44a096(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    return out;
}
function $fceb3370258170b6$export$4e2d2ead65e5f7e3(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    return out;
}
function $fceb3370258170b6$export$2060d2db72cce88f(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    return out;
}
function $fceb3370258170b6$export$cd007d971a5a2143(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    return out;
}
function $fceb3370258170b6$export$803ce6b71a0a94b2(out, a) {
    out[0] = Math.ceil(a[0]);
    out[1] = Math.ceil(a[1]);
    return out;
}
function $fceb3370258170b6$export$a3fe094919f356fd(out, a) {
    out[0] = Math.floor(a[0]);
    out[1] = Math.floor(a[1]);
    return out;
}
function $fceb3370258170b6$export$96ec731ed4dcb222(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    return out;
}
function $fceb3370258170b6$export$8960430cfd85939f(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    return out;
}
function $fceb3370258170b6$export$2077e0241d6afd3c(out, a) {
    out[0] = Math.round(a[0]);
    out[1] = Math.round(a[1]);
    return out;
}
function $fceb3370258170b6$export$dcdf75081b88279d(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    return out;
}
function $fceb3370258170b6$export$19cedf1da84ba854(out, a, b, scale1) {
    out[0] = a[0] + b[0] * scale1;
    out[1] = a[1] + b[1] * scale1;
    return out;
}
function $fceb3370258170b6$export$9f17032d917177de(a, b) {
    var x = b[0] - a[0], y = b[1] - a[1];
    return Math.hypot(x, y);
}
function $fceb3370258170b6$export$88e6ebb4fe54f538(a, b) {
    var x = b[0] - a[0], y = b[1] - a[1];
    return x * x + y * y;
}
function $fceb3370258170b6$export$f24224f1c91d8156(a) {
    var x = a[0], y = a[1];
    return Math.hypot(x, y);
}
function $fceb3370258170b6$export$ab44e1323ffc8376(a) {
    var x = a[0], y = a[1];
    return x * x + y * y;
}
function $fceb3370258170b6$export$aef51622e549b8b0(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    return out;
}
function $fceb3370258170b6$export$70ae2c07e401031b(out, a) {
    out[0] = 1.0 / a[0];
    out[1] = 1.0 / a[1];
    return out;
}
function $fceb3370258170b6$export$a3295358bff77e(out, a) {
    var x = a[0], y = a[1];
    var len1 = x * x + y * y;
    if (len1 > 0) //TODO: evaluate use of glm_invsqrt here?
    len1 = 1 / Math.sqrt(len1);
    out[0] = a[0] * len1;
    out[1] = a[1] * len1;
    return out;
}
function $fceb3370258170b6$export$94132a0e348806d4(a, b) {
    return a[0] * b[0] + a[1] * b[1];
}
function $fceb3370258170b6$export$bb646b20bb93d339(out, a, b) {
    var z = a[0] * b[1] - a[1] * b[0];
    out[0] = out[1] = 0;
    out[2] = z;
    return out;
}
function $fceb3370258170b6$export$3a89f8d6f6bf6c9f(out, a, b, t) {
    var ax = a[0], ay = a[1];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    return out;
}
function $fceb3370258170b6$export$4385e60b38654f68(out, scale2) {
    scale2 = scale2 || 1.0;
    var r = $90626a8105199b14$export$5ada478c8a628231() * 2.0 * Math.PI;
    out[0] = Math.cos(r) * scale2;
    out[1] = Math.sin(r) * scale2;
    return out;
}
function $fceb3370258170b6$export$b732428d73874bfc(out, a, m) {
    var x = a[0], y = a[1];
    out[0] = m[0] * x + m[2] * y;
    out[1] = m[1] * x + m[3] * y;
    return out;
}
function $fceb3370258170b6$export$3e55bc4b3707dfd3(out, a, m) {
    var x = a[0], y = a[1];
    out[0] = m[0] * x + m[2] * y + m[4];
    out[1] = m[1] * x + m[3] * y + m[5];
    return out;
}
function $fceb3370258170b6$export$f0bfa0a0024626ee(out, a, m) {
    var x = a[0], y = a[1];
    out[0] = m[0] * x + m[3] * y + m[6];
    out[1] = m[1] * x + m[4] * y + m[7];
    return out;
}
function $fceb3370258170b6$export$5ffbd13800309d59(out, a, m) {
    var x = a[0];
    var y = a[1];
    out[0] = m[0] * x + m[4] * y + m[12];
    out[1] = m[1] * x + m[5] * y + m[13];
    return out;
}
function $fceb3370258170b6$export$bb628a54ab399bc9(out, a, b, rad) {
    //Translate point to the origin
    var p0 = a[0] - b[0], p1 = a[1] - b[1], sinC = Math.sin(rad), cosC = Math.cos(rad); //perform rotation and translate to correct position
    out[0] = p0 * cosC - p1 * sinC + b[0];
    out[1] = p0 * sinC + p1 * cosC + b[1];
    return out;
}
function $fceb3370258170b6$export$944b09d2ad10b378(a, b) {
    var x1 = a[0], y1 = a[1], x2 = b[0], y2 = b[1], // mag is the product of the magnitudes of a and b
    mag = Math.sqrt(x1 * x1 + y1 * y1) * Math.sqrt(x2 * x2 + y2 * y2), // mag &&.. short circuits if mag == 0
    cosine = mag && (x1 * x2 + y1 * y2) / mag; // Math.min(Math.max(cosine, -1), 1) clamps the cosine between -1 and 1
    return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
function $fceb3370258170b6$export$7f9972325ebfd559(out) {
    out[0] = 0.0;
    out[1] = 0.0;
    return out;
}
function $fceb3370258170b6$export$42d51816ce590c93(a) {
    return "vec2(" + a[0] + ", " + a[1] + ")";
}
function $fceb3370258170b6$export$f2599a5cf1109d8(a, b) {
    return a[0] === b[0] && a[1] === b[1];
}
function $fceb3370258170b6$export$e9bab7fafb253603(a, b) {
    var a0 = a[0], a1 = a[1];
    var b0 = b[0], b1 = b[1];
    return Math.abs(a0 - b0) <= $90626a8105199b14$export$fd293b15f47e270 * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= $90626a8105199b14$export$fd293b15f47e270 * Math.max(1.0, Math.abs(a1), Math.abs(b1));
}
var $fceb3370258170b6$export$fc1400facf92c78 = $fceb3370258170b6$export$f24224f1c91d8156;
var $fceb3370258170b6$export$f93b5905241a7cca = $fceb3370258170b6$export$4e2d2ead65e5f7e3;
var $fceb3370258170b6$export$6e3a27864ab166fe = $fceb3370258170b6$export$2060d2db72cce88f;
var $fceb3370258170b6$export$159d9494db57879b = $fceb3370258170b6$export$cd007d971a5a2143;
var $fceb3370258170b6$export$6c4a311cc157c764 = $fceb3370258170b6$export$9f17032d917177de;
var $fceb3370258170b6$export$2422cd6c492a8b3a = $fceb3370258170b6$export$88e6ebb4fe54f538;
var $fceb3370258170b6$export$99d8dd3f32a3435 = $fceb3370258170b6$export$ab44e1323ffc8376;
var $fceb3370258170b6$export$4b80e395e36b5a56 = function() {
    var vec = $fceb3370258170b6$export$185802fd694ee1f5();
    return function(a, stride, offset, count, fn, arg) {
        var i, l;
        if (!stride) stride = 2;
        if (!offset) offset = 0;
        if (count) l = Math.min(count * stride + offset, a.length);
        else l = a.length;
        for(i = offset; i < l; i += stride){
            vec[0] = a[i];
            vec[1] = a[i + 1];
            fn(vec, vec, arg);
            a[i] = vec[0];
            a[i + 1] = vec[1];
        }
        return a;
    };
}();




var $16800f0dff513c4e$var$INDICES;
(function(INDICES1) {
    INDICES1[INDICES1["COL0ROW0"] = 0] = "COL0ROW0";
    INDICES1[INDICES1["COL0ROW1"] = 1] = "COL0ROW1";
    INDICES1[INDICES1["COL0ROW2"] = 2] = "COL0ROW2";
    INDICES1[INDICES1["COL0ROW3"] = 3] = "COL0ROW3";
    INDICES1[INDICES1["COL1ROW0"] = 4] = "COL1ROW0";
    INDICES1[INDICES1["COL1ROW1"] = 5] = "COL1ROW1";
    INDICES1[INDICES1["COL1ROW2"] = 6] = "COL1ROW2";
    INDICES1[INDICES1["COL1ROW3"] = 7] = "COL1ROW3";
    INDICES1[INDICES1["COL2ROW0"] = 8] = "COL2ROW0";
    INDICES1[INDICES1["COL2ROW1"] = 9] = "COL2ROW1";
    INDICES1[INDICES1["COL2ROW2"] = 10] = "COL2ROW2";
    INDICES1[INDICES1["COL2ROW3"] = 11] = "COL2ROW3";
    INDICES1[INDICES1["COL3ROW0"] = 12] = "COL3ROW0";
    INDICES1[INDICES1["COL3ROW1"] = 13] = "COL3ROW1";
    INDICES1[INDICES1["COL3ROW2"] = 14] = "COL3ROW2";
    INDICES1[INDICES1["COL3ROW3"] = 15] = "COL3ROW3";
})($16800f0dff513c4e$var$INDICES || ($16800f0dff513c4e$var$INDICES = {}));
const $16800f0dff513c4e$var$DEFAULT_FOVY = 45 * Math.PI / 180;
const $16800f0dff513c4e$var$DEFAULT_ASPECT = 1;
const $16800f0dff513c4e$var$DEFAULT_NEAR = 0.1;
const $16800f0dff513c4e$var$DEFAULT_FAR = 500;
const $16800f0dff513c4e$var$IDENTITY_MATRIX = Object.freeze([
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    1
]);
class $16800f0dff513c4e$export$2e2bcd8739ae039 extends (0, $cbe714f87587f435$export$2e2bcd8739ae039) {
    static get IDENTITY() {
        return $16800f0dff513c4e$var$getIdentityMatrix();
    }
    static get ZERO() {
        return $16800f0dff513c4e$var$getZeroMatrix();
    }
    get ELEMENTS() {
        return 16;
    }
    get RANK() {
        return 4;
    }
    get INDICES() {
        return $16800f0dff513c4e$var$INDICES;
    }
    constructor(array){
        super(-0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0);
        if (arguments.length === 1 && Array.isArray(array)) this.copy(array);
        else this.identity();
    }
    copy(array) {
        this[0] = array[0];
        this[1] = array[1];
        this[2] = array[2];
        this[3] = array[3];
        this[4] = array[4];
        this[5] = array[5];
        this[6] = array[6];
        this[7] = array[7];
        this[8] = array[8];
        this[9] = array[9];
        this[10] = array[10];
        this[11] = array[11];
        this[12] = array[12];
        this[13] = array[13];
        this[14] = array[14];
        this[15] = array[15];
        return this.check();
    }
    set(m00, m10, m20, m30, m01, m11, m21, m31, m02, m12, m22, m32, m03, m13, m23, m33) {
        this[0] = m00;
        this[1] = m10;
        this[2] = m20;
        this[3] = m30;
        this[4] = m01;
        this[5] = m11;
        this[6] = m21;
        this[7] = m31;
        this[8] = m02;
        this[9] = m12;
        this[10] = m22;
        this[11] = m32;
        this[12] = m03;
        this[13] = m13;
        this[14] = m23;
        this[15] = m33;
        return this.check();
    }
    setRowMajor(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
        this[0] = m00;
        this[1] = m10;
        this[2] = m20;
        this[3] = m30;
        this[4] = m01;
        this[5] = m11;
        this[6] = m21;
        this[7] = m31;
        this[8] = m02;
        this[9] = m12;
        this[10] = m22;
        this[11] = m32;
        this[12] = m03;
        this[13] = m13;
        this[14] = m23;
        this[15] = m33;
        return this.check();
    }
    toRowMajor(result) {
        result[0] = this[0];
        result[1] = this[4];
        result[2] = this[8];
        result[3] = this[12];
        result[4] = this[1];
        result[5] = this[5];
        result[6] = this[9];
        result[7] = this[13];
        result[8] = this[2];
        result[9] = this[6];
        result[10] = this[10];
        result[11] = this[14];
        result[12] = this[3];
        result[13] = this[7];
        result[14] = this[11];
        result[15] = this[15];
        return result;
    }
    identity() {
        return this.copy($16800f0dff513c4e$var$IDENTITY_MATRIX);
    }
    fromObject(object) {
        return this.check();
    }
    fromQuaternion(quaternion) {
        $46ec5f9ed0e75076$export$2ff2bbe382249af7(this, quaternion);
        return this.check();
    }
    frustum(view) {
        const { left: left , right: right , bottom: bottom , top: top , near: near = $16800f0dff513c4e$var$DEFAULT_NEAR , far: far = $16800f0dff513c4e$var$DEFAULT_FAR  } = view;
        if (far === Infinity) $16800f0dff513c4e$var$computeInfinitePerspectiveOffCenter(this, left, right, bottom, top, near);
        else $46ec5f9ed0e75076$export$89b5708c387cac6c(this, left, right, bottom, top, near, far);
        return this.check();
    }
    lookAt(view) {
        const { eye: eye , center: center = [
            0,
            0,
            0
        ] , up: up = [
            0,
            1,
            0
        ]  } = view;
        $46ec5f9ed0e75076$export$d924e14fd6d9aa66(this, eye, center, up);
        return this.check();
    }
    ortho(view) {
        const { left: left , right: right , bottom: bottom , top: top , near: near = $16800f0dff513c4e$var$DEFAULT_NEAR , far: far = $16800f0dff513c4e$var$DEFAULT_FAR  } = view;
        $46ec5f9ed0e75076$export$4f2167e613cfc87b(this, left, right, bottom, top, near, far);
        return this.check();
    }
    orthographic(view) {
        const { fovy: fovy = $16800f0dff513c4e$var$DEFAULT_FOVY , aspect: aspect = $16800f0dff513c4e$var$DEFAULT_ASPECT , focalDistance: focalDistance = 1 , near: near = $16800f0dff513c4e$var$DEFAULT_NEAR , far: far = $16800f0dff513c4e$var$DEFAULT_FAR  } = view;
        $16800f0dff513c4e$var$checkRadians(fovy);
        const halfY = fovy / 2;
        const top = focalDistance * Math.tan(halfY);
        const right = top * aspect;
        return this.ortho({
            left: -right,
            right: right,
            bottom: -top,
            top: top,
            near: near,
            far: far
        });
    }
    perspective(view) {
        const { fovy: fovy = 45 * Math.PI / 180 , aspect: aspect = 1 , near: near = 0.1 , far: far = 500  } = view;
        $16800f0dff513c4e$var$checkRadians(fovy);
        $46ec5f9ed0e75076$export$541149539f3a4684(this, fovy, aspect, near, far);
        return this.check();
    }
    determinant() {
        return $46ec5f9ed0e75076$export$a04698f914c55ed9(this);
    }
    getScale(result = [
        -0,
        -0,
        -0
    ]) {
        result[0] = Math.sqrt(this[0] * this[0] + this[1] * this[1] + this[2] * this[2]);
        result[1] = Math.sqrt(this[4] * this[4] + this[5] * this[5] + this[6] * this[6]);
        result[2] = Math.sqrt(this[8] * this[8] + this[9] * this[9] + this[10] * this[10]);
        return result;
    }
    getTranslation(result = [
        -0,
        -0,
        -0
    ]) {
        result[0] = this[12];
        result[1] = this[13];
        result[2] = this[14];
        return result;
    }
    getRotation(result, scaleResult) {
        result = result || [
            -0,
            -0,
            -0,
            -0,
            -0,
            -0,
            -0,
            -0,
            -0,
            -0,
            -0,
            -0,
            -0,
            -0,
            -0,
            -0
        ];
        scaleResult = scaleResult || [
            -0,
            -0,
            -0
        ];
        const scale = this.getScale(scaleResult);
        const inverseScale0 = 1 / scale[0];
        const inverseScale1 = 1 / scale[1];
        const inverseScale2 = 1 / scale[2];
        result[0] = this[0] * inverseScale0;
        result[1] = this[1] * inverseScale1;
        result[2] = this[2] * inverseScale2;
        result[3] = 0;
        result[4] = this[4] * inverseScale0;
        result[5] = this[5] * inverseScale1;
        result[6] = this[6] * inverseScale2;
        result[7] = 0;
        result[8] = this[8] * inverseScale0;
        result[9] = this[9] * inverseScale1;
        result[10] = this[10] * inverseScale2;
        result[11] = 0;
        result[12] = 0;
        result[13] = 0;
        result[14] = 0;
        result[15] = 1;
        return result;
    }
    getRotationMatrix3(result, scaleResult) {
        result = result || [
            -0,
            -0,
            -0,
            -0,
            -0,
            -0,
            -0,
            -0,
            -0
        ];
        scaleResult = scaleResult || [
            -0,
            -0,
            -0
        ];
        const scale = this.getScale(scaleResult);
        const inverseScale0 = 1 / scale[0];
        const inverseScale1 = 1 / scale[1];
        const inverseScale2 = 1 / scale[2];
        result[0] = this[0] * inverseScale0;
        result[1] = this[1] * inverseScale1;
        result[2] = this[2] * inverseScale2;
        result[3] = this[4] * inverseScale0;
        result[4] = this[5] * inverseScale1;
        result[5] = this[6] * inverseScale2;
        result[6] = this[8] * inverseScale0;
        result[7] = this[9] * inverseScale1;
        result[8] = this[10] * inverseScale2;
        return result;
    }
    transpose() {
        $46ec5f9ed0e75076$export$9cb09a71b7d66923(this, this);
        return this.check();
    }
    invert() {
        $46ec5f9ed0e75076$export$6897c284b6f9f4dc(this, this);
        return this.check();
    }
    multiplyLeft(a) {
        $46ec5f9ed0e75076$export$2060d2db72cce88f(this, a, this);
        return this.check();
    }
    multiplyRight(a) {
        $46ec5f9ed0e75076$export$2060d2db72cce88f(this, this, a);
        return this.check();
    }
    rotateX(radians) {
        $46ec5f9ed0e75076$export$a59c8716592e09af(this, this, radians);
        return this.check();
    }
    rotateY(radians) {
        $46ec5f9ed0e75076$export$cf71e4d4ca4d1cfd(this, this, radians);
        return this.check();
    }
    rotateZ(radians) {
        $46ec5f9ed0e75076$export$ea6eae3365de5b9c(this, this, radians);
        return this.check();
    }
    rotateXYZ(angleXYZ) {
        return this.rotateX(angleXYZ[0]).rotateY(angleXYZ[1]).rotateZ(angleXYZ[2]);
    }
    rotateAxis(radians, axis) {
        $46ec5f9ed0e75076$export$bb628a54ab399bc9(this, this, radians, axis);
        return this.check();
    }
    scale(factor) {
        $46ec5f9ed0e75076$export$dcdf75081b88279d(this, this, Array.isArray(factor) ? factor : [
            factor,
            factor,
            factor
        ]);
        return this.check();
    }
    translate(vector) {
        $46ec5f9ed0e75076$export$d73ee8ef04f5226a(this, this, vector);
        return this.check();
    }
    transform(vector, result) {
        if (vector.length === 4) {
            result = $bd1e837fe7e33410$export$5ffbd13800309d59(result || [
                -0,
                -0,
                -0,
                -0
            ], vector, this);
            (0, $c362065f7b29175e$export$3eb62eb6ef90f888)(result, 4);
            return result;
        }
        return this.transformAsPoint(vector, result);
    }
    transformAsPoint(vector, result) {
        const { length: length  } = vector;
        let out;
        switch(length){
            case 2:
                out = $fceb3370258170b6$export$5ffbd13800309d59(result || [
                    -0,
                    -0
                ], vector, this);
                break;
            case 3:
                out = $68948bc2139893c7$export$5ffbd13800309d59(result || [
                    -0,
                    -0,
                    -0
                ], vector, this);
                break;
            default:
                throw new Error("Illegal vector");
        }
        (0, $c362065f7b29175e$export$3eb62eb6ef90f888)(out, vector.length);
        return out;
    }
    transformAsVector(vector, result) {
        let out;
        switch(vector.length){
            case 2:
                out = (0, $04a7f04ce3522ae0$export$9c22d6d462b57a6c)(result || [
                    -0,
                    -0
                ], vector, this);
                break;
            case 3:
                out = (0, $04a7f04ce3522ae0$export$df62a5cc0f49271)(result || [
                    -0,
                    -0,
                    -0
                ], vector, this);
                break;
            default:
                throw new Error("Illegal vector");
        }
        (0, $c362065f7b29175e$export$3eb62eb6ef90f888)(out, vector.length);
        return out;
    }
    transformPoint(vector, result) {
        return this.transformAsPoint(vector, result);
    }
    transformVector(vector, result) {
        return this.transformAsPoint(vector, result);
    }
    transformDirection(vector, result) {
        return this.transformAsVector(vector, result);
    }
    makeRotationX(radians) {
        return this.identity().rotateX(radians);
    }
    makeTranslation(x, y, z) {
        return this.identity().translate([
            x,
            y,
            z
        ]);
    }
}
let $16800f0dff513c4e$var$ZERO;
let $16800f0dff513c4e$var$IDENTITY;
function $16800f0dff513c4e$var$getZeroMatrix() {
    if (!$16800f0dff513c4e$var$ZERO) {
        $16800f0dff513c4e$var$ZERO = new $16800f0dff513c4e$export$2e2bcd8739ae039([
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]);
        Object.freeze($16800f0dff513c4e$var$ZERO);
    }
    return $16800f0dff513c4e$var$ZERO;
}
function $16800f0dff513c4e$var$getIdentityMatrix() {
    if (!$16800f0dff513c4e$var$IDENTITY) {
        $16800f0dff513c4e$var$IDENTITY = new $16800f0dff513c4e$export$2e2bcd8739ae039();
        Object.freeze($16800f0dff513c4e$var$IDENTITY);
    }
    return $16800f0dff513c4e$var$IDENTITY;
}
function $16800f0dff513c4e$var$checkRadians(possiblyDegrees) {
    if (possiblyDegrees > Math.PI * 2) throw Error("expected radians");
}
function $16800f0dff513c4e$var$computeInfinitePerspectiveOffCenter(result, left, right, bottom, top, near) {
    const column0Row0 = 2 * near / (right - left);
    const column1Row1 = 2 * near / (top - bottom);
    const column2Row0 = (right + left) / (right - left);
    const column2Row1 = (top + bottom) / (top - bottom);
    const column2Row2 = -1;
    const column2Row3 = -1;
    const column3Row2 = -2 * near;
    result[0] = column0Row0;
    result[1] = 0;
    result[2] = 0;
    result[3] = 0;
    result[4] = 0;
    result[5] = column1Row1;
    result[6] = 0;
    result[7] = 0;
    result[8] = column2Row0;
    result[9] = column2Row1;
    result[10] = column2Row2;
    result[11] = column2Row3;
    result[12] = 0;
    result[13] = 0;
    result[14] = column3Row2;
    result[15] = 0;
    return result;
}



function $97790275b37bd567$export$1a9a28cade4dcdc4() {
    return [
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1
    ];
}
function $97790275b37bd567$export$842a2cf37af977e1(value, divisor) {
    const modulus = value % divisor;
    return modulus < 0 ? divisor + modulus : modulus;
}
function $97790275b37bd567$export$f411fdc3e02e158b(viewMatrixInverse) {
    return [
        viewMatrixInverse[12],
        viewMatrixInverse[13],
        viewMatrixInverse[14]
    ];
}
function $97790275b37bd567$export$7fd6193a8fe6de4e(viewProjectionMatrix) {
    return {
        left: $97790275b37bd567$var$getFrustumPlane(viewProjectionMatrix[3] + viewProjectionMatrix[0], viewProjectionMatrix[7] + viewProjectionMatrix[4], viewProjectionMatrix[11] + viewProjectionMatrix[8], viewProjectionMatrix[15] + viewProjectionMatrix[12]),
        right: $97790275b37bd567$var$getFrustumPlane(viewProjectionMatrix[3] - viewProjectionMatrix[0], viewProjectionMatrix[7] - viewProjectionMatrix[4], viewProjectionMatrix[11] - viewProjectionMatrix[8], viewProjectionMatrix[15] - viewProjectionMatrix[12]),
        bottom: $97790275b37bd567$var$getFrustumPlane(viewProjectionMatrix[3] + viewProjectionMatrix[1], viewProjectionMatrix[7] + viewProjectionMatrix[5], viewProjectionMatrix[11] + viewProjectionMatrix[9], viewProjectionMatrix[15] + viewProjectionMatrix[13]),
        top: $97790275b37bd567$var$getFrustumPlane(viewProjectionMatrix[3] - viewProjectionMatrix[1], viewProjectionMatrix[7] - viewProjectionMatrix[5], viewProjectionMatrix[11] - viewProjectionMatrix[9], viewProjectionMatrix[15] - viewProjectionMatrix[13]),
        near: $97790275b37bd567$var$getFrustumPlane(viewProjectionMatrix[3] + viewProjectionMatrix[2], viewProjectionMatrix[7] + viewProjectionMatrix[6], viewProjectionMatrix[11] + viewProjectionMatrix[10], viewProjectionMatrix[15] + viewProjectionMatrix[14]),
        far: $97790275b37bd567$var$getFrustumPlane(viewProjectionMatrix[3] - viewProjectionMatrix[2], viewProjectionMatrix[7] - viewProjectionMatrix[6], viewProjectionMatrix[11] - viewProjectionMatrix[10], viewProjectionMatrix[15] - viewProjectionMatrix[14])
    };
}
const $97790275b37bd567$var$scratchVector = new (0, $9c6695c39a874609$export$2e2bcd8739ae039)();
function $97790275b37bd567$var$getFrustumPlane(a, b, c, d) {
    $97790275b37bd567$var$scratchVector.set(a, b, c);
    const L = $97790275b37bd567$var$scratchVector.len();
    return {
        distance: d / L,
        normal: new (0, $9c6695c39a874609$export$2e2bcd8739ae039)(-a / L, -b / L, -c / L)
    };
}
function $97790275b37bd567$export$4e5285c56a99f06d(x) {
    return x - Math.fround(x);
}
let $97790275b37bd567$var$scratchArray;
function $97790275b37bd567$export$550bd089be4eedcb(typedArray, options) {
    const { size: size = 1 , startIndex: startIndex = 0  } = options;
    const endIndex = options.endIndex !== undefined ? options.endIndex : typedArray.length;
    const count = (endIndex - startIndex) / size;
    $97790275b37bd567$var$scratchArray = (0, $e0cd51e92519f55c$export$2e2bcd8739ae039).allocate($97790275b37bd567$var$scratchArray, count, {
        type: Float32Array,
        size: size * 2
    });
    let sourceIndex = startIndex;
    let targetIndex = 0;
    while(sourceIndex < endIndex){
        for(let j = 0; j < size; j++){
            const value = typedArray[sourceIndex++];
            $97790275b37bd567$var$scratchArray[targetIndex + j] = value;
            $97790275b37bd567$var$scratchArray[targetIndex + j + size] = $97790275b37bd567$export$4e5285c56a99f06d(value);
        }
        targetIndex += size * 2;
    }
    return $97790275b37bd567$var$scratchArray.subarray(0, count * size * 2);
}






function $8ff31ed396c58e4f$export$1a9a28cade4dcdc4() {
    return [
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1
    ];
}
function $8ff31ed396c58e4f$export$8248199402822036(matrix, vector) {
    const result = (0, $bd1e837fe7e33410$export$5ffbd13800309d59)([], vector, matrix);
    (0, $bd1e837fe7e33410$export$dcdf75081b88279d)(result, result, 1 / result[3]);
    return result;
}
function $8ff31ed396c58e4f$export$842a2cf37af977e1(value, divisor) {
    const modulus = value % divisor;
    return modulus < 0 ? divisor + modulus : modulus;
}
function $8ff31ed396c58e4f$export$3a89f8d6f6bf6c9f(start, end, step) {
    return step * end + (1 - step) * start;
}
function $8ff31ed396c58e4f$export$7d15b64cf5a3a4c4(x, min, max) {
    return x < min ? min : x > max ? max : x;
}
function $8ff31ed396c58e4f$var$ieLog2(x) {
    return Math.log(x) * Math.LOG2E;
}
const $8ff31ed396c58e4f$export$b9fae0bba9d9094d = Math.log2 || $8ff31ed396c58e4f$var$ieLog2;






function $b721105c5eaabf93$export$2e2bcd8739ae039(condition, message) {
    if (!condition) throw new Error(message || "@math.gl/web-mercator: assertion failed.");
}


const $f5ef504cb5091e21$var$PI = Math.PI;
const $f5ef504cb5091e21$var$PI_4 = $f5ef504cb5091e21$var$PI / 4;
const $f5ef504cb5091e21$var$DEGREES_TO_RADIANS = $f5ef504cb5091e21$var$PI / 180;
const $f5ef504cb5091e21$var$RADIANS_TO_DEGREES = 180 / $f5ef504cb5091e21$var$PI;
const $f5ef504cb5091e21$var$TILE_SIZE = 512;
const $f5ef504cb5091e21$var$EARTH_CIRCUMFERENCE = 40.03e6;
const $f5ef504cb5091e21$export$6872bd9851469b83 = 85.051129;
const $f5ef504cb5091e21$export$c10d0dffa5af045 = 1.5;
function $f5ef504cb5091e21$export$eda81de7742ad8e7(zoom) {
    return Math.pow(2, zoom);
}
function $f5ef504cb5091e21$export$6e08c044660f3e30(scale) {
    return (0, $8ff31ed396c58e4f$export$b9fae0bba9d9094d)(scale);
}
function $f5ef504cb5091e21$export$4a0e8ea52607cc9b(lngLat) {
    const [lng, lat] = lngLat;
    (0, $b721105c5eaabf93$export$2e2bcd8739ae039)(Number.isFinite(lng));
    (0, $b721105c5eaabf93$export$2e2bcd8739ae039)(Number.isFinite(lat) && lat >= -90 && lat <= 90, "invalid latitude");
    const lambda2 = lng * $f5ef504cb5091e21$var$DEGREES_TO_RADIANS;
    const phi2 = lat * $f5ef504cb5091e21$var$DEGREES_TO_RADIANS;
    const x = $f5ef504cb5091e21$var$TILE_SIZE * (lambda2 + $f5ef504cb5091e21$var$PI) / (2 * $f5ef504cb5091e21$var$PI);
    const y = $f5ef504cb5091e21$var$TILE_SIZE * ($f5ef504cb5091e21$var$PI + Math.log(Math.tan($f5ef504cb5091e21$var$PI_4 + phi2 * 0.5))) / (2 * $f5ef504cb5091e21$var$PI);
    return [
        x,
        y
    ];
}
function $f5ef504cb5091e21$export$66ee0abd8a6a9660(xy) {
    const [x, y] = xy;
    const lambda2 = x / $f5ef504cb5091e21$var$TILE_SIZE * (2 * $f5ef504cb5091e21$var$PI) - $f5ef504cb5091e21$var$PI;
    const phi2 = 2 * (Math.atan(Math.exp(y / $f5ef504cb5091e21$var$TILE_SIZE * (2 * $f5ef504cb5091e21$var$PI) - $f5ef504cb5091e21$var$PI)) - $f5ef504cb5091e21$var$PI_4);
    return [
        lambda2 * $f5ef504cb5091e21$var$RADIANS_TO_DEGREES,
        phi2 * $f5ef504cb5091e21$var$RADIANS_TO_DEGREES
    ];
}
function $f5ef504cb5091e21$export$f4aaab1d865abddd(options) {
    const { latitude: latitude  } = options;
    (0, $b721105c5eaabf93$export$2e2bcd8739ae039)(Number.isFinite(latitude));
    const latCosine = Math.cos(latitude * $f5ef504cb5091e21$var$DEGREES_TO_RADIANS);
    return $f5ef504cb5091e21$export$6e08c044660f3e30($f5ef504cb5091e21$var$EARTH_CIRCUMFERENCE * latCosine) - 9;
}
function $f5ef504cb5091e21$export$de3bf8f403bfc548(latitude) {
    const latCosine = Math.cos(latitude * $f5ef504cb5091e21$var$DEGREES_TO_RADIANS);
    return $f5ef504cb5091e21$var$TILE_SIZE / $f5ef504cb5091e21$var$EARTH_CIRCUMFERENCE / latCosine;
}
function $f5ef504cb5091e21$export$14a522c4e7772100(options) {
    const { latitude: latitude , longitude: longitude , highPrecision: highPrecision = false  } = options;
    (0, $b721105c5eaabf93$export$2e2bcd8739ae039)(Number.isFinite(latitude) && Number.isFinite(longitude));
    const worldSize = $f5ef504cb5091e21$var$TILE_SIZE;
    const latCosine = Math.cos(latitude * $f5ef504cb5091e21$var$DEGREES_TO_RADIANS);
    const unitsPerDegreeX = worldSize / 360;
    const unitsPerDegreeY = unitsPerDegreeX / latCosine;
    const altUnitsPerMeter = worldSize / $f5ef504cb5091e21$var$EARTH_CIRCUMFERENCE / latCosine;
    const result = {
        unitsPerMeter: [
            altUnitsPerMeter,
            altUnitsPerMeter,
            altUnitsPerMeter
        ],
        metersPerUnit: [
            1 / altUnitsPerMeter,
            1 / altUnitsPerMeter,
            1 / altUnitsPerMeter
        ],
        unitsPerDegree: [
            unitsPerDegreeX,
            unitsPerDegreeY,
            altUnitsPerMeter
        ],
        degreesPerUnit: [
            1 / unitsPerDegreeX,
            1 / unitsPerDegreeY,
            1 / altUnitsPerMeter
        ]
    };
    if (highPrecision) {
        const latCosine2 = $f5ef504cb5091e21$var$DEGREES_TO_RADIANS * Math.tan(latitude * $f5ef504cb5091e21$var$DEGREES_TO_RADIANS) / latCosine;
        const unitsPerDegreeY2 = unitsPerDegreeX * latCosine2 / 2;
        const altUnitsPerDegree2 = worldSize / $f5ef504cb5091e21$var$EARTH_CIRCUMFERENCE * latCosine2;
        const altUnitsPerMeter2 = altUnitsPerDegree2 / unitsPerDegreeY * altUnitsPerMeter;
        result.unitsPerDegree2 = [
            0,
            unitsPerDegreeY2,
            altUnitsPerDegree2
        ];
        result.unitsPerMeter2 = [
            altUnitsPerMeter2,
            0,
            altUnitsPerMeter2
        ];
    }
    return result;
}
function $f5ef504cb5091e21$export$86ab4399faf187a8(lngLatZ, xyz) {
    const [longitude, latitude, z0] = lngLatZ;
    const [x, y, z] = xyz;
    const { unitsPerMeter: unitsPerMeter1 , unitsPerMeter2: unitsPerMeter2  } = $f5ef504cb5091e21$export$14a522c4e7772100({
        longitude: longitude,
        latitude: latitude,
        highPrecision: true
    });
    const worldspace = $f5ef504cb5091e21$export$4a0e8ea52607cc9b(lngLatZ);
    worldspace[0] += x * (unitsPerMeter1[0] + unitsPerMeter2[0] * y);
    worldspace[1] += y * (unitsPerMeter1[1] + unitsPerMeter2[1] * y);
    const newLngLat = $f5ef504cb5091e21$export$66ee0abd8a6a9660(worldspace);
    const newZ = (z0 || 0) + (z || 0);
    return Number.isFinite(z0) || Number.isFinite(z) ? [
        newLngLat[0],
        newLngLat[1],
        newZ
    ] : newLngLat;
}
function $f5ef504cb5091e21$export$a4dee078b9284944(options) {
    const { height: height , pitch: pitch , bearing: bearing , altitude: altitude , scale: scale , center: center  } = options;
    const vm = (0, $8ff31ed396c58e4f$export$1a9a28cade4dcdc4)();
    $46ec5f9ed0e75076$export$d73ee8ef04f5226a(vm, vm, [
        0,
        0,
        -altitude
    ]);
    $46ec5f9ed0e75076$export$a59c8716592e09af(vm, vm, -pitch * $f5ef504cb5091e21$var$DEGREES_TO_RADIANS);
    $46ec5f9ed0e75076$export$ea6eae3365de5b9c(vm, vm, bearing * $f5ef504cb5091e21$var$DEGREES_TO_RADIANS);
    const relativeScale = scale / height;
    $46ec5f9ed0e75076$export$dcdf75081b88279d(vm, vm, [
        relativeScale,
        relativeScale,
        relativeScale
    ]);
    if (center) $46ec5f9ed0e75076$export$d73ee8ef04f5226a(vm, vm, $68948bc2139893c7$export$aef51622e549b8b0([], center));
    return vm;
}
function $f5ef504cb5091e21$export$3debb7b92b597428(options) {
    const { width: width , height: height , altitude: altitude , pitch: pitch = 0 , offset: offset , center: center , scale: scale , nearZMultiplier: nearZMultiplier = 1 , farZMultiplier: farZMultiplier = 1  } = options;
    let { fovy: fovy = $f5ef504cb5091e21$export$4b02e2005c3c5cc($f5ef504cb5091e21$export$c10d0dffa5af045)  } = options;
    if (altitude !== undefined) fovy = $f5ef504cb5091e21$export$4b02e2005c3c5cc(altitude);
    const fovRadians = fovy * $f5ef504cb5091e21$var$DEGREES_TO_RADIANS;
    const pitchRadians = pitch * $f5ef504cb5091e21$var$DEGREES_TO_RADIANS;
    const focalDistance = $f5ef504cb5091e21$export$2e0715d5da7e224d(fovy);
    let cameraToSeaLevelDistance = focalDistance;
    if (center) cameraToSeaLevelDistance += center[2] * scale / Math.cos(pitchRadians) / height;
    const fovAboveCenter = fovRadians * (0.5 + (offset ? offset[1] : 0) / height);
    const topHalfSurfaceDistance = Math.sin(fovAboveCenter) * cameraToSeaLevelDistance / Math.sin((0, $8ff31ed396c58e4f$export$7d15b64cf5a3a4c4)(Math.PI / 2 - pitchRadians - fovAboveCenter, 0.01, Math.PI - 0.01));
    const furthestDistance = Math.sin(pitchRadians) * topHalfSurfaceDistance + cameraToSeaLevelDistance;
    const horizonDistance = cameraToSeaLevelDistance * 10;
    const farZ = Math.min(furthestDistance * farZMultiplier, horizonDistance);
    return {
        fov: fovRadians,
        aspect: width / height,
        focalDistance: focalDistance,
        near: nearZMultiplier,
        far: farZ
    };
}
function $f5ef504cb5091e21$export$1d64991cd669ebf9(options) {
    const { fov: fov , aspect: aspect , near: near , far: far  } = $f5ef504cb5091e21$export$3debb7b92b597428(options);
    const projectionMatrix = $46ec5f9ed0e75076$export$541149539f3a4684([], fov, aspect, near, far);
    return projectionMatrix;
}
function $f5ef504cb5091e21$export$4b02e2005c3c5cc(altitude) {
    return 2 * Math.atan(0.5 / altitude) * $f5ef504cb5091e21$var$RADIANS_TO_DEGREES;
}
function $f5ef504cb5091e21$export$2e0715d5da7e224d(fovy) {
    return 0.5 / Math.tan(0.5 * fovy * $f5ef504cb5091e21$var$DEGREES_TO_RADIANS);
}
function $f5ef504cb5091e21$export$46d0dd92e8f9a0db(xyz, pixelProjectionMatrix) {
    const [x, y, z = 0] = xyz;
    (0, $b721105c5eaabf93$export$2e2bcd8739ae039)(Number.isFinite(x) && Number.isFinite(y) && Number.isFinite(z));
    return (0, $8ff31ed396c58e4f$export$8248199402822036)(pixelProjectionMatrix, [
        x,
        y,
        z,
        1
    ]);
}
function $f5ef504cb5091e21$export$d0eff18eb06add5f(xyz, pixelUnprojectionMatrix, targetZ = 0) {
    const [x, y, z] = xyz;
    (0, $b721105c5eaabf93$export$2e2bcd8739ae039)(Number.isFinite(x) && Number.isFinite(y), "invalid pixel coordinate");
    if (Number.isFinite(z)) {
        const coord = (0, $8ff31ed396c58e4f$export$8248199402822036)(pixelUnprojectionMatrix, [
            x,
            y,
            z,
            1
        ]);
        return coord;
    }
    const coord0 = (0, $8ff31ed396c58e4f$export$8248199402822036)(pixelUnprojectionMatrix, [
        x,
        y,
        0,
        1
    ]);
    const coord1 = (0, $8ff31ed396c58e4f$export$8248199402822036)(pixelUnprojectionMatrix, [
        x,
        y,
        1,
        1
    ]);
    const z0 = coord0[2];
    const z1 = coord1[2];
    const t = z0 === z1 ? 0 : ((targetZ || 0) - z0) / (z1 - z0);
    return $fceb3370258170b6$export$3a89f8d6f6bf6c9f([], coord0, coord1, t);
}





function $7401923064b435ee$export$2e2bcd8739ae039(options) {
    const { width: width , height: height , bounds: bounds , minExtent: minExtent = 0 , maxZoom: maxZoom = 24 , offset: offset = [
        0,
        0
    ]  } = options;
    const [[west, south], [east, north]] = bounds;
    const padding = $7401923064b435ee$var$getPaddingObject(options.padding);
    const nw = (0, $f5ef504cb5091e21$export$4a0e8ea52607cc9b)([
        west,
        (0, $8ff31ed396c58e4f$export$7d15b64cf5a3a4c4)(north, -(0, $f5ef504cb5091e21$export$6872bd9851469b83), (0, $f5ef504cb5091e21$export$6872bd9851469b83))
    ]);
    const se = (0, $f5ef504cb5091e21$export$4a0e8ea52607cc9b)([
        east,
        (0, $8ff31ed396c58e4f$export$7d15b64cf5a3a4c4)(south, -(0, $f5ef504cb5091e21$export$6872bd9851469b83), (0, $f5ef504cb5091e21$export$6872bd9851469b83))
    ]);
    const size = [
        Math.max(Math.abs(se[0] - nw[0]), minExtent),
        Math.max(Math.abs(se[1] - nw[1]), minExtent)
    ];
    const targetSize = [
        width - padding.left - padding.right - Math.abs(offset[0]) * 2,
        height - padding.top - padding.bottom - Math.abs(offset[1]) * 2
    ];
    (0, $b721105c5eaabf93$export$2e2bcd8739ae039)(targetSize[0] > 0 && targetSize[1] > 0);
    const scaleX = targetSize[0] / size[0];
    const scaleY = targetSize[1] / size[1];
    const offsetX = (padding.right - padding.left) / 2 / scaleX;
    const offsetY = (padding.bottom - padding.top) / 2 / scaleY;
    const center = [
        (se[0] + nw[0]) / 2 + offsetX,
        (se[1] + nw[1]) / 2 + offsetY
    ];
    const centerLngLat = (0, $f5ef504cb5091e21$export$66ee0abd8a6a9660)(center);
    const zoom = Math.min(maxZoom, (0, $8ff31ed396c58e4f$export$b9fae0bba9d9094d)(Math.abs(Math.min(scaleX, scaleY))));
    (0, $b721105c5eaabf93$export$2e2bcd8739ae039)(Number.isFinite(zoom));
    return {
        longitude: centerLngLat[0],
        latitude: centerLngLat[1],
        zoom: zoom
    };
}
function $7401923064b435ee$var$getPaddingObject(padding = 0) {
    if (typeof padding === "number") return {
        top: padding,
        bottom: padding,
        left: padding,
        right: padding
    };
    (0, $b721105c5eaabf93$export$2e2bcd8739ae039)(Number.isFinite(padding.top) && Number.isFinite(padding.bottom) && Number.isFinite(padding.left) && Number.isFinite(padding.right));
    return padding;
}





const $0c06f6449ce0cec0$var$DEGREES_TO_RADIANS = Math.PI / 180;
function $0c06f6449ce0cec0$export$2e2bcd8739ae039(viewport, z = 0) {
    const { width: width , height: height , unproject: unproject  } = viewport;
    const unprojectOps = {
        targetZ: z
    };
    const bottomLeft = unproject([
        0,
        height
    ], unprojectOps);
    const bottomRight = unproject([
        width,
        height
    ], unprojectOps);
    let topLeft;
    let topRight;
    const halfFov = viewport.fovy ? 0.5 * viewport.fovy * $0c06f6449ce0cec0$var$DEGREES_TO_RADIANS : Math.atan(0.5 / viewport.altitude);
    const angleToGround = (90 - viewport.pitch) * $0c06f6449ce0cec0$var$DEGREES_TO_RADIANS;
    if (halfFov > angleToGround - 0.01) {
        topLeft = $0c06f6449ce0cec0$var$unprojectOnFarPlane(viewport, 0, z);
        topRight = $0c06f6449ce0cec0$var$unprojectOnFarPlane(viewport, width, z);
    } else {
        topLeft = unproject([
            0,
            0
        ], unprojectOps);
        topRight = unproject([
            width,
            0
        ], unprojectOps);
    }
    return [
        bottomLeft,
        bottomRight,
        topRight,
        topLeft
    ];
}
function $0c06f6449ce0cec0$var$unprojectOnFarPlane(viewport, x, targetZ) {
    const { pixelUnprojectionMatrix: pixelUnprojectionMatrix  } = viewport;
    const coord0 = (0, $8ff31ed396c58e4f$export$8248199402822036)(pixelUnprojectionMatrix, [
        x,
        0,
        1,
        1
    ]);
    const coord1 = (0, $8ff31ed396c58e4f$export$8248199402822036)(pixelUnprojectionMatrix, [
        x,
        viewport.height,
        1,
        1
    ]);
    const z = targetZ * viewport.distanceScales.unitsPerMeter[2];
    const t = (z - coord0[2]) / (coord1[2] - coord0[2]);
    const coord = $fceb3370258170b6$export$3a89f8d6f6bf6c9f([], coord0, coord1, t);
    const result = (0, $f5ef504cb5091e21$export$66ee0abd8a6a9660)(coord);
    result.push(targetZ);
    return result;
}





class $65aa3992a29fe1ce$export$2e2bcd8739ae039 {
    constructor(props = {
        width: 1,
        height: 1
    }){
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "latitude", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "longitude", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "zoom", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "pitch", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "bearing", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "altitude", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "fovy", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "meterOffset", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "center", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "width", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "height", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "scale", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "distanceScales", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "viewMatrix", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "projectionMatrix", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "viewProjectionMatrix", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "pixelProjectionMatrix", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "pixelUnprojectionMatrix", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "equals", (viewport)=>{
            if (!(viewport instanceof $65aa3992a29fe1ce$export$2e2bcd8739ae039)) return false;
            return viewport.width === this.width && viewport.height === this.height && $46ec5f9ed0e75076$export$e9bab7fafb253603(viewport.projectionMatrix, this.projectionMatrix) && $46ec5f9ed0e75076$export$e9bab7fafb253603(viewport.viewMatrix, this.viewMatrix);
        });
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "project", (lngLatZ, options = {})=>{
            const { topLeft: topLeft = true  } = options;
            const worldPosition = this.projectPosition(lngLatZ);
            const coord = (0, $f5ef504cb5091e21$export$46d0dd92e8f9a0db)(worldPosition, this.pixelProjectionMatrix);
            const [x, y] = coord;
            const y2 = topLeft ? y : this.height - y;
            return lngLatZ.length === 2 ? [
                x,
                y2
            ] : [
                x,
                y2,
                coord[2]
            ];
        });
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "unproject", (xyz, options = {})=>{
            const { topLeft: topLeft = true , targetZ: targetZ  } = options;
            const [x, y, z] = xyz;
            const y2 = topLeft ? y : this.height - y;
            const targetZWorld = targetZ && targetZ * this.distanceScales.unitsPerMeter[2];
            const coord = (0, $f5ef504cb5091e21$export$d0eff18eb06add5f)([
                x,
                y2,
                z
            ], this.pixelUnprojectionMatrix, targetZWorld);
            const [X, Y, Z] = this.unprojectPosition(coord);
            if (Number.isFinite(z)) return [
                X,
                Y,
                Z
            ];
            return Number.isFinite(targetZ) ? [
                X,
                Y,
                targetZ
            ] : [
                X,
                Y
            ];
        });
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "projectPosition", (xyz)=>{
            const [X, Y] = (0, $f5ef504cb5091e21$export$4a0e8ea52607cc9b)(xyz);
            const Z = (xyz[2] || 0) * this.distanceScales.unitsPerMeter[2];
            return [
                X,
                Y,
                Z
            ];
        });
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "unprojectPosition", (xyz)=>{
            const [X, Y] = (0, $f5ef504cb5091e21$export$66ee0abd8a6a9660)(xyz);
            const Z = (xyz[2] || 0) * this.distanceScales.metersPerUnit[2];
            return [
                X,
                Y,
                Z
            ];
        });
        let { width: width , height: height , altitude: altitude = null , fovy: fovy = null  } = props;
        const { latitude: latitude = 0 , longitude: longitude = 0 , zoom: zoom = 0 , pitch: pitch = 0 , bearing: bearing = 0 , position: position = null , nearZMultiplier: nearZMultiplier = 0.02 , farZMultiplier: farZMultiplier = 1.01  } = props;
        width = width || 1;
        height = height || 1;
        if (fovy === null && altitude === null) {
            altitude = (0, $f5ef504cb5091e21$export$c10d0dffa5af045);
            fovy = (0, $f5ef504cb5091e21$export$4b02e2005c3c5cc)(altitude);
        } else if (fovy === null) fovy = (0, $f5ef504cb5091e21$export$4b02e2005c3c5cc)(altitude);
        else if (altitude === null) altitude = (0, $f5ef504cb5091e21$export$2e0715d5da7e224d)(fovy);
        const scale = (0, $f5ef504cb5091e21$export$eda81de7742ad8e7)(zoom);
        altitude = Math.max(0.75, altitude);
        const distanceScales = (0, $f5ef504cb5091e21$export$14a522c4e7772100)({
            longitude: longitude,
            latitude: latitude
        });
        const center = (0, $f5ef504cb5091e21$export$4a0e8ea52607cc9b)([
            longitude,
            latitude
        ]);
        center.push(0);
        if (position) $68948bc2139893c7$export$e16d8520af44a096(center, center, $68948bc2139893c7$export$6e3a27864ab166fe([], position, distanceScales.unitsPerMeter));
        this.projectionMatrix = (0, $f5ef504cb5091e21$export$1d64991cd669ebf9)({
            width: width,
            height: height,
            scale: scale,
            center: center,
            pitch: pitch,
            fovy: fovy,
            nearZMultiplier: nearZMultiplier,
            farZMultiplier: farZMultiplier
        });
        this.viewMatrix = (0, $f5ef504cb5091e21$export$a4dee078b9284944)({
            height: height,
            scale: scale,
            center: center,
            pitch: pitch,
            bearing: bearing,
            altitude: altitude
        });
        this.width = width;
        this.height = height;
        this.scale = scale;
        this.latitude = latitude;
        this.longitude = longitude;
        this.zoom = zoom;
        this.pitch = pitch;
        this.bearing = bearing;
        this.altitude = altitude;
        this.fovy = fovy;
        this.center = center;
        this.meterOffset = position || [
            0,
            0,
            0
        ];
        this.distanceScales = distanceScales;
        this._initMatrices();
        Object.freeze(this);
    }
    _initMatrices() {
        const { width: width , height: height , projectionMatrix: projectionMatrix , viewMatrix: viewMatrix  } = this;
        const vpm = (0, $8ff31ed396c58e4f$export$1a9a28cade4dcdc4)();
        $46ec5f9ed0e75076$export$2060d2db72cce88f(vpm, vpm, projectionMatrix);
        $46ec5f9ed0e75076$export$2060d2db72cce88f(vpm, vpm, viewMatrix);
        this.viewProjectionMatrix = vpm;
        const m = (0, $8ff31ed396c58e4f$export$1a9a28cade4dcdc4)();
        $46ec5f9ed0e75076$export$dcdf75081b88279d(m, m, [
            width / 2,
            -height / 2,
            1
        ]);
        $46ec5f9ed0e75076$export$d73ee8ef04f5226a(m, m, [
            1,
            -1,
            0
        ]);
        $46ec5f9ed0e75076$export$2060d2db72cce88f(m, m, vpm);
        const mInverse = $46ec5f9ed0e75076$export$6897c284b6f9f4dc((0, $8ff31ed396c58e4f$export$1a9a28cade4dcdc4)(), m);
        if (!mInverse) throw new Error("Pixel project matrix not invertible");
        this.pixelProjectionMatrix = m;
        this.pixelUnprojectionMatrix = mInverse;
    }
    projectFlat(lngLat) {
        return (0, $f5ef504cb5091e21$export$4a0e8ea52607cc9b)(lngLat);
    }
    unprojectFlat(xy) {
        return (0, $f5ef504cb5091e21$export$66ee0abd8a6a9660)(xy);
    }
    getMapCenterByLngLatPosition({ lngLat: lngLat , pos: pos  }) {
        const fromLocation = (0, $f5ef504cb5091e21$export$d0eff18eb06add5f)(pos, this.pixelUnprojectionMatrix);
        const toLocation = (0, $f5ef504cb5091e21$export$4a0e8ea52607cc9b)(lngLat);
        const translate = $fceb3370258170b6$export$e16d8520af44a096([], toLocation, $fceb3370258170b6$export$aef51622e549b8b0([], fromLocation));
        const newCenter = $fceb3370258170b6$export$e16d8520af44a096([], this.center, translate);
        return (0, $f5ef504cb5091e21$export$66ee0abd8a6a9660)(newCenter);
    }
    fitBounds(bounds, options = {}) {
        const { width: width , height: height  } = this;
        const { longitude: longitude , latitude: latitude , zoom: zoom  } = (0, $7401923064b435ee$export$2e2bcd8739ae039)(Object.assign({
            width: width,
            height: height,
            bounds: bounds
        }, options));
        return new $65aa3992a29fe1ce$export$2e2bcd8739ae039({
            width: width,
            height: height,
            longitude: longitude,
            latitude: latitude,
            zoom: zoom
        });
    }
    getBounds(options) {
        const corners = this.getBoundingRegion(options);
        const west = Math.min(...corners.map((p)=>p[0]));
        const east = Math.max(...corners.map((p)=>p[0]));
        const south = Math.min(...corners.map((p)=>p[1]));
        const north = Math.max(...corners.map((p)=>p[1]));
        return [
            [
                west,
                south
            ],
            [
                east,
                north
            ]
        ];
    }
    getBoundingRegion(options = {}) {
        return (0, $0c06f6449ce0cec0$export$2e2bcd8739ae039)(this, options.z || 0);
    }
    getLocationAtPoint({ lngLat: lngLat , pos: pos  }) {
        return this.getMapCenterByLngLatPosition({
            lngLat: lngLat,
            pos: pos
        });
    }
}







const $a727f0775314f814$var$TILE_SIZE = 512;
function $a727f0775314f814$export$2e2bcd8739ae039(props) {
    const { width: width , height: height , pitch: pitch = 0  } = props;
    let { longitude: longitude , latitude: latitude , zoom: zoom , bearing: bearing = 0  } = props;
    if (longitude < -180 || longitude > 180) longitude = (0, $8ff31ed396c58e4f$export$842a2cf37af977e1)(longitude + 180, 360) - 180;
    if (bearing < -180 || bearing > 180) bearing = (0, $8ff31ed396c58e4f$export$842a2cf37af977e1)(bearing + 180, 360) - 180;
    const minZoom = (0, $8ff31ed396c58e4f$export$b9fae0bba9d9094d)(height / $a727f0775314f814$var$TILE_SIZE);
    if (zoom <= minZoom) {
        zoom = minZoom;
        latitude = 0;
    } else {
        const halfHeightPixels = height / 2 / Math.pow(2, zoom);
        const minLatitude = (0, $f5ef504cb5091e21$export$66ee0abd8a6a9660)([
            0,
            halfHeightPixels
        ])[1];
        if (latitude < minLatitude) latitude = minLatitude;
        else {
            const maxLatitude = (0, $f5ef504cb5091e21$export$66ee0abd8a6a9660)([
                0,
                $a727f0775314f814$var$TILE_SIZE - halfHeightPixels
            ])[1];
            if (latitude > maxLatitude) latitude = maxLatitude;
        }
    }
    return {
        width: width,
        height: height,
        longitude: longitude,
        latitude: latitude,
        zoom: zoom,
        pitch: pitch,
        bearing: bearing
    };
}





const $d660f234a938c540$var$EPSILON = 0.01;
const $d660f234a938c540$var$VIEWPORT_TRANSITION_PROPS = [
    "longitude",
    "latitude",
    "zoom"
];
const $d660f234a938c540$var$DEFAULT_OPTS = {
    curve: 1.414,
    speed: 1.2
};
function $d660f234a938c540$export$2e2bcd8739ae039(startProps, endProps, t, options) {
    const { startZoom: startZoom , startCenterXY: startCenterXY , uDelta: uDelta , w0: w0 , u1: u1 , S: S , rho: rho , rho2: rho2 , r0: r0  } = $d660f234a938c540$var$getFlyToTransitionParams(startProps, endProps, options);
    if (u1 < $d660f234a938c540$var$EPSILON) {
        const viewport = {};
        for (const key of $d660f234a938c540$var$VIEWPORT_TRANSITION_PROPS){
            const startValue = startProps[key];
            const endValue = endProps[key];
            viewport[key] = (0, $8ff31ed396c58e4f$export$3a89f8d6f6bf6c9f)(startValue, endValue, t);
        }
        return viewport;
    }
    const s = t * S;
    const w = Math.cosh(r0) / Math.cosh(r0 + rho * s);
    const u = w0 * ((Math.cosh(r0) * Math.tanh(r0 + rho * s) - Math.sinh(r0)) / rho2) / u1;
    const scaleIncrement = 1 / w;
    const newZoom = startZoom + (0, $f5ef504cb5091e21$export$6e08c044660f3e30)(scaleIncrement);
    const newCenterWorld = $fceb3370258170b6$export$dcdf75081b88279d([], uDelta, u);
    $fceb3370258170b6$export$e16d8520af44a096(newCenterWorld, newCenterWorld, startCenterXY);
    const newCenter = (0, $f5ef504cb5091e21$export$66ee0abd8a6a9660)(newCenterWorld);
    return {
        longitude: newCenter[0],
        latitude: newCenter[1],
        zoom: newZoom
    };
}
function $d660f234a938c540$export$1d42c64f84307be3(startProps, endProps, options) {
    const opts = {
        ...$d660f234a938c540$var$DEFAULT_OPTS,
        ...options
    };
    const { screenSpeed: screenSpeed , speed: speed , maxDuration: maxDuration  } = opts;
    const { S: S , rho: rho  } = $d660f234a938c540$var$getFlyToTransitionParams(startProps, endProps, opts);
    const length = 1000 * S;
    let duration;
    if (Number.isFinite(screenSpeed)) duration = length / (screenSpeed / rho);
    else duration = length / speed;
    return Number.isFinite(maxDuration) && duration > maxDuration ? 0 : duration;
}
function $d660f234a938c540$var$getFlyToTransitionParams(startProps, endProps, opts) {
    opts = Object.assign({}, $d660f234a938c540$var$DEFAULT_OPTS, opts);
    const rho = opts.curve;
    const startZoom = startProps.zoom;
    const startCenter = [
        startProps.longitude,
        startProps.latitude
    ];
    const startScale = (0, $f5ef504cb5091e21$export$eda81de7742ad8e7)(startZoom);
    const endZoom = endProps.zoom;
    const endCenter = [
        endProps.longitude,
        endProps.latitude
    ];
    const scale = (0, $f5ef504cb5091e21$export$eda81de7742ad8e7)(endZoom - startZoom);
    const startCenterXY = (0, $f5ef504cb5091e21$export$4a0e8ea52607cc9b)(startCenter);
    const endCenterXY = (0, $f5ef504cb5091e21$export$4a0e8ea52607cc9b)(endCenter);
    const uDelta = $fceb3370258170b6$export$f93b5905241a7cca([], endCenterXY, startCenterXY);
    const w0 = Math.max(startProps.width, startProps.height);
    const w1 = w0 / scale;
    const u1 = $fceb3370258170b6$export$f24224f1c91d8156(uDelta) * startScale;
    const _u1 = Math.max(u1, $d660f234a938c540$var$EPSILON);
    const rho2 = rho * rho;
    const b0 = (w1 * w1 - w0 * w0 + rho2 * rho2 * _u1 * _u1) / (2 * w0 * rho2 * _u1);
    const b1 = (w1 * w1 - w0 * w0 - rho2 * rho2 * _u1 * _u1) / (2 * w1 * rho2 * _u1);
    const r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0);
    const r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
    const S = (r1 - r0) / rho;
    return {
        startZoom: startZoom,
        startCenterXY: startCenterXY,
        uDelta: uDelta,
        w0: w0,
        u1: u1,
        S: S,
        rho: rho,
        rho2: rho2,
        r0: r0,
        r1: r1
    };
}






const $bdb7668fd52e659a$var$DEGREES_TO_RADIANS = Math.PI / 180;
const $bdb7668fd52e659a$var$IDENTITY = (0, $97790275b37bd567$export$1a9a28cade4dcdc4)();
const $bdb7668fd52e659a$var$ZERO_VECTOR = [
    0,
    0,
    0
];
const $bdb7668fd52e659a$var$DEFAULT_DISTANCE_SCALES = {
    unitsPerMeter: [
        1,
        1,
        1
    ],
    metersPerUnit: [
        1,
        1,
        1
    ]
};
function $bdb7668fd52e659a$var$createProjectionMatrix({ width: width , height: height , orthographic: orthographic , fovyRadians: fovyRadians , focalDistance: focalDistance , padding: padding , near: near , far: far  }) {
    const aspect = width / height;
    const matrix = orthographic ? new (0, $16800f0dff513c4e$export$2e2bcd8739ae039)().orthographic({
        fovy: fovyRadians,
        aspect: aspect,
        focalDistance: focalDistance,
        near: near,
        far: far
    }) : new (0, $16800f0dff513c4e$export$2e2bcd8739ae039)().perspective({
        fovy: fovyRadians,
        aspect: aspect,
        near: near,
        far: far
    });
    if (padding) {
        const { left: left = 0 , right: right = 0 , top: top = 0 , bottom: bottom = 0  } = padding;
        const offsetX = (0, $53a37c44451cea56$export$7d15b64cf5a3a4c4)((left + width - right) / 2, 0, width) - width / 2;
        const offsetY = (0, $53a37c44451cea56$export$7d15b64cf5a3a4c4)((top + height - bottom) / 2, 0, height) - height / 2;
        matrix[8] -= offsetX * 2 / width;
        matrix[9] += offsetY * 2 / height;
    }
    return matrix;
}
class $bdb7668fd52e659a$export$2e2bcd8739ae039 {
    constructor(opts = {}){
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "id", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "x", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "y", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "width", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "height", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "isGeospatial", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "zoom", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "focalDistance", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "position", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "modelMatrix", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "distanceScales", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "scale", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "center", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "cameraPosition", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "projectionMatrix", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "viewMatrix", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "viewMatrixUncentered", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "viewMatrixInverse", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "viewProjectionMatrix", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "pixelProjectionMatrix", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "pixelUnprojectionMatrix", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "resolution", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_frustumPlanes", {});
        this.id = opts.id || this.constructor.displayName || "viewport";
        this.x = opts.x || 0;
        this.y = opts.y || 0;
        this.width = opts.width || 1;
        this.height = opts.height || 1;
        this.zoom = opts.zoom || 0;
        this.distanceScales = opts.distanceScales || $bdb7668fd52e659a$var$DEFAULT_DISTANCE_SCALES;
        this.focalDistance = opts.focalDistance || 1;
        this.position = opts.position || $bdb7668fd52e659a$var$ZERO_VECTOR;
        this.modelMatrix = opts.modelMatrix || null;
        const { longitude: longitude , latitude: latitude  } = opts;
        this.isGeospatial = Number.isFinite(latitude) && Number.isFinite(longitude);
        this._initProps(opts);
        this._initMatrices(opts);
        this.equals = this.equals.bind(this);
        this.project = this.project.bind(this);
        this.unproject = this.unproject.bind(this);
        this.projectPosition = this.projectPosition.bind(this);
        this.unprojectPosition = this.unprojectPosition.bind(this);
        this.projectFlat = this.projectFlat.bind(this);
        this.unprojectFlat = this.unprojectFlat.bind(this);
    }
    get metersPerPixel() {
        return this.distanceScales.metersPerUnit[2] / this.scale;
    }
    get projectionMode() {
        if (this.isGeospatial) return this.zoom < 12 ? (0, $b42a5b9aa3b1a41f$export$3697aaebd269a548).WEB_MERCATOR : (0, $b42a5b9aa3b1a41f$export$3697aaebd269a548).WEB_MERCATOR_AUTO_OFFSET;
        return (0, $b42a5b9aa3b1a41f$export$3697aaebd269a548).IDENTITY;
    }
    equals(viewport) {
        if (!(viewport instanceof $bdb7668fd52e659a$export$2e2bcd8739ae039)) return false;
        if (this === viewport) return true;
        return viewport.width === this.width && viewport.height === this.height && viewport.scale === this.scale && (0, $53a37c44451cea56$export$e9bab7fafb253603)(viewport.projectionMatrix, this.projectionMatrix) && (0, $53a37c44451cea56$export$e9bab7fafb253603)(viewport.viewMatrix, this.viewMatrix);
    }
    project(xyz, { topLeft: topLeft = true  } = {}) {
        const worldPosition = this.projectPosition(xyz);
        const coord = (0, $f5ef504cb5091e21$export$46d0dd92e8f9a0db)(worldPosition, this.pixelProjectionMatrix);
        const [x, y] = coord;
        const y2 = topLeft ? y : this.height - y;
        return xyz.length === 2 ? [
            x,
            y2
        ] : [
            x,
            y2,
            coord[2]
        ];
    }
    unproject(xyz, { topLeft: topLeft = true , targetZ: targetZ  } = {}) {
        const [x, y, z] = xyz;
        const y2 = topLeft ? y : this.height - y;
        const targetZWorld = targetZ && targetZ * this.distanceScales.unitsPerMeter[2];
        const coord = (0, $f5ef504cb5091e21$export$d0eff18eb06add5f)([
            x,
            y2,
            z
        ], this.pixelUnprojectionMatrix, targetZWorld);
        const [X, Y, Z] = this.unprojectPosition(coord);
        if (Number.isFinite(z)) return [
            X,
            Y,
            Z
        ];
        return Number.isFinite(targetZ) ? [
            X,
            Y,
            targetZ
        ] : [
            X,
            Y
        ];
    }
    projectPosition(xyz) {
        const [X, Y] = this.projectFlat(xyz);
        const Z = (xyz[2] || 0) * this.distanceScales.unitsPerMeter[2];
        return [
            X,
            Y,
            Z
        ];
    }
    unprojectPosition(xyz) {
        const [X, Y] = this.unprojectFlat(xyz);
        const Z = (xyz[2] || 0) * this.distanceScales.metersPerUnit[2];
        return [
            X,
            Y,
            Z
        ];
    }
    projectFlat(xyz) {
        if (this.isGeospatial) {
            const result = (0, $f5ef504cb5091e21$export$4a0e8ea52607cc9b)(xyz);
            result[1] = (0, $53a37c44451cea56$export$7d15b64cf5a3a4c4)(result[1], -318, 830);
            return result;
        }
        return xyz;
    }
    unprojectFlat(xyz) {
        if (this.isGeospatial) return (0, $f5ef504cb5091e21$export$66ee0abd8a6a9660)(xyz);
        return xyz;
    }
    getBounds(options = {}) {
        const unprojectOption = {
            targetZ: options.z || 0
        };
        const topLeft = this.unproject([
            0,
            0
        ], unprojectOption);
        const topRight = this.unproject([
            this.width,
            0
        ], unprojectOption);
        const bottomLeft = this.unproject([
            0,
            this.height
        ], unprojectOption);
        const bottomRight = this.unproject([
            this.width,
            this.height
        ], unprojectOption);
        return [
            Math.min(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]),
            Math.min(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]),
            Math.max(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]),
            Math.max(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1])
        ];
    }
    getDistanceScales(coordinateOrigin) {
        if (coordinateOrigin) return (0, $f5ef504cb5091e21$export$14a522c4e7772100)({
            longitude: coordinateOrigin[0],
            latitude: coordinateOrigin[1],
            highPrecision: true
        });
        return this.distanceScales;
    }
    containsPixel({ x: x , y: y , width: width = 1 , height: height = 1  }) {
        return x < this.x + this.width && this.x < x + width && y < this.y + this.height && this.y < y + height;
    }
    getFrustumPlanes() {
        if (this._frustumPlanes.near) return this._frustumPlanes;
        Object.assign(this._frustumPlanes, (0, $97790275b37bd567$export$7fd6193a8fe6de4e)(this.viewProjectionMatrix));
        return this._frustumPlanes;
    }
    panByPosition(coords, pixel) {
        return null;
    }
    _initProps(opts) {
        const longitude = opts.longitude;
        const latitude = opts.latitude;
        if (this.isGeospatial) {
            if (!Number.isFinite(opts.zoom)) this.zoom = (0, $f5ef504cb5091e21$export$f4aaab1d865abddd)({
                latitude: latitude
            }) + Math.log2(this.focalDistance);
            this.distanceScales = opts.distanceScales || (0, $f5ef504cb5091e21$export$14a522c4e7772100)({
                latitude: latitude,
                longitude: longitude
            });
        }
        const scale = Math.pow(2, this.zoom);
        this.scale = scale;
        const { position: position , modelMatrix: modelMatrix  } = opts;
        let meterOffset = $bdb7668fd52e659a$var$ZERO_VECTOR;
        if (position) meterOffset = modelMatrix ? new (0, $16800f0dff513c4e$export$2e2bcd8739ae039)(modelMatrix).transformAsVector(position, []) : position;
        if (this.isGeospatial) {
            const center = this.projectPosition([
                longitude,
                latitude,
                0
            ]);
            this.center = new (0, $9c6695c39a874609$export$2e2bcd8739ae039)(meterOffset).scale(this.distanceScales.unitsPerMeter).add(center);
        } else this.center = this.projectPosition(meterOffset);
    }
    _initMatrices(opts) {
        const { viewMatrix: viewMatrix = $bdb7668fd52e659a$var$IDENTITY , projectionMatrix: projectionMatrix = null , orthographic: orthographic = false , fovyRadians: fovyRadians , fovy: fovy = 75 , near: near = 0.1 , far: far = 1000 , padding: padding = null , focalDistance: focalDistance = 1  } = opts;
        this.viewMatrixUncentered = viewMatrix;
        this.viewMatrix = new (0, $16800f0dff513c4e$export$2e2bcd8739ae039)().multiplyRight(viewMatrix).translate(new (0, $9c6695c39a874609$export$2e2bcd8739ae039)(this.center).negate());
        this.projectionMatrix = projectionMatrix || $bdb7668fd52e659a$var$createProjectionMatrix({
            width: this.width,
            height: this.height,
            orthographic: orthographic,
            fovyRadians: fovyRadians || fovy * $bdb7668fd52e659a$var$DEGREES_TO_RADIANS,
            focalDistance: focalDistance,
            padding: padding,
            near: near,
            far: far
        });
        const vpm = (0, $97790275b37bd567$export$1a9a28cade4dcdc4)();
        $46ec5f9ed0e75076$export$2060d2db72cce88f(vpm, vpm, this.projectionMatrix);
        $46ec5f9ed0e75076$export$2060d2db72cce88f(vpm, vpm, this.viewMatrix);
        this.viewProjectionMatrix = vpm;
        this.viewMatrixInverse = $46ec5f9ed0e75076$export$6897c284b6f9f4dc([], this.viewMatrix) || this.viewMatrix;
        this.cameraPosition = (0, $97790275b37bd567$export$f411fdc3e02e158b)(this.viewMatrixInverse);
        const viewportMatrix = (0, $97790275b37bd567$export$1a9a28cade4dcdc4)();
        const pixelProjectionMatrix = (0, $97790275b37bd567$export$1a9a28cade4dcdc4)();
        $46ec5f9ed0e75076$export$dcdf75081b88279d(viewportMatrix, viewportMatrix, [
            this.width / 2,
            -this.height / 2,
            1
        ]);
        $46ec5f9ed0e75076$export$d73ee8ef04f5226a(viewportMatrix, viewportMatrix, [
            1,
            -1,
            0
        ]);
        $46ec5f9ed0e75076$export$2060d2db72cce88f(pixelProjectionMatrix, viewportMatrix, this.viewProjectionMatrix);
        this.pixelProjectionMatrix = pixelProjectionMatrix;
        this.pixelUnprojectionMatrix = $46ec5f9ed0e75076$export$6897c284b6f9f4dc((0, $97790275b37bd567$export$1a9a28cade4dcdc4)(), this.pixelProjectionMatrix);
        if (!this.pixelUnprojectionMatrix) (0, $146cba582e8c799f$export$2e2bcd8739ae039).warn("Pixel project matrix not invertible")();
    }
}
(0, $037483d1fb5deac8$export$2e2bcd8739ae039)($bdb7668fd52e659a$export$2e2bcd8739ae039, "displayName", "Viewport");



const $6a52b0a4ad5491f9$var$TRACE_SET_LAYERS = "layerManager.setLayers";
const $6a52b0a4ad5491f9$var$TRACE_ACTIVATE_VIEWPORT = "layerManager.activateViewport";
class $6a52b0a4ad5491f9$export$2e2bcd8739ae039 {
    constructor(gl, { deck: deck , stats: stats , viewport: _viewport , timeline: timeline  } = {}){
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "layers", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "context", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "resourceManager", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_lastRenderedLayers", []);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_needsRedraw", false);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_needsUpdate", false);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_nextLayers", null);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_debug", false);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "activateViewport", (viewport)=>{
            (0, $e34c41f170d77ab6$export$2e2bcd8739ae039)($6a52b0a4ad5491f9$var$TRACE_ACTIVATE_VIEWPORT, this, viewport);
            if (viewport) this.context.viewport = viewport;
        });
        this.layers = [];
        this.resourceManager = new (0, $23cb722a95241d61$export$2e2bcd8739ae039)({
            gl: gl,
            protocol: "deck://"
        });
        this.context = {
            mousePosition: null,
            userData: {},
            layerManager: this,
            gl: gl,
            deck: deck,
            programManager: gl && (0, $c6e8420d48e336f1$export$249fec8be25f60d5)(gl),
            stats: stats || new (0, $2fb061cfbc5cb32d$export$2e2bcd8739ae039)({
                id: "deck.gl"
            }),
            viewport: _viewport || new (0, $bdb7668fd52e659a$export$2e2bcd8739ae039)({
                id: "DEFAULT-INITIAL-VIEWPORT"
            }),
            timeline: timeline || new (0, $bc7bc101e53b8e33$export$e6a97ba2cae5bb94)(),
            resourceManager: this.resourceManager,
            onError: undefined
        };
        Object.seal(this);
    }
    finalize() {
        this.resourceManager.finalize();
        for (const layer of this.layers)this._finalizeLayer(layer);
    }
    needsRedraw(opts = {
        clearRedrawFlags: false
    }) {
        let redraw = this._needsRedraw;
        if (opts.clearRedrawFlags) this._needsRedraw = false;
        for (const layer of this.layers){
            const layerNeedsRedraw = layer.getNeedsRedraw(opts);
            redraw = redraw || layerNeedsRedraw;
        }
        return redraw;
    }
    needsUpdate() {
        if (this._nextLayers && this._nextLayers !== this._lastRenderedLayers) return "layers changed";
        return this._needsUpdate;
    }
    setNeedsRedraw(reason) {
        this._needsRedraw = this._needsRedraw || reason;
    }
    setNeedsUpdate(reason) {
        this._needsUpdate = this._needsUpdate || reason;
    }
    getLayers({ layerIds: layerIds  } = {}) {
        return layerIds ? this.layers.filter((layer)=>layerIds.find((layerId)=>layer.id.indexOf(layerId) === 0)) : this.layers;
    }
    setProps(props) {
        if ("debug" in props) this._debug = props.debug;
        if ("userData" in props) this.context.userData = props.userData;
        if ("layers" in props) this._nextLayers = props.layers;
        if ("onError" in props) this.context.onError = props.onError;
    }
    setLayers(newLayers, reason) {
        (0, $e34c41f170d77ab6$export$2e2bcd8739ae039)($6a52b0a4ad5491f9$var$TRACE_SET_LAYERS, this, reason, newLayers);
        this._lastRenderedLayers = newLayers;
        const flatLayers = (0, $755f3c37a143f46e$export$bffa455ba8c619a6)(newLayers, Boolean);
        for (const layer of flatLayers)layer.context = this.context;
        this._updateLayers(this.layers, flatLayers);
    }
    updateLayers() {
        const reason = this.needsUpdate();
        if (reason) {
            this.setNeedsRedraw("updating layers: ".concat(reason));
            this.setLayers(this._nextLayers || this._lastRenderedLayers, reason);
        }
        this._nextLayers = null;
    }
    _handleError(stage, error, layer) {
        layer.raiseError(error, "".concat(stage, " of ").concat(layer));
    }
    _updateLayers(oldLayers, newLayers) {
        const oldLayerMap = {};
        for (const oldLayer of oldLayers)if (oldLayerMap[oldLayer.id]) (0, $146cba582e8c799f$export$2e2bcd8739ae039).warn("Multiple old layers with same id ".concat(oldLayer.id))();
        else oldLayerMap[oldLayer.id] = oldLayer;
        const generatedLayers = [];
        this._updateSublayersRecursively(newLayers, oldLayerMap, generatedLayers);
        this._finalizeOldLayers(oldLayerMap);
        let needsUpdate = false;
        for (const layer of generatedLayers)if (layer.hasUniformTransition()) {
            needsUpdate = "Uniform transition in ".concat(layer);
            break;
        }
        this._needsUpdate = needsUpdate;
        this.layers = generatedLayers;
    }
    _updateSublayersRecursively(newLayers, oldLayerMap, generatedLayers) {
        for (const newLayer of newLayers){
            newLayer.context = this.context;
            const oldLayer = oldLayerMap[newLayer.id];
            if (oldLayer === null) (0, $146cba582e8c799f$export$2e2bcd8739ae039).warn("Multiple new layers with same id ".concat(newLayer.id))();
            oldLayerMap[newLayer.id] = null;
            let sublayers = null;
            try {
                if (this._debug && oldLayer !== newLayer) newLayer.validateProps();
                if (!oldLayer) this._initializeLayer(newLayer);
                else {
                    this._transferLayerState(oldLayer, newLayer);
                    this._updateLayer(newLayer);
                }
                generatedLayers.push(newLayer);
                sublayers = newLayer.isComposite ? newLayer.getSubLayers() : null;
            } catch (err) {
                this._handleError("matching", err, newLayer);
            }
            if (sublayers) this._updateSublayersRecursively(sublayers, oldLayerMap, generatedLayers);
        }
    }
    _finalizeOldLayers(oldLayerMap) {
        for(const layerId in oldLayerMap){
            const layer = oldLayerMap[layerId];
            if (layer) this._finalizeLayer(layer);
        }
    }
    _initializeLayer(layer) {
        try {
            layer._initialize();
            layer.lifecycle = (0, $434611e3e90ee53e$export$2cb9787dd463cbf4).INITIALIZED;
        } catch (err) {
            this._handleError("initialization", err, layer);
        }
    }
    _transferLayerState(oldLayer, newLayer) {
        newLayer._transferState(oldLayer);
        newLayer.lifecycle = (0, $434611e3e90ee53e$export$2cb9787dd463cbf4).MATCHED;
        if (newLayer !== oldLayer) oldLayer.lifecycle = (0, $434611e3e90ee53e$export$2cb9787dd463cbf4).AWAITING_GC;
    }
    _updateLayer(layer) {
        try {
            layer._update();
        } catch (err) {
            this._handleError("update", err, layer);
        }
    }
    _finalizeLayer(layer) {
        this._needsRedraw = this._needsRedraw || "finalized ".concat(layer);
        layer.lifecycle = (0, $434611e3e90ee53e$export$2cb9787dd463cbf4).AWAITING_FINALIZATION;
        try {
            layer._finalize();
            layer.lifecycle = (0, $434611e3e90ee53e$export$2cb9787dd463cbf4).FINALIZED;
        } catch (err) {
            this._handleError("finalization", err, layer);
        }
    }
}



function $70a948cba88c73a3$export$9cb4719e2e525b7a(a, b) {
    if (a === b) return true;
    if (!a || !b) return false;
    for(const key in a){
        const aValue = a[key];
        const bValue = b[key];
        const equals = aValue === bValue || Array.isArray(aValue) && Array.isArray(bValue) && $70a948cba88c73a3$export$9cb4719e2e525b7a(aValue, bValue);
        if (!equals) return false;
    }
    return true;
}




class $12d396d6877d881f$export$2e2bcd8739ae039 {
    constructor(props){
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "width", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "height", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "views", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "viewState", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "controllers", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "timeline", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_viewports", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_viewportMap", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_isUpdating", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_needsRedraw", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_needsUpdate", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_eventManager", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_eventCallbacks", void 0);
        this.views = [];
        this.width = 100;
        this.height = 100;
        this.viewState = {};
        this.controllers = {};
        this.timeline = props.timeline;
        this._viewports = [];
        this._viewportMap = {};
        this._isUpdating = false;
        this._needsRedraw = "First render";
        this._needsUpdate = "Initialize";
        this._eventManager = props.eventManager;
        this._eventCallbacks = {
            onViewStateChange: props.onViewStateChange,
            onInteractionStateChange: props.onInteractionStateChange
        };
        Object.seal(this);
        this.setProps(props);
    }
    finalize() {
        for(const key in this.controllers){
            const controller = this.controllers[key];
            if (controller) controller.finalize();
        }
        this.controllers = {};
    }
    needsRedraw(opts = {
        clearRedrawFlags: false
    }) {
        const redraw = this._needsRedraw;
        if (opts.clearRedrawFlags) this._needsRedraw = false;
        return redraw;
    }
    setNeedsUpdate(reason) {
        this._needsUpdate = this._needsUpdate || reason;
        this._needsRedraw = this._needsRedraw || reason;
    }
    updateViewStates() {
        for(const viewId in this.controllers){
            const controller = this.controllers[viewId];
            if (controller) controller.updateTransition();
        }
    }
    getViewports(rect) {
        if (rect) return this._viewports.filter((viewport)=>viewport.containsPixel(rect));
        return this._viewports;
    }
    getViews() {
        const viewMap = {};
        this.views.forEach((view)=>{
            viewMap[view.id] = view;
        });
        return viewMap;
    }
    getView(viewId) {
        return this.views.find((view)=>view.id === viewId);
    }
    getViewState(viewOrViewId) {
        const view = typeof viewOrViewId === "string" ? this.getView(viewOrViewId) : viewOrViewId;
        const viewState = view && this.viewState[view.getViewStateId()] || this.viewState;
        return view ? view.filterViewState(viewState) : viewState;
    }
    getViewport(viewId) {
        return this._viewportMap[viewId];
    }
    unproject(xyz, opts) {
        const viewports = this.getViewports();
        const pixel = {
            x: xyz[0],
            y: xyz[1]
        };
        for(let i = viewports.length - 1; i >= 0; --i){
            const viewport = viewports[i];
            if (viewport.containsPixel(pixel)) {
                const p = xyz.slice();
                p[0] -= viewport.x;
                p[1] -= viewport.y;
                return viewport.unproject(p, opts);
            }
        }
        return null;
    }
    setProps(props) {
        if (props.views) this._setViews(props.views);
        if (props.viewState) this._setViewState(props.viewState);
        if ("width" in props || "height" in props) this._setSize(props.width, props.height);
        if (!this._isUpdating) this._update();
    }
    _update() {
        this._isUpdating = true;
        if (this._needsUpdate) {
            this._needsUpdate = false;
            this._rebuildViewports();
        }
        if (this._needsUpdate) {
            this._needsUpdate = false;
            this._rebuildViewports();
        }
        this._isUpdating = false;
    }
    _setSize(width, height) {
        if (width !== this.width || height !== this.height) {
            this.width = width;
            this.height = height;
            this.setNeedsUpdate("Size changed");
        }
    }
    _setViews(views) {
        views = (0, $755f3c37a143f46e$export$bffa455ba8c619a6)(views, Boolean);
        const viewsChanged = this._diffViews(views, this.views);
        if (viewsChanged) this.setNeedsUpdate("views changed");
        this.views = views;
    }
    _setViewState(viewState) {
        if (viewState) {
            const viewStateChanged = !(0, $70a948cba88c73a3$export$9cb4719e2e525b7a)(viewState, this.viewState);
            if (viewStateChanged) this.setNeedsUpdate("viewState changed");
            this.viewState = viewState;
        } else (0, $146cba582e8c799f$export$2e2bcd8739ae039).warn("missing `viewState` or `initialViewState`")();
    }
    _onViewStateChange(viewId, event) {
        if (this._eventCallbacks.onViewStateChange) this._eventCallbacks.onViewStateChange({
            ...event,
            viewId: viewId
        });
    }
    _createController(view, props) {
        const Controller = props.type;
        const controller = new Controller({
            timeline: this.timeline,
            eventManager: this._eventManager,
            onViewStateChange: this._onViewStateChange.bind(this, props.id),
            onStateChange: this._eventCallbacks.onInteractionStateChange,
            makeViewport: (viewState)=>view.makeViewport({
                    viewState: viewState,
                    width: this.width,
                    height: this.height
                })
        });
        return controller;
    }
    _updateController(view, viewState, viewport, controller) {
        const controllerProps = view.controller;
        if (controllerProps) {
            const resolvedProps = {
                ...viewState,
                ...controllerProps,
                id: view.id,
                x: viewport.x,
                y: viewport.y,
                width: viewport.width,
                height: viewport.height
            };
            if (!controller) controller = this._createController(view, resolvedProps);
            if (controller) controller.setProps(resolvedProps);
            return controller;
        }
        return null;
    }
    _rebuildViewports() {
        const { views: views  } = this;
        const oldControllers = this.controllers;
        this._viewports = [];
        this.controllers = {};
        let invalidateControllers = false;
        for(let i = views.length; i--;){
            const view = views[i];
            const viewState = this.getViewState(view);
            const viewport = view.makeViewport({
                viewState: viewState,
                width: this.width,
                height: this.height
            });
            let oldController = oldControllers[view.id];
            const hasController = Boolean(view.controller);
            if (hasController && !oldController) invalidateControllers = true;
            if ((invalidateControllers || !hasController) && oldController) {
                oldController.finalize();
                oldController = null;
            }
            this.controllers[view.id] = this._updateController(view, viewState, viewport, oldController);
            this._viewports.unshift(viewport);
        }
        for(const id in oldControllers){
            const oldController = oldControllers[id];
            if (oldController && !this.controllers[id]) oldController.finalize();
        }
        this._buildViewportMap();
    }
    _buildViewportMap() {
        this._viewportMap = {};
        this._viewports.forEach((viewport)=>{
            if (viewport.id) this._viewportMap[viewport.id] = this._viewportMap[viewport.id] || viewport;
        });
    }
    _diffViews(newViews, oldViews) {
        if (newViews.length !== oldViews.length) return true;
        return newViews.some((_, i)=>!newViews[i].equals(oldViews[i]));
    }
}





const $13bad85ed5bba3fb$var$PERCENT_OR_PIXELS_REGEX = /([0-9]+\.?[0-9]*)(%|px)/;
function $13bad85ed5bba3fb$export$16d1640ef8464a10(value) {
    switch(typeof value){
        case "number":
            return {
                position: value,
                relative: false
            };
        case "string":
            const match = $13bad85ed5bba3fb$var$PERCENT_OR_PIXELS_REGEX.exec(value);
            if (match && match.length >= 3) {
                const relative = match[2] === "%";
                const position = parseFloat(match[1]);
                return {
                    position: relative ? position / 100 : position,
                    relative: relative
                };
            }
        default:
            throw new Error("Could not parse position string ".concat(value));
    }
}
function $13bad85ed5bba3fb$export$1690e12b840569b9(position, extent) {
    return position.relative ? Math.round(position.position * extent) : position.position;
}



function $828c58095cddb61a$export$2e2bcd8739ae039(condition, message) {
    if (!condition) throw new Error(message || "deck.gl: assertion failed.");
}


class $f435da35b0feb027$export$2e2bcd8739ae039 {
    constructor(props){
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "id", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "viewportInstance", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_x", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_y", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_width", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_height", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_padding", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "props", void 0);
        const { id: id , x: x = 0 , y: y = 0 , width: width = "100%" , height: height = "100%" , padding: padding = null , viewportInstance: viewportInstance  } = props || {};
        (0, $828c58095cddb61a$export$2e2bcd8739ae039)(!viewportInstance || viewportInstance instanceof (0, $bdb7668fd52e659a$export$2e2bcd8739ae039));
        this.viewportInstance = viewportInstance;
        this.id = id || this.constructor.displayName || "view";
        this.props = {
            ...props,
            id: this.id
        };
        this._x = (0, $13bad85ed5bba3fb$export$16d1640ef8464a10)(x);
        this._y = (0, $13bad85ed5bba3fb$export$16d1640ef8464a10)(y);
        this._width = (0, $13bad85ed5bba3fb$export$16d1640ef8464a10)(width);
        this._height = (0, $13bad85ed5bba3fb$export$16d1640ef8464a10)(height);
        this._padding = padding && {
            left: (0, $13bad85ed5bba3fb$export$16d1640ef8464a10)(padding.left || 0),
            right: (0, $13bad85ed5bba3fb$export$16d1640ef8464a10)(padding.right || 0),
            top: (0, $13bad85ed5bba3fb$export$16d1640ef8464a10)(padding.top || 0),
            bottom: (0, $13bad85ed5bba3fb$export$16d1640ef8464a10)(padding.bottom || 0)
        };
        this.equals = this.equals.bind(this);
        Object.seal(this);
    }
    equals(view) {
        if (this === view) return true;
        if (this.viewportInstance) return view.viewportInstance ? this.viewportInstance.equals(view.viewportInstance) : false;
        return this.ViewportType === view.ViewportType && (0, $70a948cba88c73a3$export$9cb4719e2e525b7a)(this.props, view.props);
    }
    makeViewport({ width: width , height: height , viewState: viewState  }) {
        if (this.viewportInstance) return this.viewportInstance;
        viewState = this.filterViewState(viewState);
        const viewportDimensions = this.getDimensions({
            width: width,
            height: height
        });
        return new this.ViewportType({
            ...viewState,
            ...this.props,
            ...viewportDimensions
        });
    }
    getViewStateId() {
        const { viewState: viewState  } = this.props;
        if (typeof viewState === "string") return viewState;
        return (viewState === null || viewState === void 0 ? void 0 : viewState.id) || this.id;
    }
    filterViewState(viewState) {
        if (this.props.viewState && typeof this.props.viewState === "object") {
            if (!this.props.viewState.id) return this.props.viewState;
            const newViewState = {
                ...viewState
            };
            for(const key in this.props.viewState)if (key !== "id") newViewState[key] = this.props.viewState[key];
            return newViewState;
        }
        return viewState;
    }
    getDimensions({ width: width , height: height  }) {
        const dimensions = {
            x: (0, $13bad85ed5bba3fb$export$1690e12b840569b9)(this._x, width),
            y: (0, $13bad85ed5bba3fb$export$1690e12b840569b9)(this._y, height),
            width: (0, $13bad85ed5bba3fb$export$1690e12b840569b9)(this._width, width),
            height: (0, $13bad85ed5bba3fb$export$1690e12b840569b9)(this._height, height)
        };
        if (this._padding) dimensions.padding = {
            left: (0, $13bad85ed5bba3fb$export$1690e12b840569b9)(this._padding.left, width),
            top: (0, $13bad85ed5bba3fb$export$1690e12b840569b9)(this._padding.top, height),
            right: (0, $13bad85ed5bba3fb$export$1690e12b840569b9)(this._padding.right, width),
            bottom: (0, $13bad85ed5bba3fb$export$1690e12b840569b9)(this._padding.bottom, height)
        };
        return dimensions;
    }
    get controller() {
        const opts = this.props.controller;
        if (!opts) return null;
        if (opts === true) return {
            type: this.ControllerType
        };
        if (typeof opts === "function") return {
            type: opts
        };
        return {
            type: this.ControllerType,
            ...opts
        };
    }
}







const $4ac7d89cb7f1c4ad$var$TILE_SIZE = 512;
const $4ac7d89cb7f1c4ad$var$EARTH_CIRCUMFERENCE = 40.03e6;
const $4ac7d89cb7f1c4ad$var$DEGREES_TO_RADIANS = Math.PI / 180;
function $4ac7d89cb7f1c4ad$var$unitsPerMeter(latitude) {
    const latCosine = Math.cos(latitude * $4ac7d89cb7f1c4ad$var$DEGREES_TO_RADIANS);
    return $4ac7d89cb7f1c4ad$var$TILE_SIZE / $4ac7d89cb7f1c4ad$var$EARTH_CIRCUMFERENCE / latCosine;
}
class $4ac7d89cb7f1c4ad$export$2e2bcd8739ae039 extends (0, $bdb7668fd52e659a$export$2e2bcd8739ae039) {
    constructor(opts = {}){
        const { latitude: latitude = 0 , longitude: longitude = 0 , zoom: zoom = 0 , pitch: pitch = 0 , bearing: bearing = 0 , nearZMultiplier: nearZMultiplier = 0.1 , farZMultiplier: farZMultiplier = 1.01 , orthographic: orthographic = false , projectionMatrix: projectionMatrix , repeat: repeat = false , worldOffset: worldOffset = 0 , legacyMeterSizes: legacyMeterSizes = false  } = opts;
        let { width: width , height: height , altitude: altitude = 1.5  } = opts;
        const scale = Math.pow(2, zoom);
        width = width || 1;
        height = height || 1;
        let fovy;
        let projectionParameters = null;
        if (projectionMatrix) {
            altitude = projectionMatrix[5] / 2;
            fovy = (0, $f5ef504cb5091e21$export$4b02e2005c3c5cc)(altitude);
        } else {
            if (opts.fovy) {
                fovy = opts.fovy;
                altitude = (0, $f5ef504cb5091e21$export$2e0715d5da7e224d)(fovy);
            } else fovy = (0, $f5ef504cb5091e21$export$4b02e2005c3c5cc)(altitude);
            projectionParameters = (0, $f5ef504cb5091e21$export$3debb7b92b597428)({
                width: width,
                height: height,
                pitch: pitch,
                fovy: fovy,
                nearZMultiplier: nearZMultiplier,
                farZMultiplier: farZMultiplier
            });
        }
        let viewMatrixUncentered = (0, $f5ef504cb5091e21$export$a4dee078b9284944)({
            height: height,
            pitch: pitch,
            bearing: bearing,
            scale: scale,
            altitude: altitude
        });
        if (worldOffset) {
            const viewOffset = new (0, $16800f0dff513c4e$export$2e2bcd8739ae039)().translate([
                512 * worldOffset,
                0,
                0
            ]);
            viewMatrixUncentered = viewOffset.multiplyLeft(viewMatrixUncentered);
        }
        super({
            ...opts,
            width: width,
            height: height,
            viewMatrix: viewMatrixUncentered,
            longitude: longitude,
            latitude: latitude,
            zoom: zoom,
            ...projectionParameters,
            fovy: fovy,
            focalDistance: altitude
        });
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "longitude", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "latitude", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "pitch", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "bearing", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "altitude", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "fovy", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "orthographic", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_subViewports", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_pseudoMeters", void 0);
        this.latitude = latitude;
        this.longitude = longitude;
        this.zoom = zoom;
        this.pitch = pitch;
        this.bearing = bearing;
        this.altitude = altitude;
        this.fovy = fovy;
        this.orthographic = orthographic;
        this._subViewports = repeat ? [] : null;
        this._pseudoMeters = legacyMeterSizes;
        Object.freeze(this);
    }
    get subViewports() {
        if (this._subViewports && !this._subViewports.length) {
            const bounds = this.getBounds();
            const minOffset = Math.floor((bounds[0] + 180) / 360);
            const maxOffset = Math.ceil((bounds[2] - 180) / 360);
            for(let x = minOffset; x <= maxOffset; x++){
                const offsetViewport = x ? new $4ac7d89cb7f1c4ad$export$2e2bcd8739ae039({
                    ...this,
                    worldOffset: x
                }) : this;
                this._subViewports.push(offsetViewport);
            }
        }
        return this._subViewports;
    }
    projectPosition(xyz) {
        if (this._pseudoMeters) return super.projectPosition(xyz);
        const [X, Y] = this.projectFlat(xyz);
        const Z = (xyz[2] || 0) * $4ac7d89cb7f1c4ad$var$unitsPerMeter(xyz[1]);
        return [
            X,
            Y,
            Z
        ];
    }
    unprojectPosition(xyz) {
        if (this._pseudoMeters) return super.unprojectPosition(xyz);
        const [X, Y] = this.unprojectFlat(xyz);
        const Z = (xyz[2] || 0) / $4ac7d89cb7f1c4ad$var$unitsPerMeter(Y);
        return [
            X,
            Y,
            Z
        ];
    }
    addMetersToLngLat(lngLatZ, xyz) {
        return (0, $f5ef504cb5091e21$export$86ab4399faf187a8)(lngLatZ, xyz);
    }
    panByPosition(coords, pixel) {
        const fromLocation = (0, $f5ef504cb5091e21$export$d0eff18eb06add5f)(pixel, this.pixelUnprojectionMatrix);
        const toLocation = this.projectFlat(coords);
        const translate = $fceb3370258170b6$export$e16d8520af44a096([], toLocation, $fceb3370258170b6$export$aef51622e549b8b0([], fromLocation));
        const newCenter = $fceb3370258170b6$export$e16d8520af44a096([], this.center, translate);
        const [longitude, latitude] = this.unprojectFlat(newCenter);
        return {
            longitude: longitude,
            latitude: latitude
        };
    }
    getBounds(options = {}) {
        const corners = (0, $0c06f6449ce0cec0$export$2e2bcd8739ae039)(this, options.z || 0);
        return [
            Math.min(corners[0][0], corners[1][0], corners[2][0], corners[3][0]),
            Math.min(corners[0][1], corners[1][1], corners[2][1], corners[3][1]),
            Math.max(corners[0][0], corners[1][0], corners[2][0], corners[3][0]),
            Math.max(corners[0][1], corners[1][1], corners[2][1], corners[3][1])
        ];
    }
    fitBounds(bounds, options = {}) {
        const { width: width , height: height  } = this;
        const { longitude: longitude , latitude: latitude , zoom: zoom  } = (0, $7401923064b435ee$export$2e2bcd8739ae039)({
            width: width,
            height: height,
            bounds: bounds,
            ...options
        });
        return new $4ac7d89cb7f1c4ad$export$2e2bcd8739ae039({
            width: width,
            height: height,
            longitude: longitude,
            latitude: latitude,
            zoom: zoom
        });
    }
}
(0, $037483d1fb5deac8$export$2e2bcd8739ae039)($4ac7d89cb7f1c4ad$export$2e2bcd8739ae039, "displayName", "WebMercatorViewport");







class $c302e779b9092c62$export$2e2bcd8739ae039 {
    constructor(timeline){
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_inProgress", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_handle", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_timeline", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "time", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "settings", void 0);
        this._inProgress = false;
        this._handle = null;
        this._timeline = timeline;
        this.time = 0;
        this.settings = {
            duration: 0
        };
    }
    get inProgress() {
        return this._inProgress;
    }
    start(settings) {
        var _this$settings$onStar, _this$settings;
        this.cancel();
        this.settings = settings;
        this._inProgress = true;
        (_this$settings$onStar = (_this$settings = this.settings).onStart) === null || _this$settings$onStar === void 0 || _this$settings$onStar.call(_this$settings, this);
    }
    end() {
        if (this._inProgress) {
            var _this$settings$onEnd, _this$settings2;
            this._timeline.removeChannel(this._handle);
            this._handle = null;
            this._inProgress = false;
            (_this$settings$onEnd = (_this$settings2 = this.settings).onEnd) === null || _this$settings$onEnd === void 0 || _this$settings$onEnd.call(_this$settings2, this);
        }
    }
    cancel() {
        if (this._inProgress) {
            var _this$settings$onInte, _this$settings3;
            (_this$settings$onInte = (_this$settings3 = this.settings).onInterrupt) === null || _this$settings$onInte === void 0 || _this$settings$onInte.call(_this$settings3, this);
            this._timeline.removeChannel(this._handle);
            this._handle = null;
            this._inProgress = false;
        }
    }
    update() {
        var _this$settings$onUpda, _this$settings4;
        if (!this._inProgress) return false;
        if (this._handle === null) {
            const { _timeline: timeline , settings: settings  } = this;
            this._handle = timeline.addChannel({
                delay: timeline.getTime(),
                duration: settings.duration
            });
        }
        this.time = this._timeline.getTime(this._handle);
        this._onUpdate();
        (_this$settings$onUpda = (_this$settings4 = this.settings).onUpdate) === null || _this$settings$onUpda === void 0 || _this$settings$onUpda.call(_this$settings4, this);
        if (this._timeline.isFinished(this._handle)) this.end();
        return true;
    }
    _onUpdate() {}
}


const $0c98ca1748d9c859$var$noop = ()=>{};
const $0c98ca1748d9c859$export$71599bdd9f367e95 = {
    BREAK: 1,
    SNAP_TO_END: 2,
    IGNORE: 3
};
const $0c98ca1748d9c859$var$DEFAULT_EASING = (t)=>t;
const $0c98ca1748d9c859$var$DEFAULT_INTERRUPTION = $0c98ca1748d9c859$export$71599bdd9f367e95.BREAK;
class $0c98ca1748d9c859$export$2e2bcd8739ae039 {
    constructor(opts){
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "getControllerState", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "props", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "propsInTransition", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "transition", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "onViewStateChange", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "onStateChange", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_onTransitionUpdate", (transition)=>{
            const { time: time , settings: { interpolator: interpolator , startProps: startProps , endProps: endProps , duration: duration , easing: easing  }  } = transition;
            const t = easing(time / duration);
            const viewport = interpolator.interpolateProps(startProps, endProps, t);
            this.propsInTransition = this.getControllerState({
                ...this.props,
                ...viewport
            }).getViewportProps();
            this.onViewStateChange({
                viewState: this.propsInTransition,
                oldViewState: this.props
            });
        });
        this.getControllerState = opts.getControllerState;
        this.propsInTransition = null;
        this.transition = new (0, $c302e779b9092c62$export$2e2bcd8739ae039)(opts.timeline);
        this.onViewStateChange = opts.onViewStateChange || $0c98ca1748d9c859$var$noop;
        this.onStateChange = opts.onStateChange || $0c98ca1748d9c859$var$noop;
    }
    finalize() {
        this.transition.cancel();
    }
    getViewportInTransition() {
        return this.propsInTransition;
    }
    processViewStateChange(nextProps) {
        let transitionTriggered = false;
        const currentProps = this.props;
        this.props = nextProps;
        if (!currentProps || this._shouldIgnoreViewportChange(currentProps, nextProps)) return false;
        if (this._isTransitionEnabled(nextProps)) {
            let startProps = currentProps;
            if (this.transition.inProgress) {
                const { interruption: interruption , endProps: endProps  } = this.transition.settings;
                startProps = {
                    ...currentProps,
                    ...interruption === $0c98ca1748d9c859$export$71599bdd9f367e95.SNAP_TO_END ? endProps : this.propsInTransition || currentProps
                };
            }
            this._triggerTransition(startProps, nextProps);
            transitionTriggered = true;
        } else this.transition.cancel();
        return transitionTriggered;
    }
    updateTransition() {
        this.transition.update();
    }
    _isTransitionEnabled(props) {
        const { transitionDuration: transitionDuration , transitionInterpolator: transitionInterpolator  } = props;
        return (transitionDuration > 0 || transitionDuration === "auto") && Boolean(transitionInterpolator);
    }
    _isUpdateDueToCurrentTransition(props) {
        if (this.transition.inProgress && this.propsInTransition) return this.transition.settings.interpolator.arePropsEqual(props, this.propsInTransition);
        return false;
    }
    _shouldIgnoreViewportChange(currentProps, nextProps) {
        if (this.transition.inProgress) return this.transition.settings.interruption === $0c98ca1748d9c859$export$71599bdd9f367e95.IGNORE || this._isUpdateDueToCurrentTransition(nextProps);
        if (this._isTransitionEnabled(nextProps)) return nextProps.transitionInterpolator.arePropsEqual(currentProps, nextProps);
        return true;
    }
    _triggerTransition(startProps, endProps) {
        const startViewstate = this.getControllerState(startProps);
        const endViewStateProps = this.getControllerState(endProps).shortestPathFrom(startViewstate);
        const transitionInterpolator = endProps.transitionInterpolator;
        const duration = transitionInterpolator.getDuration ? transitionInterpolator.getDuration(startProps, endProps) : endProps.transitionDuration;
        if (duration === 0) return;
        const initialProps = transitionInterpolator.initializeProps(startProps, endViewStateProps);
        this.propsInTransition = {};
        const transitionSettings = {
            duration: duration,
            easing: endProps.transitionEasing || $0c98ca1748d9c859$var$DEFAULT_EASING,
            interpolator: transitionInterpolator,
            interruption: endProps.transitionInterruption || $0c98ca1748d9c859$var$DEFAULT_INTERRUPTION,
            startProps: initialProps.start,
            endProps: initialProps.end,
            onStart: endProps.onTransitionStart,
            onUpdate: this._onTransitionUpdate,
            onInterrupt: this._onTransitionEnd(endProps.onTransitionInterrupt),
            onEnd: this._onTransitionEnd(endProps.onTransitionEnd)
        };
        this.transition.start(transitionSettings);
        this.onStateChange({
            inTransition: true
        });
        this.updateTransition();
    }
    _onTransitionEnd(callback) {
        return (transition)=>{
            this.propsInTransition = null;
            this.onStateChange({
                inTransition: false,
                isZooming: false,
                isPanning: false,
                isRotating: false
            });
            callback === null || callback === void 0 || callback(transition);
        };
    }
}






class $f6e2f9eab4b10c8b$export$2e2bcd8739ae039 {
    constructor(opts){
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_propsToCompare", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_propsToExtract", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_requiredProps", void 0);
        const { compare: compare , extract: extract , required: required  } = opts;
        this._propsToCompare = compare;
        this._propsToExtract = extract || compare;
        this._requiredProps = required;
    }
    arePropsEqual(currentProps, nextProps) {
        for (const key of this._propsToCompare){
            if (!(key in currentProps) || !(key in nextProps) || !(0, $53a37c44451cea56$export$e9bab7fafb253603)(currentProps[key], nextProps[key])) return false;
        }
        return true;
    }
    initializeProps(startProps, endProps) {
        const startViewStateProps = {};
        const endViewStateProps = {};
        for (const key of this._propsToExtract)if (key in startProps || key in endProps) {
            startViewStateProps[key] = startProps[key];
            endViewStateProps[key] = endProps[key];
        }
        this._checkRequiredProps(startViewStateProps);
        this._checkRequiredProps(endViewStateProps);
        return {
            start: startViewStateProps,
            end: endViewStateProps
        };
    }
    getDuration(startProps, endProps) {
        return endProps.transitionDuration;
    }
    _checkRequiredProps(props) {
        if (!this._requiredProps) return;
        this._requiredProps.forEach((propName)=>{
            const value = props[propName];
            (0, $828c58095cddb61a$export$2e2bcd8739ae039)(Number.isFinite(value) || Array.isArray(value), "".concat(propName, " is required for transition"));
        });
    }
}



const $be3e6f41f904fd21$var$DEFAULT_PROPS = [
    "longitude",
    "latitude",
    "zoom",
    "bearing",
    "pitch"
];
const $be3e6f41f904fd21$var$DEFAULT_REQUIRED_PROPS = [
    "longitude",
    "latitude",
    "zoom"
];
class $be3e6f41f904fd21$export$2e2bcd8739ae039 extends (0, $f6e2f9eab4b10c8b$export$2e2bcd8739ae039) {
    constructor(opts = {}){
        const transitionProps = Array.isArray(opts) ? opts : opts.transitionProps;
        const normalizedOpts = Array.isArray(opts) ? {} : opts;
        normalizedOpts.transitionProps = Array.isArray(transitionProps) ? {
            compare: transitionProps,
            required: transitionProps
        } : transitionProps || {
            compare: $be3e6f41f904fd21$var$DEFAULT_PROPS,
            required: $be3e6f41f904fd21$var$DEFAULT_REQUIRED_PROPS
        };
        super(normalizedOpts.transitionProps);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "opts", void 0);
        this.opts = normalizedOpts;
    }
    initializeProps(startProps, endProps) {
        const result = super.initializeProps(startProps, endProps);
        const { makeViewport: makeViewport , around: around  } = this.opts;
        if (makeViewport && around) {
            const startViewport = makeViewport(startProps);
            const endViewport = makeViewport(endProps);
            const aroundPosition = startViewport.unproject(around);
            result.start.around = around;
            Object.assign(result.end, {
                around: endViewport.project(aroundPosition),
                aroundPosition: aroundPosition,
                width: endProps.width,
                height: endProps.height
            });
        }
        return result;
    }
    interpolateProps(startProps, endProps, t) {
        const propsInTransition = {};
        for (const key of this._propsToExtract)propsInTransition[key] = (0, $53a37c44451cea56$export$3a89f8d6f6bf6c9f)(startProps[key] || 0, endProps[key] || 0, t);
        if (endProps.aroundPosition && this.opts.makeViewport) {
            const viewport = this.opts.makeViewport({
                ...endProps,
                ...propsInTransition
            });
            Object.assign(propsInTransition, viewport.panByPosition(endProps.aroundPosition, (0, $53a37c44451cea56$export$3a89f8d6f6bf6c9f)(startProps.around, endProps.around, t)));
        }
        return propsInTransition;
    }
}


const $9a93059544335596$var$NO_TRANSITION_PROPS = {
    transitionDuration: 0
};
const $9a93059544335596$var$DEFAULT_INERTIA = 300;
const $9a93059544335596$var$INERTIA_EASING = (t)=>1 - (1 - t) * (1 - t);
const $9a93059544335596$var$EVENT_TYPES = {
    WHEEL: [
        "wheel"
    ],
    PAN: [
        "panstart",
        "panmove",
        "panend"
    ],
    PINCH: [
        "pinchstart",
        "pinchmove",
        "pinchend"
    ],
    TRIPLE_PAN: [
        "tripanstart",
        "tripanmove",
        "tripanend"
    ],
    DOUBLE_TAP: [
        "doubletap"
    ],
    KEYBOARD: [
        "keydown"
    ]
};
const $9a93059544335596$var$pinchEventWorkaround = {};
class $9a93059544335596$export$2e2bcd8739ae039 {
    constructor(opts){
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "props", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "state", {});
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "transitionManager", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "eventManager", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "onViewStateChange", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "onStateChange", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "makeViewport", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_controllerState", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_events", {});
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_interactionState", {
            isDragging: false
        });
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_customEvents", []);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_eventStartBlocked", null);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_panMove", false);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "invertPan", false);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "dragMode", "rotate");
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "inertia", 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "scrollZoom", true);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "dragPan", true);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "dragRotate", true);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "doubleClickZoom", true);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "touchZoom", true);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "touchRotate", false);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "keyboard", true);
        this.transitionManager = new (0, $0c98ca1748d9c859$export$2e2bcd8739ae039)({
            ...opts,
            getControllerState: (props)=>new this.ControllerState(props),
            onViewStateChange: this._onTransition.bind(this),
            onStateChange: this._setInteractionState.bind(this)
        });
        this.handleEvent = this.handleEvent.bind(this);
        this.eventManager = opts.eventManager;
        this.onViewStateChange = opts.onViewStateChange || (()=>{});
        this.onStateChange = opts.onStateChange || (()=>{});
        this.makeViewport = opts.makeViewport;
    }
    set events(customEvents) {
        this.toggleEvents(this._customEvents, false);
        this.toggleEvents(customEvents, true);
        this._customEvents = customEvents;
        if (this.props) this.setProps(this.props);
    }
    finalize() {
        for(const eventName in this._events)if (this._events[eventName]) {
            var _this$eventManager;
            (_this$eventManager = this.eventManager) === null || _this$eventManager === void 0 || _this$eventManager.off(eventName, this.handleEvent);
        }
        this.transitionManager.finalize();
    }
    handleEvent(event) {
        this._controllerState = undefined;
        const eventStartBlocked = this._eventStartBlocked;
        switch(event.type){
            case "panstart":
                return eventStartBlocked ? false : this._onPanStart(event);
            case "panmove":
                return this._onPan(event);
            case "panend":
                return this._onPanEnd(event);
            case "pinchstart":
                return eventStartBlocked ? false : this._onPinchStart(event);
            case "pinchmove":
                return this._onPinch(event);
            case "pinchend":
                return this._onPinchEnd(event);
            case "tripanstart":
                return eventStartBlocked ? false : this._onTriplePanStart(event);
            case "tripanmove":
                return this._onTriplePan(event);
            case "tripanend":
                return this._onTriplePanEnd(event);
            case "doubletap":
                return this._onDoubleTap(event);
            case "wheel":
                return this._onWheel(event);
            case "keydown":
                return this._onKeyDown(event);
            default:
                return false;
        }
    }
    get controllerState() {
        this._controllerState = this._controllerState || new this.ControllerState({
            makeViewport: this.makeViewport,
            ...this.props,
            ...this.state
        });
        return this._controllerState;
    }
    getCenter(event) {
        const { x: x , y: y  } = this.props;
        const { offsetCenter: offsetCenter  } = event;
        return [
            offsetCenter.x - x,
            offsetCenter.y - y
        ];
    }
    isPointInBounds(pos, event) {
        const { width: width , height: height  } = this.props;
        if (event && event.handled) return false;
        const inside = pos[0] >= 0 && pos[0] <= width && pos[1] >= 0 && pos[1] <= height;
        if (inside && event) event.stopPropagation();
        return inside;
    }
    isFunctionKeyPressed(event) {
        const { srcEvent: srcEvent  } = event;
        return Boolean(srcEvent.metaKey || srcEvent.altKey || srcEvent.ctrlKey || srcEvent.shiftKey);
    }
    isDragging() {
        return this._interactionState.isDragging || false;
    }
    blockEvents(timeout) {
        const timer = setTimeout(()=>{
            if (this._eventStartBlocked === timer) this._eventStartBlocked = null;
        }, timeout);
        this._eventStartBlocked = timer;
    }
    setProps(props) {
        if (props.dragMode) this.dragMode = props.dragMode;
        this.props = props;
        if (!("transitionInterpolator" in props)) props.transitionInterpolator = this._getTransitionProps().transitionInterpolator;
        this.transitionManager.processViewStateChange(props);
        const { inertia: inertia  } = props;
        this.inertia = Number.isFinite(inertia) ? inertia : inertia === true ? $9a93059544335596$var$DEFAULT_INERTIA : 0;
        const { scrollZoom: scrollZoom = true , dragPan: dragPan = true , dragRotate: dragRotate = true , doubleClickZoom: doubleClickZoom = true , touchZoom: touchZoom = true , touchRotate: touchRotate = false , keyboard: keyboard = true  } = props;
        const isInteractive = Boolean(this.onViewStateChange);
        this.toggleEvents($9a93059544335596$var$EVENT_TYPES.WHEEL, isInteractive && scrollZoom);
        this.toggleEvents($9a93059544335596$var$EVENT_TYPES.PAN, isInteractive && (dragPan || dragRotate));
        this.toggleEvents($9a93059544335596$var$EVENT_TYPES.PINCH, isInteractive && (touchZoom || touchRotate));
        this.toggleEvents($9a93059544335596$var$EVENT_TYPES.TRIPLE_PAN, isInteractive && touchRotate);
        this.toggleEvents($9a93059544335596$var$EVENT_TYPES.DOUBLE_TAP, isInteractive && doubleClickZoom);
        this.toggleEvents($9a93059544335596$var$EVENT_TYPES.KEYBOARD, isInteractive && keyboard);
        this.scrollZoom = scrollZoom;
        this.dragPan = dragPan;
        this.dragRotate = dragRotate;
        this.doubleClickZoom = doubleClickZoom;
        this.touchZoom = touchZoom;
        this.touchRotate = touchRotate;
        this.keyboard = keyboard;
    }
    updateTransition() {
        this.transitionManager.updateTransition();
    }
    toggleEvents(eventNames, enabled) {
        if (this.eventManager) eventNames.forEach((eventName)=>{
            if (this._events[eventName] !== enabled) {
                this._events[eventName] = enabled;
                if (enabled) this.eventManager.on(eventName, this.handleEvent);
                else this.eventManager.off(eventName, this.handleEvent);
            }
        });
    }
    updateViewport(newControllerState, extraProps = null, interactionState = {}) {
        const viewState = {
            ...newControllerState.getViewportProps(),
            ...extraProps
        };
        const changed = this.controllerState !== newControllerState;
        this.state = newControllerState.getState();
        this._setInteractionState(interactionState);
        if (changed) {
            const oldViewState = this.controllerState && this.controllerState.getViewportProps();
            if (this.onViewStateChange) this.onViewStateChange({
                viewState: viewState,
                interactionState: this._interactionState,
                oldViewState: oldViewState
            });
        }
    }
    _onTransition(params) {
        this.onViewStateChange({
            ...params,
            interactionState: this._interactionState
        });
    }
    _setInteractionState(newStates) {
        Object.assign(this._interactionState, newStates);
        this.onStateChange(this._interactionState);
    }
    _onPanStart(event) {
        const pos = this.getCenter(event);
        if (!this.isPointInBounds(pos, event)) return false;
        let alternateMode = this.isFunctionKeyPressed(event) || event.rightButton || false;
        if (this.invertPan || this.dragMode === "pan") alternateMode = !alternateMode;
        const newControllerState = this.controllerState[alternateMode ? "panStart" : "rotateStart"]({
            pos: pos
        });
        this._panMove = alternateMode;
        this.updateViewport(newControllerState, $9a93059544335596$var$NO_TRANSITION_PROPS, {
            isDragging: true
        });
        return true;
    }
    _onPan(event) {
        if (!this.isDragging()) return false;
        return this._panMove ? this._onPanMove(event) : this._onPanRotate(event);
    }
    _onPanEnd(event) {
        if (!this.isDragging()) return false;
        return this._panMove ? this._onPanMoveEnd(event) : this._onPanRotateEnd(event);
    }
    _onPanMove(event) {
        if (!this.dragPan) return false;
        const pos = this.getCenter(event);
        const newControllerState = this.controllerState.pan({
            pos: pos
        });
        this.updateViewport(newControllerState, $9a93059544335596$var$NO_TRANSITION_PROPS, {
            isDragging: true,
            isPanning: true
        });
        return true;
    }
    _onPanMoveEnd(event) {
        const { inertia: inertia  } = this;
        if (this.dragPan && inertia && event.velocity) {
            const pos = this.getCenter(event);
            const endPos = [
                pos[0] + event.velocityX * inertia / 2,
                pos[1] + event.velocityY * inertia / 2
            ];
            const newControllerState = this.controllerState.pan({
                pos: endPos
            }).panEnd();
            this.updateViewport(newControllerState, {
                ...this._getTransitionProps(),
                transitionDuration: inertia,
                transitionEasing: $9a93059544335596$var$INERTIA_EASING
            }, {
                isDragging: false,
                isPanning: true
            });
        } else {
            const newControllerState = this.controllerState.panEnd();
            this.updateViewport(newControllerState, null, {
                isDragging: false,
                isPanning: false
            });
        }
        return true;
    }
    _onPanRotate(event) {
        if (!this.dragRotate) return false;
        const pos = this.getCenter(event);
        const newControllerState = this.controllerState.rotate({
            pos: pos
        });
        this.updateViewport(newControllerState, $9a93059544335596$var$NO_TRANSITION_PROPS, {
            isDragging: true,
            isRotating: true
        });
        return true;
    }
    _onPanRotateEnd(event) {
        const { inertia: inertia  } = this;
        if (this.dragRotate && inertia && event.velocity) {
            const pos = this.getCenter(event);
            const endPos = [
                pos[0] + event.velocityX * inertia / 2,
                pos[1] + event.velocityY * inertia / 2
            ];
            const newControllerState = this.controllerState.rotate({
                pos: endPos
            }).rotateEnd();
            this.updateViewport(newControllerState, {
                ...this._getTransitionProps(),
                transitionDuration: inertia,
                transitionEasing: $9a93059544335596$var$INERTIA_EASING
            }, {
                isDragging: false,
                isRotating: true
            });
        } else {
            const newControllerState = this.controllerState.rotateEnd();
            this.updateViewport(newControllerState, null, {
                isDragging: false,
                isRotating: false
            });
        }
        return true;
    }
    _onWheel(event) {
        if (!this.scrollZoom) return false;
        event.srcEvent.preventDefault();
        const pos = this.getCenter(event);
        if (!this.isPointInBounds(pos, event)) return false;
        const { speed: speed = 0.01 , smooth: smooth = false  } = this.scrollZoom === true ? {} : this.scrollZoom;
        const { delta: delta  } = event;
        let scale = 2 / (1 + Math.exp(-Math.abs(delta * speed)));
        if (delta < 0 && scale !== 0) scale = 1 / scale;
        const newControllerState = this.controllerState.zoom({
            pos: pos,
            scale: scale
        });
        this.updateViewport(newControllerState, {
            ...this._getTransitionProps({
                around: pos
            }),
            transitionDuration: smooth ? 250 : 1
        }, {
            isZooming: true,
            isPanning: true
        });
        return true;
    }
    _onTriplePanStart(event) {
        const pos = this.getCenter(event);
        if (!this.isPointInBounds(pos, event)) return false;
        const newControllerState = this.controllerState.rotateStart({
            pos: pos
        });
        this.updateViewport(newControllerState, $9a93059544335596$var$NO_TRANSITION_PROPS, {
            isDragging: true
        });
        return true;
    }
    _onTriplePan(event) {
        if (!this.touchRotate) return false;
        if (!this.isDragging()) return false;
        const pos = this.getCenter(event);
        pos[0] -= event.deltaX;
        const newControllerState = this.controllerState.rotate({
            pos: pos
        });
        this.updateViewport(newControllerState, $9a93059544335596$var$NO_TRANSITION_PROPS, {
            isDragging: true,
            isRotating: true
        });
        return true;
    }
    _onTriplePanEnd(event) {
        if (!this.isDragging()) return false;
        const { inertia: inertia  } = this;
        if (this.touchRotate && inertia && event.velocityY) {
            const pos = this.getCenter(event);
            const endPos = [
                pos[0],
                pos[1] += event.velocityY * inertia / 2
            ];
            const newControllerState = this.controllerState.rotate({
                pos: endPos
            });
            this.updateViewport(newControllerState, {
                ...this._getTransitionProps(),
                transitionDuration: inertia,
                transitionEasing: $9a93059544335596$var$INERTIA_EASING
            }, {
                isDragging: false,
                isRotating: true
            });
            this.blockEvents(inertia);
        } else {
            const newControllerState = this.controllerState.rotateEnd();
            this.updateViewport(newControllerState, null, {
                isDragging: false,
                isRotating: false
            });
        }
        return true;
    }
    _onPinchStart(event) {
        const pos = this.getCenter(event);
        if (!this.isPointInBounds(pos, event)) return false;
        const newControllerState = this.controllerState.zoomStart({
            pos: pos
        }).rotateStart({
            pos: pos
        });
        $9a93059544335596$var$pinchEventWorkaround._startPinchRotation = event.rotation;
        $9a93059544335596$var$pinchEventWorkaround._lastPinchEvent = event;
        this.updateViewport(newControllerState, $9a93059544335596$var$NO_TRANSITION_PROPS, {
            isDragging: true
        });
        return true;
    }
    _onPinch(event) {
        if (!this.touchZoom && !this.touchRotate) return false;
        if (!this.isDragging()) return false;
        let newControllerState = this.controllerState;
        if (this.touchZoom) {
            const { scale: scale  } = event;
            const pos = this.getCenter(event);
            newControllerState = newControllerState.zoom({
                pos: pos,
                scale: scale
            });
        }
        if (this.touchRotate) {
            const { rotation: rotation  } = event;
            newControllerState = newControllerState.rotate({
                deltaAngleX: $9a93059544335596$var$pinchEventWorkaround._startPinchRotation - rotation
            });
        }
        this.updateViewport(newControllerState, $9a93059544335596$var$NO_TRANSITION_PROPS, {
            isDragging: true,
            isPanning: this.touchZoom,
            isZooming: this.touchZoom,
            isRotating: this.touchRotate
        });
        $9a93059544335596$var$pinchEventWorkaround._lastPinchEvent = event;
        return true;
    }
    _onPinchEnd(event) {
        if (!this.isDragging()) return false;
        const { inertia: inertia  } = this;
        const { _lastPinchEvent: _lastPinchEvent  } = $9a93059544335596$var$pinchEventWorkaround;
        if (this.touchZoom && inertia && _lastPinchEvent && event.scale !== _lastPinchEvent.scale) {
            const pos = this.getCenter(event);
            let newControllerState = this.controllerState.rotateEnd();
            const z = Math.log2(event.scale);
            const velocityZ = (z - Math.log2(_lastPinchEvent.scale)) / (event.deltaTime - _lastPinchEvent.deltaTime);
            const endScale = Math.pow(2, z + velocityZ * inertia / 2);
            newControllerState = newControllerState.zoom({
                pos: pos,
                scale: endScale
            }).zoomEnd();
            this.updateViewport(newControllerState, {
                ...this._getTransitionProps({
                    around: pos
                }),
                transitionDuration: inertia,
                transitionEasing: $9a93059544335596$var$INERTIA_EASING
            }, {
                isDragging: false,
                isPanning: this.touchZoom,
                isZooming: this.touchZoom,
                isRotating: false
            });
            this.blockEvents(inertia);
        } else {
            const newControllerState = this.controllerState.zoomEnd().rotateEnd();
            this.updateViewport(newControllerState, null, {
                isDragging: false,
                isPanning: false,
                isZooming: false,
                isRotating: false
            });
        }
        $9a93059544335596$var$pinchEventWorkaround._startPinchRotation = null;
        $9a93059544335596$var$pinchEventWorkaround._lastPinchEvent = null;
        return true;
    }
    _onDoubleTap(event) {
        if (!this.doubleClickZoom) return false;
        const pos = this.getCenter(event);
        if (!this.isPointInBounds(pos, event)) return false;
        const isZoomOut = this.isFunctionKeyPressed(event);
        const newControllerState = this.controllerState.zoom({
            pos: pos,
            scale: isZoomOut ? 0.5 : 2
        });
        this.updateViewport(newControllerState, this._getTransitionProps({
            around: pos
        }), {
            isZooming: true,
            isPanning: true
        });
        this.blockEvents(100);
        return true;
    }
    _onKeyDown(event) {
        if (!this.keyboard) return false;
        const funcKey = this.isFunctionKeyPressed(event);
        const { zoomSpeed: zoomSpeed , moveSpeed: moveSpeed , rotateSpeedX: rotateSpeedX , rotateSpeedY: rotateSpeedY  } = this.keyboard === true ? {} : this.keyboard;
        const { controllerState: controllerState  } = this;
        let newControllerState;
        const interactionState = {};
        switch(event.srcEvent.code){
            case "Minus":
                newControllerState = funcKey ? controllerState.zoomOut(zoomSpeed).zoomOut(zoomSpeed) : controllerState.zoomOut(zoomSpeed);
                interactionState.isZooming = true;
                break;
            case "Equal":
                newControllerState = funcKey ? controllerState.zoomIn(zoomSpeed).zoomIn(zoomSpeed) : controllerState.zoomIn(zoomSpeed);
                interactionState.isZooming = true;
                break;
            case "ArrowLeft":
                if (funcKey) {
                    newControllerState = controllerState.rotateLeft(rotateSpeedX);
                    interactionState.isRotating = true;
                } else {
                    newControllerState = controllerState.moveLeft(moveSpeed);
                    interactionState.isPanning = true;
                }
                break;
            case "ArrowRight":
                if (funcKey) {
                    newControllerState = controllerState.rotateRight(rotateSpeedX);
                    interactionState.isRotating = true;
                } else {
                    newControllerState = controllerState.moveRight(moveSpeed);
                    interactionState.isPanning = true;
                }
                break;
            case "ArrowUp":
                if (funcKey) {
                    newControllerState = controllerState.rotateUp(rotateSpeedY);
                    interactionState.isRotating = true;
                } else {
                    newControllerState = controllerState.moveUp(moveSpeed);
                    interactionState.isPanning = true;
                }
                break;
            case "ArrowDown":
                if (funcKey) {
                    newControllerState = controllerState.rotateDown(rotateSpeedY);
                    interactionState.isRotating = true;
                } else {
                    newControllerState = controllerState.moveDown(moveSpeed);
                    interactionState.isPanning = true;
                }
                break;
            default:
                return false;
        }
        this.updateViewport(newControllerState, this._getTransitionProps(), interactionState);
        return true;
    }
    _getTransitionProps(opts) {
        const { transition: transition  } = this;
        if (!transition || !transition.transitionInterpolator) return $9a93059544335596$var$NO_TRANSITION_PROPS;
        return opts ? {
            ...transition,
            transitionInterpolator: new (0, $be3e6f41f904fd21$export$2e2bcd8739ae039)({
                ...opts,
                ...transition.transitionInterpolator.opts,
                makeViewport: this.controllerState.makeViewport
            })
        } : transition;
    }
}



class $56f07b62de053c52$export$2e2bcd8739ae039 {
    constructor(props, state){
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_viewportProps", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_state", void 0);
        this._viewportProps = this.applyConstraints(props);
        this._state = state;
    }
    getViewportProps() {
        return this._viewportProps;
    }
    getState() {
        return this._state;
    }
}





const $67cdee9be4ca71e5$var$PITCH_MOUSE_THRESHOLD = 5;
const $67cdee9be4ca71e5$var$PITCH_ACCEL = 1.2;
class $67cdee9be4ca71e5$export$11a6af20c28b5410 extends (0, $56f07b62de053c52$export$2e2bcd8739ae039) {
    constructor(options){
        const { width: width , height: height , latitude: latitude , longitude: longitude , zoom: zoom , bearing: bearing = 0 , pitch: pitch = 0 , altitude: altitude = 1.5 , position: position = [
            0,
            0,
            0
        ] , maxZoom: maxZoom = 20 , minZoom: minZoom = 0 , maxPitch: maxPitch = 60 , minPitch: minPitch = 0 , startPanLngLat: startPanLngLat , startZoomLngLat: startZoomLngLat , startRotatePos: startRotatePos , startBearing: startBearing , startPitch: startPitch , startZoom: startZoom , normalize: normalize = true  } = options;
        (0, $828c58095cddb61a$export$2e2bcd8739ae039)(Number.isFinite(longitude));
        (0, $828c58095cddb61a$export$2e2bcd8739ae039)(Number.isFinite(latitude));
        (0, $828c58095cddb61a$export$2e2bcd8739ae039)(Number.isFinite(zoom));
        super({
            width: width,
            height: height,
            latitude: latitude,
            longitude: longitude,
            zoom: zoom,
            bearing: bearing,
            pitch: pitch,
            altitude: altitude,
            maxZoom: maxZoom,
            minZoom: minZoom,
            maxPitch: maxPitch,
            minPitch: minPitch,
            normalize: normalize,
            position: position
        }, {
            startPanLngLat: startPanLngLat,
            startZoomLngLat: startZoomLngLat,
            startRotatePos: startRotatePos,
            startBearing: startBearing,
            startPitch: startPitch,
            startZoom: startZoom
        });
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "makeViewport", void 0);
        this.makeViewport = options.makeViewport;
    }
    panStart({ pos: pos  }) {
        return this._getUpdatedState({
            startPanLngLat: this._unproject(pos)
        });
    }
    pan({ pos: pos , startPos: startPos  }) {
        const startPanLngLat = this.getState().startPanLngLat || this._unproject(startPos);
        if (!startPanLngLat) return this;
        const viewport = this.makeViewport(this.getViewportProps());
        const newProps = viewport.panByPosition(startPanLngLat, pos);
        return this._getUpdatedState(newProps);
    }
    panEnd() {
        return this._getUpdatedState({
            startPanLngLat: null
        });
    }
    rotateStart({ pos: pos  }) {
        return this._getUpdatedState({
            startRotatePos: pos,
            startBearing: this.getViewportProps().bearing,
            startPitch: this.getViewportProps().pitch
        });
    }
    rotate({ pos: pos , deltaAngleX: deltaAngleX = 0 , deltaAngleY: deltaAngleY = 0  }) {
        const { startRotatePos: startRotatePos , startBearing: startBearing , startPitch: startPitch  } = this.getState();
        if (!startRotatePos || startBearing === undefined || startPitch === undefined) return this;
        let newRotation;
        if (pos) newRotation = this._getNewRotation(pos, startRotatePos, startPitch, startBearing);
        else newRotation = {
            bearing: startBearing + deltaAngleX,
            pitch: startPitch + deltaAngleY
        };
        return this._getUpdatedState(newRotation);
    }
    rotateEnd() {
        return this._getUpdatedState({
            startBearing: null,
            startPitch: null
        });
    }
    zoomStart({ pos: pos  }) {
        return this._getUpdatedState({
            startZoomLngLat: this._unproject(pos),
            startZoom: this.getViewportProps().zoom
        });
    }
    zoom({ pos: pos , startPos: startPos , scale: scale  }) {
        let { startZoom: startZoom , startZoomLngLat: startZoomLngLat  } = this.getState();
        if (!startZoomLngLat) {
            startZoom = this.getViewportProps().zoom;
            startZoomLngLat = this._unproject(startPos) || this._unproject(pos);
        }
        if (!startZoomLngLat) return this;
        const { maxZoom: maxZoom , minZoom: minZoom  } = this.getViewportProps();
        let zoom = startZoom + Math.log2(scale);
        zoom = (0, $53a37c44451cea56$export$7d15b64cf5a3a4c4)(zoom, minZoom, maxZoom);
        const zoomedViewport = this.makeViewport({
            ...this.getViewportProps(),
            zoom: zoom
        });
        return this._getUpdatedState({
            zoom: zoom,
            ...zoomedViewport.panByPosition(startZoomLngLat, pos)
        });
    }
    zoomEnd() {
        return this._getUpdatedState({
            startZoomLngLat: null,
            startZoom: null
        });
    }
    zoomIn(speed = 2) {
        return this._zoomFromCenter(speed);
    }
    zoomOut(speed = 2) {
        return this._zoomFromCenter(1 / speed);
    }
    moveLeft(speed = 100) {
        return this._panFromCenter([
            speed,
            0
        ]);
    }
    moveRight(speed = 100) {
        return this._panFromCenter([
            -speed,
            0
        ]);
    }
    moveUp(speed = 100) {
        return this._panFromCenter([
            0,
            speed
        ]);
    }
    moveDown(speed = 100) {
        return this._panFromCenter([
            0,
            -speed
        ]);
    }
    rotateLeft(speed = 15) {
        return this._getUpdatedState({
            bearing: this.getViewportProps().bearing - speed
        });
    }
    rotateRight(speed = 15) {
        return this._getUpdatedState({
            bearing: this.getViewportProps().bearing + speed
        });
    }
    rotateUp(speed = 10) {
        return this._getUpdatedState({
            pitch: this.getViewportProps().pitch + speed
        });
    }
    rotateDown(speed = 10) {
        return this._getUpdatedState({
            pitch: this.getViewportProps().pitch - speed
        });
    }
    shortestPathFrom(viewState) {
        const fromProps = viewState.getViewportProps();
        const props = {
            ...this.getViewportProps()
        };
        const { bearing: bearing , longitude: longitude  } = props;
        if (Math.abs(bearing - fromProps.bearing) > 180) props.bearing = bearing < 0 ? bearing + 360 : bearing - 360;
        if (Math.abs(longitude - fromProps.longitude) > 180) props.longitude = longitude < 0 ? longitude + 360 : longitude - 360;
        return props;
    }
    applyConstraints(props) {
        const { maxZoom: maxZoom , minZoom: minZoom , zoom: zoom  } = props;
        props.zoom = (0, $53a37c44451cea56$export$7d15b64cf5a3a4c4)(zoom, minZoom, maxZoom);
        const { maxPitch: maxPitch , minPitch: minPitch , pitch: pitch  } = props;
        props.pitch = (0, $53a37c44451cea56$export$7d15b64cf5a3a4c4)(pitch, minPitch, maxPitch);
        const { normalize: normalize = true  } = props;
        if (normalize) Object.assign(props, (0, $a727f0775314f814$export$2e2bcd8739ae039)(props));
        return props;
    }
    _zoomFromCenter(scale) {
        const { width: width , height: height  } = this.getViewportProps();
        return this.zoom({
            pos: [
                width / 2,
                height / 2
            ],
            scale: scale
        });
    }
    _panFromCenter(offset) {
        const { width: width , height: height  } = this.getViewportProps();
        return this.pan({
            startPos: [
                width / 2,
                height / 2
            ],
            pos: [
                width / 2 + offset[0],
                height / 2 + offset[1]
            ]
        });
    }
    _getUpdatedState(newProps) {
        return new this.constructor({
            makeViewport: this.makeViewport,
            ...this.getViewportProps(),
            ...this.getState(),
            ...newProps
        });
    }
    _unproject(pos) {
        const viewport = this.makeViewport(this.getViewportProps());
        return pos && viewport.unproject(pos);
    }
    _getNewRotation(pos, startPos, startPitch, startBearing) {
        const deltaX = pos[0] - startPos[0];
        const deltaY = pos[1] - startPos[1];
        const centerY = pos[1];
        const startY = startPos[1];
        const { width: width , height: height  } = this.getViewportProps();
        const deltaScaleX = deltaX / width;
        let deltaScaleY = 0;
        if (deltaY > 0) {
            if (Math.abs(height - startY) > $67cdee9be4ca71e5$var$PITCH_MOUSE_THRESHOLD) deltaScaleY = deltaY / (startY - height) * $67cdee9be4ca71e5$var$PITCH_ACCEL;
        } else if (deltaY < 0) {
            if (startY > $67cdee9be4ca71e5$var$PITCH_MOUSE_THRESHOLD) deltaScaleY = 1 - centerY / startY;
        }
        deltaScaleY = (0, $53a37c44451cea56$export$7d15b64cf5a3a4c4)(deltaScaleY, -1, 1);
        const { minPitch: minPitch , maxPitch: maxPitch  } = this.getViewportProps();
        const bearing = startBearing + 180 * deltaScaleX;
        let pitch = startPitch;
        if (deltaScaleY > 0) pitch = startPitch + deltaScaleY * (maxPitch - startPitch);
        else if (deltaScaleY < 0) pitch = startPitch - deltaScaleY * (minPitch - startPitch);
        return {
            pitch: pitch,
            bearing: bearing
        };
    }
}
class $67cdee9be4ca71e5$export$2e2bcd8739ae039 extends (0, $9a93059544335596$export$2e2bcd8739ae039) {
    constructor(...args){
        super(...args);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "ControllerState", $67cdee9be4ca71e5$export$11a6af20c28b5410);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "transition", {
            transitionDuration: 300,
            transitionInterpolator: new (0, $be3e6f41f904fd21$export$2e2bcd8739ae039)({
                transitionProps: {
                    compare: [
                        "longitude",
                        "latitude",
                        "zoom",
                        "bearing",
                        "pitch",
                        "position"
                    ],
                    required: [
                        "longitude",
                        "latitude",
                        "zoom"
                    ]
                }
            })
        });
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "dragMode", "pan");
    }
    setProps(props) {
        props.position = props.position || [
            0,
            0,
            0
        ];
        const oldProps = this.props;
        super.setProps(props);
        const dimensionChanged = !oldProps || oldProps.height !== props.height;
        if (dimensionChanged) this.updateViewport(new this.ControllerState({
            makeViewport: this.makeViewport,
            ...props,
            ...this.state
        }));
    }
}


class $d73daa375e65bcb3$export$2e2bcd8739ae039 extends (0, $f435da35b0feb027$export$2e2bcd8739ae039) {
    get ViewportType() {
        return 0, $4ac7d89cb7f1c4ad$export$2e2bcd8739ae039;
    }
    get ControllerType() {
        return 0, $67cdee9be4ca71e5$export$2e2bcd8739ae039;
    }
}
(0, $037483d1fb5deac8$export$2e2bcd8739ae039)($d73daa375e65bcb3$export$2e2bcd8739ae039, "displayName", "MapView");







const $f48ccf05d22c92a4$var$DEFAULT_LIGHT_COLOR = [
    255,
    255,
    255
];
const $f48ccf05d22c92a4$var$DEFAULT_LIGHT_INTENSITY = 1.0;
let $f48ccf05d22c92a4$var$idCount = 0;
class $f48ccf05d22c92a4$export$af279bfef9ec2c96 {
    constructor(props = {}){
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "id", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "color", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "intensity", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "type", "ambient");
        const { color: color = $f48ccf05d22c92a4$var$DEFAULT_LIGHT_COLOR  } = props;
        const { intensity: intensity = $f48ccf05d22c92a4$var$DEFAULT_LIGHT_INTENSITY  } = props;
        this.id = props.id || "ambient-".concat($f48ccf05d22c92a4$var$idCount++);
        this.color = color;
        this.intensity = intensity;
    }
}




const $26151c4aae5387e4$var$DEFAULT_LIGHT_COLOR = [
    255,
    255,
    255
];
const $26151c4aae5387e4$var$DEFAULT_LIGHT_INTENSITY = 1.0;
const $26151c4aae5387e4$var$DEFAULT_LIGHT_DIRECTION = [
    0.0,
    0.0,
    -1
];
let $26151c4aae5387e4$var$idCount = 0;
class $26151c4aae5387e4$export$3fea33cc9972c868 {
    constructor(props = {}){
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "id", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "color", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "intensity", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "type", "directional");
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "direction", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "shadow", void 0);
        const { color: color = $26151c4aae5387e4$var$DEFAULT_LIGHT_COLOR  } = props;
        const { intensity: intensity = $26151c4aae5387e4$var$DEFAULT_LIGHT_INTENSITY  } = props;
        const { direction: direction = $26151c4aae5387e4$var$DEFAULT_LIGHT_DIRECTION  } = props;
        const { _shadow: _shadow = false  } = props;
        this.id = props.id || "directional-".concat($26151c4aae5387e4$var$idCount++);
        this.color = color;
        this.intensity = intensity;
        this.type = "directional";
        this.direction = new (0, $9c6695c39a874609$export$2e2bcd8739ae039)(direction).normalize().toArray();
        this.shadow = _shadow;
    }
    getProjectedLight(opts) {
        return this;
    }
}





class $9818e5fdfdc2540b$export$2e2bcd8739ae039 {
    constructor(gl, props = {
        id: "pass"
    }){
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "id", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "gl", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "props", void 0);
        const { id: id  } = props;
        this.id = id;
        this.gl = gl;
        this.props = {
            ...props
        };
    }
    setProps(props) {
        Object.assign(this.props, props);
    }
    render(params) {}
    cleanup() {}
}



class $b1756d854624bf2b$export$2e2bcd8739ae039 extends (0, $9818e5fdfdc2540b$export$2e2bcd8739ae039) {
    render(options) {
        const gl = this.gl;
        (0, $54220aa8b6471f1a$export$60752c4a8a24d484)(gl, {
            framebuffer: options.target
        });
        return this._drawLayers(options);
    }
    _drawLayers(options) {
        const { target: target , moduleParameters: moduleParameters , viewports: viewports , views: views , onViewportActive: onViewportActive , clearCanvas: clearCanvas = true  } = options;
        options.pass = options.pass || "unknown";
        const gl = this.gl;
        if (clearCanvas) $b1756d854624bf2b$var$clearGLCanvas(gl);
        const renderStats = [];
        for (const viewport of viewports){
            const view = views && views[viewport.id];
            onViewportActive(viewport);
            const drawLayerParams = this._getDrawLayerParams(viewport, options);
            const subViewports = viewport.subViewports || [
                viewport
            ];
            for (const subViewport of subViewports){
                const stats = this._drawLayersInViewport(gl, {
                    target: target,
                    moduleParameters: moduleParameters,
                    viewport: subViewport,
                    view: view,
                    pass: options.pass,
                    layers: options.layers
                }, drawLayerParams);
                renderStats.push(stats);
            }
        }
        return renderStats;
    }
    _getDrawLayerParams(viewport, { layers: layers , pass: pass , layerFilter: layerFilter , cullRect: cullRect , effects: effects , moduleParameters: moduleParameters  }) {
        const drawLayerParams = [];
        const indexResolver = $b1756d854624bf2b$export$8510ed7ba103de75();
        const drawContext = {
            layer: layers[0],
            viewport: viewport,
            isPicking: pass.startsWith("picking"),
            renderPass: pass,
            cullRect: cullRect
        };
        const layerFilterCache = {};
        for(let layerIndex = 0; layerIndex < layers.length; layerIndex++){
            const layer = layers[layerIndex];
            const shouldDrawLayer = this._shouldDrawLayer(layer, drawContext, layerFilter, layerFilterCache);
            const layerParam = {
                shouldDrawLayer: shouldDrawLayer
            };
            if (shouldDrawLayer) {
                layerParam.layerRenderIndex = indexResolver(layer, shouldDrawLayer);
                layerParam.moduleParameters = this._getModuleParameters(layer, effects, pass, moduleParameters);
                layerParam.layerParameters = this.getLayerParameters(layer, layerIndex, viewport);
            }
            drawLayerParams[layerIndex] = layerParam;
        }
        return drawLayerParams;
    }
    _drawLayersInViewport(gl, { layers: layers , moduleParameters: globalModuleParameters , pass: pass , target: target , viewport: viewport , view: view  }, drawLayerParams) {
        const glViewport = $b1756d854624bf2b$var$getGLViewport(gl, {
            moduleParameters: globalModuleParameters,
            target: target,
            viewport: viewport
        });
        if (view && view.props.clear) {
            const clearOpts = view.props.clear === true ? {
                color: true,
                depth: true
            } : view.props.clear;
            (0, $54220aa8b6471f1a$export$b1e7058a2936b651)(gl, {
                scissorTest: true,
                scissor: glViewport
            }, ()=>(0, $9d2da77370080708$export$42ffd38884aecdac)(gl, clearOpts));
        }
        const renderStatus = {
            totalCount: layers.length,
            visibleCount: 0,
            compositeCount: 0,
            pickableCount: 0
        };
        (0, $54220aa8b6471f1a$export$60752c4a8a24d484)(gl, {
            viewport: glViewport
        });
        for(let layerIndex = 0; layerIndex < layers.length; layerIndex++){
            const layer = layers[layerIndex];
            const { shouldDrawLayer: shouldDrawLayer , layerRenderIndex: layerRenderIndex , moduleParameters: moduleParameters , layerParameters: layerParameters  } = drawLayerParams[layerIndex];
            if (shouldDrawLayer && layer.props.pickable) renderStatus.pickableCount++;
            if (layer.isComposite) renderStatus.compositeCount++;
            else if (shouldDrawLayer) {
                renderStatus.visibleCount++;
                moduleParameters.viewport = viewport;
                try {
                    layer._drawLayer({
                        moduleParameters: moduleParameters,
                        uniforms: {
                            layerIndex: layerRenderIndex
                        },
                        parameters: layerParameters
                    });
                } catch (err) {
                    layer.raiseError(err, "drawing ".concat(layer, " to ").concat(pass));
                }
            }
        }
        return renderStatus;
    }
    shouldDrawLayer(layer) {
        return true;
    }
    getModuleParameters(layer, effects) {
        return null;
    }
    getLayerParameters(layer, layerIndex, viewport) {
        return layer.props.parameters;
    }
    _shouldDrawLayer(layer, drawContext, layerFilter, layerFilterCache) {
        const shouldDrawLayer = layer.props.visible && this.shouldDrawLayer(layer);
        if (!shouldDrawLayer) return false;
        drawContext.layer = layer;
        let parent = layer.parent;
        while(parent){
            if (!parent.props.visible || !parent.filterSubLayer(drawContext)) return false;
            drawContext.layer = parent;
            parent = parent.parent;
        }
        if (layerFilter) {
            const rootLayerId = drawContext.layer.id;
            if (!(rootLayerId in layerFilterCache)) layerFilterCache[rootLayerId] = layerFilter(drawContext);
            if (!layerFilterCache[rootLayerId]) return false;
        }
        layer.activateViewport(drawContext.viewport);
        return true;
    }
    _getModuleParameters(layer, effects, pass, overrides) {
        var _layer$internalState;
        const moduleParameters = Object.assign(Object.create(((_layer$internalState = layer.internalState) === null || _layer$internalState === void 0 ? void 0 : _layer$internalState.propsInTransition) || layer.props), {
            autoWrapLongitude: layer.wrapLongitude,
            viewport: layer.context.viewport,
            mousePosition: layer.context.mousePosition,
            pickingActive: 0,
            devicePixelRatio: (0, $294e503c6396a3ff$export$df40057290e74703)(this.gl)
        });
        if (effects) for (const effect of effects){
            var _effect$getModulePara;
            Object.assign(moduleParameters, (_effect$getModulePara = effect.getModuleParameters) === null || _effect$getModulePara === void 0 ? void 0 : _effect$getModulePara.call(effect, layer));
        }
        return Object.assign(moduleParameters, this.getModuleParameters(layer, effects), overrides);
    }
}
function $b1756d854624bf2b$export$8510ed7ba103de75(startIndex = 0, layerIndices = {}) {
    const resolvers = {};
    const resolveLayerIndex = (layer, isDrawn)=>{
        const indexOverride = layer.props._offset;
        const layerId = layer.id;
        const parentId = layer.parent && layer.parent.id;
        let index;
        if (parentId && !(parentId in layerIndices)) resolveLayerIndex(layer.parent, false);
        if (parentId in resolvers) {
            const resolver = resolvers[parentId] = resolvers[parentId] || $b1756d854624bf2b$export$8510ed7ba103de75(layerIndices[parentId], layerIndices);
            index = resolver(layer, isDrawn);
            resolvers[layerId] = resolver;
        } else if (Number.isFinite(indexOverride)) {
            index = indexOverride + (layerIndices[parentId] || 0);
            resolvers[layerId] = null;
        } else index = startIndex;
        if (isDrawn && index >= startIndex) startIndex = index + 1;
        layerIndices[layerId] = index;
        return index;
    };
    return resolveLayerIndex;
}
function $b1756d854624bf2b$var$getGLViewport(gl, { moduleParameters: moduleParameters , target: target , viewport: viewport  }) {
    const useTarget = target && target.id !== "default-framebuffer";
    const pixelRatio = moduleParameters && moduleParameters.devicePixelRatio || (0, $294e503c6396a3ff$export$df40057290e74703)(gl);
    const height = useTarget ? target.height : gl.drawingBufferHeight;
    const dimensions = viewport;
    return [
        dimensions.x * pixelRatio,
        height - (dimensions.y + dimensions.height) * pixelRatio,
        dimensions.width * pixelRatio,
        dimensions.height * pixelRatio
    ];
}
function $b1756d854624bf2b$var$clearGLCanvas(gl) {
    const width = gl.drawingBufferWidth;
    const height = gl.drawingBufferHeight;
    (0, $54220aa8b6471f1a$export$60752c4a8a24d484)(gl, {
        viewport: [
            0,
            0,
            width,
            height
        ]
    });
    gl.clear(16640);
}



class $82ba7828a81ad8c8$export$2e2bcd8739ae039 extends (0, $b1756d854624bf2b$export$2e2bcd8739ae039) {
    constructor(gl, props){
        super(gl, props);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "shadowMap", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "depthBuffer", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "fbo", void 0);
        this.shadowMap = new (0, $df31c887249e3faa$export$2e2bcd8739ae039)(gl, {
            width: 1,
            height: 1,
            parameters: {
                [10241]: 9729,
                [10240]: 9729,
                [10242]: 33071,
                [10243]: 33071
            }
        });
        this.depthBuffer = new (0, $0082476f18a250b0$export$2e2bcd8739ae039)(gl, {
            format: 33189,
            width: 1,
            height: 1
        });
        this.fbo = new (0, $a0e9e15bc57c4882$export$2e2bcd8739ae039)(gl, {
            id: "shadowmap",
            width: 1,
            height: 1,
            attachments: {
                [36064]: this.shadowMap,
                [36096]: this.depthBuffer
            }
        });
    }
    render(params) {
        const target = this.fbo;
        (0, $54220aa8b6471f1a$export$b1e7058a2936b651)(this.gl, {
            depthRange: [
                0,
                1
            ],
            depthTest: true,
            blend: false,
            clearColor: [
                1,
                1,
                1,
                1
            ]
        }, ()=>{
            const viewport = params.viewports[0];
            const pixelRatio = (0, $294e503c6396a3ff$export$df40057290e74703)(this.gl);
            const width = viewport.width * pixelRatio;
            const height = viewport.height * pixelRatio;
            if (width !== target.width || height !== target.height) target.resize({
                width: width,
                height: height
            });
            super.render({
                ...params,
                target: target,
                pass: "shadow"
            });
        });
    }
    shouldDrawLayer(layer) {
        return layer.props.shadowEnabled !== false;
    }
    getModuleParameters() {
        return {
            drawToShadowMap: true
        };
    }
    delete() {
        if (this.fbo) {
            this.fbo.delete();
            this.fbo = null;
        }
        if (this.shadowMap) {
            this.shadowMap.delete();
            this.shadowMap = null;
        }
        if (this.depthBuffer) {
            this.depthBuffer.delete();
            this.depthBuffer = null;
        }
    }
}







const $030e4e4ffe0eebc5$var$vs = "\nconst int max_lights = 2;\nuniform mat4 shadow_uViewProjectionMatrices[max_lights];\nuniform vec4 shadow_uProjectCenters[max_lights];\nuniform bool shadow_uDrawShadowMap;\nuniform bool shadow_uUseShadowMap;\nuniform int shadow_uLightId;\nuniform float shadow_uLightCount;\n\nvarying vec3 shadow_vPosition[max_lights];\n\nvec4 shadow_setVertexPosition(vec4 position_commonspace) {\n  if (shadow_uDrawShadowMap) {\n    return project_common_position_to_clipspace(position_commonspace, shadow_uViewProjectionMatrices[shadow_uLightId], shadow_uProjectCenters[shadow_uLightId]);\n  }\n  if (shadow_uUseShadowMap) {\n    for (int i = 0; i < max_lights; i++) {\n      if(i < int(shadow_uLightCount)) {\n        vec4 shadowMap_position = project_common_position_to_clipspace(position_commonspace, shadow_uViewProjectionMatrices[i], shadow_uProjectCenters[i]);\n        shadow_vPosition[i] = (shadowMap_position.xyz / shadowMap_position.w + 1.0) / 2.0;\n      }\n    }\n  }\n  return gl_Position;\n}\n";
const $030e4e4ffe0eebc5$var$fs = "\nconst int max_lights = 2;\nuniform bool shadow_uDrawShadowMap;\nuniform bool shadow_uUseShadowMap;\nuniform sampler2D shadow_uShadowMap0;\nuniform sampler2D shadow_uShadowMap1;\nuniform vec4 shadow_uColor;\nuniform float shadow_uLightCount;\n\nvarying vec3 shadow_vPosition[max_lights];\n\nconst vec4 bitPackShift = vec4(1.0, 255.0, 65025.0, 16581375.0);\nconst vec4 bitUnpackShift = 1.0 / bitPackShift;\nconst vec4 bitMask = vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0,  0.0);\n\nfloat shadow_getShadowWeight(vec3 position, sampler2D shadowMap) {\n  vec4 rgbaDepth = texture2D(shadowMap, position.xy);\n\n  float z = dot(rgbaDepth, bitUnpackShift);\n  return smoothstep(0.001, 0.01, position.z - z);\n}\n\nvec4 shadow_filterShadowColor(vec4 color) {\n  if (shadow_uDrawShadowMap) {\n    vec4 rgbaDepth = fract(gl_FragCoord.z * bitPackShift);\n    rgbaDepth -= rgbaDepth.gbaa * bitMask;\n    return rgbaDepth;\n  }\n  if (shadow_uUseShadowMap) {\n    float shadowAlpha = 0.0;\n    shadowAlpha += shadow_getShadowWeight(shadow_vPosition[0], shadow_uShadowMap0);\n    if(shadow_uLightCount > 1.0) {\n      shadowAlpha += shadow_getShadowWeight(shadow_vPosition[1], shadow_uShadowMap1);\n    }\n    shadowAlpha *= shadow_uColor.a / shadow_uLightCount;\n    float blendedAlpha = shadowAlpha + color.a * (1.0 - shadowAlpha);\n\n    return vec4(\n      mix(color.rgb, shadow_uColor.rgb, shadowAlpha / blendedAlpha),\n      blendedAlpha\n    );\n  }\n  return color;\n}\n";
const $030e4e4ffe0eebc5$var$getMemoizedViewportCenterPosition = (0, $1ccdae01919b6bce$export$2e2bcd8739ae039)($030e4e4ffe0eebc5$var$getViewportCenterPosition);
const $030e4e4ffe0eebc5$var$getMemoizedViewProjectionMatrices = (0, $1ccdae01919b6bce$export$2e2bcd8739ae039)($030e4e4ffe0eebc5$var$getViewProjectionMatrices);
const $030e4e4ffe0eebc5$var$DEFAULT_SHADOW_COLOR = [
    0,
    0,
    0,
    1.0
];
const $030e4e4ffe0eebc5$var$VECTOR_TO_POINT_MATRIX = [
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    0
];
function $030e4e4ffe0eebc5$var$screenToCommonSpace(xyz, pixelUnprojectionMatrix) {
    const [x, y, z] = xyz;
    const coord = (0, $f5ef504cb5091e21$export$d0eff18eb06add5f)([
        x,
        y,
        z
    ], pixelUnprojectionMatrix);
    if (Number.isFinite(z)) return coord;
    return [
        coord[0],
        coord[1],
        0
    ];
}
function $030e4e4ffe0eebc5$var$getViewportCenterPosition({ viewport: viewport , center: center  }) {
    return new (0, $16800f0dff513c4e$export$2e2bcd8739ae039)(viewport.viewProjectionMatrix).invert().transform(center);
}
function $030e4e4ffe0eebc5$var$getViewProjectionMatrices({ viewport: viewport , shadowMatrices: shadowMatrices  }) {
    const projectionMatrices = [];
    const pixelUnprojectionMatrix = viewport.pixelUnprojectionMatrix;
    const farZ = viewport.isGeospatial ? undefined : 1;
    const corners = [
        [
            0,
            0,
            farZ
        ],
        [
            viewport.width,
            0,
            farZ
        ],
        [
            0,
            viewport.height,
            farZ
        ],
        [
            viewport.width,
            viewport.height,
            farZ
        ],
        [
            0,
            0,
            -1
        ],
        [
            viewport.width,
            0,
            -1
        ],
        [
            0,
            viewport.height,
            -1
        ],
        [
            viewport.width,
            viewport.height,
            -1
        ]
    ].map((pixel)=>$030e4e4ffe0eebc5$var$screenToCommonSpace(pixel, pixelUnprojectionMatrix));
    for (const shadowMatrix of shadowMatrices){
        const viewMatrix = shadowMatrix.clone().translate(new (0, $9c6695c39a874609$export$2e2bcd8739ae039)(viewport.center).negate());
        const positions = corners.map((corner)=>viewMatrix.transform(corner));
        const projectionMatrix = new (0, $16800f0dff513c4e$export$2e2bcd8739ae039)().ortho({
            left: Math.min(...positions.map((position)=>position[0])),
            right: Math.max(...positions.map((position)=>position[0])),
            bottom: Math.min(...positions.map((position)=>position[1])),
            top: Math.max(...positions.map((position)=>position[1])),
            near: Math.min(...positions.map((position)=>-position[2])),
            far: Math.max(...positions.map((position)=>-position[2]))
        });
        projectionMatrices.push(projectionMatrix.multiplyRight(shadowMatrix));
    }
    return projectionMatrices;
}
function $030e4e4ffe0eebc5$var$createShadowUniforms(opts, context) {
    const { shadowEnabled: shadowEnabled = true  } = opts;
    if (!shadowEnabled || !opts.shadowMatrices || !opts.shadowMatrices.length) return {
        shadow_uDrawShadowMap: false,
        shadow_uUseShadowMap: false
    };
    const uniforms = {
        shadow_uDrawShadowMap: Boolean(opts.drawToShadowMap),
        shadow_uUseShadowMap: opts.shadowMaps ? opts.shadowMaps.length > 0 : false,
        shadow_uColor: opts.shadowColor || $030e4e4ffe0eebc5$var$DEFAULT_SHADOW_COLOR,
        shadow_uLightId: opts.shadowLightId || 0,
        shadow_uLightCount: opts.shadowMatrices.length
    };
    const center = $030e4e4ffe0eebc5$var$getMemoizedViewportCenterPosition({
        viewport: opts.viewport,
        center: context.project_uCenter
    });
    const projectCenters = [];
    const viewProjectionMatrices = $030e4e4ffe0eebc5$var$getMemoizedViewProjectionMatrices({
        shadowMatrices: opts.shadowMatrices,
        viewport: opts.viewport
    }).slice();
    for(let i = 0; i < opts.shadowMatrices.length; i++){
        const viewProjectionMatrix = viewProjectionMatrices[i];
        const viewProjectionMatrixCentered = viewProjectionMatrix.clone().translate(new (0, $9c6695c39a874609$export$2e2bcd8739ae039)(opts.viewport.center).negate());
        if (context.project_uCoordinateSystem === (0, $b42a5b9aa3b1a41f$export$e4ccd0285368e485).LNGLAT && context.project_uProjectionMode === (0, $b42a5b9aa3b1a41f$export$3697aaebd269a548).WEB_MERCATOR) {
            viewProjectionMatrices[i] = viewProjectionMatrixCentered;
            projectCenters[i] = center;
        } else {
            viewProjectionMatrices[i] = viewProjectionMatrix.clone().multiplyRight($030e4e4ffe0eebc5$var$VECTOR_TO_POINT_MATRIX);
            projectCenters[i] = viewProjectionMatrixCentered.transform(center);
        }
    }
    for(let i1 = 0; i1 < viewProjectionMatrices.length; i1++){
        uniforms["shadow_uViewProjectionMatrices[".concat(i1, "]")] = viewProjectionMatrices[i1];
        uniforms["shadow_uProjectCenters[".concat(i1, "]")] = projectCenters[i1];
        if (opts.shadowMaps && opts.shadowMaps.length > 0) uniforms["shadow_uShadowMap".concat(i1)] = opts.shadowMaps[i1];
        else uniforms["shadow_uShadowMap".concat(i1)] = opts.dummyShadowMap;
    }
    return uniforms;
}
var $030e4e4ffe0eebc5$export$2e2bcd8739ae039 = {
    name: "shadow",
    dependencies: [
        (0, $669f9ad1259ddfee$export$2e2bcd8739ae039)
    ],
    vs: $030e4e4ffe0eebc5$var$vs,
    fs: $030e4e4ffe0eebc5$var$fs,
    inject: {
        "vs:DECKGL_FILTER_GL_POSITION": "\n    position = shadow_setVertexPosition(geometry.position);\n    ",
        "fs:DECKGL_FILTER_COLOR": "\n    color = shadow_filterShadowColor(color);\n    "
    },
    getUniforms: (opts = {}, context = {})=>{
        if ("viewport" in opts && (opts.drawToShadowMap || opts.shadowMaps && opts.shadowMaps.length > 0)) return $030e4e4ffe0eebc5$var$createShadowUniforms(opts, context);
        return {};
    }
};


const $70e78b90cf44affe$var$DEFAULT_AMBIENT_LIGHT_PROPS = {
    color: [
        255,
        255,
        255
    ],
    intensity: 1.0
};
const $70e78b90cf44affe$var$DEFAULT_DIRECTIONAL_LIGHT_PROPS = [
    {
        color: [
            255,
            255,
            255
        ],
        intensity: 1.0,
        direction: [
            -1,
            3,
            -1
        ]
    },
    {
        color: [
            255,
            255,
            255
        ],
        intensity: 0.9,
        direction: [
            1,
            -8,
            -2.5
        ]
    }
];
const $70e78b90cf44affe$var$DEFAULT_SHADOW_COLOR = [
    0,
    0,
    0,
    200 / 255
];
class $70e78b90cf44affe$export$2e2bcd8739ae039 {
    constructor(props = {}){
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "id", "lighting-effect");
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "props", null);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "shadowColor", $70e78b90cf44affe$var$DEFAULT_SHADOW_COLOR);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "shadow", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "ambientLight", null);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "directionalLights", []);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "pointLights", []);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "shadowPasses", []);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "shadowMaps", []);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "dummyShadowMap", null);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "programManager", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "shadowMatrices", void 0);
        for(const key in props){
            const lightSource = props[key];
            switch(lightSource.type){
                case "ambient":
                    this.ambientLight = lightSource;
                    break;
                case "directional":
                    this.directionalLights.push(lightSource);
                    break;
                case "point":
                    this.pointLights.push(lightSource);
                    break;
                default:
            }
        }
        this._applyDefaultLights();
        this.shadow = this.directionalLights.some((light)=>light.shadow);
    }
    preRender(gl, { layers: layers , layerFilter: layerFilter , viewports: viewports , onViewportActive: onViewportActive , views: views  }) {
        if (!this.shadow) return;
        this.shadowMatrices = this._calculateMatrices();
        if (this.shadowPasses.length === 0) this._createShadowPasses(gl);
        if (!this.programManager) {
            this.programManager = (0, $389aec4f13e2bfb5$export$2e2bcd8739ae039).getDefaultProgramManager(gl);
            if (0, $030e4e4ffe0eebc5$export$2e2bcd8739ae039) this.programManager.addDefaultModule((0, $030e4e4ffe0eebc5$export$2e2bcd8739ae039));
        }
        if (!this.dummyShadowMap) this.dummyShadowMap = new (0, $df31c887249e3faa$export$2e2bcd8739ae039)(gl, {
            width: 1,
            height: 1
        });
        for(let i = 0; i < this.shadowPasses.length; i++){
            const shadowPass = this.shadowPasses[i];
            shadowPass.render({
                layers: layers,
                layerFilter: layerFilter,
                viewports: viewports,
                onViewportActive: onViewportActive,
                views: views,
                moduleParameters: {
                    shadowLightId: i,
                    dummyShadowMap: this.dummyShadowMap,
                    shadowMatrices: this.shadowMatrices
                }
            });
        }
    }
    getModuleParameters(layer) {
        const parameters = this.shadow ? {
            shadowMaps: this.shadowMaps,
            dummyShadowMap: this.dummyShadowMap,
            shadowColor: this.shadowColor,
            shadowMatrices: this.shadowMatrices
        } : {};
        parameters.lightSources = {
            ambientLight: this.ambientLight,
            directionalLights: this.directionalLights.map((directionalLight)=>directionalLight.getProjectedLight({
                    layer: layer
                })),
            pointLights: this.pointLights.map((pointLight)=>pointLight.getProjectedLight({
                    layer: layer
                }))
        };
        return parameters;
    }
    cleanup() {
        for (const shadowPass of this.shadowPasses)shadowPass.delete();
        this.shadowPasses.length = 0;
        this.shadowMaps.length = 0;
        if (this.dummyShadowMap) {
            this.dummyShadowMap.delete();
            this.dummyShadowMap = null;
        }
        if (this.shadow && this.programManager) {
            this.programManager.removeDefaultModule((0, $030e4e4ffe0eebc5$export$2e2bcd8739ae039));
            this.programManager = null;
        }
    }
    _calculateMatrices() {
        const lightMatrices = [];
        for (const light of this.directionalLights){
            const viewMatrix = new (0, $16800f0dff513c4e$export$2e2bcd8739ae039)().lookAt({
                eye: new (0, $9c6695c39a874609$export$2e2bcd8739ae039)(light.direction).negate()
            });
            lightMatrices.push(viewMatrix);
        }
        return lightMatrices;
    }
    _createShadowPasses(gl) {
        for(let i = 0; i < this.directionalLights.length; i++){
            const shadowPass = new (0, $82ba7828a81ad8c8$export$2e2bcd8739ae039)(gl);
            this.shadowPasses[i] = shadowPass;
            this.shadowMaps[i] = shadowPass.shadowMap;
        }
    }
    _applyDefaultLights() {
        const { ambientLight: ambientLight , pointLights: pointLights , directionalLights: directionalLights  } = this;
        if (!ambientLight && pointLights.length === 0 && directionalLights.length === 0) {
            this.ambientLight = new (0, $f48ccf05d22c92a4$export$af279bfef9ec2c96)($70e78b90cf44affe$var$DEFAULT_AMBIENT_LIGHT_PROPS);
            this.directionalLights.push(new (0, $26151c4aae5387e4$export$3fea33cc9972c868)($70e78b90cf44affe$var$DEFAULT_DIRECTIONAL_LIGHT_PROPS[0]), new (0, $26151c4aae5387e4$export$3fea33cc9972c868)($70e78b90cf44affe$var$DEFAULT_DIRECTIONAL_LIGHT_PROPS[1]));
        }
    }
}









class $b8b5894efb4b3eb3$export$2e2bcd8739ae039 extends (0, $b1756d854624bf2b$export$2e2bcd8739ae039) {
    constructor(gl, props){
        super(gl, props);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "maskMap", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "fbo", void 0);
        const { mapSize: mapSize = 2048  } = props;
        this.maskMap = new (0, $df31c887249e3faa$export$2e2bcd8739ae039)(gl, {
            width: mapSize,
            height: mapSize,
            parameters: {
                [10241]: 9729,
                [10240]: 9729,
                [10242]: 33071,
                [10243]: 33071
            }
        });
        this.fbo = new (0, $a0e9e15bc57c4882$export$2e2bcd8739ae039)(gl, {
            id: "maskmap",
            width: mapSize,
            height: mapSize,
            attachments: {
                [36064]: this.maskMap
            }
        });
    }
    render(options) {
        const gl = this.gl;
        const colorMask = [
            false,
            false,
            false,
            false
        ];
        colorMask[options.channel] = true;
        return (0, $54220aa8b6471f1a$export$b1e7058a2936b651)(gl, {
            clearColor: [
                255,
                255,
                255,
                255
            ],
            blend: true,
            blendFunc: [
                0,
                1
            ],
            blendEquation: 32778,
            colorMask: colorMask,
            depthTest: false
        }, ()=>super.render({
                ...options,
                target: this.fbo,
                pass: "mask"
            }));
    }
    shouldDrawLayer(layer) {
        return layer.props.operation === (0, $b42a5b9aa3b1a41f$export$b56168d831461ce2).MASK;
    }
    delete() {
        this.fbo.delete();
        this.maskMap.delete();
    }
}









const $9a3d69191761b73c$var$viewMatrix = new (0, $16800f0dff513c4e$export$2e2bcd8739ae039)().lookAt({
    eye: [
        0,
        0,
        1
    ]
});
function $9a3d69191761b73c$var$getProjectionMatrix({ width: width , height: height , near: near , far: far , padding: padding  }) {
    let left = -width / 2;
    let right = width / 2;
    let bottom = -height / 2;
    let top = height / 2;
    if (padding) {
        const { left: l = 0 , right: r = 0 , top: t = 0 , bottom: b = 0  } = padding;
        const offsetX = (0, $53a37c44451cea56$export$7d15b64cf5a3a4c4)((l + width - r) / 2, 0, width) - width / 2;
        const offsetY = (0, $53a37c44451cea56$export$7d15b64cf5a3a4c4)((t + height - b) / 2, 0, height) - height / 2;
        left -= offsetX;
        right -= offsetX;
        bottom += offsetY;
        top += offsetY;
    }
    return new (0, $16800f0dff513c4e$export$2e2bcd8739ae039)().ortho({
        left: left,
        right: right,
        bottom: bottom,
        top: top,
        near: near,
        far: far
    });
}
class $9a3d69191761b73c$export$2e2bcd8739ae039 extends (0, $bdb7668fd52e659a$export$2e2bcd8739ae039) {
    constructor(props){
        const { width: width , height: height , near: near = 0.1 , far: far = 1000 , zoom: zoom = 0 , target: target = [
            0,
            0,
            0
        ] , padding: padding = null , flipY: flipY = true  } = props;
        const zoomX = Array.isArray(zoom) ? zoom[0] : zoom;
        const zoomY = Array.isArray(zoom) ? zoom[1] : zoom;
        const zoom_ = Math.min(zoomX, zoomY);
        const scale = Math.pow(2, zoom_);
        let distanceScales;
        if (zoomX !== zoomY) {
            const scaleX = Math.pow(2, zoomX);
            const scaleY = Math.pow(2, zoomY);
            distanceScales = {
                unitsPerMeter: [
                    scaleX / scale,
                    scaleY / scale,
                    1
                ],
                metersPerUnit: [
                    scale / scaleX,
                    scale / scaleY,
                    1
                ]
            };
        }
        super({
            ...props,
            longitude: undefined,
            position: target,
            viewMatrix: $9a3d69191761b73c$var$viewMatrix.clone().scale([
                scale,
                scale * (flipY ? -1 : 1),
                scale
            ]),
            projectionMatrix: $9a3d69191761b73c$var$getProjectionMatrix({
                width: width || 1,
                height: height || 1,
                padding: padding,
                near: near,
                far: far
            }),
            zoom: zoom_,
            distanceScales: distanceScales
        });
    }
    projectFlat([X, Y]) {
        const { unitsPerMeter: unitsPerMeter  } = this.distanceScales;
        return [
            X * unitsPerMeter[0],
            Y * unitsPerMeter[1]
        ];
    }
    unprojectFlat([x, y]) {
        const { metersPerUnit: metersPerUnit  } = this.distanceScales;
        return [
            x * metersPerUnit[0],
            y * metersPerUnit[1]
        ];
    }
    panByPosition(coords, pixel) {
        const fromLocation = (0, $f5ef504cb5091e21$export$d0eff18eb06add5f)(pixel, this.pixelUnprojectionMatrix);
        const toLocation = this.projectFlat(coords);
        const translate = $fceb3370258170b6$export$e16d8520af44a096([], toLocation, $fceb3370258170b6$export$aef51622e549b8b0([], fromLocation));
        const newCenter = $fceb3370258170b6$export$e16d8520af44a096([], this.center, translate);
        return {
            target: this.unprojectFlat(newCenter)
        };
    }
}











class $5b780d9404959b95$export$b17d281980b58efa extends (0, $56f07b62de053c52$export$2e2bcd8739ae039) {
    constructor(options){
        const { width: width , height: height , rotationX: rotationX = 0 , rotationOrbit: rotationOrbit = 0 , target: target = [
            0,
            0,
            0
        ] , zoom: zoom = 0 , minRotationX: minRotationX = -90 , maxRotationX: maxRotationX = 90 , minZoom: minZoom = -Infinity , maxZoom: maxZoom = Infinity , startPanPosition: startPanPosition , startRotatePos: startRotatePos , startRotationX: startRotationX , startRotationOrbit: startRotationOrbit , startZoomPosition: startZoomPosition , startZoom: startZoom  } = options;
        super({
            width: width,
            height: height,
            rotationX: rotationX,
            rotationOrbit: rotationOrbit,
            target: target,
            zoom: zoom,
            minRotationX: minRotationX,
            maxRotationX: maxRotationX,
            minZoom: minZoom,
            maxZoom: maxZoom
        }, {
            startPanPosition: startPanPosition,
            startRotatePos: startRotatePos,
            startRotationX: startRotationX,
            startRotationOrbit: startRotationOrbit,
            startZoomPosition: startZoomPosition,
            startZoom: startZoom
        });
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "makeViewport", void 0);
        this.makeViewport = options.makeViewport;
    }
    panStart({ pos: pos  }) {
        return this._getUpdatedState({
            startPanPosition: this._unproject(pos)
        });
    }
    pan({ pos: pos , startPosition: startPosition  }) {
        const startPanPosition = this.getState().startPanPosition || startPosition;
        if (!startPanPosition) return this;
        const viewport = this.makeViewport(this.getViewportProps());
        const newProps = viewport.panByPosition(startPanPosition, pos);
        return this._getUpdatedState(newProps);
    }
    panEnd() {
        return this._getUpdatedState({
            startPanPosition: null
        });
    }
    rotateStart({ pos: pos  }) {
        return this._getUpdatedState({
            startRotatePos: pos,
            startRotationX: this.getViewportProps().rotationX,
            startRotationOrbit: this.getViewportProps().rotationOrbit
        });
    }
    rotate({ pos: pos , deltaAngleX: deltaAngleX = 0 , deltaAngleY: deltaAngleY = 0  }) {
        const { startRotatePos: startRotatePos , startRotationX: startRotationX , startRotationOrbit: startRotationOrbit  } = this.getState();
        const { width: width , height: height  } = this.getViewportProps();
        if (!startRotatePos || startRotationX === undefined || startRotationOrbit === undefined) return this;
        let newRotation;
        if (pos) {
            let deltaScaleX = (pos[0] - startRotatePos[0]) / width;
            const deltaScaleY = (pos[1] - startRotatePos[1]) / height;
            if (startRotationX < -90 || startRotationX > 90) deltaScaleX *= -1;
            newRotation = {
                rotationX: startRotationX + deltaScaleY * 180,
                rotationOrbit: startRotationOrbit + deltaScaleX * 180
            };
        } else newRotation = {
            rotationX: startRotationX + deltaAngleY,
            rotationOrbit: startRotationOrbit + deltaAngleX
        };
        return this._getUpdatedState(newRotation);
    }
    rotateEnd() {
        return this._getUpdatedState({
            startRotationX: null,
            startRotationOrbit: null
        });
    }
    shortestPathFrom(viewState) {
        const fromProps = viewState.getViewportProps();
        const props = {
            ...this.getViewportProps()
        };
        const { rotationOrbit: rotationOrbit  } = props;
        if (Math.abs(rotationOrbit - fromProps.rotationOrbit) > 180) props.rotationOrbit = rotationOrbit < 0 ? rotationOrbit + 360 : rotationOrbit - 360;
        return props;
    }
    zoomStart({ pos: pos  }) {
        return this._getUpdatedState({
            startZoomPosition: this._unproject(pos),
            startZoom: this.getViewportProps().zoom
        });
    }
    zoom({ pos: pos , startPos: startPos , scale: scale  }) {
        let { startZoom: startZoom , startZoomPosition: startZoomPosition  } = this.getState();
        if (!startZoomPosition) {
            startZoom = this.getViewportProps().zoom;
            startZoomPosition = this._unproject(startPos) || this._unproject(pos);
        }
        if (!startZoomPosition) return this;
        const newZoom = this._calculateNewZoom({
            scale: scale,
            startZoom: startZoom
        });
        const zoomedViewport = this.makeViewport({
            ...this.getViewportProps(),
            zoom: newZoom
        });
        return this._getUpdatedState({
            zoom: newZoom,
            ...zoomedViewport.panByPosition(startZoomPosition, pos)
        });
    }
    zoomEnd() {
        return this._getUpdatedState({
            startZoomPosition: null,
            startZoom: null
        });
    }
    zoomIn(speed = 2) {
        return this._getUpdatedState({
            zoom: this._calculateNewZoom({
                scale: speed
            })
        });
    }
    zoomOut(speed = 2) {
        return this._getUpdatedState({
            zoom: this._calculateNewZoom({
                scale: 1 / speed
            })
        });
    }
    moveLeft(speed = 50) {
        return this._panFromCenter([
            -speed,
            0
        ]);
    }
    moveRight(speed = 50) {
        return this._panFromCenter([
            speed,
            0
        ]);
    }
    moveUp(speed = 50) {
        return this._panFromCenter([
            0,
            -speed
        ]);
    }
    moveDown(speed = 50) {
        return this._panFromCenter([
            0,
            speed
        ]);
    }
    rotateLeft(speed = 15) {
        return this._getUpdatedState({
            rotationOrbit: this.getViewportProps().rotationOrbit - speed
        });
    }
    rotateRight(speed = 15) {
        return this._getUpdatedState({
            rotationOrbit: this.getViewportProps().rotationOrbit + speed
        });
    }
    rotateUp(speed = 10) {
        return this._getUpdatedState({
            rotationX: this.getViewportProps().rotationX - speed
        });
    }
    rotateDown(speed = 10) {
        return this._getUpdatedState({
            rotationX: this.getViewportProps().rotationX + speed
        });
    }
    _unproject(pos) {
        const viewport = this.makeViewport(this.getViewportProps());
        return pos && viewport.unproject(pos);
    }
    _calculateNewZoom({ scale: scale , startZoom: startZoom  }) {
        const { maxZoom: maxZoom , minZoom: minZoom  } = this.getViewportProps();
        if (startZoom === undefined) startZoom = this.getViewportProps().zoom;
        const zoom = startZoom + Math.log2(scale);
        return (0, $53a37c44451cea56$export$7d15b64cf5a3a4c4)(zoom, minZoom, maxZoom);
    }
    _panFromCenter(offset) {
        const { width: width , height: height , target: target  } = this.getViewportProps();
        return this.pan({
            startPosition: target,
            pos: [
                width / 2 + offset[0],
                height / 2 + offset[1]
            ]
        });
    }
    _getUpdatedState(newProps) {
        return new this.constructor({
            makeViewport: this.makeViewport,
            ...this.getViewportProps(),
            ...this.getState(),
            ...newProps
        });
    }
    applyConstraints(props) {
        const { maxZoom: maxZoom , minZoom: minZoom , zoom: zoom , maxRotationX: maxRotationX , minRotationX: minRotationX , rotationOrbit: rotationOrbit  } = props;
        props.zoom = Array.isArray(zoom) ? [
            (0, $53a37c44451cea56$export$7d15b64cf5a3a4c4)(zoom[0], minZoom, maxZoom),
            (0, $53a37c44451cea56$export$7d15b64cf5a3a4c4)(zoom[1], minZoom, maxZoom)
        ] : (0, $53a37c44451cea56$export$7d15b64cf5a3a4c4)(zoom, minZoom, maxZoom);
        props.rotationX = (0, $53a37c44451cea56$export$7d15b64cf5a3a4c4)(props.rotationX, minRotationX, maxRotationX);
        if (rotationOrbit < -180 || rotationOrbit > 180) props.rotationOrbit = (0, $97790275b37bd567$export$842a2cf37af977e1)(rotationOrbit + 180, 360) - 180;
        return props;
    }
}
class $5b780d9404959b95$export$2e2bcd8739ae039 extends (0, $9a93059544335596$export$2e2bcd8739ae039) {
    constructor(...args){
        super(...args);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "ControllerState", $5b780d9404959b95$export$b17d281980b58efa);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "transition", {
            transitionDuration: 300,
            transitionInterpolator: new (0, $be3e6f41f904fd21$export$2e2bcd8739ae039)({
                transitionProps: {
                    compare: [
                        "target",
                        "zoom",
                        "rotationX",
                        "rotationOrbit"
                    ],
                    required: [
                        "target",
                        "zoom"
                    ]
                }
            })
        });
    }
}



class $ab1daa2b350c5b59$var$OrthographicState extends (0, $5b780d9404959b95$export$b17d281980b58efa) {
    constructor(props){
        super(props);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "zoomAxis", void 0);
        this.zoomAxis = props.zoomAxis || "all";
    }
    _calculateNewZoom({ scale: scale , startZoom: startZoom  }) {
        const { maxZoom: maxZoom , minZoom: minZoom  } = this.getViewportProps();
        if (startZoom === undefined) startZoom = this.getViewportProps().zoom;
        let deltaZoom = Math.log2(scale);
        if (Array.isArray(startZoom)) {
            let [newZoomX, newZoomY] = startZoom;
            switch(this.zoomAxis){
                case "X":
                    newZoomX = (0, $53a37c44451cea56$export$7d15b64cf5a3a4c4)(newZoomX + deltaZoom, minZoom, maxZoom);
                    break;
                case "Y":
                    newZoomY = (0, $53a37c44451cea56$export$7d15b64cf5a3a4c4)(newZoomY + deltaZoom, minZoom, maxZoom);
                    break;
                default:
                    let z = Math.min(newZoomX + deltaZoom, newZoomY + deltaZoom);
                    if (z < minZoom) deltaZoom += minZoom - z;
                    z = Math.max(newZoomX + deltaZoom, newZoomY + deltaZoom);
                    if (z > maxZoom) deltaZoom += maxZoom - z;
                    newZoomX += deltaZoom;
                    newZoomY += deltaZoom;
            }
            return [
                newZoomX,
                newZoomY
            ];
        }
        return (0, $53a37c44451cea56$export$7d15b64cf5a3a4c4)(startZoom + deltaZoom, minZoom, maxZoom);
    }
}
class $ab1daa2b350c5b59$export$2e2bcd8739ae039 extends (0, $9a93059544335596$export$2e2bcd8739ae039) {
    constructor(...args){
        super(...args);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "ControllerState", $ab1daa2b350c5b59$var$OrthographicState);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "transition", {
            transitionDuration: 300,
            transitionInterpolator: new (0, $be3e6f41f904fd21$export$2e2bcd8739ae039)([
                "target",
                "zoom"
            ])
        });
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "dragMode", "pan");
    }
    _onPanRotate() {
        return false;
    }
}


class $dc21c358ed1a7258$export$2e2bcd8739ae039 extends (0, $f435da35b0feb027$export$2e2bcd8739ae039) {
    get ViewportType() {
        return 0, $9a3d69191761b73c$export$2e2bcd8739ae039;
    }
    get ControllerType() {
        return 0, $ab1daa2b350c5b59$export$2e2bcd8739ae039;
    }
}
(0, $037483d1fb5deac8$export$2e2bcd8739ae039)($dc21c358ed1a7258$export$2e2bcd8739ae039, "displayName", "OrthographicView");




function $9d65382866ab2814$export$b63ee16b61fa2407({ layers: layers , viewport: viewport  }) {
    let bounds = null;
    for (const layer of layers){
        const subLayerBounds = layer.getBounds();
        if (subLayerBounds) {
            if (bounds) {
                bounds[0] = Math.min(bounds[0], subLayerBounds[0][0]);
                bounds[1] = Math.min(bounds[1], subLayerBounds[0][1]);
                bounds[2] = Math.max(bounds[2], subLayerBounds[1][0]);
                bounds[3] = Math.max(bounds[3], subLayerBounds[1][1]);
            } else bounds = [
                subLayerBounds[0][0],
                subLayerBounds[0][1],
                subLayerBounds[1][0],
                subLayerBounds[1][1]
            ];
        }
    }
    const viewportBounds = viewport.getBounds();
    if (!bounds) return viewportBounds;
    const paddedBounds = $9d65382866ab2814$var$_doubleBounds(viewportBounds);
    if (bounds[2] - bounds[0] < paddedBounds[2] - paddedBounds[0] || bounds[3] - bounds[1] < paddedBounds[3] - paddedBounds[1]) return bounds;
    bounds[0] = Math.max(bounds[0], paddedBounds[0]);
    bounds[1] = Math.max(bounds[1], paddedBounds[1]);
    bounds[2] = Math.min(bounds[2], paddedBounds[2]);
    bounds[3] = Math.min(bounds[3], paddedBounds[3]);
    return bounds;
}
function $9d65382866ab2814$export$c2166da56ef13b51({ bounds: bounds , viewport: viewport , width: width , height: height  }) {
    if (bounds[2] <= bounds[0] || bounds[3] <= bounds[1]) return null;
    const padding = 1;
    width -= padding * 2;
    height -= padding * 2;
    if (viewport instanceof (0, $4ac7d89cb7f1c4ad$export$2e2bcd8739ae039)) {
        const { longitude: longitude , latitude: latitude , zoom: zoom  } = (0, $7401923064b435ee$export$2e2bcd8739ae039)({
            width: width,
            height: height,
            bounds: [
                [
                    bounds[0],
                    bounds[1]
                ],
                [
                    bounds[2],
                    bounds[3]
                ]
            ],
            maxZoom: 20
        });
        return new (0, $4ac7d89cb7f1c4ad$export$2e2bcd8739ae039)({
            longitude: longitude,
            latitude: latitude,
            zoom: zoom,
            x: padding,
            y: padding,
            width: width,
            height: height
        });
    }
    const center = [
        (bounds[0] + bounds[2]) / 2,
        (bounds[1] + bounds[3]) / 2,
        0
    ];
    const scale = Math.min(20, width / (bounds[2] - bounds[0]), height / (bounds[3] - bounds[1]));
    return new (0, $dc21c358ed1a7258$export$2e2bcd8739ae039)({
        x: padding,
        y: padding
    }).makeViewport({
        width: width,
        height: height,
        viewState: {
            target: center,
            zoom: Math.log2(scale)
        }
    });
}
function $9d65382866ab2814$var$_doubleBounds(bounds) {
    const size = {
        x: bounds[2] - bounds[0],
        y: bounds[3] - bounds[1]
    };
    const center = {
        x: bounds[0] + 0.5 * size.x,
        y: bounds[1] + 0.5 * size.y
    };
    return [
        center.x - size.x,
        center.y - size.y,
        center.x + size.x,
        center.y + size.y
    ];
}



class $1db2fd26802cc688$export$2e2bcd8739ae039 {
    constructor(){
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "id", "mask-effect");
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "props", null);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "useInPicking", true);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "dummyMaskMap", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "channels", []);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "masks", null);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "maskPass", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "maskMap", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "lastViewport", void 0);
    }
    preRender(gl, { layers: layers , layerFilter: layerFilter , viewports: viewports , onViewportActive: onViewportActive , views: views  }) {
        if (!this.dummyMaskMap) this.dummyMaskMap = new (0, $df31c887249e3faa$export$2e2bcd8739ae039)(gl, {
            width: 1,
            height: 1
        });
        const maskLayers = layers.filter((l)=>l.props.visible && l.props.operation === (0, $b42a5b9aa3b1a41f$export$b56168d831461ce2).MASK);
        if (maskLayers.length === 0) {
            this.masks = null;
            this.channels.length = 0;
            return;
        }
        this.masks = {};
        if (!this.maskPass) {
            this.maskPass = new (0, $b8b5894efb4b3eb3$export$2e2bcd8739ae039)(gl, {
                id: "default-mask"
            });
            this.maskMap = this.maskPass.maskMap;
        }
        const channelMap = this._sortMaskChannels(maskLayers);
        const viewport = viewports[0];
        const viewportChanged = !this.lastViewport || !this.lastViewport.equals(viewport);
        for(const maskId in channelMap)this._renderChannel(channelMap[maskId], {
            layerFilter: layerFilter,
            onViewportActive: onViewportActive,
            views: views,
            viewport: viewport,
            viewportChanged: viewportChanged
        });
    }
    _renderChannel(channelInfo, { layerFilter: layerFilter , onViewportActive: onViewportActive , views: views , viewport: viewport , viewportChanged: viewportChanged  }) {
        const oldChannelInfo = this.channels[channelInfo.index];
        if (!oldChannelInfo) return;
        const maskChanged = channelInfo === oldChannelInfo || oldChannelInfo.layers.length !== channelInfo.layers.length || channelInfo.layerBounds.some((b, i)=>b !== oldChannelInfo.layerBounds[i]);
        channelInfo.bounds = oldChannelInfo.bounds;
        channelInfo.maskBounds = oldChannelInfo.maskBounds;
        this.channels[channelInfo.index] = channelInfo;
        if (maskChanged || viewportChanged) {
            this.lastViewport = viewport;
            channelInfo.bounds = (0, $9d65382866ab2814$export$b63ee16b61fa2407)({
                layers: channelInfo.layers,
                viewport: viewport
            });
            if (maskChanged || !(0, $53a37c44451cea56$export$e9bab7fafb253603)(channelInfo.bounds, oldChannelInfo.bounds)) {
                const { maskPass: maskPass , maskMap: maskMap  } = this;
                const maskViewport = (0, $9d65382866ab2814$export$c2166da56ef13b51)({
                    bounds: channelInfo.bounds,
                    viewport: viewport,
                    width: maskMap.width,
                    height: maskMap.height
                });
                channelInfo.maskBounds = maskViewport ? maskViewport.getBounds() : [
                    0,
                    0,
                    1,
                    1
                ];
                maskPass.render({
                    pass: "mask",
                    channel: channelInfo.index,
                    layers: channelInfo.layers,
                    layerFilter: layerFilter,
                    viewports: maskViewport ? [
                        maskViewport
                    ] : [],
                    onViewportActive: onViewportActive,
                    views: views,
                    moduleParameters: {
                        devicePixelRatio: 1
                    }
                });
            }
        }
        this.masks[channelInfo.id] = {
            index: channelInfo.index,
            bounds: channelInfo.maskBounds,
            coordinateOrigin: channelInfo.coordinateOrigin,
            coordinateSystem: channelInfo.coordinateSystem
        };
    }
    _sortMaskChannels(maskLayers) {
        const channelMap = {};
        let channelCount = 0;
        for (const layer of maskLayers){
            const { id: id  } = layer.root;
            let channelInfo = channelMap[id];
            if (!channelInfo) {
                if (++channelCount > 4) {
                    (0, $146cba582e8c799f$export$2e2bcd8739ae039).warn("Too many mask layers. The max supported is 4")();
                    continue;
                }
                channelInfo = {
                    id: id,
                    index: this.channels.findIndex((c)=>(c === null || c === void 0 ? void 0 : c.id) === id),
                    layers: [],
                    layerBounds: [],
                    coordinateOrigin: layer.root.props.coordinateOrigin,
                    coordinateSystem: layer.root.props.coordinateSystem
                };
                channelMap[id] = channelInfo;
            }
            channelInfo.layers.push(layer);
            channelInfo.layerBounds.push(layer.getBounds());
        }
        for(let i = 0; i < 4; i++){
            const channelInfo = this.channels[i];
            if (!channelInfo || !(channelInfo.id in channelMap)) this.channels[i] = null;
        }
        for(const maskId in channelMap){
            const channelInfo = channelMap[maskId];
            if (channelInfo.index < 0) {
                channelInfo.index = this.channels.findIndex((c)=>!c);
                this.channels[channelInfo.index] = channelInfo;
            }
        }
        return channelMap;
    }
    getModuleParameters() {
        return {
            maskMap: this.masks ? this.maskMap : this.dummyMaskMap,
            maskChannels: this.masks
        };
    }
    cleanup() {
        if (this.dummyMaskMap) {
            this.dummyMaskMap.delete();
            this.dummyMaskMap = undefined;
        }
        if (this.maskPass) {
            this.maskPass.delete();
            this.maskPass = undefined;
            this.maskMap = undefined;
        }
        this.lastViewport = undefined;
        this.masks = null;
        this.channels.length = 0;
    }
}


const $6a78b0e959df691c$var$DEFAULT_LIGHTING_EFFECT = new (0, $70e78b90cf44affe$export$2e2bcd8739ae039)();
class $6a78b0e959df691c$export$2e2bcd8739ae039 {
    constructor(){
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "effects", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_internalEffects", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_needsRedraw", void 0);
        this.effects = [];
        this._internalEffects = [];
        this._needsRedraw = "Initial render";
        this.setEffects();
    }
    setProps(props) {
        if ("effects" in props) {
            if (props.effects.length !== this.effects.length || !(0, $70a948cba88c73a3$export$9cb4719e2e525b7a)(props.effects, this.effects)) {
                this.setEffects(props.effects);
                this._needsRedraw = "effects changed";
            }
        }
    }
    needsRedraw(opts = {
        clearRedrawFlags: false
    }) {
        const redraw = this._needsRedraw;
        if (opts.clearRedrawFlags) this._needsRedraw = false;
        return redraw;
    }
    getEffects() {
        return this._internalEffects;
    }
    finalize() {
        this.cleanup();
    }
    setEffects(effects = []) {
        this.cleanup();
        this.effects = effects;
        this._internalEffects = effects.slice();
        this._internalEffects.push(new (0, $1db2fd26802cc688$export$2e2bcd8739ae039)());
        if (!effects.some((effect)=>effect instanceof (0, $70e78b90cf44affe$export$2e2bcd8739ae039))) this._internalEffects.push($6a78b0e959df691c$var$DEFAULT_LIGHTING_EFFECT);
    }
    cleanup() {
        for (const effect of this.effects)effect.cleanup();
        for (const effect1 of this._internalEffects)effect1.cleanup();
        this.effects.length = 0;
        this._internalEffects.length = 0;
    }
}





class $9b7315ba3a82d7e0$export$2e2bcd8739ae039 extends (0, $b1756d854624bf2b$export$2e2bcd8739ae039) {
    shouldDrawLayer(layer) {
        return layer.props.operation === (0, $b42a5b9aa3b1a41f$export$b56168d831461ce2).DRAW;
    }
}







const $7ea8e8d62e8ae777$var$PICKING_PARAMETERS = {
    blendFunc: [
        1,
        0,
        32771,
        0
    ],
    blendEquation: 32774
};
class $7ea8e8d62e8ae777$export$2e2bcd8739ae039 extends (0, $b1756d854624bf2b$export$2e2bcd8739ae039) {
    constructor(...args){
        super(...args);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "pickZ", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_colors", null);
    }
    render(props) {
        if (props.pickingFBO) return this._drawPickingBuffer(props);
        return super.render(props);
    }
    _drawPickingBuffer({ layers: layers , layerFilter: layerFilter , views: views , viewports: viewports , onViewportActive: onViewportActive , pickingFBO: pickingFBO , deviceRect: { x: x , y: y , width: width , height: height  } , cullRect: cullRect , effects: effects , pass: pass = "picking" , pickZ: pickZ  }) {
        const gl = this.gl;
        this.pickZ = pickZ;
        const encodedColors = pickZ ? null : {
            byLayer: new Map(),
            byAlpha: []
        };
        this._colors = encodedColors;
        const renderStatus = (0, $54220aa8b6471f1a$export$b1e7058a2936b651)(gl, {
            scissorTest: true,
            scissor: [
                x,
                y,
                width,
                height
            ],
            clearColor: [
                0,
                0,
                0,
                0
            ],
            depthMask: true,
            depthTest: true,
            depthRange: [
                0,
                1
            ],
            colorMask: [
                true,
                true,
                true,
                true
            ],
            ...$7ea8e8d62e8ae777$var$PICKING_PARAMETERS,
            blend: !pickZ
        }, ()=>super.render({
                target: pickingFBO,
                layers: layers,
                layerFilter: layerFilter,
                views: views,
                viewports: viewports,
                onViewportActive: onViewportActive,
                cullRect: cullRect,
                effects: effects === null || effects === void 0 ? void 0 : effects.filter((e)=>e.useInPicking),
                pass: pass
            }));
        this._colors = null;
        const decodePickingColor = encodedColors && $7ea8e8d62e8ae777$var$decodeColor.bind(null, encodedColors);
        return {
            decodePickingColor: decodePickingColor,
            stats: renderStatus
        };
    }
    shouldDrawLayer(layer) {
        return layer.props.pickable && layer.props.operation === (0, $b42a5b9aa3b1a41f$export$b56168d831461ce2).DRAW;
    }
    getModuleParameters() {
        return {
            pickingActive: 1,
            pickingAttribute: this.pickZ,
            lightSources: {}
        };
    }
    getLayerParameters(layer, layerIndex, viewport) {
        const pickParameters = {
            ...layer.props.parameters
        };
        if (!this._colors) pickParameters.blend = false;
        else {
            Object.assign(pickParameters, $7ea8e8d62e8ae777$var$PICKING_PARAMETERS);
            pickParameters.blend = true;
            pickParameters.blendColor = $7ea8e8d62e8ae777$var$encodeColor(this._colors, layer, viewport);
        }
        return pickParameters;
    }
}
function $7ea8e8d62e8ae777$var$encodeColor(encoded, layer, viewport) {
    const { byLayer: byLayer , byAlpha: byAlpha  } = encoded;
    let a;
    let entry = byLayer.get(layer);
    if (entry) {
        entry.viewports.push(viewport);
        a = entry.a;
    } else {
        a = byLayer.size + 1;
        if (a <= 255) {
            entry = {
                a: a,
                layer: layer,
                viewports: [
                    viewport
                ]
            };
            byLayer.set(layer, entry);
            byAlpha[a] = entry;
        } else {
            (0, $146cba582e8c799f$export$2e2bcd8739ae039).warn("Too many pickable layers, only picking the first 255")();
            a = 0;
        }
    }
    return [
        0,
        0,
        0,
        a / 255
    ];
}
function $7ea8e8d62e8ae777$var$decodeColor(encoded, pickedColor) {
    const entry = encoded.byAlpha[pickedColor[3]];
    return entry && {
        pickedLayer: entry.layer,
        pickedViewports: entry.viewports,
        pickedObjectIndex: entry.layer.decodePickingColor(pickedColor)
    };
}



const $44be24ae5116c7d5$var$TRACE_RENDER_LAYERS = "deckRenderer.renderLayers";
class $44be24ae5116c7d5$export$2e2bcd8739ae039 {
    constructor(gl){
        this.gl = gl;
        this.layerFilter = null;
        this.drawPickingColors = false;
        this.drawLayersPass = new (0, $9b7315ba3a82d7e0$export$2e2bcd8739ae039)(gl);
        this.pickLayersPass = new (0, $7ea8e8d62e8ae777$export$2e2bcd8739ae039)(gl);
        this.renderCount = 0;
        this._needsRedraw = "Initial render";
        this.renderBuffers = [];
        this.lastPostProcessEffect = null;
    }
    setProps(props) {
        if ("layerFilter" in props && this.layerFilter !== props.layerFilter) {
            this.layerFilter = props.layerFilter;
            this._needsRedraw = "layerFilter changed";
        }
        if ("drawPickingColors" in props && this.drawPickingColors !== props.drawPickingColors) {
            this.drawPickingColors = props.drawPickingColors;
            this._needsRedraw = "drawPickingColors changed";
        }
    }
    renderLayers(opts) {
        const layerPass = this.drawPickingColors ? this.pickLayersPass : this.drawLayersPass;
        opts.layerFilter = opts.layerFilter || this.layerFilter;
        opts.effects = opts.effects || [];
        opts.target = opts.target || (0, $a0e9e15bc57c4882$export$2e2bcd8739ae039).getDefaultFramebuffer(this.gl);
        this._preRender(opts.effects, opts);
        const outputBuffer = this.lastPostProcessEffect ? this.renderBuffers[0] : opts.target;
        const renderStats = layerPass.render({
            ...opts,
            target: outputBuffer
        });
        this._postRender(opts.effects, opts);
        this.renderCount++;
        (0, $e34c41f170d77ab6$export$2e2bcd8739ae039)($44be24ae5116c7d5$var$TRACE_RENDER_LAYERS, this, renderStats, opts);
    }
    needsRedraw(opts = {
        clearRedrawFlags: false
    }) {
        const redraw = this._needsRedraw;
        if (opts.clearRedrawFlags) this._needsRedraw = false;
        return redraw;
    }
    finalize() {
        const { renderBuffers: renderBuffers  } = this;
        for (const buffer of renderBuffers)buffer.delete();
        renderBuffers.length = 0;
    }
    _preRender(effects, opts) {
        let lastPostProcessEffect = null;
        for (const effect of effects){
            effect.preRender(this.gl, opts);
            if (effect.postRender) lastPostProcessEffect = effect;
        }
        if (lastPostProcessEffect) this._resizeRenderBuffers();
        this.lastPostProcessEffect = lastPostProcessEffect;
    }
    _resizeRenderBuffers() {
        const { renderBuffers: renderBuffers  } = this;
        if (renderBuffers.length === 0) renderBuffers.push(new (0, $a0e9e15bc57c4882$export$2e2bcd8739ae039)(this.gl), new (0, $a0e9e15bc57c4882$export$2e2bcd8739ae039)(this.gl));
        for (const buffer of renderBuffers)buffer.resize();
    }
    _postRender(effects, opts) {
        const { renderBuffers: renderBuffers  } = this;
        const params = {
            inputBuffer: renderBuffers[0],
            swapBuffer: renderBuffers[1],
            target: null
        };
        for (const effect of effects)if (effect.postRender) {
            if (effect === this.lastPostProcessEffect) {
                params.target = opts.target;
                effect.postRender(this.gl, params);
                break;
            }
            const buffer = effect.postRender(this.gl, params);
            params.inputBuffer = buffer;
            params.swapBuffer = buffer === renderBuffers[0] ? renderBuffers[1] : renderBuffers[0];
        }
    }
}






const $7bec4d100b868a63$var$NO_PICKED_OBJECT = {
    pickedColor: null,
    pickedObjectIndex: -1
};
function $7bec4d100b868a63$export$e05a34ecba4eb9c3({ pickedColors: pickedColors , decodePickingColor: decodePickingColor , deviceX: deviceX , deviceY: deviceY , deviceRadius: deviceRadius , deviceRect: deviceRect  }) {
    const { x: x , y: y , width: width , height: height  } = deviceRect;
    let minSquareDistanceToCenter = deviceRadius * deviceRadius;
    let closestPixelIndex = -1;
    let i = 0;
    for(let row = 0; row < height; row++){
        const dy = row + y - deviceY;
        const dy2 = dy * dy;
        if (dy2 > minSquareDistanceToCenter) i += 4 * width;
        else for(let col = 0; col < width; col++){
            const pickedLayerIndex = pickedColors[i + 3] - 1;
            if (pickedLayerIndex >= 0) {
                const dx = col + x - deviceX;
                const d2 = dx * dx + dy2;
                if (d2 <= minSquareDistanceToCenter) {
                    minSquareDistanceToCenter = d2;
                    closestPixelIndex = i;
                }
            }
            i += 4;
        }
    }
    if (closestPixelIndex >= 0) {
        const pickedColor = pickedColors.slice(closestPixelIndex, closestPixelIndex + 4);
        const pickedObject = decodePickingColor(pickedColor);
        if (pickedObject) {
            const dy = Math.floor(closestPixelIndex / 4 / width);
            const dx = closestPixelIndex / 4 - dy * width;
            return {
                ...pickedObject,
                pickedColor: pickedColor,
                pickedX: x + dx,
                pickedY: y + dy
            };
        }
        (0, $146cba582e8c799f$export$2e2bcd8739ae039).error("Picked non-existent layer. Is picking buffer corrupt?")();
    }
    return $7bec4d100b868a63$var$NO_PICKED_OBJECT;
}
function $7bec4d100b868a63$export$f950d2b96083ede4({ pickedColors: pickedColors , decodePickingColor: decodePickingColor  }) {
    const uniqueColors = new Map();
    if (pickedColors) for(let i = 0; i < pickedColors.length; i += 4){
        const pickedLayerIndex = pickedColors[i + 3] - 1;
        if (pickedLayerIndex >= 0) {
            const pickedColor = pickedColors.slice(i, i + 4);
            const colorKey = pickedColor.join(",");
            if (!uniqueColors.has(colorKey)) {
                const pickedObject = decodePickingColor(pickedColor);
                if (pickedObject) uniqueColors.set(colorKey, {
                    ...pickedObject,
                    color: pickedColor
                });
                else (0, $146cba582e8c799f$export$2e2bcd8739ae039).error("Picked non-existent layer. Is picking buffer corrupt?")();
            }
        }
    }
    return Array.from(uniqueColors.values());
}


function $52af7c9fc3561b1c$export$ac275af7ad62fedf({ pickInfo: pickInfo , viewports: viewports , pixelRatio: pixelRatio , x: x , y: y , z: z  }) {
    let pickedViewport = viewports[0];
    if (viewports.length > 1) pickedViewport = $52af7c9fc3561b1c$var$getViewportFromCoordinates((pickInfo === null || pickInfo === void 0 ? void 0 : pickInfo.pickedViewports) || viewports, {
        x: x,
        y: y
    });
    let coordinate;
    if (pickedViewport) {
        const point = [
            x - pickedViewport.x,
            y - pickedViewport.y
        ];
        if (z !== undefined) point[2] = z;
        coordinate = pickedViewport.unproject(point);
    }
    return {
        color: null,
        layer: null,
        viewport: pickedViewport,
        index: -1,
        picked: false,
        x: x,
        y: y,
        pixel: [
            x,
            y
        ],
        coordinate: coordinate,
        devicePixel: pickInfo && "pickedX" in pickInfo ? [
            pickInfo.pickedX,
            pickInfo.pickedY
        ] : undefined,
        pixelRatio: pixelRatio
    };
}
function $52af7c9fc3561b1c$export$5169f687738446ff(opts) {
    const { pickInfo: pickInfo , lastPickedInfo: lastPickedInfo , mode: mode , layers: layers  } = opts;
    const { pickedColor: pickedColor , pickedLayer: pickedLayer , pickedObjectIndex: pickedObjectIndex  } = pickInfo;
    const affectedLayers = pickedLayer ? [
        pickedLayer
    ] : [];
    if (mode === "hover") {
        const lastPickedPixelIndex = lastPickedInfo.index;
        const lastPickedLayerId = lastPickedInfo.layerId;
        const pickedLayerId = pickedLayer ? pickedLayer.props.id : null;
        if (pickedLayerId !== lastPickedLayerId || pickedObjectIndex !== lastPickedPixelIndex) {
            if (pickedLayerId !== lastPickedLayerId) {
                const lastPickedLayer = layers.find((layer)=>layer.props.id === lastPickedLayerId);
                if (lastPickedLayer) affectedLayers.unshift(lastPickedLayer);
            }
            lastPickedInfo.layerId = pickedLayerId;
            lastPickedInfo.index = pickedObjectIndex;
            lastPickedInfo.info = null;
        }
    }
    const baseInfo = $52af7c9fc3561b1c$export$ac275af7ad62fedf(opts);
    const infos = new Map();
    infos.set(null, baseInfo);
    affectedLayers.forEach((layer)=>{
        let info = {
            ...baseInfo
        };
        if (layer === pickedLayer) {
            info.color = pickedColor;
            info.index = pickedObjectIndex;
            info.picked = true;
        }
        info = $52af7c9fc3561b1c$export$8ad0e0d5dfb9b541({
            layer: layer,
            info: info,
            mode: mode
        });
        const rootLayer = info.layer;
        if (layer === pickedLayer && mode === "hover") lastPickedInfo.info = info;
        infos.set(rootLayer.id, info);
        if (mode === "hover") rootLayer.updateAutoHighlight(info);
    });
    return infos;
}
function $52af7c9fc3561b1c$export$8ad0e0d5dfb9b541({ layer: layer , info: info , mode: mode  }) {
    while(layer && info){
        const sourceLayer = info.layer || null;
        info.sourceLayer = sourceLayer;
        info.layer = layer;
        info = layer.getPickingInfo({
            info: info,
            mode: mode,
            sourceLayer: sourceLayer
        });
        layer = layer.parent;
    }
    return info;
}
function $52af7c9fc3561b1c$var$getViewportFromCoordinates(viewports, pixel) {
    for(let i = viewports.length - 1; i >= 0; i--){
        const viewport = viewports[i];
        if (viewport.containsPixel(pixel)) return viewport;
    }
    return viewports[0];
}


class $846591e5a404f643$export$2e2bcd8739ae039 {
    constructor(gl){
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "gl", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "pickingFBO", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "depthFBO", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "pickLayersPass", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "layerFilter", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "lastPickedInfo", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_pickable", true);
        this.gl = gl;
        this.pickLayersPass = new (0, $7ea8e8d62e8ae777$export$2e2bcd8739ae039)(gl);
        this.lastPickedInfo = {
            index: -1,
            layerId: null,
            info: null
        };
    }
    setProps(props) {
        if ("layerFilter" in props) this.layerFilter = props.layerFilter;
        if ("_pickable" in props) this._pickable = props._pickable;
    }
    finalize() {
        if (this.pickingFBO) this.pickingFBO.delete();
        if (this.depthFBO) {
            this.depthFBO.color.delete();
            this.depthFBO.delete();
        }
    }
    pickObject(opts) {
        return this._pickClosestObject(opts);
    }
    pickObjects(opts) {
        return this._pickVisibleObjects(opts);
    }
    getLastPickedObject({ x: x , y: y , layers: layers , viewports: viewports  }, lastPickedInfo = this.lastPickedInfo.info) {
        const lastPickedLayerId = lastPickedInfo && lastPickedInfo.layer && lastPickedInfo.layer.id;
        const lastPickedViewportId = lastPickedInfo && lastPickedInfo.viewport && lastPickedInfo.viewport.id;
        const layer = lastPickedLayerId ? layers.find((l)=>l.id === lastPickedLayerId) : null;
        const viewport = lastPickedViewportId && viewports.find((v)=>v.id === lastPickedViewportId) || viewports[0];
        const coordinate = viewport && viewport.unproject([
            x - viewport.x,
            y - viewport.y
        ]);
        const info = {
            x: x,
            y: y,
            viewport: viewport,
            coordinate: coordinate,
            layer: layer
        };
        return {
            ...lastPickedInfo,
            ...info
        };
    }
    _resizeBuffer() {
        var _this$pickingFBO, _this$depthFBO;
        const { gl: gl  } = this;
        if (!this.pickingFBO) {
            this.pickingFBO = new (0, $a0e9e15bc57c4882$export$2e2bcd8739ae039)(gl);
            if ((0, $a0e9e15bc57c4882$export$2e2bcd8739ae039).isSupported(gl, {
                colorBufferFloat: true
            })) {
                const depthFBO = new (0, $a0e9e15bc57c4882$export$2e2bcd8739ae039)(gl);
                depthFBO.attach({
                    [36064]: new (0, $df31c887249e3faa$export$2e2bcd8739ae039)(gl, {
                        format: (0, $325e733792a03f4e$export$e3518b1ac7891039)(gl) ? 34836 : 6408,
                        type: 5126
                    })
                });
                this.depthFBO = depthFBO;
            }
        }
        (_this$pickingFBO = this.pickingFBO) === null || _this$pickingFBO === void 0 || _this$pickingFBO.resize({
            width: gl.canvas.width,
            height: gl.canvas.height
        });
        (_this$depthFBO = this.depthFBO) === null || _this$depthFBO === void 0 || _this$depthFBO.resize({
            width: gl.canvas.width,
            height: gl.canvas.height
        });
    }
    _getPickable(layers) {
        if (this._pickable === false) return null;
        const pickableLayers = layers.filter((layer)=>layer.isPickable() && !layer.isComposite);
        return pickableLayers.length ? pickableLayers : null;
    }
    _pickClosestObject({ layers: layers , views: views , viewports: viewports , x: x , y: y , radius: radius = 0 , depth: depth = 1 , mode: mode = "query" , unproject3D: unproject3D , onViewportActive: onViewportActive , effects: effects  }) {
        const pickableLayers = this._getPickable(layers);
        const pixelRatio = (0, $294e503c6396a3ff$export$df40057290e74703)(this.gl);
        if (!pickableLayers) return {
            result: [],
            emptyInfo: (0, $52af7c9fc3561b1c$export$ac275af7ad62fedf)({
                viewports: viewports,
                x: x,
                y: y,
                pixelRatio: pixelRatio
            })
        };
        this._resizeBuffer();
        const devicePixelRange = (0, $294e503c6396a3ff$export$af080a4e21b7825c)(this.gl, [
            x,
            y
        ], true);
        const devicePixel = [
            devicePixelRange.x + Math.floor(devicePixelRange.width / 2),
            devicePixelRange.y + Math.floor(devicePixelRange.height / 2)
        ];
        const deviceRadius = Math.round(radius * pixelRatio);
        const { width: width , height: height  } = this.pickingFBO;
        const deviceRect = this._getPickingRect({
            deviceX: devicePixel[0],
            deviceY: devicePixel[1],
            deviceRadius: deviceRadius,
            deviceWidth: width,
            deviceHeight: height
        });
        const cullRect = {
            x: x - radius,
            y: y - radius,
            width: radius * 2 + 1,
            height: radius * 2 + 1
        };
        let infos;
        const result = [];
        const affectedLayers = new Set();
        for(let i = 0; i < depth; i++){
            let pickInfo;
            if (deviceRect) {
                const pickedResult = this._drawAndSample({
                    layers: pickableLayers,
                    views: views,
                    viewports: viewports,
                    onViewportActive: onViewportActive,
                    deviceRect: deviceRect,
                    cullRect: cullRect,
                    effects: effects,
                    pass: "picking:".concat(mode)
                });
                pickInfo = (0, $7bec4d100b868a63$export$e05a34ecba4eb9c3)({
                    ...pickedResult,
                    deviceX: devicePixel[0],
                    deviceY: devicePixel[1],
                    deviceRadius: deviceRadius,
                    deviceRect: deviceRect
                });
            } else pickInfo = {
                pickedColor: null,
                pickedObjectIndex: -1
            };
            let z;
            if (pickInfo.pickedLayer && unproject3D && this.depthFBO) {
                const pickedResultPass2 = this._drawAndSample({
                    layers: [
                        pickInfo.pickedLayer
                    ],
                    views: views,
                    viewports: viewports,
                    onViewportActive: onViewportActive,
                    deviceRect: {
                        x: pickInfo.pickedX,
                        y: pickInfo.pickedY,
                        width: 1,
                        height: 1
                    },
                    cullRect: cullRect,
                    effects: effects,
                    pass: "picking:".concat(mode, ":z")
                }, true);
                z = pickedResultPass2.pickedColors[0];
            }
            if (pickInfo.pickedLayer && i + 1 < depth) {
                affectedLayers.add(pickInfo.pickedLayer);
                pickInfo.pickedLayer.disablePickingIndex(pickInfo.pickedObjectIndex);
            }
            infos = (0, $52af7c9fc3561b1c$export$5169f687738446ff)({
                pickInfo: pickInfo,
                lastPickedInfo: this.lastPickedInfo,
                mode: mode,
                layers: pickableLayers,
                viewports: viewports,
                x: x,
                y: y,
                z: z,
                pixelRatio: pixelRatio
            });
            for (const info of infos.values())if (info.layer) result.push(info);
            if (!pickInfo.pickedColor) break;
        }
        for (const layer of affectedLayers)layer.restorePickingColors();
        return {
            result: result,
            emptyInfo: infos.get(null)
        };
    }
    _pickVisibleObjects({ layers: layers , views: views , viewports: viewports , x: x , y: y , width: width = 1 , height: height = 1 , mode: mode = "query" , maxObjects: maxObjects = null , onViewportActive: onViewportActive , effects: effects  }) {
        const pickableLayers = this._getPickable(layers);
        if (!pickableLayers) return [];
        this._resizeBuffer();
        const pixelRatio = (0, $294e503c6396a3ff$export$df40057290e74703)(this.gl);
        const leftTop = (0, $294e503c6396a3ff$export$af080a4e21b7825c)(this.gl, [
            x,
            y
        ], true);
        const deviceLeft = leftTop.x;
        const deviceTop = leftTop.y + leftTop.height;
        const rightBottom = (0, $294e503c6396a3ff$export$af080a4e21b7825c)(this.gl, [
            x + width,
            y + height
        ], true);
        const deviceRight = rightBottom.x + rightBottom.width;
        const deviceBottom = rightBottom.y;
        const deviceRect = {
            x: deviceLeft,
            y: deviceBottom,
            width: deviceRight - deviceLeft,
            height: deviceTop - deviceBottom
        };
        const pickedResult = this._drawAndSample({
            layers: pickableLayers,
            views: views,
            viewports: viewports,
            onViewportActive: onViewportActive,
            deviceRect: deviceRect,
            cullRect: {
                x: x,
                y: y,
                width: width,
                height: height
            },
            effects: effects,
            pass: "picking:".concat(mode)
        });
        const pickInfos = (0, $7bec4d100b868a63$export$f950d2b96083ede4)(pickedResult);
        const uniqueInfos = new Map();
        const isMaxObjects = Number.isFinite(maxObjects);
        for(let i = 0; i < pickInfos.length; i++){
            if (isMaxObjects && maxObjects && uniqueInfos.size >= maxObjects) break;
            const pickInfo = pickInfos[i];
            let info = {
                color: pickInfo.pickedColor,
                layer: null,
                index: pickInfo.pickedObjectIndex,
                picked: true,
                x: x,
                y: y,
                pixelRatio: pixelRatio
            };
            info = (0, $52af7c9fc3561b1c$export$8ad0e0d5dfb9b541)({
                layer: pickInfo.pickedLayer,
                info: info,
                mode: mode
            });
            if (!uniqueInfos.has(info.object)) uniqueInfos.set(info.object, info);
        }
        return Array.from(uniqueInfos.values());
    }
    _drawAndSample({ layers: layers , views: views , viewports: viewports , onViewportActive: onViewportActive , deviceRect: deviceRect , cullRect: cullRect , effects: effects , pass: pass  }, pickZ = false) {
        const pickingFBO = pickZ ? this.depthFBO : this.pickingFBO;
        const { decodePickingColor: decodePickingColor  } = this.pickLayersPass.render({
            layers: layers,
            layerFilter: this.layerFilter,
            views: views,
            viewports: viewports,
            onViewportActive: onViewportActive,
            pickingFBO: pickingFBO,
            deviceRect: deviceRect,
            cullRect: cullRect,
            effects: effects,
            pass: pass,
            pickZ: pickZ
        });
        const { x: x , y: y , width: width , height: height  } = deviceRect;
        const pickedColors = new (pickZ ? Float32Array : Uint8Array)(width * height * 4);
        (0, $c192e756436d1779$export$f9f2f48e7f9faaa5)(pickingFBO, {
            sourceX: x,
            sourceY: y,
            sourceWidth: width,
            sourceHeight: height,
            target: pickedColors
        });
        return {
            pickedColors: pickedColors,
            decodePickingColor: decodePickingColor
        };
    }
    _getPickingRect({ deviceX: deviceX , deviceY: deviceY , deviceRadius: deviceRadius , deviceWidth: deviceWidth , deviceHeight: deviceHeight  }) {
        const x = Math.max(0, deviceX - deviceRadius);
        const y = Math.max(0, deviceY - deviceRadius);
        const width = Math.min(deviceWidth, deviceX + deviceRadius + 1) - x;
        const height = Math.min(deviceHeight, deviceY + deviceRadius + 1) - y;
        if (width <= 0 || height <= 0) return null;
        return {
            x: x,
            y: y,
            width: width,
            height: height
        };
    }
}



const $0ce0aac1c3cdf79a$var$defaultStyle = {
    zIndex: "1",
    position: "absolute",
    pointerEvents: "none",
    color: "#a0a7b4",
    backgroundColor: "#29323c",
    padding: "10px",
    top: "0",
    left: "0",
    display: "none"
};
class $0ce0aac1c3cdf79a$export$2e2bcd8739ae039 {
    constructor(canvas){
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "el", null);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "isVisible", false);
        const canvasParent = canvas.parentElement;
        if (canvasParent) {
            this.el = document.createElement("div");
            this.el.className = "deck-tooltip";
            Object.assign(this.el.style, $0ce0aac1c3cdf79a$var$defaultStyle);
            canvasParent.appendChild(this.el);
        }
    }
    setTooltip(displayInfo, x, y) {
        const el = this.el;
        if (!el) return;
        if (typeof displayInfo === "string") el.innerText = displayInfo;
        else if (!displayInfo) {
            this.isVisible = false;
            el.style.display = "none";
            return;
        } else {
            if (displayInfo.text) el.innerText = displayInfo.text;
            if (displayInfo.html) el.innerHTML = displayInfo.html;
            if (displayInfo.className) el.className = displayInfo.className;
            Object.assign(el.style, displayInfo.style);
        }
        this.isVisible = true;
        el.style.display = "block";
        el.style.transform = "translate(".concat(x, "px, ").concat(y, "px)");
    }
    remove() {
        if (this.el) {
            this.el.remove();
            this.el = null;
        }
    }
}






const $6ac05cc9715692e0$export$a4ad2735b021c132 = "3.2.5";




const { _parseImageNode: $aa0764cc8dcd9b15$var$_parseImageNode  } = globalThis;
const $aa0764cc8dcd9b15$var$IMAGE_SUPPORTED = typeof Image !== "undefined";
const $aa0764cc8dcd9b15$var$IMAGE_BITMAP_SUPPORTED = typeof ImageBitmap !== "undefined";
const $aa0764cc8dcd9b15$var$NODE_IMAGE_SUPPORTED = Boolean($aa0764cc8dcd9b15$var$_parseImageNode);
const $aa0764cc8dcd9b15$var$DATA_SUPPORTED = (0, $4684b3280a916bc3$export$4e09c449d6c407f7) ? true : $aa0764cc8dcd9b15$var$NODE_IMAGE_SUPPORTED;
function $aa0764cc8dcd9b15$export$b6d6c5f9d0d9c212(type) {
    switch(type){
        case "auto":
            return $aa0764cc8dcd9b15$var$IMAGE_BITMAP_SUPPORTED || $aa0764cc8dcd9b15$var$IMAGE_SUPPORTED || $aa0764cc8dcd9b15$var$DATA_SUPPORTED;
        case "imagebitmap":
            return $aa0764cc8dcd9b15$var$IMAGE_BITMAP_SUPPORTED;
        case "image":
            return $aa0764cc8dcd9b15$var$IMAGE_SUPPORTED;
        case "data":
            return $aa0764cc8dcd9b15$var$DATA_SUPPORTED;
        default:
            throw new Error("@loaders.gl/images: image ".concat(type, " not supported in this environment"));
    }
}
function $aa0764cc8dcd9b15$export$2b0a859319ebc411() {
    if ($aa0764cc8dcd9b15$var$IMAGE_BITMAP_SUPPORTED) return "imagebitmap";
    if ($aa0764cc8dcd9b15$var$IMAGE_SUPPORTED) return "image";
    if ($aa0764cc8dcd9b15$var$DATA_SUPPORTED) return "data";
    throw new Error("Install '@loaders.gl/polyfills' to parse images under Node.js");
}


function $da2179cf94f5991c$export$fb85bc5d6d9ef19b(image) {
    return Boolean($da2179cf94f5991c$var$getImageTypeOrNull(image));
}
function $da2179cf94f5991c$export$2d0b7dd5ef39c509(image) {
    switch($da2179cf94f5991c$export$b8e3c51900b5ca88(image)){
        case "imagebitmap":
            image.close();
            break;
        default:
    }
}
function $da2179cf94f5991c$export$b8e3c51900b5ca88(image) {
    const format = $da2179cf94f5991c$var$getImageTypeOrNull(image);
    if (!format) throw new Error("Not an image");
    return format;
}
function $da2179cf94f5991c$export$ada5537b2c061996(image) {
    return $da2179cf94f5991c$export$d93c68e129326488(image);
}
function $da2179cf94f5991c$export$d93c68e129326488(image) {
    switch($da2179cf94f5991c$export$b8e3c51900b5ca88(image)){
        case "data":
            return image;
        case "image":
        case "imagebitmap":
            const canvas = document.createElement("canvas");
            const context = canvas.getContext("2d");
            if (!context) throw new Error("getImageData");
            canvas.width = image.width;
            canvas.height = image.height;
            context.drawImage(image, 0, 0);
            return context.getImageData(0, 0, image.width, image.height);
        default:
            throw new Error("getImageData");
    }
}
function $da2179cf94f5991c$var$getImageTypeOrNull(image) {
    if (typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) return "imagebitmap";
    if (typeof Image !== "undefined" && image instanceof Image) return "image";
    if (image && typeof image === "object" && image.data && image.width && image.height) return "data";
    return null;
}


const $015d5caac190482a$var$SVG_DATA_URL_PATTERN = /^data:image\/svg\+xml/;
const $015d5caac190482a$var$SVG_URL_PATTERN = /\.svg((\?|#).*)?$/;
function $015d5caac190482a$export$165b39ed277223c2(url) {
    return url && ($015d5caac190482a$var$SVG_DATA_URL_PATTERN.test(url) || $015d5caac190482a$var$SVG_URL_PATTERN.test(url));
}
function $015d5caac190482a$export$d1c0f60cd342a54(arrayBuffer, url) {
    if ($015d5caac190482a$export$165b39ed277223c2(url)) {
        const textDecoder = new TextDecoder();
        let xmlText = textDecoder.decode(arrayBuffer);
        try {
            if (typeof unescape === "function" && typeof encodeURIComponent === "function") xmlText = unescape(encodeURIComponent(xmlText));
        } catch (error) {
            throw new Error(error.message);
        }
        const src = "data:image/svg+xml;base64,".concat(btoa(xmlText));
        return src;
    }
    return $015d5caac190482a$export$37610328929d7521(arrayBuffer, url);
}
function $015d5caac190482a$export$37610328929d7521(arrayBuffer, url) {
    if ($015d5caac190482a$export$165b39ed277223c2(url)) throw new Error("SVG cannot be parsed directly to imagebitmap");
    return new Blob([
        new Uint8Array(arrayBuffer)
    ]);
}


async function $1d0090429568bf29$export$2e2bcd8739ae039(arrayBuffer, options, url) {
    const blobOrDataUrl = (0, $015d5caac190482a$export$d1c0f60cd342a54)(arrayBuffer, url);
    const URL = self.URL || self.webkitURL;
    const objectUrl = typeof blobOrDataUrl !== "string" && URL.createObjectURL(blobOrDataUrl);
    try {
        return await $1d0090429568bf29$export$2f2a1d2adfedb145(objectUrl || blobOrDataUrl, options);
    } finally{
        if (objectUrl) URL.revokeObjectURL(objectUrl);
    }
}
async function $1d0090429568bf29$export$2f2a1d2adfedb145(url, options) {
    const image = new Image();
    image.src = url;
    if (options.image && options.image.decode && image.decode) {
        await image.decode();
        return image;
    }
    return await new Promise((resolve, reject)=>{
        try {
            image.onload = ()=>resolve(image);
            image.onerror = (err)=>reject(new Error("Could not load image ".concat(url, ": ").concat(err)));
        } catch (error) {
            reject(error);
        }
    });
}




const $a8272a33ac9d2a51$var$EMPTY_OBJECT = {};
let $a8272a33ac9d2a51$var$imagebitmapOptionsSupported = true;
async function $a8272a33ac9d2a51$export$2e2bcd8739ae039(arrayBuffer, options, url) {
    let blob;
    if ((0, $015d5caac190482a$export$165b39ed277223c2)(url)) {
        const image = await (0, $1d0090429568bf29$export$2e2bcd8739ae039)(arrayBuffer, options, url);
        blob = image;
    } else blob = (0, $015d5caac190482a$export$37610328929d7521)(arrayBuffer, url);
    const imagebitmapOptions = options && options.imagebitmap;
    return await $a8272a33ac9d2a51$var$safeCreateImageBitmap(blob, imagebitmapOptions);
}
async function $a8272a33ac9d2a51$var$safeCreateImageBitmap(blob, imagebitmapOptions = null) {
    if ($a8272a33ac9d2a51$var$isEmptyObject(imagebitmapOptions) || !$a8272a33ac9d2a51$var$imagebitmapOptionsSupported) imagebitmapOptions = null;
    if (imagebitmapOptions) try {
        return await createImageBitmap(blob, imagebitmapOptions);
    } catch (error) {
        console.warn(error);
        $a8272a33ac9d2a51$var$imagebitmapOptionsSupported = false;
    }
    return await createImageBitmap(blob);
}
function $a8272a33ac9d2a51$var$isEmptyObject(object) {
    for(const key in object || $a8272a33ac9d2a51$var$EMPTY_OBJECT)return false;
    return true;
}



const $b08c3d5f2810bbd6$var$BIG_ENDIAN = false;
const $b08c3d5f2810bbd6$var$LITTLE_ENDIAN = true;
function $b08c3d5f2810bbd6$export$6dae8baa11df6159(binaryData) {
    const dataView = $b08c3d5f2810bbd6$var$toDataView(binaryData);
    return $b08c3d5f2810bbd6$var$getPngMetadata(dataView) || $b08c3d5f2810bbd6$var$getJpegMetadata(dataView) || $b08c3d5f2810bbd6$var$getGifMetadata(dataView) || $b08c3d5f2810bbd6$export$1e6b8ff544bd73cb(dataView);
}
function $b08c3d5f2810bbd6$var$getPngMetadata(binaryData) {
    const dataView = $b08c3d5f2810bbd6$var$toDataView(binaryData);
    const isPng = dataView.byteLength >= 24 && dataView.getUint32(0, $b08c3d5f2810bbd6$var$BIG_ENDIAN) === 0x89504e47;
    if (!isPng) return null;
    return {
        mimeType: "image/png",
        width: dataView.getUint32(16, $b08c3d5f2810bbd6$var$BIG_ENDIAN),
        height: dataView.getUint32(20, $b08c3d5f2810bbd6$var$BIG_ENDIAN)
    };
}
function $b08c3d5f2810bbd6$var$getGifMetadata(binaryData) {
    const dataView = $b08c3d5f2810bbd6$var$toDataView(binaryData);
    const isGif = dataView.byteLength >= 10 && dataView.getUint32(0, $b08c3d5f2810bbd6$var$BIG_ENDIAN) === 0x47494638;
    if (!isGif) return null;
    return {
        mimeType: "image/gif",
        width: dataView.getUint16(6, $b08c3d5f2810bbd6$var$LITTLE_ENDIAN),
        height: dataView.getUint16(8, $b08c3d5f2810bbd6$var$LITTLE_ENDIAN)
    };
}
function $b08c3d5f2810bbd6$export$1e6b8ff544bd73cb(binaryData) {
    const dataView = $b08c3d5f2810bbd6$var$toDataView(binaryData);
    const isBmp = dataView.byteLength >= 14 && dataView.getUint16(0, $b08c3d5f2810bbd6$var$BIG_ENDIAN) === 0x424d && dataView.getUint32(2, $b08c3d5f2810bbd6$var$LITTLE_ENDIAN) === dataView.byteLength;
    if (!isBmp) return null;
    return {
        mimeType: "image/bmp",
        width: dataView.getUint32(18, $b08c3d5f2810bbd6$var$LITTLE_ENDIAN),
        height: dataView.getUint32(22, $b08c3d5f2810bbd6$var$LITTLE_ENDIAN)
    };
}
function $b08c3d5f2810bbd6$var$getJpegMetadata(binaryData) {
    const dataView = $b08c3d5f2810bbd6$var$toDataView(binaryData);
    const isJpeg = dataView.byteLength >= 3 && dataView.getUint16(0, $b08c3d5f2810bbd6$var$BIG_ENDIAN) === 0xffd8 && dataView.getUint8(2) === 0xff;
    if (!isJpeg) return null;
    const { tableMarkers: tableMarkers , sofMarkers: sofMarkers  } = $b08c3d5f2810bbd6$var$getJpegMarkers();
    let i = 2;
    while(i + 9 < dataView.byteLength){
        const marker = dataView.getUint16(i, $b08c3d5f2810bbd6$var$BIG_ENDIAN);
        if (sofMarkers.has(marker)) return {
            mimeType: "image/jpeg",
            height: dataView.getUint16(i + 5, $b08c3d5f2810bbd6$var$BIG_ENDIAN),
            width: dataView.getUint16(i + 7, $b08c3d5f2810bbd6$var$BIG_ENDIAN)
        };
        if (!tableMarkers.has(marker)) return null;
        i += 2;
        i += dataView.getUint16(i, $b08c3d5f2810bbd6$var$BIG_ENDIAN);
    }
    return null;
}
function $b08c3d5f2810bbd6$var$getJpegMarkers() {
    const tableMarkers = new Set([
        0xffdb,
        0xffc4,
        0xffcc,
        0xffdd,
        0xfffe
    ]);
    for(let i = 0xffe0; i < 0xfff0; ++i)tableMarkers.add(i);
    const sofMarkers = new Set([
        0xffc0,
        0xffc1,
        0xffc2,
        0xffc3,
        0xffc5,
        0xffc6,
        0xffc7,
        0xffc9,
        0xffca,
        0xffcb,
        0xffcd,
        0xffce,
        0xffcf,
        0xffde
    ]);
    return {
        tableMarkers: tableMarkers,
        sofMarkers: sofMarkers
    };
}
function $b08c3d5f2810bbd6$var$toDataView(data) {
    if (data instanceof DataView) return data;
    if (ArrayBuffer.isView(data)) return new DataView(data.buffer);
    if (data instanceof ArrayBuffer) return new DataView(data);
    throw new Error("toDataView");
}


async function $5992765fc8a62fc2$export$2e2bcd8739ae039(arrayBuffer, options) {
    const { mimeType: mimeType  } = (0, $b08c3d5f2810bbd6$export$6dae8baa11df6159)(arrayBuffer) || {};
    const _parseImageNode = globalThis._parseImageNode;
    (0, $e2d3345494943a51$export$a7a9523472993e97)(_parseImageNode);
    return await _parseImageNode(arrayBuffer, mimeType);
}


async function $cd314c20e1568fab$export$2e2bcd8739ae039(arrayBuffer, options, context) {
    options = options || {};
    const imageOptions = options.image || {};
    const imageType = imageOptions.type || "auto";
    const { url: url  } = context || {};
    const loadType = $cd314c20e1568fab$var$getLoadableImageType(imageType);
    let image;
    switch(loadType){
        case "imagebitmap":
            image = await (0, $a8272a33ac9d2a51$export$2e2bcd8739ae039)(arrayBuffer, options, url);
            break;
        case "image":
            image = await (0, $1d0090429568bf29$export$2e2bcd8739ae039)(arrayBuffer, options, url);
            break;
        case "data":
            image = await (0, $5992765fc8a62fc2$export$2e2bcd8739ae039)(arrayBuffer, options);
            break;
        default:
            (0, $e2d3345494943a51$export$a7a9523472993e97)(false);
    }
    if (imageType === "data") image = (0, $da2179cf94f5991c$export$d93c68e129326488)(image);
    return image;
}
function $cd314c20e1568fab$var$getLoadableImageType(type) {
    switch(type){
        case "auto":
        case "data":
            return (0, $aa0764cc8dcd9b15$export$2b0a859319ebc411)();
        default:
            (0, $aa0764cc8dcd9b15$export$b6d6c5f9d0d9c212)(type);
            return type;
    }
}



const $c5b13686f235cd74$var$EXTENSIONS = [
    "png",
    "jpg",
    "jpeg",
    "gif",
    "webp",
    "bmp",
    "ico",
    "svg"
];
const $c5b13686f235cd74$var$MIME_TYPES = [
    "image/png",
    "image/jpeg",
    "image/gif",
    "image/webp",
    "image/bmp",
    "image/vnd.microsoft.icon",
    "image/svg+xml"
];
const $c5b13686f235cd74$var$DEFAULT_IMAGE_LOADER_OPTIONS = {
    image: {
        type: "auto",
        decode: true
    }
};
const $c5b13686f235cd74$export$8905ce1c7a2464a1 = {
    id: "image",
    module: "images",
    name: "Images",
    version: (0, $6ac05cc9715692e0$export$a4ad2735b021c132),
    mimeTypes: $c5b13686f235cd74$var$MIME_TYPES,
    extensions: $c5b13686f235cd74$var$EXTENSIONS,
    parse: (0, $cd314c20e1568fab$export$2e2bcd8739ae039),
    tests: [
        (arrayBuffer)=>Boolean((0, $b08c3d5f2810bbd6$export$6dae8baa11df6159)(new DataView(arrayBuffer)))
    ],
    options: $c5b13686f235cd74$var$DEFAULT_IMAGE_LOADER_OPTIONS
};
const $c5b13686f235cd74$export$249a824650b4f45f = $c5b13686f235cd74$export$8905ce1c7a2464a1;





function $bb2666eab5426e5e$var$isJSON(text) {
    const firstChar = text[0];
    const lastChar = text[text.length - 1];
    return firstChar === "{" && lastChar === "}" || firstChar === "[" && lastChar === "]";
}
var $bb2666eab5426e5e$export$2e2bcd8739ae039 = {
    id: "JSON",
    name: "JSON",
    module: "",
    version: "",
    options: {},
    extensions: [
        "json",
        "geojson"
    ],
    mimeTypes: [
        "application/json",
        "application/geo+json"
    ],
    testText: $bb2666eab5426e5e$var$isJSON,
    parseTextSync: JSON.parse
};


const $fb7f1a5ab7b23558$var$version = "8.8.4";
const $fb7f1a5ab7b23558$var$existingVersion = globalThis.deck && globalThis.deck.VERSION;
if ($fb7f1a5ab7b23558$var$existingVersion && $fb7f1a5ab7b23558$var$existingVersion !== $fb7f1a5ab7b23558$var$version) throw new Error("deck.gl - multiple versions detected: ".concat($fb7f1a5ab7b23558$var$existingVersion, " vs ").concat($fb7f1a5ab7b23558$var$version));
if (!$fb7f1a5ab7b23558$var$existingVersion) {
    (0, $146cba582e8c799f$export$2e2bcd8739ae039).log(1, "deck.gl ".concat($fb7f1a5ab7b23558$var$version))();
    globalThis.deck = {
        ...globalThis.deck,
        VERSION: $fb7f1a5ab7b23558$var$version,
        version: $fb7f1a5ab7b23558$var$version,
        log: $146cba582e8c799f$export$2e2bcd8739ae039,
        _registerLoggers: (0, $e34c41f170d77ab6$export$6503ec6e8aabbaf)
    };
    (0, $74a7778b58c84a5d$export$74069a1a10fa28e5)([
        (0, $bb2666eab5426e5e$export$2e2bcd8739ae039),
        [
            (0, $c5b13686f235cd74$export$8905ce1c7a2464a1),
            {
                imagebitmap: {
                    premultiplyAlpha: "none"
                }
            }
        ]
    ]);
}
var $fb7f1a5ab7b23558$export$2e2bcd8739ae039 = globalThis.deck;





var $9232896258c69fa7$exports = {};
/*! Hammer.JS - v2.0.7 - 2016-04-22
 * http://hammerjs.github.io/
 *
 * Copyright (c) 2016 Jorik Tangelder;
 * Licensed under the MIT license */ (function(window, document, exportName, undefined) {
    "use strict";
    var VENDOR_PREFIXES = [
        "",
        "webkit",
        "Moz",
        "MS",
        "ms",
        "o"
    ];
    var TEST_ELEMENT = document.createElement("div");
    var TYPE_FUNCTION = "function";
    var round = Math.round;
    var abs = Math.abs;
    var now = Date.now;
    /**
 * set a timeout with a given scope
 * @param {Function} fn
 * @param {Number} timeout
 * @param {Object} context
 * @returns {number}
 */ function setTimeoutContext(fn, timeout, context) {
        return setTimeout(bindFn(fn, context), timeout);
    }
    /**
 * if the argument is an array, we want to execute the fn on each entry
 * if it aint an array we don't want to do a thing.
 * this is used by all the methods that accept a single and array argument.
 * @param {*|Array} arg
 * @param {String} fn
 * @param {Object} [context]
 * @returns {Boolean}
 */ function invokeArrayArg(arg, fn, context) {
        if (Array.isArray(arg)) {
            each(arg, context[fn], context);
            return true;
        }
        return false;
    }
    /**
 * walk objects and arrays
 * @param {Object} obj
 * @param {Function} iterator
 * @param {Object} context
 */ function each(obj, iterator, context) {
        var i;
        if (!obj) return;
        if (obj.forEach) obj.forEach(iterator, context);
        else if (obj.length !== undefined) {
            i = 0;
            while(i < obj.length){
                iterator.call(context, obj[i], i, obj);
                i++;
            }
        } else for(i in obj)obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);
    }
    /**
 * wrap a method with a deprecation warning and stack trace
 * @param {Function} method
 * @param {String} name
 * @param {String} message
 * @returns {Function} A new function wrapping the supplied method.
 */ function deprecate(method, name, message) {
        var deprecationMessage = "DEPRECATED METHOD: " + name + "\n" + message + " AT \n";
        return function() {
            var e = new Error("get-stack-trace");
            var stack = e && e.stack ? e.stack.replace(/^[^\(]+?[\n$]/gm, "").replace(/^\s+at\s+/gm, "").replace(/^Object.<anonymous>\s*\(/gm, "{anonymous}()@") : "Unknown Stack Trace";
            var log = window.console && (window.console.warn || window.console.log);
            if (log) log.call(window.console, deprecationMessage, stack);
            return method.apply(this, arguments);
        };
    }
    /**
 * extend object.
 * means that properties in dest will be overwritten by the ones in src.
 * @param {Object} target
 * @param {...Object} objects_to_assign
 * @returns {Object} target
 */ var assign;
    if (typeof Object.assign !== "function") assign = function assign(target) {
        if (target === undefined || target === null) throw new TypeError("Cannot convert undefined or null to object");
        var output = Object(target);
        for(var index = 1; index < arguments.length; index++){
            var source = arguments[index];
            if (source !== undefined && source !== null) {
                for(var nextKey in source)if (source.hasOwnProperty(nextKey)) output[nextKey] = source[nextKey];
            }
        }
        return output;
    };
    else assign = Object.assign;
    /**
 * extend object.
 * means that properties in dest will be overwritten by the ones in src.
 * @param {Object} dest
 * @param {Object} src
 * @param {Boolean} [merge=false]
 * @returns {Object} dest
 */ var extend = deprecate(function extend(dest, src, merge) {
        var keys = Object.keys(src);
        var i = 0;
        while(i < keys.length){
            if (!merge || merge && dest[keys[i]] === undefined) dest[keys[i]] = src[keys[i]];
            i++;
        }
        return dest;
    }, "extend", "Use `assign`.");
    /**
 * merge the values from src in the dest.
 * means that properties that exist in dest will not be overwritten by src
 * @param {Object} dest
 * @param {Object} src
 * @returns {Object} dest
 */ var merge1 = deprecate(function merge(dest, src) {
        return extend(dest, src, true);
    }, "merge", "Use `assign`.");
    /**
 * simple class inheritance
 * @param {Function} child
 * @param {Function} base
 * @param {Object} [properties]
 */ function inherit(child, base, properties) {
        var baseP = base.prototype, childP;
        childP = child.prototype = Object.create(baseP);
        childP.constructor = child;
        childP._super = baseP;
        if (properties) assign(childP, properties);
    }
    /**
 * simple function bind
 * @param {Function} fn
 * @param {Object} context
 * @returns {Function}
 */ function bindFn(fn, context) {
        return function boundFn() {
            return fn.apply(context, arguments);
        };
    }
    /**
 * let a boolean value also be a function that must return a boolean
 * this first item in args will be used as the context
 * @param {Boolean|Function} val
 * @param {Array} [args]
 * @returns {Boolean}
 */ function boolOrFn(val, args) {
        if (typeof val == TYPE_FUNCTION) return val.apply(args ? args[0] || undefined : undefined, args);
        return val;
    }
    /**
 * use the val2 when val1 is undefined
 * @param {*} val1
 * @param {*} val2
 * @returns {*}
 */ function ifUndefined(val1, val2) {
        return val1 === undefined ? val2 : val1;
    }
    /**
 * addEventListener with multiple events at once
 * @param {EventTarget} target
 * @param {String} types
 * @param {Function} handler
 */ function addEventListeners(target, types, handler) {
        each(splitStr(types), function(type) {
            target.addEventListener(type, handler, false);
        });
    }
    /**
 * removeEventListener with multiple events at once
 * @param {EventTarget} target
 * @param {String} types
 * @param {Function} handler
 */ function removeEventListeners(target, types, handler) {
        each(splitStr(types), function(type) {
            target.removeEventListener(type, handler, false);
        });
    }
    /**
 * find if a node is in the given parent
 * @method hasParent
 * @param {HTMLElement} node
 * @param {HTMLElement} parent
 * @return {Boolean} found
 */ function hasParent(node, parent) {
        while(node){
            if (node == parent) return true;
            node = node.parentNode;
        }
        return false;
    }
    /**
 * small indexOf wrapper
 * @param {String} str
 * @param {String} find
 * @returns {Boolean} found
 */ function inStr(str, find) {
        return str.indexOf(find) > -1;
    }
    /**
 * split string on whitespace
 * @param {String} str
 * @returns {Array} words
 */ function splitStr(str) {
        return str.trim().split(/\s+/g);
    }
    /**
 * find if a array contains the object using indexOf or a simple polyFill
 * @param {Array} src
 * @param {String} find
 * @param {String} [findByKey]
 * @return {Boolean|Number} false when not found, or the index
 */ function inArray(src, find, findByKey) {
        if (src.indexOf && !findByKey) return src.indexOf(find);
        else {
            var i = 0;
            while(i < src.length){
                if (findByKey && src[i][findByKey] == find || !findByKey && src[i] === find) return i;
                i++;
            }
            return -1;
        }
    }
    /**
 * convert array-like objects to real arrays
 * @param {Object} obj
 * @returns {Array}
 */ function toArray(obj) {
        return Array.prototype.slice.call(obj, 0);
    }
    /**
 * unique array with objects based on a key (like 'id') or just by the array's value
 * @param {Array} src [{id:1},{id:2},{id:1}]
 * @param {String} [key]
 * @param {Boolean} [sort=False]
 * @returns {Array} [{id:1},{id:2}]
 */ function uniqueArray(src, key, sort) {
        var results = [];
        var values = [];
        var i = 0;
        while(i < src.length){
            var val = key ? src[i][key] : src[i];
            if (inArray(values, val) < 0) results.push(src[i]);
            values[i] = val;
            i++;
        }
        if (sort) {
            if (!key) results = results.sort();
            else results = results.sort(function sortUniqueArray(a, b) {
                return a[key] > b[key];
            });
        }
        return results;
    }
    /**
 * get the prefixed property
 * @param {Object} obj
 * @param {String} property
 * @returns {String|Undefined} prefixed
 */ function prefixed(obj, property) {
        var prefix, prop;
        var camelProp = property[0].toUpperCase() + property.slice(1);
        var i = 0;
        while(i < VENDOR_PREFIXES.length){
            prefix = VENDOR_PREFIXES[i];
            prop = prefix ? prefix + camelProp : property;
            if (prop in obj) return prop;
            i++;
        }
        return undefined;
    }
    /**
 * get a unique id
 * @returns {number} uniqueId
 */ var _uniqueId = 1;
    function uniqueId() {
        return _uniqueId++;
    }
    /**
 * get the window object of an element
 * @param {HTMLElement} element
 * @returns {DocumentView|Window}
 */ function getWindowForElement(element) {
        var doc = element.ownerDocument || element;
        return doc.defaultView || doc.parentWindow || window;
    }
    var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;
    var SUPPORT_TOUCH = "ontouchstart" in window;
    var SUPPORT_POINTER_EVENTS = prefixed(window, "PointerEvent") !== undefined;
    var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);
    var INPUT_TYPE_TOUCH = "touch";
    var INPUT_TYPE_PEN = "pen";
    var INPUT_TYPE_MOUSE = "mouse";
    var INPUT_TYPE_KINECT = "kinect";
    var COMPUTE_INTERVAL = 25;
    var INPUT_START = 1;
    var INPUT_MOVE = 2;
    var INPUT_END = 4;
    var INPUT_CANCEL = 8;
    var DIRECTION_NONE = 1;
    var DIRECTION_LEFT = 2;
    var DIRECTION_RIGHT = 4;
    var DIRECTION_UP = 8;
    var DIRECTION_DOWN = 16;
    var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
    var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
    var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;
    var PROPS_XY = [
        "x",
        "y"
    ];
    var PROPS_CLIENT_XY = [
        "clientX",
        "clientY"
    ];
    /**
 * create new input type manager
 * @param {Manager} manager
 * @param {Function} callback
 * @returns {Input}
 * @constructor
 */ function Input(manager, callback) {
        var self = this;
        this.manager = manager;
        this.callback = callback;
        this.element = manager.element;
        this.target = manager.options.inputTarget;
        // smaller wrapper around the handler, for the scope and the enabled state of the manager,
        // so when disabled the input events are completely bypassed.
        this.domHandler = function(ev) {
            if (boolOrFn(manager.options.enable, [
                manager
            ])) self.handler(ev);
        };
        this.init();
    }
    Input.prototype = {
        /**
     * should handle the inputEvent data and trigger the callback
     * @virtual
     */ handler: function() {},
        /**
     * bind the events
     */ init: function() {
            this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
            this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
            this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
        },
        /**
     * unbind the events
     */ destroy: function() {
            this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
            this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
            this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
        }
    };
    /**
 * create new input type manager
 * called by the Manager constructor
 * @param {Hammer} manager
 * @returns {Input}
 */ function createInputInstance(manager) {
        var Type;
        var inputClass = manager.options.inputClass;
        if (inputClass) Type = inputClass;
        else if (SUPPORT_POINTER_EVENTS) Type = PointerEventInput;
        else if (SUPPORT_ONLY_TOUCH) Type = TouchInput;
        else if (!SUPPORT_TOUCH) Type = MouseInput;
        else Type = TouchMouseInput;
        return new Type(manager, inputHandler);
    }
    /**
 * handle input events
 * @param {Manager} manager
 * @param {String} eventType
 * @param {Object} input
 */ function inputHandler(manager, eventType, input) {
        var pointersLen = input.pointers.length;
        var changedPointersLen = input.changedPointers.length;
        var isFirst = eventType & INPUT_START && pointersLen - changedPointersLen === 0;
        var isFinal = eventType & (INPUT_END | INPUT_CANCEL) && pointersLen - changedPointersLen === 0;
        input.isFirst = !!isFirst;
        input.isFinal = !!isFinal;
        if (isFirst) manager.session = {};
        // source event is the normalized value of the domEvents
        // like 'touchstart, mouseup, pointerdown'
        input.eventType = eventType;
        // compute scale, rotation etc
        computeInputData(manager, input);
        // emit secret event
        manager.emit("hammer.input", input);
        manager.recognize(input);
        manager.session.prevInput = input;
    }
    /**
 * extend the data with some usable properties like scale, rotate, velocity etc
 * @param {Object} manager
 * @param {Object} input
 */ function computeInputData(manager, input) {
        var session = manager.session;
        var pointers = input.pointers;
        var pointersLength = pointers.length;
        // store the first input to calculate the distance and direction
        if (!session.firstInput) session.firstInput = simpleCloneInputData(input);
        // to compute scale and rotation we need to store the multiple touches
        if (pointersLength > 1 && !session.firstMultiple) session.firstMultiple = simpleCloneInputData(input);
        else if (pointersLength === 1) session.firstMultiple = false;
        var firstInput = session.firstInput;
        var firstMultiple = session.firstMultiple;
        var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;
        var center = input.center = getCenter(pointers);
        input.timeStamp = now();
        input.deltaTime = input.timeStamp - firstInput.timeStamp;
        input.angle = getAngle(offsetCenter, center);
        input.distance = getDistance(offsetCenter, center);
        computeDeltaXY(session, input);
        input.offsetDirection = getDirection(input.deltaX, input.deltaY);
        var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);
        input.overallVelocityX = overallVelocity.x;
        input.overallVelocityY = overallVelocity.y;
        input.overallVelocity = abs(overallVelocity.x) > abs(overallVelocity.y) ? overallVelocity.x : overallVelocity.y;
        input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
        input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;
        input.maxPointers = !session.prevInput ? input.pointers.length : input.pointers.length > session.prevInput.maxPointers ? input.pointers.length : session.prevInput.maxPointers;
        computeIntervalInputData(session, input);
        // find the correct target
        var target = manager.element;
        if (hasParent(input.srcEvent.target, target)) target = input.srcEvent.target;
        input.target = target;
    }
    function computeDeltaXY(session, input) {
        var center = input.center;
        var offset = session.offsetDelta || {};
        var prevDelta = session.prevDelta || {};
        var prevInput = session.prevInput || {};
        if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {
            prevDelta = session.prevDelta = {
                x: prevInput.deltaX || 0,
                y: prevInput.deltaY || 0
            };
            offset = session.offsetDelta = {
                x: center.x,
                y: center.y
            };
        }
        input.deltaX = prevDelta.x + (center.x - offset.x);
        input.deltaY = prevDelta.y + (center.y - offset.y);
    }
    /**
 * velocity is calculated every x ms
 * @param {Object} session
 * @param {Object} input
 */ function computeIntervalInputData(session, input) {
        var last = session.lastInterval || input, deltaTime = input.timeStamp - last.timeStamp, velocity, velocityX, velocityY, direction;
        if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {
            var deltaX = input.deltaX - last.deltaX;
            var deltaY = input.deltaY - last.deltaY;
            var v = getVelocity(deltaTime, deltaX, deltaY);
            velocityX = v.x;
            velocityY = v.y;
            velocity = abs(v.x) > abs(v.y) ? v.x : v.y;
            direction = getDirection(deltaX, deltaY);
            session.lastInterval = input;
        } else {
            // use latest velocity info if it doesn't overtake a minimum period
            velocity = last.velocity;
            velocityX = last.velocityX;
            velocityY = last.velocityY;
            direction = last.direction;
        }
        input.velocity = velocity;
        input.velocityX = velocityX;
        input.velocityY = velocityY;
        input.direction = direction;
    }
    /**
 * create a simple clone from the input used for storage of firstInput and firstMultiple
 * @param {Object} input
 * @returns {Object} clonedInputData
 */ function simpleCloneInputData(input) {
        // make a simple copy of the pointers because we will get a reference if we don't
        // we only need clientXY for the calculations
        var pointers = [];
        var i = 0;
        while(i < input.pointers.length){
            pointers[i] = {
                clientX: round(input.pointers[i].clientX),
                clientY: round(input.pointers[i].clientY)
            };
            i++;
        }
        return {
            timeStamp: now(),
            pointers: pointers,
            center: getCenter(pointers),
            deltaX: input.deltaX,
            deltaY: input.deltaY
        };
    }
    /**
 * get the center of all the pointers
 * @param {Array} pointers
 * @return {Object} center contains `x` and `y` properties
 */ function getCenter(pointers) {
        var pointersLength = pointers.length;
        // no need to loop when only one touch
        if (pointersLength === 1) return {
            x: round(pointers[0].clientX),
            y: round(pointers[0].clientY)
        };
        var x = 0, y = 0, i = 0;
        while(i < pointersLength){
            x += pointers[i].clientX;
            y += pointers[i].clientY;
            i++;
        }
        return {
            x: round(x / pointersLength),
            y: round(y / pointersLength)
        };
    }
    /**
 * calculate the velocity between two points. unit is in px per ms.
 * @param {Number} deltaTime
 * @param {Number} x
 * @param {Number} y
 * @return {Object} velocity `x` and `y`
 */ function getVelocity(deltaTime, x, y) {
        return {
            x: x / deltaTime || 0,
            y: y / deltaTime || 0
        };
    }
    /**
 * get the direction between two points
 * @param {Number} x
 * @param {Number} y
 * @return {Number} direction
 */ function getDirection(x, y) {
        if (x === y) return DIRECTION_NONE;
        if (abs(x) >= abs(y)) return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
        return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
    }
    /**
 * calculate the absolute distance between two points
 * @param {Object} p1 {x, y}
 * @param {Object} p2 {x, y}
 * @param {Array} [props] containing x and y keys
 * @return {Number} distance
 */ function getDistance(p1, p2, props) {
        if (!props) props = PROPS_XY;
        var x = p2[props[0]] - p1[props[0]], y = p2[props[1]] - p1[props[1]];
        return Math.sqrt(x * x + y * y);
    }
    /**
 * calculate the angle between two coordinates
 * @param {Object} p1
 * @param {Object} p2
 * @param {Array} [props] containing x and y keys
 * @return {Number} angle
 */ function getAngle(p1, p2, props) {
        if (!props) props = PROPS_XY;
        var x = p2[props[0]] - p1[props[0]], y = p2[props[1]] - p1[props[1]];
        return Math.atan2(y, x) * 180 / Math.PI;
    }
    /**
 * calculate the rotation degrees between two pointersets
 * @param {Array} start array of pointers
 * @param {Array} end array of pointers
 * @return {Number} rotation
 */ function getRotation(start, end) {
        return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);
    }
    /**
 * calculate the scale factor between two pointersets
 * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
 * @param {Array} start array of pointers
 * @param {Array} end array of pointers
 * @return {Number} scale
 */ function getScale(start, end) {
        return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
    }
    var MOUSE_INPUT_MAP = {
        mousedown: INPUT_START,
        mousemove: INPUT_MOVE,
        mouseup: INPUT_END
    };
    var MOUSE_ELEMENT_EVENTS = "mousedown";
    var MOUSE_WINDOW_EVENTS = "mousemove mouseup";
    /**
 * Mouse events input
 * @constructor
 * @extends Input
 */ function MouseInput() {
        this.evEl = MOUSE_ELEMENT_EVENTS;
        this.evWin = MOUSE_WINDOW_EVENTS;
        this.pressed = false; // mousedown state
        Input.apply(this, arguments);
    }
    inherit(MouseInput, Input, {
        /**
     * handle mouse events
     * @param {Object} ev
     */ handler: function MEhandler(ev) {
            var eventType = MOUSE_INPUT_MAP[ev.type];
            // on start we want to have the left mouse button down
            if (eventType & INPUT_START && ev.button === 0) this.pressed = true;
            if (eventType & INPUT_MOVE && ev.which !== 1) eventType = INPUT_END;
            // mouse must be down
            if (!this.pressed) return;
            if (eventType & INPUT_END) this.pressed = false;
            this.callback(this.manager, eventType, {
                pointers: [
                    ev
                ],
                changedPointers: [
                    ev
                ],
                pointerType: INPUT_TYPE_MOUSE,
                srcEvent: ev
            });
        }
    });
    var POINTER_INPUT_MAP = {
        pointerdown: INPUT_START,
        pointermove: INPUT_MOVE,
        pointerup: INPUT_END,
        pointercancel: INPUT_CANCEL,
        pointerout: INPUT_CANCEL
    };
    // in IE10 the pointer types is defined as an enum
    var IE10_POINTER_TYPE_ENUM = {
        2: INPUT_TYPE_TOUCH,
        3: INPUT_TYPE_PEN,
        4: INPUT_TYPE_MOUSE,
        5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816
    };
    var POINTER_ELEMENT_EVENTS = "pointerdown";
    var POINTER_WINDOW_EVENTS = "pointermove pointerup pointercancel";
    // IE10 has prefixed support, and case-sensitive
    if (window.MSPointerEvent && !window.PointerEvent) {
        POINTER_ELEMENT_EVENTS = "MSPointerDown";
        POINTER_WINDOW_EVENTS = "MSPointerMove MSPointerUp MSPointerCancel";
    }
    /**
 * Pointer events input
 * @constructor
 * @extends Input
 */ function PointerEventInput() {
        this.evEl = POINTER_ELEMENT_EVENTS;
        this.evWin = POINTER_WINDOW_EVENTS;
        Input.apply(this, arguments);
        this.store = this.manager.session.pointerEvents = [];
    }
    inherit(PointerEventInput, Input, {
        /**
     * handle mouse events
     * @param {Object} ev
     */ handler: function PEhandler(ev) {
            var store = this.store;
            var removePointer = false;
            var eventTypeNormalized = ev.type.toLowerCase().replace("ms", "");
            var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
            var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;
            var isTouch = pointerType == INPUT_TYPE_TOUCH;
            // get index of the event in the store
            var storeIndex = inArray(store, ev.pointerId, "pointerId");
            // start and mouse must be down
            if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {
                if (storeIndex < 0) {
                    store.push(ev);
                    storeIndex = store.length - 1;
                }
            } else if (eventType & (INPUT_END | INPUT_CANCEL)) removePointer = true;
            // it not found, so the pointer hasn't been down (so it's probably a hover)
            if (storeIndex < 0) return;
            // update the event in the store
            store[storeIndex] = ev;
            this.callback(this.manager, eventType, {
                pointers: store,
                changedPointers: [
                    ev
                ],
                pointerType: pointerType,
                srcEvent: ev
            });
            if (removePointer) // remove from the store
            store.splice(storeIndex, 1);
        }
    });
    var SINGLE_TOUCH_INPUT_MAP = {
        touchstart: INPUT_START,
        touchmove: INPUT_MOVE,
        touchend: INPUT_END,
        touchcancel: INPUT_CANCEL
    };
    var SINGLE_TOUCH_TARGET_EVENTS = "touchstart";
    var SINGLE_TOUCH_WINDOW_EVENTS = "touchstart touchmove touchend touchcancel";
    /**
 * Touch events input
 * @constructor
 * @extends Input
 */ function SingleTouchInput() {
        this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
        this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
        this.started = false;
        Input.apply(this, arguments);
    }
    inherit(SingleTouchInput, Input, {
        handler: function TEhandler(ev) {
            var type = SINGLE_TOUCH_INPUT_MAP[ev.type];
            // should we handle the touch events?
            if (type === INPUT_START) this.started = true;
            if (!this.started) return;
            var touches = normalizeSingleTouches.call(this, ev, type);
            // when done, reset the started state
            if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) this.started = false;
            this.callback(this.manager, type, {
                pointers: touches[0],
                changedPointers: touches[1],
                pointerType: INPUT_TYPE_TOUCH,
                srcEvent: ev
            });
        }
    });
    /**
 * @this {TouchInput}
 * @param {Object} ev
 * @param {Number} type flag
 * @returns {undefined|Array} [all, changed]
 */ function normalizeSingleTouches(ev, type) {
        var all = toArray(ev.touches);
        var changed = toArray(ev.changedTouches);
        if (type & (INPUT_END | INPUT_CANCEL)) all = uniqueArray(all.concat(changed), "identifier", true);
        return [
            all,
            changed
        ];
    }
    var TOUCH_INPUT_MAP = {
        touchstart: INPUT_START,
        touchmove: INPUT_MOVE,
        touchend: INPUT_END,
        touchcancel: INPUT_CANCEL
    };
    var TOUCH_TARGET_EVENTS = "touchstart touchmove touchend touchcancel";
    /**
 * Multi-user touch events input
 * @constructor
 * @extends Input
 */ function TouchInput() {
        this.evTarget = TOUCH_TARGET_EVENTS;
        this.targetIds = {};
        Input.apply(this, arguments);
    }
    inherit(TouchInput, Input, {
        handler: function MTEhandler(ev) {
            var type = TOUCH_INPUT_MAP[ev.type];
            var touches = getTouches.call(this, ev, type);
            if (!touches) return;
            this.callback(this.manager, type, {
                pointers: touches[0],
                changedPointers: touches[1],
                pointerType: INPUT_TYPE_TOUCH,
                srcEvent: ev
            });
        }
    });
    /**
 * @this {TouchInput}
 * @param {Object} ev
 * @param {Number} type flag
 * @returns {undefined|Array} [all, changed]
 */ function getTouches(ev, type) {
        var allTouches = toArray(ev.touches);
        var targetIds = this.targetIds;
        // when there is only one touch, the process can be simplified
        if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {
            targetIds[allTouches[0].identifier] = true;
            return [
                allTouches,
                allTouches
            ];
        }
        var i, targetTouches, changedTouches = toArray(ev.changedTouches), changedTargetTouches = [], target = this.target;
        // get target touches from touches
        targetTouches = allTouches.filter(function(touch) {
            return hasParent(touch.target, target);
        });
        // collect touches
        if (type === INPUT_START) {
            i = 0;
            while(i < targetTouches.length){
                targetIds[targetTouches[i].identifier] = true;
                i++;
            }
        }
        // filter changed touches to only contain touches that exist in the collected target ids
        i = 0;
        while(i < changedTouches.length){
            if (targetIds[changedTouches[i].identifier]) changedTargetTouches.push(changedTouches[i]);
            // cleanup removed touches
            if (type & (INPUT_END | INPUT_CANCEL)) delete targetIds[changedTouches[i].identifier];
            i++;
        }
        if (!changedTargetTouches.length) return;
        return [
            // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
            uniqueArray(targetTouches.concat(changedTargetTouches), "identifier", true),
            changedTargetTouches
        ];
    }
    /**
 * Combined touch and mouse input
 *
 * Touch has a higher priority then mouse, and while touching no mouse events are allowed.
 * This because touch devices also emit mouse events while doing a touch.
 *
 * @constructor
 * @extends Input
 */ var DEDUP_TIMEOUT = 2500;
    var DEDUP_DISTANCE = 25;
    function TouchMouseInput() {
        Input.apply(this, arguments);
        var handler = bindFn(this.handler, this);
        this.touch = new TouchInput(this.manager, handler);
        this.mouse = new MouseInput(this.manager, handler);
        this.primaryTouch = null;
        this.lastTouches = [];
    }
    inherit(TouchMouseInput, Input, {
        /**
     * handle mouse and touch events
     * @param {Hammer} manager
     * @param {String} inputEvent
     * @param {Object} inputData
     */ handler: function TMEhandler(manager, inputEvent, inputData) {
            var isTouch = inputData.pointerType == INPUT_TYPE_TOUCH, isMouse = inputData.pointerType == INPUT_TYPE_MOUSE;
            if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) return;
            // when we're in a touch event, record touches to  de-dupe synthetic mouse event
            if (isTouch) recordTouches.call(this, inputEvent, inputData);
            else if (isMouse && isSyntheticEvent.call(this, inputData)) return;
            this.callback(manager, inputEvent, inputData);
        },
        /**
     * remove the event listeners
     */ destroy: function destroy() {
            this.touch.destroy();
            this.mouse.destroy();
        }
    });
    function recordTouches(eventType, eventData) {
        if (eventType & INPUT_START) {
            this.primaryTouch = eventData.changedPointers[0].identifier;
            setLastTouch.call(this, eventData);
        } else if (eventType & (INPUT_END | INPUT_CANCEL)) setLastTouch.call(this, eventData);
    }
    function setLastTouch(eventData) {
        var touch = eventData.changedPointers[0];
        if (touch.identifier === this.primaryTouch) {
            var lastTouch = {
                x: touch.clientX,
                y: touch.clientY
            };
            this.lastTouches.push(lastTouch);
            var lts = this.lastTouches;
            var removeLastTouch = function() {
                var i = lts.indexOf(lastTouch);
                if (i > -1) lts.splice(i, 1);
            };
            setTimeout(removeLastTouch, DEDUP_TIMEOUT);
        }
    }
    function isSyntheticEvent(eventData) {
        var x = eventData.srcEvent.clientX, y = eventData.srcEvent.clientY;
        for(var i = 0; i < this.lastTouches.length; i++){
            var t = this.lastTouches[i];
            var dx = Math.abs(x - t.x), dy = Math.abs(y - t.y);
            if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) return true;
        }
        return false;
    }
    var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, "touchAction");
    var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;
    // magical touchAction value
    var TOUCH_ACTION_COMPUTE = "compute";
    var TOUCH_ACTION_AUTO = "auto";
    var TOUCH_ACTION_MANIPULATION = "manipulation"; // not implemented
    var TOUCH_ACTION_NONE = "none";
    var TOUCH_ACTION_PAN_X = "pan-x";
    var TOUCH_ACTION_PAN_Y = "pan-y";
    var TOUCH_ACTION_MAP = getTouchActionProps();
    /**
 * Touch Action
 * sets the touchAction property or uses the js alternative
 * @param {Manager} manager
 * @param {String} value
 * @constructor
 */ function TouchAction(manager, value) {
        this.manager = manager;
        this.set(value);
    }
    TouchAction.prototype = {
        /**
     * set the touchAction value on the element or enable the polyfill
     * @param {String} value
     */ set: function(value) {
            // find out the touch-action by the event handlers
            if (value == TOUCH_ACTION_COMPUTE) value = this.compute();
            if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
            this.actions = value.toLowerCase().trim();
        },
        /**
     * just re-set the touchAction value
     */ update: function() {
            this.set(this.manager.options.touchAction);
        },
        /**
     * compute the value for the touchAction property based on the recognizer's settings
     * @returns {String} value
     */ compute: function() {
            var actions = [];
            each(this.manager.recognizers, function(recognizer) {
                if (boolOrFn(recognizer.options.enable, [
                    recognizer
                ])) actions = actions.concat(recognizer.getTouchAction());
            });
            return cleanTouchActions(actions.join(" "));
        },
        /**
     * this method is called on each input cycle and provides the preventing of the browser behavior
     * @param {Object} input
     */ preventDefaults: function(input) {
            var srcEvent = input.srcEvent;
            var direction = input.offsetDirection;
            // if the touch action did prevented once this session
            if (this.manager.session.prevented) {
                srcEvent.preventDefault();
                return;
            }
            var actions = this.actions;
            var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];
            var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];
            var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];
            if (hasNone) {
                //do not prevent defaults if this is a tap gesture
                var isTapPointer = input.pointers.length === 1;
                var isTapMovement = input.distance < 2;
                var isTapTouchTime = input.deltaTime < 250;
                if (isTapPointer && isTapMovement && isTapTouchTime) return;
            }
            if (hasPanX && hasPanY) // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent
            return;
            if (hasNone || hasPanY && direction & DIRECTION_HORIZONTAL || hasPanX && direction & DIRECTION_VERTICAL) return this.preventSrc(srcEvent);
        },
        /**
     * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
     * @param {Object} srcEvent
     */ preventSrc: function(srcEvent) {
            this.manager.session.prevented = true;
            srcEvent.preventDefault();
        }
    };
    /**
 * when the touchActions are collected they are not a valid value, so we need to clean things up. *
 * @param {String} actions
 * @returns {*}
 */ function cleanTouchActions(actions) {
        // none
        if (inStr(actions, TOUCH_ACTION_NONE)) return TOUCH_ACTION_NONE;
        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);
        // if both pan-x and pan-y are set (different recognizers
        // for different directions, e.g. horizontal pan but vertical swipe?)
        // we need none (as otherwise with pan-x pan-y combined none of these
        // recognizers will work, since the browser would handle all panning
        if (hasPanX && hasPanY) return TOUCH_ACTION_NONE;
        // pan-x OR pan-y
        if (hasPanX || hasPanY) return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
        // manipulation
        if (inStr(actions, TOUCH_ACTION_MANIPULATION)) return TOUCH_ACTION_MANIPULATION;
        return TOUCH_ACTION_AUTO;
    }
    function getTouchActionProps() {
        if (!NATIVE_TOUCH_ACTION) return false;
        var touchMap = {};
        var cssSupports = window.CSS && window.CSS.supports;
        [
            "auto",
            "manipulation",
            "pan-y",
            "pan-x",
            "pan-x pan-y",
            "none"
        ].forEach(function(val) {
            // If css.supports is not supported but there is native touch-action assume it supports
            // all values. This is the case for IE 10 and 11.
            touchMap[val] = cssSupports ? window.CSS.supports("touch-action", val) : true;
        });
        return touchMap;
    }
    /**
 * Recognizer flow explained; *
 * All recognizers have the initial state of POSSIBLE when a input session starts.
 * The definition of a input session is from the first input until the last input, with all it's movement in it. *
 * Example session for mouse-input: mousedown -> mousemove -> mouseup
 *
 * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed
 * which determines with state it should be.
 *
 * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to
 * POSSIBLE to give it another change on the next cycle.
 *
 *               Possible
 *                  |
 *            +-----+---------------+
 *            |                     |
 *      +-----+-----+               |
 *      |           |               |
 *   Failed      Cancelled          |
 *                          +-------+------+
 *                          |              |
 *                      Recognized       Began
 *                                         |
 *                                      Changed
 *                                         |
 *                                  Ended/Recognized
 */ var STATE_POSSIBLE = 1;
    var STATE_BEGAN = 2;
    var STATE_CHANGED = 4;
    var STATE_ENDED = 8;
    var STATE_RECOGNIZED = STATE_ENDED;
    var STATE_CANCELLED = 16;
    var STATE_FAILED = 32;
    /**
 * Recognizer
 * Every recognizer needs to extend from this class.
 * @constructor
 * @param {Object} options
 */ function Recognizer(options) {
        this.options = assign({}, this.defaults, options || {});
        this.id = uniqueId();
        this.manager = null;
        // default is enable true
        this.options.enable = ifUndefined(this.options.enable, true);
        this.state = STATE_POSSIBLE;
        this.simultaneous = {};
        this.requireFail = [];
    }
    Recognizer.prototype = {
        /**
     * @virtual
     * @type {Object}
     */ defaults: {},
        /**
     * set options
     * @param {Object} options
     * @return {Recognizer}
     */ set: function(options) {
            assign(this.options, options);
            // also update the touchAction, in case something changed about the directions/enabled state
            this.manager && this.manager.touchAction.update();
            return this;
        },
        /**
     * recognize simultaneous with an other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */ recognizeWith: function(otherRecognizer) {
            if (invokeArrayArg(otherRecognizer, "recognizeWith", this)) return this;
            var simultaneous = this.simultaneous;
            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
            if (!simultaneous[otherRecognizer.id]) {
                simultaneous[otherRecognizer.id] = otherRecognizer;
                otherRecognizer.recognizeWith(this);
            }
            return this;
        },
        /**
     * drop the simultaneous link. it doesnt remove the link on the other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */ dropRecognizeWith: function(otherRecognizer) {
            if (invokeArrayArg(otherRecognizer, "dropRecognizeWith", this)) return this;
            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
            delete this.simultaneous[otherRecognizer.id];
            return this;
        },
        /**
     * recognizer can only run when an other is failing
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */ requireFailure: function(otherRecognizer) {
            if (invokeArrayArg(otherRecognizer, "requireFailure", this)) return this;
            var requireFail = this.requireFail;
            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
            if (inArray(requireFail, otherRecognizer) === -1) {
                requireFail.push(otherRecognizer);
                otherRecognizer.requireFailure(this);
            }
            return this;
        },
        /**
     * drop the requireFailure link. it does not remove the link on the other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */ dropRequireFailure: function(otherRecognizer) {
            if (invokeArrayArg(otherRecognizer, "dropRequireFailure", this)) return this;
            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
            var index = inArray(this.requireFail, otherRecognizer);
            if (index > -1) this.requireFail.splice(index, 1);
            return this;
        },
        /**
     * has require failures boolean
     * @returns {boolean}
     */ hasRequireFailures: function() {
            return this.requireFail.length > 0;
        },
        /**
     * if the recognizer can recognize simultaneous with an other recognizer
     * @param {Recognizer} otherRecognizer
     * @returns {Boolean}
     */ canRecognizeWith: function(otherRecognizer) {
            return !!this.simultaneous[otherRecognizer.id];
        },
        /**
     * You should use `tryEmit` instead of `emit` directly to check
     * that all the needed recognizers has failed before emitting.
     * @param {Object} input
     */ emit: function(input) {
            var self = this;
            var state = this.state;
            function emit(event) {
                self.manager.emit(event, input);
            }
            // 'panstart' and 'panmove'
            if (state < STATE_ENDED) emit(self.options.event + stateStr(state));
            emit(self.options.event); // simple 'eventName' events
            if (input.additionalEvent) emit(input.additionalEvent);
            // panend and pancancel
            if (state >= STATE_ENDED) emit(self.options.event + stateStr(state));
        },
        /**
     * Check that all the require failure recognizers has failed,
     * if true, it emits a gesture event,
     * otherwise, setup the state to FAILED.
     * @param {Object} input
     */ tryEmit: function(input) {
            if (this.canEmit()) return this.emit(input);
            // it's failing anyway
            this.state = STATE_FAILED;
        },
        /**
     * can we emit?
     * @returns {boolean}
     */ canEmit: function() {
            var i = 0;
            while(i < this.requireFail.length){
                if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) return false;
                i++;
            }
            return true;
        },
        /**
     * update the recognizer
     * @param {Object} inputData
     */ recognize: function(inputData) {
            // make a new copy of the inputData
            // so we can change the inputData without messing up the other recognizers
            var inputDataClone = assign({}, inputData);
            // is is enabled and allow recognizing?
            if (!boolOrFn(this.options.enable, [
                this,
                inputDataClone
            ])) {
                this.reset();
                this.state = STATE_FAILED;
                return;
            }
            // reset when we've reached the end
            if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) this.state = STATE_POSSIBLE;
            this.state = this.process(inputDataClone);
            // the recognizer has recognized a gesture
            // so trigger an event
            if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) this.tryEmit(inputDataClone);
        },
        /**
     * return the state of the recognizer
     * the actual recognizing happens in this method
     * @virtual
     * @param {Object} inputData
     * @returns {Const} STATE
     */ process: function(inputData) {},
        /**
     * return the preferred touch-action
     * @virtual
     * @returns {Array}
     */ getTouchAction: function() {},
        /**
     * called when the gesture isn't allowed to recognize
     * like when another is being recognized or it is disabled
     * @virtual
     */ reset: function() {}
    };
    /**
 * get a usable string, used as event postfix
 * @param {Const} state
 * @returns {String} state
 */ function stateStr(state) {
        if (state & STATE_CANCELLED) return "cancel";
        else if (state & STATE_ENDED) return "end";
        else if (state & STATE_CHANGED) return "move";
        else if (state & STATE_BEGAN) return "start";
        return "";
    }
    /**
 * direction cons to string
 * @param {Const} direction
 * @returns {String}
 */ function directionStr(direction) {
        if (direction == DIRECTION_DOWN) return "down";
        else if (direction == DIRECTION_UP) return "up";
        else if (direction == DIRECTION_LEFT) return "left";
        else if (direction == DIRECTION_RIGHT) return "right";
        return "";
    }
    /**
 * get a recognizer by name if it is bound to a manager
 * @param {Recognizer|String} otherRecognizer
 * @param {Recognizer} recognizer
 * @returns {Recognizer}
 */ function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
        var manager = recognizer.manager;
        if (manager) return manager.get(otherRecognizer);
        return otherRecognizer;
    }
    /**
 * This recognizer is just used as a base for the simple attribute recognizers.
 * @constructor
 * @extends Recognizer
 */ function AttrRecognizer() {
        Recognizer.apply(this, arguments);
    }
    inherit(AttrRecognizer, Recognizer, {
        /**
     * @namespace
     * @memberof AttrRecognizer
     */ defaults: {
            /**
         * @type {Number}
         * @default 1
         */ pointers: 1
        },
        /**
     * Used to check if it the recognizer receives valid input, like input.distance > 10.
     * @memberof AttrRecognizer
     * @param {Object} input
     * @returns {Boolean} recognized
     */ attrTest: function(input) {
            var optionPointers = this.options.pointers;
            return optionPointers === 0 || input.pointers.length === optionPointers;
        },
        /**
     * Process the input and return the state for the recognizer
     * @memberof AttrRecognizer
     * @param {Object} input
     * @returns {*} State
     */ process: function(input) {
            var state = this.state;
            var eventType = input.eventType;
            var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
            var isValid = this.attrTest(input);
            // on cancel input and we've recognized before, return STATE_CANCELLED
            if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) return state | STATE_CANCELLED;
            else if (isRecognized || isValid) {
                if (eventType & INPUT_END) return state | STATE_ENDED;
                else if (!(state & STATE_BEGAN)) return STATE_BEGAN;
                return state | STATE_CHANGED;
            }
            return STATE_FAILED;
        }
    });
    /**
 * Pan
 * Recognized when the pointer is down and moved in the allowed direction.
 * @constructor
 * @extends AttrRecognizer
 */ function PanRecognizer() {
        AttrRecognizer.apply(this, arguments);
        this.pX = null;
        this.pY = null;
    }
    inherit(PanRecognizer, AttrRecognizer, {
        /**
     * @namespace
     * @memberof PanRecognizer
     */ defaults: {
            event: "pan",
            threshold: 10,
            pointers: 1,
            direction: DIRECTION_ALL
        },
        getTouchAction: function() {
            var direction = this.options.direction;
            var actions = [];
            if (direction & DIRECTION_HORIZONTAL) actions.push(TOUCH_ACTION_PAN_Y);
            if (direction & DIRECTION_VERTICAL) actions.push(TOUCH_ACTION_PAN_X);
            return actions;
        },
        directionTest: function(input) {
            var options = this.options;
            var hasMoved = true;
            var distance = input.distance;
            var direction = input.direction;
            var x = input.deltaX;
            var y = input.deltaY;
            // lock to axis?
            if (!(direction & options.direction)) {
                if (options.direction & DIRECTION_HORIZONTAL) {
                    direction = x === 0 ? DIRECTION_NONE : x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
                    hasMoved = x != this.pX;
                    distance = Math.abs(input.deltaX);
                } else {
                    direction = y === 0 ? DIRECTION_NONE : y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
                    hasMoved = y != this.pY;
                    distance = Math.abs(input.deltaY);
                }
            }
            input.direction = direction;
            return hasMoved && distance > options.threshold && direction & options.direction;
        },
        attrTest: function(input) {
            return AttrRecognizer.prototype.attrTest.call(this, input) && (this.state & STATE_BEGAN || !(this.state & STATE_BEGAN) && this.directionTest(input));
        },
        emit: function(input) {
            this.pX = input.deltaX;
            this.pY = input.deltaY;
            var direction = directionStr(input.direction);
            if (direction) input.additionalEvent = this.options.event + direction;
            this._super.emit.call(this, input);
        }
    });
    /**
 * Pinch
 * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).
 * @constructor
 * @extends AttrRecognizer
 */ function PinchRecognizer() {
        AttrRecognizer.apply(this, arguments);
    }
    inherit(PinchRecognizer, AttrRecognizer, {
        /**
     * @namespace
     * @memberof PinchRecognizer
     */ defaults: {
            event: "pinch",
            threshold: 0,
            pointers: 2
        },
        getTouchAction: function() {
            return [
                TOUCH_ACTION_NONE
            ];
        },
        attrTest: function(input) {
            return this._super.attrTest.call(this, input) && (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
        },
        emit: function(input) {
            if (input.scale !== 1) {
                var inOut = input.scale < 1 ? "in" : "out";
                input.additionalEvent = this.options.event + inOut;
            }
            this._super.emit.call(this, input);
        }
    });
    /**
 * Press
 * Recognized when the pointer is down for x ms without any movement.
 * @constructor
 * @extends Recognizer
 */ function PressRecognizer() {
        Recognizer.apply(this, arguments);
        this._timer = null;
        this._input = null;
    }
    inherit(PressRecognizer, Recognizer, {
        /**
     * @namespace
     * @memberof PressRecognizer
     */ defaults: {
            event: "press",
            pointers: 1,
            time: 251,
            threshold: 9 // a minimal movement is ok, but keep it low
        },
        getTouchAction: function() {
            return [
                TOUCH_ACTION_AUTO
            ];
        },
        process: function(input) {
            var options = this.options;
            var validPointers = input.pointers.length === options.pointers;
            var validMovement = input.distance < options.threshold;
            var validTime = input.deltaTime > options.time;
            this._input = input;
            // we only allow little movement
            // and we've reached an end event, so a tap is possible
            if (!validMovement || !validPointers || input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime) this.reset();
            else if (input.eventType & INPUT_START) {
                this.reset();
                this._timer = setTimeoutContext(function() {
                    this.state = STATE_RECOGNIZED;
                    this.tryEmit();
                }, options.time, this);
            } else if (input.eventType & INPUT_END) return STATE_RECOGNIZED;
            return STATE_FAILED;
        },
        reset: function() {
            clearTimeout(this._timer);
        },
        emit: function(input) {
            if (this.state !== STATE_RECOGNIZED) return;
            if (input && input.eventType & INPUT_END) this.manager.emit(this.options.event + "up", input);
            else {
                this._input.timeStamp = now();
                this.manager.emit(this.options.event, this._input);
            }
        }
    });
    /**
 * Rotate
 * Recognized when two or more pointer are moving in a circular motion.
 * @constructor
 * @extends AttrRecognizer
 */ function RotateRecognizer() {
        AttrRecognizer.apply(this, arguments);
    }
    inherit(RotateRecognizer, AttrRecognizer, {
        /**
     * @namespace
     * @memberof RotateRecognizer
     */ defaults: {
            event: "rotate",
            threshold: 0,
            pointers: 2
        },
        getTouchAction: function() {
            return [
                TOUCH_ACTION_NONE
            ];
        },
        attrTest: function(input) {
            return this._super.attrTest.call(this, input) && (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
        }
    });
    /**
 * Swipe
 * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.
 * @constructor
 * @extends AttrRecognizer
 */ function SwipeRecognizer() {
        AttrRecognizer.apply(this, arguments);
    }
    inherit(SwipeRecognizer, AttrRecognizer, {
        /**
     * @namespace
     * @memberof SwipeRecognizer
     */ defaults: {
            event: "swipe",
            threshold: 10,
            velocity: 0.3,
            direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
            pointers: 1
        },
        getTouchAction: function() {
            return PanRecognizer.prototype.getTouchAction.call(this);
        },
        attrTest: function(input) {
            var direction = this.options.direction;
            var velocity;
            if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) velocity = input.overallVelocity;
            else if (direction & DIRECTION_HORIZONTAL) velocity = input.overallVelocityX;
            else if (direction & DIRECTION_VERTICAL) velocity = input.overallVelocityY;
            return this._super.attrTest.call(this, input) && direction & input.offsetDirection && input.distance > this.options.threshold && input.maxPointers == this.options.pointers && abs(velocity) > this.options.velocity && input.eventType & INPUT_END;
        },
        emit: function(input) {
            var direction = directionStr(input.offsetDirection);
            if (direction) this.manager.emit(this.options.event + direction, input);
            this.manager.emit(this.options.event, input);
        }
    });
    /**
 * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur
 * between the given interval and position. The delay option can be used to recognize multi-taps without firing
 * a single tap.
 *
 * The eventData from the emitted event contains the property `tapCount`, which contains the amount of
 * multi-taps being recognized.
 * @constructor
 * @extends Recognizer
 */ function TapRecognizer() {
        Recognizer.apply(this, arguments);
        // previous time and center,
        // used for tap counting
        this.pTime = false;
        this.pCenter = false;
        this._timer = null;
        this._input = null;
        this.count = 0;
    }
    inherit(TapRecognizer, Recognizer, {
        /**
     * @namespace
     * @memberof PinchRecognizer
     */ defaults: {
            event: "tap",
            pointers: 1,
            taps: 1,
            interval: 300,
            time: 250,
            threshold: 9,
            posThreshold: 10 // a multi-tap can be a bit off the initial position
        },
        getTouchAction: function() {
            return [
                TOUCH_ACTION_MANIPULATION
            ];
        },
        process: function(input) {
            var options = this.options;
            var validPointers = input.pointers.length === options.pointers;
            var validMovement = input.distance < options.threshold;
            var validTouchTime = input.deltaTime < options.time;
            this.reset();
            if (input.eventType & INPUT_START && this.count === 0) return this.failTimeout();
            // we only allow little movement
            // and we've reached an end event, so a tap is possible
            if (validMovement && validTouchTime && validPointers) {
                if (input.eventType != INPUT_END) return this.failTimeout();
                var validInterval = this.pTime ? input.timeStamp - this.pTime < options.interval : true;
                var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;
                this.pTime = input.timeStamp;
                this.pCenter = input.center;
                if (!validMultiTap || !validInterval) this.count = 1;
                else this.count += 1;
                this._input = input;
                // if tap count matches we have recognized it,
                // else it has began recognizing...
                var tapCount = this.count % options.taps;
                if (tapCount === 0) {
                    // no failing requirements, immediately trigger the tap event
                    // or wait as long as the multitap interval to trigger
                    if (!this.hasRequireFailures()) return STATE_RECOGNIZED;
                    else {
                        this._timer = setTimeoutContext(function() {
                            this.state = STATE_RECOGNIZED;
                            this.tryEmit();
                        }, options.interval, this);
                        return STATE_BEGAN;
                    }
                }
            }
            return STATE_FAILED;
        },
        failTimeout: function() {
            this._timer = setTimeoutContext(function() {
                this.state = STATE_FAILED;
            }, this.options.interval, this);
            return STATE_FAILED;
        },
        reset: function() {
            clearTimeout(this._timer);
        },
        emit: function() {
            if (this.state == STATE_RECOGNIZED) {
                this._input.tapCount = this.count;
                this.manager.emit(this.options.event, this._input);
            }
        }
    });
    /**
 * Simple way to create a manager with a default set of recognizers.
 * @param {HTMLElement} element
 * @param {Object} [options]
 * @constructor
 */ function Hammer(element, options) {
        options = options || {};
        options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);
        return new Manager(element, options);
    }
    /**
 * @const {string}
 */ Hammer.VERSION = "2.0.7";
    /**
 * default settings
 * @namespace
 */ Hammer.defaults = {
        /**
     * set if DOM events are being triggered.
     * But this is slower and unused by simple implementations, so disabled by default.
     * @type {Boolean}
     * @default false
     */ domEvents: false,
        /**
     * The value for the touchAction property/fallback.
     * When set to `compute` it will magically set the correct value based on the added recognizers.
     * @type {String}
     * @default compute
     */ touchAction: TOUCH_ACTION_COMPUTE,
        /**
     * @type {Boolean}
     * @default true
     */ enable: true,
        /**
     * EXPERIMENTAL FEATURE -- can be removed/changed
     * Change the parent input target element.
     * If Null, then it is being set the to main element.
     * @type {Null|EventTarget}
     * @default null
     */ inputTarget: null,
        /**
     * force an input class
     * @type {Null|Function}
     * @default null
     */ inputClass: null,
        /**
     * Default recognizer setup when calling `Hammer()`
     * When creating a new Manager these will be skipped.
     * @type {Array}
     */ preset: [
            // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]
            [
                RotateRecognizer,
                {
                    enable: false
                }
            ],
            [
                PinchRecognizer,
                {
                    enable: false
                },
                [
                    "rotate"
                ]
            ],
            [
                SwipeRecognizer,
                {
                    direction: DIRECTION_HORIZONTAL
                }
            ],
            [
                PanRecognizer,
                {
                    direction: DIRECTION_HORIZONTAL
                },
                [
                    "swipe"
                ]
            ],
            [
                TapRecognizer
            ],
            [
                TapRecognizer,
                {
                    event: "doubletap",
                    taps: 2
                },
                [
                    "tap"
                ]
            ],
            [
                PressRecognizer
            ]
        ],
        /**
     * Some CSS properties can be used to improve the working of Hammer.
     * Add them to this method and they will be set when creating a new Manager.
     * @namespace
     */ cssProps: {
            /**
         * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
         * @type {String}
         * @default 'none'
         */ userSelect: "none",
            /**
         * Disable the Windows Phone grippers when pressing an element.
         * @type {String}
         * @default 'none'
         */ touchSelect: "none",
            /**
         * Disables the default callout shown when you touch and hold a touch target.
         * On iOS, when you touch and hold a touch target such as a link, Safari displays
         * a callout containing information about the link. This property allows you to disable that callout.
         * @type {String}
         * @default 'none'
         */ touchCallout: "none",
            /**
         * Specifies whether zooming is enabled. Used by IE10>
         * @type {String}
         * @default 'none'
         */ contentZooming: "none",
            /**
         * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
         * @type {String}
         * @default 'none'
         */ userDrag: "none",
            /**
         * Overrides the highlight color shown when the user taps a link or a JavaScript
         * clickable element in iOS. This property obeys the alpha value, if specified.
         * @type {String}
         * @default 'rgba(0,0,0,0)'
         */ tapHighlightColor: "rgba(0,0,0,0)"
        }
    };
    var STOP = 1;
    var FORCED_STOP = 2;
    /**
 * Manager
 * @param {HTMLElement} element
 * @param {Object} [options]
 * @constructor
 */ function Manager(element, options) {
        this.options = assign({}, Hammer.defaults, options || {});
        this.options.inputTarget = this.options.inputTarget || element;
        this.handlers = {};
        this.session = {};
        this.recognizers = [];
        this.oldCssProps = {};
        this.element = element;
        this.input = createInputInstance(this);
        this.touchAction = new TouchAction(this, this.options.touchAction);
        toggleCssProps(this, true);
        each(this.options.recognizers, function(item) {
            var recognizer = this.add(new item[0](item[1]));
            item[2] && recognizer.recognizeWith(item[2]);
            item[3] && recognizer.requireFailure(item[3]);
        }, this);
    }
    Manager.prototype = {
        /**
     * set options
     * @param {Object} options
     * @returns {Manager}
     */ set: function(options) {
            assign(this.options, options);
            // Options that need a little more setup
            if (options.touchAction) this.touchAction.update();
            if (options.inputTarget) {
                // Clean up existing event listeners and reinitialize
                this.input.destroy();
                this.input.target = options.inputTarget;
                this.input.init();
            }
            return this;
        },
        /**
     * stop recognizing for this session.
     * This session will be discarded, when a new [input]start event is fired.
     * When forced, the recognizer cycle is stopped immediately.
     * @param {Boolean} [force]
     */ stop: function(force) {
            this.session.stopped = force ? FORCED_STOP : STOP;
        },
        /**
     * run the recognizers!
     * called by the inputHandler function on every movement of the pointers (touches)
     * it walks through all the recognizers and tries to detect the gesture that is being made
     * @param {Object} inputData
     */ recognize: function(inputData) {
            var session = this.session;
            if (session.stopped) return;
            // run the touch-action polyfill
            this.touchAction.preventDefaults(inputData);
            var recognizer;
            var recognizers = this.recognizers;
            // this holds the recognizer that is being recognized.
            // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED
            // if no recognizer is detecting a thing, it is set to `null`
            var curRecognizer = session.curRecognizer;
            // reset when the last recognizer is recognized
            // or when we're in a new session
            if (!curRecognizer || curRecognizer && curRecognizer.state & STATE_RECOGNIZED) curRecognizer = session.curRecognizer = null;
            var i = 0;
            while(i < recognizers.length){
                recognizer = recognizers[i];
                // find out if we are allowed try to recognize the input for this one.
                // 1.   allow if the session is NOT forced stopped (see the .stop() method)
                // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one
                //      that is being recognized.
                // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.
                //      this can be setup with the `recognizeWith()` method on the recognizer.
                if (session.stopped !== FORCED_STOP && (!curRecognizer || recognizer == curRecognizer || recognizer.canRecognizeWith(curRecognizer))) recognizer.recognize(inputData);
                else recognizer.reset();
                // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the
                // current active recognizer. but only if we don't already have an active recognizer
                if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) curRecognizer = session.curRecognizer = recognizer;
                i++;
            }
        },
        /**
     * get a recognizer by its event name.
     * @param {Recognizer|String} recognizer
     * @returns {Recognizer|Null}
     */ get: function(recognizer) {
            if (recognizer instanceof Recognizer) return recognizer;
            var recognizers = this.recognizers;
            for(var i = 0; i < recognizers.length; i++){
                if (recognizers[i].options.event == recognizer) return recognizers[i];
            }
            return null;
        },
        /**
     * add a recognizer to the manager
     * existing recognizers with the same event name will be removed
     * @param {Recognizer} recognizer
     * @returns {Recognizer|Manager}
     */ add: function(recognizer) {
            if (invokeArrayArg(recognizer, "add", this)) return this;
            // remove existing
            var existing = this.get(recognizer.options.event);
            if (existing) this.remove(existing);
            this.recognizers.push(recognizer);
            recognizer.manager = this;
            this.touchAction.update();
            return recognizer;
        },
        /**
     * remove a recognizer by name or instance
     * @param {Recognizer|String} recognizer
     * @returns {Manager}
     */ remove: function(recognizer) {
            if (invokeArrayArg(recognizer, "remove", this)) return this;
            recognizer = this.get(recognizer);
            // let's make sure this recognizer exists
            if (recognizer) {
                var recognizers = this.recognizers;
                var index = inArray(recognizers, recognizer);
                if (index !== -1) {
                    recognizers.splice(index, 1);
                    this.touchAction.update();
                }
            }
            return this;
        },
        /**
     * bind event
     * @param {String} events
     * @param {Function} handler
     * @returns {EventEmitter} this
     */ on: function(events, handler) {
            if (events === undefined) return;
            if (handler === undefined) return;
            var handlers = this.handlers;
            each(splitStr(events), function(event) {
                handlers[event] = handlers[event] || [];
                handlers[event].push(handler);
            });
            return this;
        },
        /**
     * unbind event, leave emit blank to remove all handlers
     * @param {String} events
     * @param {Function} [handler]
     * @returns {EventEmitter} this
     */ off: function(events, handler) {
            if (events === undefined) return;
            var handlers = this.handlers;
            each(splitStr(events), function(event) {
                if (!handler) delete handlers[event];
                else handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);
            });
            return this;
        },
        /**
     * emit event to the listeners
     * @param {String} event
     * @param {Object} data
     */ emit: function(event, data) {
            // we also want to trigger dom events
            if (this.options.domEvents) triggerDomEvent(event, data);
            // no handlers, so skip it all
            var handlers = this.handlers[event] && this.handlers[event].slice();
            if (!handlers || !handlers.length) return;
            data.type = event;
            data.preventDefault = function() {
                data.srcEvent.preventDefault();
            };
            var i = 0;
            while(i < handlers.length){
                handlers[i](data);
                i++;
            }
        },
        /**
     * destroy the manager and unbinds all events
     * it doesn't unbind dom events, that is the user own responsibility
     */ destroy: function() {
            this.element && toggleCssProps(this, false);
            this.handlers = {};
            this.session = {};
            this.input.destroy();
            this.element = null;
        }
    };
    /**
 * add/remove the css properties as defined in manager.options.cssProps
 * @param {Manager} manager
 * @param {Boolean} add
 */ function toggleCssProps(manager, add) {
        var element = manager.element;
        if (!element.style) return;
        var prop;
        each(manager.options.cssProps, function(value, name) {
            prop = prefixed(element.style, name);
            if (add) {
                manager.oldCssProps[prop] = element.style[prop];
                element.style[prop] = value;
            } else element.style[prop] = manager.oldCssProps[prop] || "";
        });
        if (!add) manager.oldCssProps = {};
    }
    /**
 * trigger dom event
 * @param {String} event
 * @param {Object} data
 */ function triggerDomEvent(event, data) {
        var gestureEvent = document.createEvent("Event");
        gestureEvent.initEvent(event, true, true);
        gestureEvent.gesture = data;
        data.target.dispatchEvent(gestureEvent);
    }
    assign(Hammer, {
        INPUT_START: INPUT_START,
        INPUT_MOVE: INPUT_MOVE,
        INPUT_END: INPUT_END,
        INPUT_CANCEL: INPUT_CANCEL,
        STATE_POSSIBLE: STATE_POSSIBLE,
        STATE_BEGAN: STATE_BEGAN,
        STATE_CHANGED: STATE_CHANGED,
        STATE_ENDED: STATE_ENDED,
        STATE_RECOGNIZED: STATE_RECOGNIZED,
        STATE_CANCELLED: STATE_CANCELLED,
        STATE_FAILED: STATE_FAILED,
        DIRECTION_NONE: DIRECTION_NONE,
        DIRECTION_LEFT: DIRECTION_LEFT,
        DIRECTION_RIGHT: DIRECTION_RIGHT,
        DIRECTION_UP: DIRECTION_UP,
        DIRECTION_DOWN: DIRECTION_DOWN,
        DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,
        DIRECTION_VERTICAL: DIRECTION_VERTICAL,
        DIRECTION_ALL: DIRECTION_ALL,
        Manager: Manager,
        Input: Input,
        TouchAction: TouchAction,
        TouchInput: TouchInput,
        MouseInput: MouseInput,
        PointerEventInput: PointerEventInput,
        TouchMouseInput: TouchMouseInput,
        SingleTouchInput: SingleTouchInput,
        Recognizer: Recognizer,
        AttrRecognizer: AttrRecognizer,
        Tap: TapRecognizer,
        Pan: PanRecognizer,
        Swipe: SwipeRecognizer,
        Pinch: PinchRecognizer,
        Rotate: RotateRecognizer,
        Press: PressRecognizer,
        on: addEventListeners,
        off: removeEventListeners,
        each: each,
        merge: merge1,
        extend: extend,
        assign: assign,
        inherit: inherit,
        bindFn: bindFn,
        prefixed: prefixed
    });
    // this prevents errors when Hammer is loaded in the presence of an AMD
    //  style loader but by script tag, not by the loader.
    var freeGlobal = typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}; // jshint ignore:line
    freeGlobal.Hammer = Hammer;
    if (typeof define === "function" && define.amd) define(function() {
        return Hammer;
    });
    else if ($9232896258c69fa7$exports) $9232896258c69fa7$exports = Hammer;
    else window[exportName] = Hammer;
})(window, document, "Hammer");


/**
 * This file contains overrides the default
 * hammer.js functions to add our own utility
 */ /* eslint-disable */ /* Hammer.js constants */ const $35cf891399782003$var$INPUT_START = 1;
const $35cf891399782003$var$INPUT_MOVE = 2;
const $35cf891399782003$var$INPUT_END = 4;
const $35cf891399782003$var$MOUSE_INPUT_MAP = {
    mousedown: $35cf891399782003$var$INPUT_START,
    mousemove: $35cf891399782003$var$INPUT_MOVE,
    mouseup: $35cf891399782003$var$INPUT_END
};
/**
 * Helper function that returns true if any element in an array meets given criteria.
 * Because older browsers do not support `Array.prototype.some`
 * @params array {Array}
 * @params predict {Function}
 */ function $35cf891399782003$var$some(array, predict) {
    for(let i = 0; i < array.length; i++){
        if (predict(array[i])) return true;
    }
    return false;
}
function $35cf891399782003$export$feb1ac98c5ad1053(PointerEventInput) {
    const oldHandler = PointerEventInput.prototype.handler;
    // overrides PointerEventInput.handler to accept right mouse button
    PointerEventInput.prototype.handler = function handler(ev) {
        const store = this.store;
        // Allow non-left mouse buttons through
        if (ev.button > 0 && ev.type === "pointerdown") {
            if (!$35cf891399782003$var$some(store, (e)=>e.pointerId === ev.pointerId)) store.push(ev);
        }
        oldHandler.call(this, ev);
    };
}
function $35cf891399782003$export$adfd6dd2dd4d96db(MouseInput) {
    MouseInput.prototype.handler = function handler(ev) {
        let eventType = $35cf891399782003$var$MOUSE_INPUT_MAP[ev.type];
        // on start we want to have the mouse button down
        if (eventType & $35cf891399782003$var$INPUT_START && ev.button >= 0) this.pressed = true;
        if (eventType & $35cf891399782003$var$INPUT_MOVE && ev.which === 0) eventType = $35cf891399782003$var$INPUT_END;
        // mouse must be down
        if (!this.pressed) return;
        if (eventType & $35cf891399782003$var$INPUT_END) this.pressed = false;
        this.callback(this.manager, eventType, {
            pointers: [
                ev
            ],
            changedPointers: [
                ev
            ],
            pointerType: "mouse",
            srcEvent: ev
        });
    };
}


(0, $35cf891399782003$export$feb1ac98c5ad1053)((0, (/*@__PURE__*/$parcel$interopDefault($9232896258c69fa7$exports))).PointerEventInput);
(0, $35cf891399782003$export$adfd6dd2dd4d96db)((0, (/*@__PURE__*/$parcel$interopDefault($9232896258c69fa7$exports))).MouseInput);
const $44b838deaec206ae$export$d0d38e7dec7a1a61 = (0, (/*@__PURE__*/$parcel$interopDefault($9232896258c69fa7$exports))).Manager;
var $44b838deaec206ae$export$2e2bcd8739ae039 = (0, (/*@__PURE__*/$parcel$interopDefault($9232896258c69fa7$exports)));


class $7369164f897f54bf$export$2e2bcd8739ae039 {
    constructor(element, callback, options){
        this.element = element;
        this.callback = callback;
        this.options = {
            enable: true,
            ...options
        };
    }
}



const $368369ab2de6fcb8$export$2dfe3ccfbb9a4dca = (0, $44b838deaec206ae$export$2e2bcd8739ae039) ? [
    [
        (0, $44b838deaec206ae$export$2e2bcd8739ae039).Pan,
        {
            event: "tripan",
            pointers: 3,
            threshold: 0,
            enable: false
        }
    ],
    [
        (0, $44b838deaec206ae$export$2e2bcd8739ae039).Rotate,
        {
            enable: false
        }
    ],
    [
        (0, $44b838deaec206ae$export$2e2bcd8739ae039).Pinch,
        {
            enable: false
        }
    ],
    [
        (0, $44b838deaec206ae$export$2e2bcd8739ae039).Swipe,
        {
            enable: false
        }
    ],
    [
        (0, $44b838deaec206ae$export$2e2bcd8739ae039).Pan,
        {
            threshold: 0,
            enable: false
        }
    ],
    [
        (0, $44b838deaec206ae$export$2e2bcd8739ae039).Press,
        {
            enable: false
        }
    ],
    [
        (0, $44b838deaec206ae$export$2e2bcd8739ae039).Tap,
        {
            event: "doubletap",
            taps: 2,
            enable: false
        }
    ],
    // TODO - rename to 'tap' and 'singletap' in the next major release
    [
        (0, $44b838deaec206ae$export$2e2bcd8739ae039).Tap,
        {
            event: "anytap",
            enable: false
        }
    ],
    [
        (0, $44b838deaec206ae$export$2e2bcd8739ae039).Tap,
        {
            enable: false
        }
    ]
] : null;
const $368369ab2de6fcb8$export$3188734ead87a63d = {
    tripan: [
        "rotate",
        "pinch",
        "pan"
    ],
    rotate: [
        "pinch"
    ],
    pinch: [
        "pan"
    ],
    pan: [
        "press",
        "doubletap",
        "anytap",
        "tap"
    ],
    doubletap: [
        "anytap"
    ],
    anytap: [
        "tap"
    ]
};
const $368369ab2de6fcb8$export$3da361ddf819b1fc = {
    doubletap: [
        "tap"
    ]
};
const $368369ab2de6fcb8$export$7e5632c88be0a3be = {
    pointerdown: "pointerdown",
    pointermove: "pointermove",
    pointerup: "pointerup",
    touchstart: "pointerdown",
    touchmove: "pointermove",
    touchend: "pointerup",
    mousedown: "pointerdown",
    mousemove: "pointermove",
    mouseup: "pointerup"
};
const $368369ab2de6fcb8$export$dddb9e29f5b2e5aa = {
    KEY_EVENTS: [
        "keydown",
        "keyup"
    ],
    MOUSE_EVENTS: [
        "mousedown",
        "mousemove",
        "mouseup",
        "mouseover",
        "mouseout",
        "mouseleave"
    ],
    WHEEL_EVENTS: [
        // Chrome, Safari
        "wheel",
        // IE
        "mousewheel"
    ]
};
const $368369ab2de6fcb8$export$5e103639c5775d6b = {
    tap: "tap",
    anytap: "anytap",
    doubletap: "doubletap",
    press: "press",
    pinch: "pinch",
    pinchin: "pinch",
    pinchout: "pinch",
    pinchstart: "pinch",
    pinchmove: "pinch",
    pinchend: "pinch",
    pinchcancel: "pinch",
    rotate: "rotate",
    rotatestart: "rotate",
    rotatemove: "rotate",
    rotateend: "rotate",
    rotatecancel: "rotate",
    tripan: "tripan",
    tripanstart: "tripan",
    tripanmove: "tripan",
    tripanup: "tripan",
    tripandown: "tripan",
    tripanleft: "tripan",
    tripanright: "tripan",
    tripanend: "tripan",
    tripancancel: "tripan",
    pan: "pan",
    panstart: "pan",
    panmove: "pan",
    panup: "pan",
    pandown: "pan",
    panleft: "pan",
    panright: "pan",
    panend: "pan",
    pancancel: "pan",
    swipe: "swipe",
    swipeleft: "swipe",
    swiperight: "swipe",
    swipeup: "swipe",
    swipedown: "swipe"
};
const $368369ab2de6fcb8$export$580af412e0595c74 = {
    click: "tap",
    anyclick: "anytap",
    dblclick: "doubletap",
    mousedown: "pointerdown",
    mousemove: "pointermove",
    mouseup: "pointerup",
    mouseover: "pointerover",
    mouseout: "pointerout",
    mouseleave: "pointerleave"
};


const $03535674bc5b5a9a$export$3dcce53a3755dc8c = typeof navigator !== "undefined" && navigator.userAgent ? navigator.userAgent.toLowerCase() : "";
const $03535674bc5b5a9a$export$8291e5b88f90ce4 = typeof window !== "undefined" ? window : $parcel$global;
const $03535674bc5b5a9a$export$90b4d2ff6acb88af = typeof $parcel$global !== "undefined" ? $parcel$global : window;
const $03535674bc5b5a9a$export$5a7bfc01df82fcd1 = typeof document !== "undefined" ? document : {};
/*
 * Detect whether passive option is supported by the current browser.
 * https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener
   #Safely_detecting_option_support
 */ let $03535674bc5b5a9a$export$f972eb82d6211f6 = false;
/* eslint-disable accessor-pairs, no-empty */ try {
    const options = {
        // This function will be called when the browser
        // attempts to access the passive property.
        get passive () {
            $03535674bc5b5a9a$export$f972eb82d6211f6 = true;
            return true;
        }
    };
    $03535674bc5b5a9a$export$8291e5b88f90ce4.addEventListener("test", null, options);
    $03535674bc5b5a9a$export$8291e5b88f90ce4.removeEventListener("test", null);
} catch (err) {
    $03535674bc5b5a9a$export$f972eb82d6211f6 = false;
}


const $2f48018e669b380c$var$firefox = (0, $03535674bc5b5a9a$export$3dcce53a3755dc8c).indexOf("firefox") !== -1;
const { WHEEL_EVENTS: $2f48018e669b380c$var$WHEEL_EVENTS  } = (0, $368369ab2de6fcb8$export$dddb9e29f5b2e5aa);
const $2f48018e669b380c$var$EVENT_TYPE = "wheel";
// Constants for normalizing input delta
const $2f48018e669b380c$var$WHEEL_DELTA_MAGIC_SCALER = 4.000244140625;
const $2f48018e669b380c$var$WHEEL_DELTA_PER_LINE = 40;
// Slow down zoom if shift key is held for more precise zooming
const $2f48018e669b380c$var$SHIFT_MULTIPLIER = 0.25;
class $2f48018e669b380c$export$2e2bcd8739ae039 extends (0, $7369164f897f54bf$export$2e2bcd8739ae039) {
    constructor(element, callback, options){
        super(element, callback, options);
        /* eslint-disable complexity, max-statements */ this.handleEvent = (event)=>{
            if (!this.options.enable) return;
            let value = event.deltaY;
            if ((0, $03535674bc5b5a9a$export$8291e5b88f90ce4).WheelEvent) {
                // Firefox doubles the values on retina screens...
                if ($2f48018e669b380c$var$firefox && event.deltaMode === (0, $03535674bc5b5a9a$export$8291e5b88f90ce4).WheelEvent.DOM_DELTA_PIXEL) value /= (0, $03535674bc5b5a9a$export$8291e5b88f90ce4).devicePixelRatio;
                if (event.deltaMode === (0, $03535674bc5b5a9a$export$8291e5b88f90ce4).WheelEvent.DOM_DELTA_LINE) value *= $2f48018e669b380c$var$WHEEL_DELTA_PER_LINE;
            }
            if (value !== 0 && value % $2f48018e669b380c$var$WHEEL_DELTA_MAGIC_SCALER === 0) // This one is definitely a mouse wheel event.
            // Normalize this value to match trackpad.
            value = Math.floor(value / $2f48018e669b380c$var$WHEEL_DELTA_MAGIC_SCALER);
            if (event.shiftKey && value) value = value * $2f48018e669b380c$var$SHIFT_MULTIPLIER;
            this.callback({
                type: $2f48018e669b380c$var$EVENT_TYPE,
                center: {
                    x: event.clientX,
                    y: event.clientY
                },
                delta: -value,
                srcEvent: event,
                pointerType: "mouse",
                target: event.target
            });
        };
        this.events = (this.options.events || []).concat($2f48018e669b380c$var$WHEEL_EVENTS);
        this.events.forEach((event)=>element.addEventListener(event, this.handleEvent, (0, $03535674bc5b5a9a$export$f972eb82d6211f6) ? {
                passive: false
            } : false));
    }
    destroy() {
        this.events.forEach((event)=>this.element.removeEventListener(event, this.handleEvent));
    }
    /**
     * Enable this input (begin processing events)
     * if the specified event type is among those handled by this input.
     */ enableEventType(eventType, enabled) {
        if (eventType === $2f48018e669b380c$var$EVENT_TYPE) this.options.enable = enabled;
    }
}




const { MOUSE_EVENTS: $859b18b18dc30513$var$MOUSE_EVENTS  } = (0, $368369ab2de6fcb8$export$dddb9e29f5b2e5aa);
const $859b18b18dc30513$var$MOVE_EVENT_TYPE = "pointermove";
const $859b18b18dc30513$var$OVER_EVENT_TYPE = "pointerover";
const $859b18b18dc30513$var$OUT_EVENT_TYPE = "pointerout";
const $859b18b18dc30513$var$ENTER_EVENT_TYPE = "pointerenter";
const $859b18b18dc30513$var$LEAVE_EVENT_TYPE = "pointerleave";
class $859b18b18dc30513$export$2e2bcd8739ae039 extends (0, $7369164f897f54bf$export$2e2bcd8739ae039) {
    constructor(element, callback, options){
        super(element, callback, options);
        this.handleEvent = (event)=>{
            this.handleOverEvent(event);
            this.handleOutEvent(event);
            this.handleEnterEvent(event);
            this.handleLeaveEvent(event);
            this.handleMoveEvent(event);
        };
        this.pressed = false;
        const { enable: enable  } = this.options;
        this.enableMoveEvent = enable;
        this.enableLeaveEvent = enable;
        this.enableEnterEvent = enable;
        this.enableOutEvent = enable;
        this.enableOverEvent = enable;
        this.events = (this.options.events || []).concat($859b18b18dc30513$var$MOUSE_EVENTS);
        this.events.forEach((event)=>element.addEventListener(event, this.handleEvent));
    }
    destroy() {
        this.events.forEach((event)=>this.element.removeEventListener(event, this.handleEvent));
    }
    /**
     * Enable this input (begin processing events)
     * if the specified event type is among those handled by this input.
     */ enableEventType(eventType, enabled) {
        if (eventType === $859b18b18dc30513$var$MOVE_EVENT_TYPE) this.enableMoveEvent = enabled;
        if (eventType === $859b18b18dc30513$var$OVER_EVENT_TYPE) this.enableOverEvent = enabled;
        if (eventType === $859b18b18dc30513$var$OUT_EVENT_TYPE) this.enableOutEvent = enabled;
        if (eventType === $859b18b18dc30513$var$ENTER_EVENT_TYPE) this.enableEnterEvent = enabled;
        if (eventType === $859b18b18dc30513$var$LEAVE_EVENT_TYPE) this.enableLeaveEvent = enabled;
    }
    handleOverEvent(event) {
        if (this.enableOverEvent) {
            if (event.type === "mouseover") this._emit($859b18b18dc30513$var$OVER_EVENT_TYPE, event);
        }
    }
    handleOutEvent(event) {
        if (this.enableOutEvent) {
            if (event.type === "mouseout") this._emit($859b18b18dc30513$var$OUT_EVENT_TYPE, event);
        }
    }
    handleEnterEvent(event) {
        if (this.enableEnterEvent) {
            if (event.type === "mouseenter") this._emit($859b18b18dc30513$var$ENTER_EVENT_TYPE, event);
        }
    }
    handleLeaveEvent(event) {
        if (this.enableLeaveEvent) {
            if (event.type === "mouseleave") this._emit($859b18b18dc30513$var$LEAVE_EVENT_TYPE, event);
        }
    }
    handleMoveEvent(event) {
        if (this.enableMoveEvent) switch(event.type){
            case "mousedown":
                if (event.button >= 0) // Button is down
                this.pressed = true;
                break;
            case "mousemove":
                // Move events use `which` to track the button being pressed
                if (event.which === 0) // Button is not down
                this.pressed = false;
                if (!this.pressed) // Drag events are emitted by hammer already
                // we just need to emit the move event on hover
                this._emit($859b18b18dc30513$var$MOVE_EVENT_TYPE, event);
                break;
            case "mouseup":
                this.pressed = false;
                break;
            default:
        }
    }
    _emit(type, event) {
        this.callback({
            type: type,
            center: {
                x: event.clientX,
                y: event.clientY
            },
            srcEvent: event,
            pointerType: "mouse",
            target: event.target
        });
    }
}




const { KEY_EVENTS: $376b75237faf2ae2$var$KEY_EVENTS  } = (0, $368369ab2de6fcb8$export$dddb9e29f5b2e5aa);
const $376b75237faf2ae2$var$DOWN_EVENT_TYPE = "keydown";
const $376b75237faf2ae2$var$UP_EVENT_TYPE = "keyup";
class $376b75237faf2ae2$export$2e2bcd8739ae039 extends (0, $7369164f897f54bf$export$2e2bcd8739ae039) {
    constructor(element, callback, options){
        super(element, callback, options);
        this.handleEvent = (event)=>{
            // Ignore if focused on text input
            const targetElement = event.target || event.srcElement;
            if (targetElement.tagName === "INPUT" && targetElement.type === "text" || targetElement.tagName === "TEXTAREA") return;
            if (this.enableDownEvent && event.type === "keydown") this.callback({
                type: $376b75237faf2ae2$var$DOWN_EVENT_TYPE,
                srcEvent: event,
                key: event.key,
                target: event.target
            });
            if (this.enableUpEvent && event.type === "keyup") this.callback({
                type: $376b75237faf2ae2$var$UP_EVENT_TYPE,
                srcEvent: event,
                key: event.key,
                target: event.target
            });
        };
        this.enableDownEvent = this.options.enable;
        this.enableUpEvent = this.options.enable;
        this.events = (this.options.events || []).concat($376b75237faf2ae2$var$KEY_EVENTS);
        element.tabIndex = this.options.tabIndex || 0;
        element.style.outline = "none";
        this.events.forEach((event)=>element.addEventListener(event, this.handleEvent));
    }
    destroy() {
        this.events.forEach((event)=>this.element.removeEventListener(event, this.handleEvent));
    }
    /**
     * Enable this input (begin processing events)
     * if the specified event type is among those handled by this input.
     */ enableEventType(eventType, enabled) {
        if (eventType === $376b75237faf2ae2$var$DOWN_EVENT_TYPE) this.enableDownEvent = enabled;
        if (eventType === $376b75237faf2ae2$var$UP_EVENT_TYPE) this.enableUpEvent = enabled;
    }
}



const $8b4fbfbcbca96ee3$var$EVENT_TYPE = "contextmenu";
class $8b4fbfbcbca96ee3$export$2e2bcd8739ae039 extends (0, $7369164f897f54bf$export$2e2bcd8739ae039) {
    constructor(element, callback, options){
        super(element, callback, options);
        this.handleEvent = (event)=>{
            if (!this.options.enable) return;
            this.callback({
                type: $8b4fbfbcbca96ee3$var$EVENT_TYPE,
                center: {
                    x: event.clientX,
                    y: event.clientY
                },
                srcEvent: event,
                pointerType: "mouse",
                target: event.target
            });
        };
        element.addEventListener("contextmenu", this.handleEvent);
    }
    destroy() {
        this.element.removeEventListener("contextmenu", this.handleEvent);
    }
    /**
     * Enable this input (begin processing events)
     * if the specified event type is among those handled by this input.
     */ enableEventType(eventType, enabled) {
        if (eventType === $8b4fbfbcbca96ee3$var$EVENT_TYPE) this.options.enable = enabled;
    }
}


/* Constants */ const $4ff014f8ca280599$var$DOWN_EVENT = 1;
const $4ff014f8ca280599$var$MOVE_EVENT = 2;
const $4ff014f8ca280599$var$UP_EVENT = 4;
const $4ff014f8ca280599$var$MOUSE_EVENTS = {
    pointerdown: $4ff014f8ca280599$var$DOWN_EVENT,
    pointermove: $4ff014f8ca280599$var$MOVE_EVENT,
    pointerup: $4ff014f8ca280599$var$UP_EVENT,
    mousedown: $4ff014f8ca280599$var$DOWN_EVENT,
    mousemove: $4ff014f8ca280599$var$MOVE_EVENT,
    mouseup: $4ff014f8ca280599$var$UP_EVENT
};
// MouseEvent.which https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/which
const $4ff014f8ca280599$var$MOUSE_EVENT_WHICH_LEFT = 1;
const $4ff014f8ca280599$var$MOUSE_EVENT_WHICH_MIDDLE = 2;
const $4ff014f8ca280599$var$MOUSE_EVENT_WHICH_RIGHT = 3;
// MouseEvent.button https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button
const $4ff014f8ca280599$var$MOUSE_EVENT_BUTTON_LEFT = 0;
const $4ff014f8ca280599$var$MOUSE_EVENT_BUTTON_MIDDLE = 1;
const $4ff014f8ca280599$var$MOUSE_EVENT_BUTTON_RIGHT = 2;
// MouseEvent.buttons https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons
const $4ff014f8ca280599$var$MOUSE_EVENT_BUTTONS_LEFT_MASK = 1;
const $4ff014f8ca280599$var$MOUSE_EVENT_BUTTONS_RIGHT_MASK = 2;
const $4ff014f8ca280599$var$MOUSE_EVENT_BUTTONS_MIDDLE_MASK = 4;
function $4ff014f8ca280599$export$b439c24608871a9a(event) {
    const eventType = $4ff014f8ca280599$var$MOUSE_EVENTS[event.srcEvent.type];
    if (!eventType) // Not a mouse evet
    return null;
    const { buttons: buttons , button: button , which: which  } = event.srcEvent;
    let leftButton = false;
    let middleButton = false;
    let rightButton = false;
    if (// button is up, need to find out which one was pressed before
    eventType === $4ff014f8ca280599$var$UP_EVENT || eventType === $4ff014f8ca280599$var$MOVE_EVENT && !Number.isFinite(buttons)) {
        leftButton = which === $4ff014f8ca280599$var$MOUSE_EVENT_WHICH_LEFT;
        middleButton = which === $4ff014f8ca280599$var$MOUSE_EVENT_WHICH_MIDDLE;
        rightButton = which === $4ff014f8ca280599$var$MOUSE_EVENT_WHICH_RIGHT;
    } else if (eventType === $4ff014f8ca280599$var$MOVE_EVENT) {
        leftButton = Boolean(buttons & $4ff014f8ca280599$var$MOUSE_EVENT_BUTTONS_LEFT_MASK);
        middleButton = Boolean(buttons & $4ff014f8ca280599$var$MOUSE_EVENT_BUTTONS_MIDDLE_MASK);
        rightButton = Boolean(buttons & $4ff014f8ca280599$var$MOUSE_EVENT_BUTTONS_RIGHT_MASK);
    } else if (eventType === $4ff014f8ca280599$var$DOWN_EVENT) {
        leftButton = button === $4ff014f8ca280599$var$MOUSE_EVENT_BUTTON_LEFT;
        middleButton = button === $4ff014f8ca280599$var$MOUSE_EVENT_BUTTON_MIDDLE;
        rightButton = button === $4ff014f8ca280599$var$MOUSE_EVENT_BUTTON_RIGHT;
    }
    return {
        leftButton: leftButton,
        middleButton: middleButton,
        rightButton: rightButton
    };
}
function $4ff014f8ca280599$export$456611cab2a1cf25(event, rootElement) {
    const center = event.center;
    // `center` is a hammer.js event property
    if (!center) // Not a gestural event
    return null;
    const rect = rootElement.getBoundingClientRect();
    // Fix scale for map affected by a CSS transform.
    // See https://stackoverflow.com/a/26893663/3528533
    const scaleX = rect.width / rootElement.offsetWidth || 1;
    const scaleY = rect.height / rootElement.offsetHeight || 1;
    // Calculate center relative to the root element
    const offsetCenter = {
        x: (center.x - rect.left - rootElement.clientLeft) / scaleX,
        y: (center.y - rect.top - rootElement.clientTop) / scaleY
    };
    return {
        center: center,
        offsetCenter: offsetCenter
    };
}


const $e66c1fd4b977e653$var$DEFAULT_OPTIONS = {
    srcElement: "root",
    priority: 0
};
class $e66c1fd4b977e653$export$2e2bcd8739ae039 {
    constructor(eventManager){
        /**
         * Handles hammerjs event
         */ this.handleEvent = (event)=>{
            if (this.isEmpty()) return;
            const mjolnirEvent = this._normalizeEvent(event);
            let target = event.srcEvent.target;
            while(target && target !== mjolnirEvent.rootElement){
                this._emit(mjolnirEvent, target);
                if (mjolnirEvent.handled) return;
                target = target.parentNode;
            }
            this._emit(mjolnirEvent, "root");
        };
        this.eventManager = eventManager;
        this.handlers = [];
        // Element -> handler map
        this.handlersByElement = new Map();
        this._active = false;
    }
    // Returns true if there are no non-passive handlers
    isEmpty() {
        return !this._active;
    }
    add(type, handler, options, once = false, passive = false) {
        const { handlers: handlers , handlersByElement: handlersByElement  } = this;
        let opts = $e66c1fd4b977e653$var$DEFAULT_OPTIONS;
        if (typeof options === "string" || options && options.addEventListener) // is DOM element, backward compatibility
        // @ts-ignore
        opts = {
            ...$e66c1fd4b977e653$var$DEFAULT_OPTIONS,
            srcElement: options
        };
        else if (options) opts = {
            ...$e66c1fd4b977e653$var$DEFAULT_OPTIONS,
            ...options
        };
        let entries = handlersByElement.get(opts.srcElement);
        if (!entries) {
            entries = [];
            handlersByElement.set(opts.srcElement, entries);
        }
        const entry = {
            type: type,
            handler: handler,
            srcElement: opts.srcElement,
            priority: opts.priority
        };
        if (once) entry.once = true;
        if (passive) entry.passive = true;
        handlers.push(entry);
        this._active = this._active || !entry.passive;
        // Sort handlers by descending priority
        // Handlers with the same priority are excuted in the order of registration
        let insertPosition = entries.length - 1;
        while(insertPosition >= 0){
            if (entries[insertPosition].priority >= entry.priority) break;
            insertPosition--;
        }
        entries.splice(insertPosition + 1, 0, entry);
    }
    remove(type, handler) {
        const { handlers: handlers , handlersByElement: handlersByElement  } = this;
        for(let i = handlers.length - 1; i >= 0; i--){
            const entry = handlers[i];
            if (entry.type === type && entry.handler === handler) {
                handlers.splice(i, 1);
                const entries = handlersByElement.get(entry.srcElement);
                entries.splice(entries.indexOf(entry), 1);
                if (entries.length === 0) handlersByElement.delete(entry.srcElement);
            }
        }
        this._active = handlers.some((entry)=>!entry.passive);
    }
    /**
     * Invoke handlers on a particular element
     */ _emit(event, srcElement) {
        const entries = this.handlersByElement.get(srcElement);
        if (entries) {
            let immediatePropagationStopped = false;
            // Prevents the current event from bubbling up
            const stopPropagation = ()=>{
                event.handled = true;
            };
            // Prevent any remaining listeners from being called
            const stopImmediatePropagation = ()=>{
                event.handled = true;
                immediatePropagationStopped = true;
            };
            const entriesToRemove = [];
            for(let i = 0; i < entries.length; i++){
                const { type: type , handler: handler , once: once  } = entries[i];
                handler({
                    ...event,
                    type: // @ts-ignore
                    type,
                    stopPropagation: stopPropagation,
                    stopImmediatePropagation: stopImmediatePropagation
                });
                if (once) entriesToRemove.push(entries[i]);
                if (immediatePropagationStopped) break;
            }
            for(let i1 = 0; i1 < entriesToRemove.length; i1++){
                const { type: type , handler: handler  } = entriesToRemove[i1];
                this.remove(type, handler);
            }
        }
    }
    /**
     * Normalizes hammerjs and custom events to have predictable fields.
     */ _normalizeEvent(event) {
        const rootElement = this.eventManager.getElement();
        return {
            ...event,
            ...(0, $4ff014f8ca280599$export$b439c24608871a9a)(event),
            ...(0, $4ff014f8ca280599$export$456611cab2a1cf25)(event, rootElement),
            preventDefault: ()=>{
                event.srcEvent.preventDefault();
            },
            stopImmediatePropagation: null,
            stopPropagation: null,
            handled: false,
            rootElement: rootElement
        };
    }
}



const $1e4596bb66c8c182$var$DEFAULT_OPTIONS = {
    // event handlers
    events: null,
    // custom recognizers
    recognizers: null,
    recognizerOptions: {},
    Manager: // Manager class
    $44b838deaec206ae$export$d0d38e7dec7a1a61,
    // allow browser default touch action
    // https://github.com/uber/react-map-gl/issues/506
    touchAction: "none",
    tabIndex: 0
};
class $1e4596bb66c8c182$export$2e2bcd8739ae039 {
    constructor(element = null, options){
        /**
         * Handle basic events using the 'hammer.input' Hammer.js API:
         * Before running Recognizers, Hammer emits a 'hammer.input' event
         * with the basic event info. This function emits all basic events
         * aliased to the "class" of event received.
         * See constants.BASIC_EVENT_CLASSES basic event class definitions.
         */ this._onBasicInput = (event)=>{
            const { srcEvent: srcEvent  } = event;
            const alias = (0, $368369ab2de6fcb8$export$7e5632c88be0a3be)[srcEvent.type];
            if (alias) // fire all events aliased to srcEvent.type
            this.manager.emit(alias, event);
        };
        /**
         * Handle events not supported by Hammer.js,
         * and pipe back out through same (Hammer) channel used by other events.
         */ this._onOtherEvent = (event)=>{
            // console.log('onotherevent', event.type, event)
            this.manager.emit(event.type, event);
        };
        this.options = {
            ...$1e4596bb66c8c182$var$DEFAULT_OPTIONS,
            ...options
        };
        this.events = new Map();
        this.setElement(element);
        // Register all passed events.
        const { events: events  } = this.options;
        if (events) this.on(events);
    }
    getElement() {
        return this.element;
    }
    setElement(element) {
        if (this.element) // unregister all events
        this.destroy();
        this.element = element;
        if (!element) return;
        const { options: options  } = this;
        const ManagerClass = options.Manager;
        this.manager = new ManagerClass(element, {
            touchAction: options.touchAction,
            recognizers: options.recognizers || (0, $368369ab2de6fcb8$export$2dfe3ccfbb9a4dca)
        }).on("hammer.input", this._onBasicInput);
        if (!options.recognizers) // Set default recognize withs
        // http://hammerjs.github.io/recognize-with/
        Object.keys((0, $368369ab2de6fcb8$export$3188734ead87a63d)).forEach((name)=>{
            const recognizer = this.manager.get(name);
            if (recognizer) (0, $368369ab2de6fcb8$export$3188734ead87a63d)[name].forEach((otherName)=>{
                recognizer.recognizeWith(otherName);
            });
        });
        // Set recognizer options
        for(const recognizerName in options.recognizerOptions){
            const recognizer = this.manager.get(recognizerName);
            if (recognizer) {
                const recognizerOption = options.recognizerOptions[recognizerName];
                // `enable` is managed by the event registrations
                delete recognizerOption.enable;
                recognizer.set(recognizerOption);
            }
        }
        // Handle events not handled by Hammer.js:
        // - mouse wheel
        // - pointer/touch/mouse move
        this.wheelInput = new (0, $2f48018e669b380c$export$2e2bcd8739ae039)(element, this._onOtherEvent, {
            enable: false
        });
        this.moveInput = new (0, $859b18b18dc30513$export$2e2bcd8739ae039)(element, this._onOtherEvent, {
            enable: false
        });
        this.keyInput = new (0, $376b75237faf2ae2$export$2e2bcd8739ae039)(element, this._onOtherEvent, {
            enable: false,
            tabIndex: options.tabIndex
        });
        this.contextmenuInput = new (0, $8b4fbfbcbca96ee3$export$2e2bcd8739ae039)(element, this._onOtherEvent, {
            enable: false
        });
        // Register all existing events
        for (const [eventAlias, eventRegistrar] of this.events)if (!eventRegistrar.isEmpty()) {
            // Enable recognizer for this event.
            this._toggleRecognizer(eventRegistrar.recognizerName, true);
            this.manager.on(eventAlias, eventRegistrar.handleEvent);
        }
    }
    // Tear down internal event management implementations.
    destroy() {
        if (this.element) {
            // wheelInput etc. are created in setElement() and therefore
            // cannot exist if there is no element
            this.wheelInput.destroy();
            this.moveInput.destroy();
            this.keyInput.destroy();
            this.contextmenuInput.destroy();
            this.manager.destroy();
            this.wheelInput = null;
            this.moveInput = null;
            this.keyInput = null;
            this.contextmenuInput = null;
            this.manager = null;
            this.element = null;
        }
    }
    /** Register an event handler function to be called on `event` */ on(event, handler, opts) {
        this._addEventHandler(event, handler, opts, false);
    }
    once(event, handler, opts) {
        this._addEventHandler(event, handler, opts, true);
    }
    watch(event, handler, opts) {
        this._addEventHandler(event, handler, opts, false, true);
    }
    off(event, handler) {
        this._removeEventHandler(event, handler);
    }
    /*
     * Enable/disable recognizer for the given event
     */ _toggleRecognizer(name, enabled) {
        const { manager: manager  } = this;
        if (!manager) return;
        const recognizer = manager.get(name);
        // @ts-ignore
        if (recognizer && recognizer.options.enable !== enabled) {
            recognizer.set({
                enable: enabled
            });
            const fallbackRecognizers = (0, $368369ab2de6fcb8$export$3da361ddf819b1fc)[name];
            if (fallbackRecognizers && !this.options.recognizers) // Set default require failures
            // http://hammerjs.github.io/require-failure/
            fallbackRecognizers.forEach((otherName)=>{
                const otherRecognizer = manager.get(otherName);
                if (enabled) {
                    // Wait for this recognizer to fail
                    otherRecognizer.requireFailure(name);
                    /**
                         * This seems to be a bug in hammerjs:
                         * requireFailure() adds both ways
                         * dropRequireFailure() only drops one way
                         * https://github.com/hammerjs/hammer.js/blob/master/src/recognizerjs/
                           recognizer-constructor.js#L136
                         */ recognizer.dropRequireFailure(otherName);
                } else // Do not wait for this recognizer to fail
                otherRecognizer.dropRequireFailure(name);
            });
        }
        this.wheelInput.enableEventType(name, enabled);
        this.moveInput.enableEventType(name, enabled);
        this.keyInput.enableEventType(name, enabled);
        this.contextmenuInput.enableEventType(name, enabled);
    }
    /**
     * Process the event registration for a single event + handler.
     */ _addEventHandler(event, handler, opts, once, passive) {
        if (typeof event !== "string") {
            // @ts-ignore
            opts = handler;
            // If `event` is a map, call `on()` for each entry.
            for(const eventName in event)this._addEventHandler(eventName, event[eventName], opts, once, passive);
            return;
        }
        const { manager: manager , events: events  } = this;
        // Alias to a recognized gesture as necessary.
        const eventAlias = (0, $368369ab2de6fcb8$export$580af412e0595c74)[event] || event;
        let eventRegistrar = events.get(eventAlias);
        if (!eventRegistrar) {
            eventRegistrar = new (0, $e66c1fd4b977e653$export$2e2bcd8739ae039)(this);
            events.set(eventAlias, eventRegistrar);
            // Enable recognizer for this event.
            eventRegistrar.recognizerName = (0, $368369ab2de6fcb8$export$5e103639c5775d6b)[eventAlias] || eventAlias;
            // Listen to the event
            if (manager) manager.on(eventAlias, eventRegistrar.handleEvent);
        }
        eventRegistrar.add(event, handler, opts, once, passive);
        if (!eventRegistrar.isEmpty()) this._toggleRecognizer(eventRegistrar.recognizerName, true);
    }
    /**
     * Process the event deregistration for a single event + handler.
     */ _removeEventHandler(event, handler) {
        if (typeof event !== "string") {
            // If `event` is a map, call `off()` for each entry.
            for(const eventName in event)this._removeEventHandler(eventName, event[eventName]);
            return;
        }
        const { events: events  } = this;
        // Alias to a recognized gesture as necessary.
        const eventAlias = (0, $368369ab2de6fcb8$export$580af412e0595c74)[event] || event;
        const eventRegistrar = events.get(eventAlias);
        if (!eventRegistrar) return;
        eventRegistrar.remove(event, handler);
        if (eventRegistrar.isEmpty()) {
            const { recognizerName: recognizerName  } = eventRegistrar;
            // Disable recognizer if no more handlers are attached to its events
            let isRecognizerUsed = false;
            for (const eh of events.values())if (eh.recognizerName === recognizerName && !eh.isEmpty()) {
                isRecognizerUsed = true;
                break;
            }
            if (!isRecognizerUsed) this._toggleRecognizer(recognizerName, false);
        }
    }
}






function $4afbf505f2c4bce1$var$noop() {}
const $4afbf505f2c4bce1$var$getCursor = ({ isDragging: isDragging  })=>isDragging ? "grabbing" : "grab";
const $4afbf505f2c4bce1$var$defaultProps = {
    id: "",
    width: "100%",
    height: "100%",
    style: null,
    viewState: null,
    initialViewState: null,
    pickingRadius: 0,
    layerFilter: null,
    glOptions: {},
    parameters: {},
    parent: null,
    gl: null,
    canvas: null,
    layers: [],
    effects: [],
    views: null,
    controller: null,
    useDevicePixels: true,
    touchAction: "none",
    eventRecognizerOptions: {},
    _framebuffer: null,
    _animate: false,
    _pickable: true,
    _typedArrayManagerProps: {},
    _customRender: null,
    onWebGLInitialized: $4afbf505f2c4bce1$var$noop,
    onResize: $4afbf505f2c4bce1$var$noop,
    onViewStateChange: $4afbf505f2c4bce1$var$noop,
    onInteractionStateChange: $4afbf505f2c4bce1$var$noop,
    onBeforeRender: $4afbf505f2c4bce1$var$noop,
    onAfterRender: $4afbf505f2c4bce1$var$noop,
    onLoad: $4afbf505f2c4bce1$var$noop,
    onError: (error)=>(0, $146cba582e8c799f$export$2e2bcd8739ae039).error(error.message)(),
    onHover: null,
    onClick: null,
    onDragStart: null,
    onDrag: null,
    onDragEnd: null,
    _onMetrics: null,
    getCursor: $4afbf505f2c4bce1$var$getCursor,
    getTooltip: null,
    debug: false,
    drawPickingColors: false
};
class $4afbf505f2c4bce1$export$2e2bcd8739ae039 {
    constructor(props){
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "props", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "width", 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "height", 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "userData", {});
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "canvas", null);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "viewManager", null);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "layerManager", null);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "effectManager", null);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "deckRenderer", null);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "deckPicker", null);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "eventManager", null);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "tooltip", null);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "metrics", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "animationLoop", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "stats", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "viewState", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "cursorState", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_needsRedraw", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_pickRequest", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_lastPointerDownInfo", null);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_metricsCounter", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_onPointerMove", (event)=>{
            const { _pickRequest: _pickRequest  } = this;
            if (event.type === "pointerleave") {
                _pickRequest.x = -1;
                _pickRequest.y = -1;
                _pickRequest.radius = 0;
            } else if (event.leftButton || event.rightButton) return;
            else {
                const pos = event.offsetCenter;
                if (!pos) return;
                _pickRequest.x = pos.x;
                _pickRequest.y = pos.y;
                _pickRequest.radius = this.props.pickingRadius;
            }
            if (this.layerManager) this.layerManager.context.mousePosition = {
                x: _pickRequest.x,
                y: _pickRequest.y
            };
            _pickRequest.event = event;
        });
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_onEvent", (event)=>{
            const eventOptions = (0, $b42a5b9aa3b1a41f$export$fa3d5b535a2458a1)[event.type];
            const pos = event.offsetCenter;
            if (!eventOptions || !pos || !this.layerManager) return;
            const layers = this.layerManager.getLayers();
            const info = this.deckPicker.getLastPickedObject({
                x: pos.x,
                y: pos.y,
                layers: layers,
                viewports: this.getViewports(pos)
            }, this._lastPointerDownInfo);
            const { layer: layer  } = info;
            const layerHandler = layer && (layer[eventOptions.handler] || layer.props[eventOptions.handler]);
            const rootHandler = this.props[eventOptions.handler];
            let handled = false;
            if (layerHandler) handled = layerHandler.call(layer, info, event);
            if (!handled && rootHandler) rootHandler(info, event);
        });
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_onPointerDown", (event)=>{
            const pos = event.offsetCenter;
            const pickedInfo = this._pick("pickObject", "pickObject Time", {
                x: pos.x,
                y: pos.y,
                radius: this.props.pickingRadius
            });
            this._lastPointerDownInfo = pickedInfo.result[0] || pickedInfo.emptyInfo;
        });
        this.props = {
            ...$4afbf505f2c4bce1$var$defaultProps,
            ...props
        };
        props = this.props;
        this._needsRedraw = "Initial render";
        this._pickRequest = {
            mode: "hover",
            x: -1,
            y: -1,
            radius: 0,
            event: null
        };
        this.cursorState = {
            isHovering: false,
            isDragging: false
        };
        if (props.viewState && props.initialViewState) (0, $146cba582e8c799f$export$2e2bcd8739ae039).warn("View state tracking is disabled. Use either `initialViewState` for auto update or `viewState` for manual update.")();
        if ((0, $ef7c7b0387e72f27$export$2e2bcd8739ae039)() === "IE") (0, $146cba582e8c799f$export$2e2bcd8739ae039).warn("IE 11 is not supported")();
        this.viewState = props.initialViewState;
        if (!props.gl) {
            if (typeof document !== "undefined") this.canvas = this._createCanvas(props);
        }
        this.animationLoop = this._createAnimationLoop(props);
        this.stats = new (0, $2fb061cfbc5cb32d$export$2e2bcd8739ae039)({
            id: "deck.gl"
        });
        this.metrics = {
            fps: 0,
            setPropsTime: 0,
            updateAttributesTime: 0,
            framesRedrawn: 0,
            pickTime: 0,
            pickCount: 0,
            gpuTime: 0,
            gpuTimePerFrame: 0,
            cpuTime: 0,
            cpuTimePerFrame: 0,
            bufferMemory: 0,
            textureMemory: 0,
            renderbufferMemory: 0,
            gpuMemory: 0
        };
        this._metricsCounter = 0;
        this.setProps(props);
        if (props._typedArrayManagerProps) (0, $e0cd51e92519f55c$export$2e2bcd8739ae039).setOptions(props._typedArrayManagerProps);
        this.animationLoop.start();
    }
    finalize() {
        var _this$layerManager, _this$viewManager, _this$effectManager, _this$deckRenderer, _this$deckPicker, _this$eventManager, _this$tooltip;
        this.animationLoop.stop();
        this.animationLoop = null;
        this._lastPointerDownInfo = null;
        (_this$layerManager = this.layerManager) === null || _this$layerManager === void 0 || _this$layerManager.finalize();
        this.layerManager = null;
        (_this$viewManager = this.viewManager) === null || _this$viewManager === void 0 || _this$viewManager.finalize();
        this.viewManager = null;
        (_this$effectManager = this.effectManager) === null || _this$effectManager === void 0 || _this$effectManager.finalize();
        this.effectManager = null;
        (_this$deckRenderer = this.deckRenderer) === null || _this$deckRenderer === void 0 || _this$deckRenderer.finalize();
        this.deckRenderer = null;
        (_this$deckPicker = this.deckPicker) === null || _this$deckPicker === void 0 || _this$deckPicker.finalize();
        this.deckPicker = null;
        (_this$eventManager = this.eventManager) === null || _this$eventManager === void 0 || _this$eventManager.destroy();
        this.eventManager = null;
        (_this$tooltip = this.tooltip) === null || _this$tooltip === void 0 || _this$tooltip.remove();
        this.tooltip = null;
        if (!this.props.canvas && !this.props.gl && this.canvas) {
            var _this$canvas$parentEl;
            (_this$canvas$parentEl = this.canvas.parentElement) === null || _this$canvas$parentEl === void 0 || _this$canvas$parentEl.removeChild(this.canvas);
            this.canvas = null;
        }
    }
    setProps(props) {
        this.stats.get("setProps Time").timeStart();
        if ("onLayerHover" in props) (0, $146cba582e8c799f$export$2e2bcd8739ae039).removed("onLayerHover", "onHover")();
        if ("onLayerClick" in props) (0, $146cba582e8c799f$export$2e2bcd8739ae039).removed("onLayerClick", "onClick")();
        if (props.initialViewState && !(0, $70a948cba88c73a3$export$9cb4719e2e525b7a)(this.props.initialViewState, props.initialViewState)) this.viewState = props.initialViewState;
        Object.assign(this.props, props);
        this._setCanvasSize(this.props);
        const resolvedProps = Object.create(this.props);
        Object.assign(resolvedProps, {
            views: this._getViews(),
            width: this.width,
            height: this.height,
            viewState: this._getViewState()
        });
        this.animationLoop.setProps(resolvedProps);
        if (this.layerManager) {
            this.viewManager.setProps(resolvedProps);
            this.layerManager.activateViewport(this.getViewports()[0]);
            this.layerManager.setProps(resolvedProps);
            this.effectManager.setProps(resolvedProps);
            this.deckRenderer.setProps(resolvedProps);
            this.deckPicker.setProps(resolvedProps);
        }
        this.stats.get("setProps Time").timeEnd();
    }
    needsRedraw(opts = {
        clearRedrawFlags: false
    }) {
        if (!this.layerManager) return false;
        if (this.props._animate) return "Deck._animate";
        let redraw = this._needsRedraw;
        if (opts.clearRedrawFlags) this._needsRedraw = false;
        const viewManagerNeedsRedraw = this.viewManager.needsRedraw(opts);
        const layerManagerNeedsRedraw = this.layerManager.needsRedraw(opts);
        const effectManagerNeedsRedraw = this.effectManager.needsRedraw(opts);
        const deckRendererNeedsRedraw = this.deckRenderer.needsRedraw(opts);
        redraw = redraw || viewManagerNeedsRedraw || layerManagerNeedsRedraw || effectManagerNeedsRedraw || deckRendererNeedsRedraw;
        return redraw;
    }
    redraw(reason) {
        if (!this.layerManager) return;
        let redrawReason = this.needsRedraw({
            clearRedrawFlags: true
        });
        redrawReason = reason || redrawReason;
        if (!redrawReason) return;
        this.stats.get("Redraw Count").incrementCount();
        if (this.props._customRender) this.props._customRender(redrawReason);
        else this._drawLayers(redrawReason);
    }
    get isInitialized() {
        return this.viewManager !== null;
    }
    getViews() {
        (0, $828c58095cddb61a$export$2e2bcd8739ae039)(this.viewManager);
        return this.viewManager.views;
    }
    getViewports(rect) {
        (0, $828c58095cddb61a$export$2e2bcd8739ae039)(this.viewManager);
        return this.viewManager.getViewports(rect);
    }
    pickObject(opts) {
        const infos = this._pick("pickObject", "pickObject Time", opts).result;
        return infos.length ? infos[0] : null;
    }
    pickMultipleObjects(opts) {
        opts.depth = opts.depth || 10;
        return this._pick("pickObject", "pickMultipleObjects Time", opts).result;
    }
    pickObjects(opts) {
        return this._pick("pickObjects", "pickObjects Time", opts);
    }
    _addResources(resources, forceUpdate = false) {
        for(const id in resources)this.layerManager.resourceManager.add({
            resourceId: id,
            data: resources[id],
            forceUpdate: forceUpdate
        });
    }
    _removeResources(resourceIds) {
        for (const id of resourceIds)this.layerManager.resourceManager.remove(id);
    }
    _pick(method, statKey, opts) {
        (0, $828c58095cddb61a$export$2e2bcd8739ae039)(this.deckPicker);
        const { stats: stats  } = this;
        stats.get("Pick Count").incrementCount();
        stats.get(statKey).timeStart();
        const infos = this.deckPicker[method]({
            layers: this.layerManager.getLayers(opts),
            views: this.viewManager.getViews(),
            viewports: this.getViewports(opts),
            onViewportActive: this.layerManager.activateViewport,
            effects: this.effectManager.getEffects(),
            ...opts
        });
        stats.get(statKey).timeEnd();
        return infos;
    }
    _createCanvas(props) {
        let canvas = props.canvas;
        if (typeof canvas === "string") {
            canvas = document.getElementById(canvas);
            (0, $828c58095cddb61a$export$2e2bcd8739ae039)(canvas);
        }
        if (!canvas) {
            canvas = document.createElement("canvas");
            canvas.id = props.id || "deckgl-overlay";
            const parent = props.parent || document.body;
            parent.appendChild(canvas);
        }
        Object.assign(canvas.style, props.style);
        return canvas;
    }
    _setCanvasSize(props) {
        if (!this.canvas) return;
        const { width: width , height: height  } = props;
        if (width || width === 0) {
            const cssWidth = Number.isFinite(width) ? "".concat(width, "px") : width;
            this.canvas.style.width = cssWidth;
        }
        if (height || height === 0) {
            var _props$style;
            const cssHeight = Number.isFinite(height) ? "".concat(height, "px") : height;
            this.canvas.style.position = ((_props$style = props.style) === null || _props$style === void 0 ? void 0 : _props$style.position) || "absolute";
            this.canvas.style.height = cssHeight;
        }
    }
    _updateCanvasSize() {
        const { canvas: canvas  } = this;
        if (!canvas) return;
        const newWidth = canvas.clientWidth || canvas.width;
        const newHeight = canvas.clientHeight || canvas.height;
        if (newWidth !== this.width || newHeight !== this.height) {
            var _this$viewManager2;
            this.width = newWidth;
            this.height = newHeight;
            (_this$viewManager2 = this.viewManager) === null || _this$viewManager2 === void 0 || _this$viewManager2.setProps({
                width: newWidth,
                height: newHeight
            });
            this.props.onResize({
                width: newWidth,
                height: newHeight
            });
        }
    }
    _createAnimationLoop(props) {
        const { width: width , height: height , gl: gl , glOptions: glOptions , debug: debug , onError: onError , onBeforeRender: onBeforeRender , onAfterRender: onAfterRender , useDevicePixels: useDevicePixels  } = props;
        return new (0, $8a761c509fabf16c$export$2e2bcd8739ae039)({
            width: width,
            height: height,
            useDevicePixels: useDevicePixels,
            autoResizeViewport: false,
            gl: gl,
            onCreateContext: (opts)=>(0, $f89b67ad8c6f5746$export$a32ea65c51ffebe7)({
                    ...glOptions,
                    ...opts,
                    canvas: this.canvas,
                    debug: debug,
                    onContextLost: ()=>this._onContextLost()
                }),
            onInitialize: (context)=>this._setGLContext(context.gl),
            onRender: this._onRenderFrame.bind(this),
            onBeforeRender: onBeforeRender,
            onAfterRender: onAfterRender,
            onError: onError
        });
    }
    _getViewState() {
        return this.props.viewState || this.viewState;
    }
    _getViews() {
        let views = this.props.views || [
            new (0, $d73daa375e65bcb3$export$2e2bcd8739ae039)({
                id: "default-view"
            })
        ];
        views = Array.isArray(views) ? views : [
            views
        ];
        if (views.length && this.props.controller) views[0].props.controller = this.props.controller;
        return views;
    }
    _onContextLost() {
        const { onError: onError  } = this.props;
        if (this.animationLoop && onError) onError(new Error("WebGL context is lost"));
    }
    _pickAndCallback() {
        const { _pickRequest: _pickRequest  } = this;
        if (_pickRequest.event) {
            const { result: result , emptyInfo: emptyInfo  } = this._pick("pickObject", "pickObject Time", _pickRequest);
            this.cursorState.isHovering = result.length > 0;
            let pickedInfo = emptyInfo;
            let handled = false;
            for (const info of result){
                var _info$layer;
                pickedInfo = info;
                handled = ((_info$layer = info.layer) === null || _info$layer === void 0 ? void 0 : _info$layer.onHover(info, _pickRequest.event)) || handled;
            }
            if (!handled && this.props.onHover) this.props.onHover(pickedInfo, _pickRequest.event);
            if (this.props.getTooltip && this.tooltip) {
                const displayInfo = this.props.getTooltip(pickedInfo);
                this.tooltip.setTooltip(displayInfo, pickedInfo.x, pickedInfo.y);
            }
            _pickRequest.event = null;
        }
    }
    _updateCursor() {
        const container = this.props.parent || this.canvas;
        if (container) container.style.cursor = this.props.getCursor(this.cursorState);
    }
    _setGLContext(gl) {
        if (this.layerManager) return;
        if (!this.canvas) {
            this.canvas = gl.canvas;
            (0, $f89b67ad8c6f5746$export$6b6cef073fe6a207)(gl, {
                enable: true,
                copyState: true
            });
        }
        this.tooltip = new (0, $0ce0aac1c3cdf79a$export$2e2bcd8739ae039)(this.canvas);
        (0, $54220aa8b6471f1a$export$60752c4a8a24d484)(gl, {
            blend: true,
            blendFunc: [
                770,
                771,
                1,
                771
            ],
            polygonOffsetFill: true,
            depthTest: true,
            depthFunc: 515
        });
        this.props.onWebGLInitialized(gl);
        const timeline = new (0, $bc7bc101e53b8e33$export$e6a97ba2cae5bb94)();
        timeline.play();
        this.animationLoop.attachTimeline(timeline);
        this.eventManager = new (0, $1e4596bb66c8c182$export$2e2bcd8739ae039)(this.props.parent || gl.canvas, {
            touchAction: this.props.touchAction,
            recognizerOptions: this.props.eventRecognizerOptions,
            events: {
                pointerdown: this._onPointerDown,
                pointermove: this._onPointerMove,
                pointerleave: this._onPointerMove
            }
        });
        for(const eventType in 0, $b42a5b9aa3b1a41f$export$fa3d5b535a2458a1)this.eventManager.on(eventType, this._onEvent);
        this.viewManager = new (0, $12d396d6877d881f$export$2e2bcd8739ae039)({
            timeline: timeline,
            eventManager: this.eventManager,
            onViewStateChange: this._onViewStateChange.bind(this),
            onInteractionStateChange: this._onInteractionStateChange.bind(this),
            views: this._getViews(),
            viewState: this._getViewState(),
            width: this.width,
            height: this.height
        });
        const viewport = this.viewManager.getViewports()[0];
        this.layerManager = new (0, $6a52b0a4ad5491f9$export$2e2bcd8739ae039)(gl, {
            deck: this,
            stats: this.stats,
            viewport: viewport,
            timeline: timeline
        });
        this.effectManager = new (0, $6a78b0e959df691c$export$2e2bcd8739ae039)();
        this.deckRenderer = new (0, $44be24ae5116c7d5$export$2e2bcd8739ae039)(gl);
        this.deckPicker = new (0, $846591e5a404f643$export$2e2bcd8739ae039)(gl);
        this.setProps(this.props);
        this._updateCanvasSize();
        this.props.onLoad();
    }
    _drawLayers(redrawReason, renderOptions) {
        const { gl: gl  } = this.layerManager.context;
        (0, $54220aa8b6471f1a$export$60752c4a8a24d484)(gl, this.props.parameters);
        this.props.onBeforeRender({
            gl: gl
        });
        this.deckRenderer.renderLayers({
            target: this.props._framebuffer,
            layers: this.layerManager.getLayers(),
            viewports: this.viewManager.getViewports(),
            onViewportActive: this.layerManager.activateViewport,
            views: this.viewManager.getViews(),
            pass: "screen",
            redrawReason: redrawReason,
            effects: this.effectManager.getEffects(),
            ...renderOptions
        });
        this.props.onAfterRender({
            gl: gl
        });
    }
    _onRenderFrame(animationProps) {
        this._getFrameStats();
        if ((this._metricsCounter++) % 60 === 0) {
            this._getMetrics();
            this.stats.reset();
            (0, $146cba582e8c799f$export$2e2bcd8739ae039).table(4, this.metrics)();
            if (this.props._onMetrics) this.props._onMetrics(this.metrics);
        }
        this._updateCanvasSize();
        this._updateCursor();
        if (this.tooltip.isVisible && this.viewManager.needsRedraw()) this.tooltip.setTooltip(null);
        this.layerManager.updateLayers();
        this._pickAndCallback();
        this.redraw();
        if (this.viewManager) this.viewManager.updateViewStates();
    }
    _onViewStateChange(params) {
        const viewState = this.props.onViewStateChange(params) || params.viewState;
        if (this.viewState) {
            this.viewState = {
                ...this.viewState,
                [params.viewId]: viewState
            };
            if (!this.props.viewState) {
                if (this.viewManager) this.viewManager.setProps({
                    viewState: this.viewState
                });
            }
        }
    }
    _onInteractionStateChange(interactionState) {
        this.cursorState.isDragging = interactionState.isDragging || false;
        this.props.onInteractionStateChange(interactionState);
    }
    _getFrameStats() {
        const { stats: stats  } = this;
        stats.get("frameRate").timeEnd();
        stats.get("frameRate").timeStart();
        const animationLoopStats = this.animationLoop.stats;
        stats.get("GPU Time").addTime(animationLoopStats.get("GPU Time").lastTiming);
        stats.get("CPU Time").addTime(animationLoopStats.get("CPU Time").lastTiming);
    }
    _getMetrics() {
        const { metrics: metrics , stats: stats  } = this;
        metrics.fps = stats.get("frameRate").getHz();
        metrics.setPropsTime = stats.get("setProps Time").time;
        metrics.updateAttributesTime = stats.get("Update Attributes").time;
        metrics.framesRedrawn = stats.get("Redraw Count").count;
        metrics.pickTime = stats.get("pickObject Time").time + stats.get("pickMultipleObjects Time").time + stats.get("pickObjects Time").time;
        metrics.pickCount = stats.get("Pick Count").count;
        metrics.gpuTime = stats.get("GPU Time").time;
        metrics.cpuTime = stats.get("CPU Time").time;
        metrics.gpuTimePerFrame = stats.get("GPU Time").getAverageTime();
        metrics.cpuTimePerFrame = stats.get("CPU Time").getAverageTime();
        const memoryStats = (0, $0a3fbec7776af5cb$export$fb95d6e12d0fb414).get("Memory Usage");
        metrics.bufferMemory = memoryStats.get("Buffer Memory").count;
        metrics.textureMemory = memoryStats.get("Texture Memory").count;
        metrics.renderbufferMemory = memoryStats.get("Renderbuffer Memory").count;
        metrics.gpuMemory = memoryStats.get("GPU Memory").count;
    }
}
(0, $037483d1fb5deac8$export$2e2bcd8739ae039)($4afbf505f2c4bce1$export$2e2bcd8739ae039, "defaultProps", $4afbf505f2c4bce1$var$defaultProps);
(0, $037483d1fb5deac8$export$2e2bcd8739ae039)($4afbf505f2c4bce1$export$2e2bcd8739ae039, "VERSION", (0, $fb7f1a5ab7b23558$export$2e2bcd8739ae039).VERSION);








class $2cbd04ac4b17a1fc$export$2e2bcd8739ae039 {
    constructor(dataColumn, opts){
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "opts", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "source", void 0);
        this.opts = opts;
        this.source = dataColumn;
    }
    get value() {
        return this.source.value;
    }
    getValue() {
        const buffer = this.source.getBuffer();
        const accessor = this.getAccessor();
        if (buffer) return [
            buffer,
            accessor
        ];
        const { value: value  } = this.source;
        const { size: size  } = accessor;
        let constantValue = value;
        if (value && value.length !== size) {
            constantValue = new Float32Array(size);
            const index = accessor.elementOffset || 0;
            for(let i = 0; i < size; ++i)constantValue[i] = value[index + i];
        }
        return constantValue;
    }
    getAccessor() {
        return {
            ...this.source.getAccessor(),
            ...this.opts
        };
    }
}


function $91f302df6555cc52$export$99de3c889be30ec5(glType) {
    switch(glType){
        case 5126:
            return Float32Array;
        case 5130:
            return Float64Array;
        case 5123:
        case 33635:
        case 32819:
        case 32820:
            return Uint16Array;
        case 5125:
            return Uint32Array;
        case 5121:
            return Uint8ClampedArray;
        case 5120:
            return Int8Array;
        case 5122:
            return Int16Array;
        case 5124:
            return Int32Array;
        default:
            throw new Error("Unknown GL type");
    }
}





function $6d94c441f227935a$var$getStride(accessor) {
    return accessor.stride || accessor.size * accessor.bytesPerElement;
}
function $6d94c441f227935a$var$resolveShaderAttribute(baseAccessor, shaderAttributeOptions) {
    if (shaderAttributeOptions.offset) (0, $146cba582e8c799f$export$2e2bcd8739ae039).removed("shaderAttribute.offset", "vertexOffset, elementOffset")();
    const stride = $6d94c441f227935a$var$getStride(baseAccessor);
    const vertexOffset = shaderAttributeOptions.vertexOffset !== undefined ? shaderAttributeOptions.vertexOffset : baseAccessor.vertexOffset || 0;
    const elementOffset = shaderAttributeOptions.elementOffset || 0;
    const offset = vertexOffset * stride + elementOffset * baseAccessor.bytesPerElement + (baseAccessor.offset || 0);
    return {
        ...shaderAttributeOptions,
        offset: offset,
        stride: stride
    };
}
function $6d94c441f227935a$var$resolveDoublePrecisionShaderAttributes(baseAccessor, shaderAttributeOptions) {
    const resolvedOptions = $6d94c441f227935a$var$resolveShaderAttribute(baseAccessor, shaderAttributeOptions);
    return {
        high: resolvedOptions,
        low: {
            ...resolvedOptions,
            offset: resolvedOptions.offset + baseAccessor.size * 4
        }
    };
}
class $6d94c441f227935a$export$2e2bcd8739ae039 {
    constructor(gl, opts, state){
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "gl", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "id", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "size", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "settings", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "value", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "doublePrecision", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "_buffer", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "state", void 0);
        this.gl = gl;
        this.id = opts.id || "";
        this.size = opts.size || 1;
        const logicalType = opts.logicalType || opts.type;
        const doublePrecision = logicalType === 5130;
        let { defaultValue: defaultValue  } = opts;
        defaultValue = Number.isFinite(defaultValue) ? [
            defaultValue
        ] : defaultValue || new Array(this.size).fill(0);
        let bufferType;
        if (doublePrecision) bufferType = 5126;
        else if (!logicalType && opts.isIndexed) bufferType = gl && (0, $75ff6bc03ebbcaf6$export$805ddaeeece0413e)(gl, (0, $8cba87f65ded858b$export$d6a5c11f04f75862).ELEMENT_INDEX_UINT32) ? 5125 : 5123;
        else bufferType = logicalType || 5126;
        let defaultType = (0, $91f302df6555cc52$export$99de3c889be30ec5)(logicalType || bufferType || 5126);
        this.doublePrecision = doublePrecision;
        if (doublePrecision && opts.fp64 === false) defaultType = Float32Array;
        this.value = null;
        this.settings = {
            ...opts,
            defaultType: defaultType,
            defaultValue: defaultValue,
            logicalType: logicalType,
            type: bufferType,
            size: this.size,
            bytesPerElement: defaultType.BYTES_PER_ELEMENT
        };
        this.state = {
            ...state,
            externalBuffer: null,
            bufferAccessor: this.settings,
            allocatedValue: null,
            numInstances: 0,
            bounds: null,
            constant: false
        };
        this._buffer = null;
    }
    get isConstant() {
        return this.state.constant;
    }
    get buffer() {
        if (!this._buffer) {
            const { isIndexed: isIndexed , type: type  } = this.settings;
            this._buffer = new (0, $28a69bf6d03705d1$export$2e2bcd8739ae039)(this.gl, {
                id: this.id,
                target: isIndexed ? 34963 : 34962,
                accessor: {
                    type: type
                }
            });
        }
        return this._buffer;
    }
    get byteOffset() {
        const accessor = this.getAccessor();
        if (accessor.vertexOffset) return accessor.vertexOffset * $6d94c441f227935a$var$getStride(accessor);
        return 0;
    }
    get numInstances() {
        return this.state.numInstances;
    }
    set numInstances(n) {
        this.state.numInstances = n;
    }
    delete() {
        if (this._buffer) {
            this._buffer.delete();
            this._buffer = null;
        }
        (0, $e0cd51e92519f55c$export$2e2bcd8739ae039).release(this.state.allocatedValue);
    }
    getShaderAttributes(id, options) {
        if (this.doublePrecision) {
            const shaderAttributes = {};
            const isBuffer64Bit = this.value instanceof Float64Array;
            const doubleShaderAttributeDefs = $6d94c441f227935a$var$resolveDoublePrecisionShaderAttributes(this.getAccessor(), options || {});
            shaderAttributes[id] = new (0, $2cbd04ac4b17a1fc$export$2e2bcd8739ae039)(this, doubleShaderAttributeDefs.high);
            shaderAttributes["".concat(id, "64Low")] = isBuffer64Bit ? new (0, $2cbd04ac4b17a1fc$export$2e2bcd8739ae039)(this, doubleShaderAttributeDefs.low) : new Float32Array(this.size);
            return shaderAttributes;
        }
        if (options) {
            const shaderAttributeDef = $6d94c441f227935a$var$resolveShaderAttribute(this.getAccessor(), options);
            return {
                [id]: new (0, $2cbd04ac4b17a1fc$export$2e2bcd8739ae039)(this, shaderAttributeDef)
            };
        }
        return {
            [id]: this
        };
    }
    getBuffer() {
        if (this.state.constant) return null;
        return this.state.externalBuffer || this._buffer;
    }
    getValue() {
        if (this.state.constant) return this.value;
        return [
            this.getBuffer(),
            this.getAccessor()
        ];
    }
    getAccessor() {
        return this.state.bufferAccessor;
    }
    getBounds() {
        if (this.state.bounds) return this.state.bounds;
        let result = null;
        if (this.state.constant && this.value) {
            const min = Array.from(this.value);
            result = [
                min,
                min
            ];
        } else {
            const { value: value , numInstances: numInstances , size: size  } = this;
            const len = numInstances * size;
            if (value && len && value.length >= len) {
                const min = new Array(size).fill(Infinity);
                const max = new Array(size).fill(-Infinity);
                for(let i = 0; i < len;)for(let j = 0; j < size; j++){
                    const v = value[i++];
                    if (v < min[j]) min[j] = v;
                    if (v > max[j]) max[j] = v;
                }
                result = [
                    min,
                    max
                ];
            }
        }
        this.state.bounds = result;
        return result;
    }
    setData(data) {
        const { state: state  } = this;
        let opts;
        if (ArrayBuffer.isView(data)) opts = {
            value: data
        };
        else if (data instanceof (0, $28a69bf6d03705d1$export$2e2bcd8739ae039)) opts = {
            buffer: data
        };
        else opts = data;
        const accessor = {
            ...this.settings,
            ...opts
        };
        state.bufferAccessor = accessor;
        state.bounds = null;
        if (opts.constant) {
            let value = opts.value;
            value = this._normalizeValue(value, [], 0);
            if (this.settings.normalized) value = this.normalizeConstant(value);
            const hasChanged = !state.constant || !this._areValuesEqual(value, this.value);
            if (!hasChanged) return false;
            state.externalBuffer = null;
            state.constant = true;
            this.value = value;
        } else if (opts.buffer) {
            const buffer = opts.buffer;
            state.externalBuffer = buffer;
            state.constant = false;
            this.value = opts.value || null;
            const isBuffer64Bit = opts.value instanceof Float64Array;
            accessor.type = opts.type || buffer.accessor.type;
            accessor.bytesPerElement = buffer.accessor.BYTES_PER_ELEMENT * (isBuffer64Bit ? 2 : 1);
            accessor.stride = $6d94c441f227935a$var$getStride(accessor);
        } else if (opts.value) {
            this._checkExternalBuffer(opts);
            let value = opts.value;
            state.externalBuffer = null;
            state.constant = false;
            this.value = value;
            accessor.bytesPerElement = value.BYTES_PER_ELEMENT;
            accessor.stride = $6d94c441f227935a$var$getStride(accessor);
            const { buffer: buffer , byteOffset: byteOffset  } = this;
            if (this.doublePrecision && value instanceof Float64Array) value = (0, $97790275b37bd567$export$550bd089be4eedcb)(value, accessor);
            const requiredBufferSize = value.byteLength + byteOffset + accessor.stride * 2;
            if (buffer.byteLength < requiredBufferSize) buffer.reallocate(requiredBufferSize);
            buffer.setAccessor(null);
            buffer.subData({
                data: value,
                offset: byteOffset
            });
            accessor.type = opts.type || buffer.accessor.type;
        }
        return true;
    }
    updateSubBuffer(opts = {}) {
        this.state.bounds = null;
        const value = this.value;
        const { startOffset: startOffset = 0 , endOffset: endOffset  } = opts;
        this.buffer.subData({
            data: this.doublePrecision && value instanceof Float64Array ? (0, $97790275b37bd567$export$550bd089be4eedcb)(value, {
                size: this.size,
                startIndex: startOffset,
                endIndex: endOffset
            }) : value.subarray(startOffset, endOffset),
            offset: startOffset * value.BYTES_PER_ELEMENT + this.byteOffset
        });
    }
    allocate(numInstances, copy = false) {
        const { state: state  } = this;
        const oldValue = state.allocatedValue;
        const value = (0, $e0cd51e92519f55c$export$2e2bcd8739ae039).allocate(oldValue, numInstances + 1, {
            size: this.size,
            type: this.settings.defaultType,
            copy: copy
        });
        this.value = value;
        const { buffer: buffer , byteOffset: byteOffset  } = this;
        if (buffer.byteLength < value.byteLength + byteOffset) {
            buffer.reallocate(value.byteLength + byteOffset);
            if (copy && oldValue) buffer.subData({
                data: oldValue instanceof Float64Array ? (0, $97790275b37bd567$export$550bd089be4eedcb)(oldValue, this) : oldValue,
                offset: byteOffset
            });
        }
        state.allocatedValue = value;
        state.constant = false;
        state.externalBuffer = null;
        state.bufferAccessor = this.settings;
        return true;
    }
    _checkExternalBuffer(opts) {
        const { value: value  } = opts;
        if (!ArrayBuffer.isView(value)) throw new Error("Attribute ".concat(this.id, " value is not TypedArray"));
        const ArrayType = this.settings.defaultType;
        let illegalArrayType = false;
        if (this.doublePrecision) illegalArrayType = value.BYTES_PER_ELEMENT < 4;
        if (illegalArrayType) throw new Error("Attribute ".concat(this.id, " does not support ").concat(value.constructor.name));
        if (!(value instanceof ArrayType) && this.settings.normalized && !("normalized" in opts)) (0, $146cba582e8c799f$export$2e2bcd8739ae039).warn("Attribute ".concat(this.id, " is normalized"))();
    }
    normalizeConstant(value) {
        switch(this.settings.type){
            case 5120:
                return new Float32Array(value).map((x)=>(x + 128) / 255 * 2 - 1);
            case 5122:
                return new Float32Array(value).map((x)=>(x + 32768) / 65535 * 2 - 1);
            case 5121:
                return new Float32Array(value).map((x)=>x / 255);
            case 5123:
                return new Float32Array(value).map((x)=>x / 65535);
            default:
                return value;
        }
    }
    _normalizeValue(value, out, start) {
        const { defaultValue: defaultValue , size: size  } = this.settings;
        if (Number.isFinite(value)) {
            out[start] = value;
            return out;
        }
        if (!value) {
            out[start] = defaultValue[0];
            return out;
        }
        switch(size){
            case 4:
                out[start + 3] = Number.isFinite(value[3]) ? value[3] : defaultValue[3];
            case 3:
                out[start + 2] = Number.isFinite(value[2]) ? value[2] : defaultValue[2];
            case 2:
                out[start + 1] = Number.isFinite(value[1]) ? value[1] : defaultValue[1];
            case 1:
                out[start + 0] = Number.isFinite(value[0]) ? value[0] : defaultValue[0];
                break;
            default:
                let i = size;
                while(--i >= 0)out[start + i] = Number.isFinite(value[i]) ? value[i] : defaultValue[i];
        }
        return out;
    }
    _areValuesEqual(value1, value2) {
        if (!value1 || !value2) return false;
        const { size: size  } = this;
        for(let i = 0; i < size; i++){
            if (value1[i] !== value2[i]) return false;
        }
        return true;
    }
}



const $98a5ab1cbad9db41$var$EMPTY_ARRAY = [];
const $98a5ab1cbad9db41$var$placeholderArray = [];
function $98a5ab1cbad9db41$export$f9c2f07d6e2a6221(data, startRow = 0, endRow = Infinity) {
    let iterable = $98a5ab1cbad9db41$var$EMPTY_ARRAY;
    const objectInfo = {
        index: -1,
        data: data,
        target: []
    };
    if (!data) iterable = $98a5ab1cbad9db41$var$EMPTY_ARRAY;
    else if (typeof data[Symbol.iterator] === "function") iterable = data;
    else if (data.length > 0) {
        $98a5ab1cbad9db41$var$placeholderArray.length = data.length;
        iterable = $98a5ab1cbad9db41$var$placeholderArray;
    }
    if (startRow > 0 || Number.isFinite(endRow)) {
        iterable = (Array.isArray(iterable) ? iterable : Array.from(iterable)).slice(startRow, endRow);
        objectInfo.index = startRow - 1;
    }
    return {
        iterable: iterable,
        objectInfo: objectInfo
    };
}
function $98a5ab1cbad9db41$export$edb10ab8dd75a915(data) {
    return data && data[Symbol.asyncIterator];
}
function $98a5ab1cbad9db41$export$9c57eba05c1e4d4(typedArray, options) {
    const { size: size , stride: stride , offset: offset , startIndices: startIndices , nested: nested  } = options;
    const bytesPerElement = typedArray.BYTES_PER_ELEMENT;
    const elementStride = stride ? stride / bytesPerElement : size;
    const elementOffset = offset ? offset / bytesPerElement : 0;
    const vertexCount = Math.floor((typedArray.length - elementOffset) / elementStride);
    return (_, { index: index , target: target  })=>{
        if (!startIndices) {
            const sourceIndex = index * elementStride + elementOffset;
            for(let j = 0; j < size; j++)target[j] = typedArray[sourceIndex + j];
            return target;
        }
        const startIndex = startIndices[index];
        const endIndex = startIndices[index + 1] || vertexCount;
        let result;
        if (nested) {
            result = new Array(endIndex - startIndex);
            for(let i = startIndex; i < endIndex; i++){
                const sourceIndex = i * elementStride + elementOffset;
                target = new Array(size);
                for(let j = 0; j < size; j++)target[j] = typedArray[sourceIndex + j];
                result[i - startIndex] = target;
            }
        } else if (elementStride === size) result = typedArray.subarray(startIndex * size + elementOffset, endIndex * size + elementOffset);
        else {
            result = new typedArray.constructor((endIndex - startIndex) * size);
            let targetIndex = 0;
            for(let i = startIndex; i < endIndex; i++){
                const sourceIndex = i * elementStride + elementOffset;
                for(let j = 0; j < size; j++)result[targetIndex++] = typedArray[sourceIndex + j];
            }
        }
        return result;
    };
}



const $53843625f668a1e2$export$ccb33e29d92c9a58 = [];
const $53843625f668a1e2$export$3789e4b2a10baa2b = [
    [
        0,
        Infinity
    ]
];
function $53843625f668a1e2$export$e16d8520af44a096(rangeList, range) {
    if (rangeList === $53843625f668a1e2$export$3789e4b2a10baa2b) return rangeList;
    if (range[0] < 0) range[0] = 0;
    if (range[0] >= range[1]) return rangeList;
    const newRangeList = [];
    const len = rangeList.length;
    let insertPosition = 0;
    for(let i = 0; i < len; i++){
        const range0 = rangeList[i];
        if (range0[1] < range[0]) {
            newRangeList.push(range0);
            insertPosition = i + 1;
        } else if (range0[0] > range[1]) newRangeList.push(range0);
        else range = [
            Math.min(range0[0], range[0]),
            Math.max(range0[1], range[1])
        ];
    }
    newRangeList.splice(insertPosition, 0, range);
    return newRangeList;
}


function $d269dda6547e463a$var$padArrayChunk(options) {
    const { source: source , target: target , start: start = 0 , size: size , getData: getData  } = options;
    const end = options.end || target.length;
    const sourceLength = source.length;
    const targetLength = end - start;
    if (sourceLength > targetLength) {
        target.set(source.subarray(0, targetLength), start);
        return;
    }
    target.set(source, start);
    if (!getData) return;
    let i = sourceLength;
    while(i < targetLength){
        const datum = getData(i, source);
        for(let j = 0; j < size; j++){
            target[start + i] = datum[j] || 0;
            i++;
        }
    }
}
function $d269dda6547e463a$export$6735fc2994e30dd0({ source: source , target: target , size: size , getData: getData , sourceStartIndices: sourceStartIndices , targetStartIndices: targetStartIndices  }) {
    if (!Array.isArray(targetStartIndices)) {
        $d269dda6547e463a$var$padArrayChunk({
            source: source,
            target: target,
            size: size,
            getData: getData
        });
        return target;
    }
    let sourceIndex = 0;
    let targetIndex = 0;
    const getChunkData = getData && ((i, chunk)=>getData(i + targetIndex, chunk));
    const n = Math.min(sourceStartIndices.length, targetStartIndices.length);
    for(let i1 = 1; i1 < n; i1++){
        const nextSourceIndex = sourceStartIndices[i1] * size;
        const nextTargetIndex = targetStartIndices[i1] * size;
        $d269dda6547e463a$var$padArrayChunk({
            source: source.subarray(sourceIndex, nextSourceIndex),
            target: target,
            start: targetIndex,
            end: nextTargetIndex,
            size: size,
            getData: getChunkData
        });
        sourceIndex = nextSourceIndex;
        targetIndex = nextTargetIndex;
    }
    if (targetIndex < target.length) $d269dda6547e463a$var$padArrayChunk({
        source: [],
        target: target,
        start: targetIndex,
        size: size,
        getData: getChunkData
    });
    return target;
}


const $53f36c75cb59dde5$var$DEFAULT_TRANSITION_SETTINGS = {
    interpolation: {
        duration: 0,
        easing: (t)=>t
    },
    spring: {
        stiffness: 0.05,
        damping: 0.5
    }
};
function $53f36c75cb59dde5$export$47e87a95cf522e8c(userSettings, layerSettings) {
    if (!userSettings) return null;
    if (Number.isFinite(userSettings)) userSettings = {
        type: "interpolation",
        duration: userSettings
    };
    const type = userSettings.type || "interpolation";
    return {
        ...$53f36c75cb59dde5$var$DEFAULT_TRANSITION_SETTINGS[type],
        ...layerSettings,
        ...userSettings,
        type: type
    };
}
function $53f36c75cb59dde5$export$f3e2a32ee07ef92d(gl, attribute) {
    const buffer = attribute.getBuffer();
    if (buffer) return [
        buffer,
        {
            divisor: 0,
            size: attribute.size,
            normalized: attribute.settings.normalized
        }
    ];
    return attribute.value;
}
function $53f36c75cb59dde5$export$4f893656e30128e9(size) {
    switch(size){
        case 1:
            return "float";
        case 2:
            return "vec2";
        case 3:
            return "vec3";
        case 4:
            return "vec4";
        default:
            throw new Error('No defined attribute type for size "'.concat(size, '"'));
    }
}
function $53f36c75cb59dde5$export$1dcce42e2b71f528(buffers) {
    buffers.push(buffers.shift());
}
function $53f36c75cb59dde5$export$bd45d69169402c18(attribute, numInstances) {
    const { doublePrecision: doublePrecision , settings: settings , value: value , size: size  } = attribute;
    const multiplier = doublePrecision && value instanceof Float64Array ? 2 : 1;
    return (settings.noAlloc ? value.length : numInstances * size) * multiplier;
}
function $53f36c75cb59dde5$export$28f1d2df7aaab3dd({ buffer: buffer , numInstances: numInstances , attribute: attribute , fromLength: fromLength , fromStartIndices: fromStartIndices , getData: getData = (x)=>x  }) {
    const precisionMultiplier = attribute.doublePrecision && attribute.value instanceof Float64Array ? 2 : 1;
    const size = attribute.size * precisionMultiplier;
    const byteOffset = attribute.byteOffset;
    const toStartIndices = attribute.startIndices;
    const hasStartIndices = fromStartIndices && toStartIndices;
    const toLength = $53f36c75cb59dde5$export$bd45d69169402c18(attribute, numInstances);
    const isConstant = attribute.isConstant;
    if (!hasStartIndices && fromLength >= toLength) return;
    const toData = isConstant ? attribute.value : attribute.getBuffer().getData({
        srcByteOffset: byteOffset
    });
    if (attribute.settings.normalized && !isConstant) {
        const getter = getData;
        getData = (value, chunk)=>attribute.normalizeConstant(getter(value, chunk));
    }
    const getMissingData = isConstant ? (i, chunk)=>getData(toData, chunk) : (i, chunk)=>getData(toData.subarray(i, i + size), chunk);
    const source = buffer.getData({
        length: fromLength
    });
    const data = new Float32Array(toLength);
    (0, $d269dda6547e463a$export$6735fc2994e30dd0)({
        source: source,
        target: data,
        sourceStartIndices: fromStartIndices,
        targetStartIndices: toStartIndices,
        size: size,
        getData: getMissingData
    });
    if (buffer.byteLength < data.byteLength + byteOffset) buffer.reallocate(data.byteLength + byteOffset);
    buffer.subData({
        data: data,
        offset: byteOffset
    });
}


class $b8b4c55857af23f6$export$2e2bcd8739ae039 extends (0, $6d94c441f227935a$export$2e2bcd8739ae039) {
    constructor(gl, opts){
        super(gl, opts, {
            startIndices: null,
            lastExternalBuffer: null,
            binaryValue: null,
            binaryAccessor: null,
            needsUpdate: true,
            needsRedraw: false,
            updateRanges: $53843625f668a1e2$export$3789e4b2a10baa2b
        });
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "constant", false);
        this.settings.update = opts.update || (opts.accessor ? this._autoUpdater : undefined);
        Object.seal(this.settings);
        Object.seal(this.state);
        this._validateAttributeUpdaters();
    }
    get startIndices() {
        return this.state.startIndices;
    }
    set startIndices(layout) {
        this.state.startIndices = layout;
    }
    needsUpdate() {
        return this.state.needsUpdate;
    }
    needsRedraw({ clearChangedFlags: clearChangedFlags = false  } = {}) {
        const needsRedraw = this.state.needsRedraw;
        this.state.needsRedraw = needsRedraw && !clearChangedFlags;
        return needsRedraw;
    }
    getUpdateTriggers() {
        const { accessor: accessor  } = this.settings;
        return [
            this.id
        ].concat(typeof accessor !== "function" && accessor || []);
    }
    supportsTransition() {
        return Boolean(this.settings.transition);
    }
    getTransitionSetting(opts) {
        if (!opts || !this.supportsTransition()) return null;
        const { accessor: accessor  } = this.settings;
        const layerSettings = this.settings.transition;
        const userSettings = Array.isArray(accessor) ? opts[accessor.find((a)=>opts[a])] : opts[accessor];
        return (0, $53f36c75cb59dde5$export$47e87a95cf522e8c)(userSettings, layerSettings);
    }
    setNeedsUpdate(reason = this.id, dataRange) {
        this.state.needsUpdate = this.state.needsUpdate || reason;
        this.setNeedsRedraw(reason);
        if (dataRange) {
            const { startRow: startRow = 0 , endRow: endRow = Infinity  } = dataRange;
            this.state.updateRanges = $53843625f668a1e2$export$e16d8520af44a096(this.state.updateRanges, [
                startRow,
                endRow
            ]);
        } else this.state.updateRanges = $53843625f668a1e2$export$3789e4b2a10baa2b;
    }
    clearNeedsUpdate() {
        this.state.needsUpdate = false;
        this.state.updateRanges = $53843625f668a1e2$export$ccb33e29d92c9a58;
    }
    setNeedsRedraw(reason = this.id) {
        this.state.needsRedraw = this.state.needsRedraw || reason;
    }
    allocate(numInstances) {
        const { state: state , settings: settings  } = this;
        if (settings.noAlloc) return false;
        if (settings.update) {
            super.allocate(numInstances, state.updateRanges !== $53843625f668a1e2$export$3789e4b2a10baa2b);
            return true;
        }
        return false;
    }
    updateBuffer({ numInstances: numInstances , data: data , props: props , context: context  }) {
        if (!this.needsUpdate()) return false;
        const { state: { updateRanges: updateRanges  } , settings: { update: update , noAlloc: noAlloc  }  } = this;
        let updated = true;
        if (update) {
            for (const [startRow, endRow] of updateRanges)update.call(context, this, {
                data: data,
                startRow: startRow,
                endRow: endRow,
                props: props,
                numInstances: numInstances
            });
            if (!this.value) ;
            else if (this.constant || this.buffer.byteLength < this.value.byteLength + this.byteOffset) {
                this.setData({
                    value: this.value,
                    constant: this.constant
                });
                this.constant = false;
            } else for (const [startRow1, endRow1] of updateRanges){
                const startOffset = Number.isFinite(startRow1) ? this.getVertexOffset(startRow1) : 0;
                const endOffset = Number.isFinite(endRow1) ? this.getVertexOffset(endRow1) : noAlloc || !Number.isFinite(numInstances) ? this.value.length : numInstances * this.size;
                super.updateSubBuffer({
                    startOffset: startOffset,
                    endOffset: endOffset
                });
            }
            this._checkAttributeArray();
        } else updated = false;
        this.clearNeedsUpdate();
        this.setNeedsRedraw();
        return updated;
    }
    setConstantValue(value) {
        if (value === undefined || typeof value === "function") return false;
        const hasChanged = this.setData({
            constant: true,
            value: value
        });
        if (hasChanged) this.setNeedsRedraw();
        this.clearNeedsUpdate();
        return true;
    }
    setExternalBuffer(buffer) {
        const { state: state  } = this;
        if (!buffer) {
            state.lastExternalBuffer = null;
            return false;
        }
        this.clearNeedsUpdate();
        if (state.lastExternalBuffer === buffer) return true;
        state.lastExternalBuffer = buffer;
        this.setNeedsRedraw();
        this.setData(buffer);
        return true;
    }
    setBinaryValue(buffer, startIndices = null) {
        const { state: state , settings: settings  } = this;
        if (!buffer) {
            state.binaryValue = null;
            state.binaryAccessor = null;
            return false;
        }
        if (settings.noAlloc) return false;
        if (state.binaryValue === buffer) {
            this.clearNeedsUpdate();
            return true;
        }
        state.binaryValue = buffer;
        this.setNeedsRedraw();
        const needsUpdate = settings.transform || startIndices !== this.startIndices;
        if (needsUpdate) {
            if (ArrayBuffer.isView(buffer)) buffer = {
                value: buffer
            };
            const binaryValue = buffer;
            (0, $828c58095cddb61a$export$2e2bcd8739ae039)(ArrayBuffer.isView(binaryValue.value), "invalid ".concat(settings.accessor));
            const needsNormalize = Boolean(binaryValue.size) && binaryValue.size !== this.size;
            state.binaryAccessor = (0, $98a5ab1cbad9db41$export$9c57eba05c1e4d4)(binaryValue.value, {
                size: binaryValue.size || this.size,
                stride: binaryValue.stride,
                offset: binaryValue.offset,
                startIndices: startIndices,
                nested: needsNormalize
            });
            return false;
        }
        this.clearNeedsUpdate();
        this.setData(buffer);
        return true;
    }
    getVertexOffset(row) {
        const { startIndices: startIndices  } = this;
        const vertexIndex = startIndices ? startIndices[row] : row;
        return vertexIndex * this.size;
    }
    getShaderAttributes() {
        const shaderAttributeDefs = this.settings.shaderAttributes || {
            [this.id]: null
        };
        const shaderAttributes = {};
        for(const shaderAttributeName in shaderAttributeDefs)Object.assign(shaderAttributes, super.getShaderAttributes(shaderAttributeName, shaderAttributeDefs[shaderAttributeName]));
        return shaderAttributes;
    }
    _autoUpdater(attribute, { data: data , startRow: startRow , endRow: endRow , props: props , numInstances: numInstances  }) {
        if (attribute.constant) return;
        const { settings: settings , state: state , value: value , size: size , startIndices: startIndices  } = attribute;
        const { accessor: accessor , transform: transform  } = settings;
        const accessorFunc = state.binaryAccessor || (typeof accessor === "function" ? accessor : props[accessor]);
        (0, $828c58095cddb61a$export$2e2bcd8739ae039)(typeof accessorFunc === "function", 'accessor "'.concat(accessor, '" is not a function'));
        let i = attribute.getVertexOffset(startRow);
        const { iterable: iterable , objectInfo: objectInfo  } = (0, $98a5ab1cbad9db41$export$f9c2f07d6e2a6221)(data, startRow, endRow);
        for (const object of iterable){
            objectInfo.index++;
            let objectValue = accessorFunc(object, objectInfo);
            if (transform) objectValue = transform.call(this, objectValue);
            if (startIndices) {
                const numVertices = (objectInfo.index < startIndices.length - 1 ? startIndices[objectInfo.index + 1] : numInstances) - startIndices[objectInfo.index];
                if (objectValue && Array.isArray(objectValue[0])) {
                    let startIndex = i;
                    for (const item of objectValue){
                        attribute._normalizeValue(item, value, startIndex);
                        startIndex += size;
                    }
                } else if (objectValue && objectValue.length > size) value.set(objectValue, i);
                else {
                    attribute._normalizeValue(objectValue, objectInfo.target, 0);
                    (0, $755f3c37a143f46e$export$57295b69bf9c5d15)({
                        target: value,
                        source: objectInfo.target,
                        start: i,
                        count: numVertices
                    });
                }
                i += numVertices * size;
            } else {
                attribute._normalizeValue(objectValue, value, i);
                i += size;
            }
        }
    }
    _validateAttributeUpdaters() {
        const { settings: settings  } = this;
        const hasUpdater = settings.noAlloc || typeof settings.update === "function";
        if (!hasUpdater) throw new Error("Attribute ".concat(this.id, " missing update or accessor"));
    }
    _checkAttributeArray() {
        const { value: value  } = this;
        const limit = Math.min(4, this.size);
        if (value && value.length >= limit) {
            let valid = true;
            switch(limit){
                case 4:
                    valid = valid && Number.isFinite(value[3]);
                case 3:
                    valid = valid && Number.isFinite(value[2]);
                case 2:
                    valid = valid && Number.isFinite(value[1]);
                case 1:
                    valid = valid && Number.isFinite(value[0]);
                    break;
                default:
                    valid = false;
            }
            if (!valid) throw new Error("Illegal attribute generated for ".concat(this.id));
        }
    }
}











class $d18e9b9fa4b85e18$export$2e2bcd8739ae039 {
    constructor({ gl: gl , attribute: attribute , timeline: timeline  }){
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "gl", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "type", "interpolation");
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "attributeInTransition", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "settings", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "attribute", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "transition", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "currentStartIndices", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "currentLength", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "transform", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "buffers", void 0);
        this.gl = gl;
        this.transition = new (0, $c302e779b9092c62$export$2e2bcd8739ae039)(timeline);
        this.attribute = attribute;
        this.attributeInTransition = new (0, $b8b4c55857af23f6$export$2e2bcd8739ae039)(gl, attribute.settings);
        this.currentStartIndices = attribute.startIndices;
        this.currentLength = 0;
        this.transform = $d18e9b9fa4b85e18$var$getTransform(gl, attribute);
        const bufferOpts = {
            byteLength: 0,
            usage: 35050
        };
        this.buffers = [
            new (0, $28a69bf6d03705d1$export$2e2bcd8739ae039)(gl, bufferOpts),
            new (0, $28a69bf6d03705d1$export$2e2bcd8739ae039)(gl, bufferOpts)
        ];
    }
    get inProgress() {
        return this.transition.inProgress;
    }
    start(transitionSettings, numInstances) {
        if (transitionSettings.duration <= 0) {
            this.transition.cancel();
            return;
        }
        this.settings = transitionSettings;
        const { gl: gl , buffers: buffers , attribute: attribute  } = this;
        (0, $53f36c75cb59dde5$export$1dcce42e2b71f528)(buffers);
        const padBufferOpts = {
            numInstances: numInstances,
            attribute: attribute,
            fromLength: this.currentLength,
            fromStartIndices: this.currentStartIndices,
            getData: transitionSettings.enter
        };
        for (const buffer of buffers)(0, $53f36c75cb59dde5$export$28f1d2df7aaab3dd)({
            buffer: buffer,
            ...padBufferOpts
        });
        this.currentStartIndices = attribute.startIndices;
        this.currentLength = (0, $53f36c75cb59dde5$export$bd45d69169402c18)(attribute, numInstances);
        this.attributeInTransition.setData({
            buffer: buffers[1],
            value: attribute.value
        });
        this.transition.start(transitionSettings);
        this.transform.update({
            elementCount: Math.floor(this.currentLength / attribute.size),
            sourceBuffers: {
                aFrom: buffers[0],
                aTo: (0, $53f36c75cb59dde5$export$f3e2a32ee07ef92d)(gl, attribute)
            },
            feedbackBuffers: {
                vCurrent: buffers[1]
            }
        });
    }
    update() {
        const updated = this.transition.update();
        if (updated) {
            const { duration: duration , easing: easing  } = this.settings;
            const { time: time  } = this.transition;
            let t = time / duration;
            if (easing) t = easing(t);
            this.transform.run({
                uniforms: {
                    time: t
                }
            });
        }
        return updated;
    }
    cancel() {
        this.transition.cancel();
        this.transform.delete();
        for (const buffer of this.buffers)buffer.delete();
        this.buffers.length = 0;
    }
}
const $d18e9b9fa4b85e18$var$vs = "\n#define SHADER_NAME interpolation-transition-vertex-shader\n\nuniform float time;\nattribute ATTRIBUTE_TYPE aFrom;\nattribute ATTRIBUTE_TYPE aTo;\nvarying ATTRIBUTE_TYPE vCurrent;\n\nvoid main(void) {\n  vCurrent = mix(aFrom, aTo, time);\n  gl_Position = vec4(0.0);\n}\n";
function $d18e9b9fa4b85e18$var$getTransform(gl, attribute) {
    const attributeType = (0, $53f36c75cb59dde5$export$4f893656e30128e9)(attribute.size);
    return new (0, $00030bb52e16e5ae$export$2e2bcd8739ae039)(gl, {
        vs: $d18e9b9fa4b85e18$var$vs,
        defines: {
            ATTRIBUTE_TYPE: attributeType
        },
        varyings: [
            "vCurrent"
        ]
    });
}







class $4f4b22efa0676c69$export$2e2bcd8739ae039 {
    constructor({ gl: gl , attribute: attribute , timeline: timeline  }){
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "gl", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "type", "spring");
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "attributeInTransition", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "settings", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "attribute", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "transition", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "currentStartIndices", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "currentLength", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "texture", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "framebuffer", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "transform", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "buffers", void 0);
        this.gl = gl;
        this.type = "spring";
        this.transition = new (0, $c302e779b9092c62$export$2e2bcd8739ae039)(timeline);
        this.attribute = attribute;
        this.attributeInTransition = new (0, $b8b4c55857af23f6$export$2e2bcd8739ae039)(gl, {
            ...attribute.settings,
            normalized: false
        });
        this.currentStartIndices = attribute.startIndices;
        this.currentLength = 0;
        this.texture = $4f4b22efa0676c69$var$getTexture(gl);
        this.framebuffer = $4f4b22efa0676c69$var$getFramebuffer(gl, this.texture);
        this.transform = $4f4b22efa0676c69$var$getTransform(gl, attribute, this.framebuffer);
        const bufferOpts = {
            byteLength: 0,
            usage: 35050
        };
        this.buffers = [
            new (0, $28a69bf6d03705d1$export$2e2bcd8739ae039)(gl, bufferOpts),
            new (0, $28a69bf6d03705d1$export$2e2bcd8739ae039)(gl, bufferOpts),
            new (0, $28a69bf6d03705d1$export$2e2bcd8739ae039)(gl, bufferOpts)
        ];
    }
    get inProgress() {
        return this.transition.inProgress;
    }
    start(transitionSettings, numInstances) {
        const { gl: gl , buffers: buffers , attribute: attribute  } = this;
        const padBufferOpts = {
            numInstances: numInstances,
            attribute: attribute,
            fromLength: this.currentLength,
            fromStartIndices: this.currentStartIndices,
            getData: transitionSettings.enter
        };
        for (const buffer of buffers)(0, $53f36c75cb59dde5$export$28f1d2df7aaab3dd)({
            buffer: buffer,
            ...padBufferOpts
        });
        this.settings = transitionSettings;
        this.currentStartIndices = attribute.startIndices;
        this.currentLength = (0, $53f36c75cb59dde5$export$bd45d69169402c18)(attribute, numInstances);
        this.attributeInTransition.setData({
            buffer: buffers[1],
            value: attribute.value
        });
        this.transition.start({
            ...transitionSettings,
            duration: Infinity
        });
        this.transform.update({
            elementCount: Math.floor(this.currentLength / attribute.size),
            sourceBuffers: {
                aTo: (0, $53f36c75cb59dde5$export$f3e2a32ee07ef92d)(gl, attribute)
            }
        });
    }
    update() {
        const { buffers: buffers , transform: transform , framebuffer: framebuffer , transition: transition  } = this;
        const updated = transition.update();
        if (!updated) return false;
        const settings = this.settings;
        transform.update({
            sourceBuffers: {
                aPrev: buffers[0],
                aCur: buffers[1]
            },
            feedbackBuffers: {
                vNext: buffers[2]
            }
        });
        transform.run({
            framebuffer: framebuffer,
            discard: false,
            clearRenderTarget: true,
            uniforms: {
                stiffness: settings.stiffness,
                damping: settings.damping
            },
            parameters: {
                depthTest: false,
                blend: true,
                viewport: [
                    0,
                    0,
                    1,
                    1
                ],
                blendFunc: [
                    1,
                    1
                ],
                blendEquation: [
                    32776,
                    32776
                ]
            }
        });
        (0, $53f36c75cb59dde5$export$1dcce42e2b71f528)(buffers);
        this.attributeInTransition.setData({
            buffer: buffers[1],
            value: this.attribute.value
        });
        const isTransitioning = (0, $c192e756436d1779$export$f9f2f48e7f9faaa5)(framebuffer)[0] > 0;
        if (!isTransitioning) transition.end();
        return true;
    }
    cancel() {
        this.transition.cancel();
        this.transform.delete();
        for (const buffer of this.buffers)buffer.delete();
        this.buffers.length = 0;
        this.texture.delete();
        this.framebuffer.delete();
    }
}
function $4f4b22efa0676c69$var$getTransform(gl, attribute, framebuffer) {
    const attributeType = (0, $53f36c75cb59dde5$export$4f893656e30128e9)(attribute.size);
    return new (0, $00030bb52e16e5ae$export$2e2bcd8739ae039)(gl, {
        framebuffer: framebuffer,
        vs: "\n#define SHADER_NAME spring-transition-vertex-shader\n\n#define EPSILON 0.00001\n\nuniform float stiffness;\nuniform float damping;\nattribute ATTRIBUTE_TYPE aPrev;\nattribute ATTRIBUTE_TYPE aCur;\nattribute ATTRIBUTE_TYPE aTo;\nvarying ATTRIBUTE_TYPE vNext;\nvarying float vIsTransitioningFlag;\n\nATTRIBUTE_TYPE getNextValue(ATTRIBUTE_TYPE cur, ATTRIBUTE_TYPE prev, ATTRIBUTE_TYPE dest) {\n  ATTRIBUTE_TYPE velocity = cur - prev;\n  ATTRIBUTE_TYPE delta = dest - cur;\n  ATTRIBUTE_TYPE spring = delta * stiffness;\n  ATTRIBUTE_TYPE damper = velocity * -1.0 * damping;\n  return spring + damper + velocity + cur;\n}\n\nvoid main(void) {\n  bool isTransitioning = length(aCur - aPrev) > EPSILON || length(aTo - aCur) > EPSILON;\n  vIsTransitioningFlag = isTransitioning ? 1.0 : 0.0;\n\n  vNext = getNextValue(aCur, aPrev, aTo);\n  gl_Position = vec4(0, 0, 0, 1);\n  gl_PointSize = 100.0;\n}\n",
        fs: "\n#define SHADER_NAME spring-transition-is-transitioning-fragment-shader\n\nvarying float vIsTransitioningFlag;\n\nvoid main(void) {\n  if (vIsTransitioningFlag == 0.0) {\n    discard;\n  }\n  gl_FragColor = vec4(1.0);\n}",
        defines: {
            ATTRIBUTE_TYPE: attributeType
        },
        varyings: [
            "vNext"
        ]
    });
}
function $4f4b22efa0676c69$var$getTexture(gl) {
    return new (0, $df31c887249e3faa$export$2e2bcd8739ae039)(gl, {
        data: new Uint8Array(4),
        format: 6408,
        type: 5121,
        border: 0,
        mipmaps: false,
        dataFormat: 6408,
        width: 1,
        height: 1
    });
}
function $4f4b22efa0676c69$var$getFramebuffer(gl, texture) {
    return new (0, $a0e9e15bc57c4882$export$2e2bcd8739ae039)(gl, {
        id: "spring-transition-is-transitioning-framebuffer",
        width: 1,
        height: 1,
        attachments: {
            [36064]: texture
        }
    });
}



const $e3df2d5e12435106$var$TRANSITION_TYPES = {
    interpolation: (0, $d18e9b9fa4b85e18$export$2e2bcd8739ae039),
    spring: (0, $4f4b22efa0676c69$export$2e2bcd8739ae039)
};
class $e3df2d5e12435106$export$2e2bcd8739ae039 {
    constructor(gl, { id: id , timeline: timeline  }){
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "id", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "isSupported", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "gl", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "timeline", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "transitions", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "needsRedraw", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "numInstances", void 0);
        this.id = id;
        this.gl = gl;
        this.timeline = timeline;
        this.transitions = {};
        this.needsRedraw = false;
        this.numInstances = 1;
        this.isSupported = (0, $00030bb52e16e5ae$export$2e2bcd8739ae039).isSupported(gl);
    }
    finalize() {
        for(const attributeName in this.transitions)this._removeTransition(attributeName);
    }
    update({ attributes: attributes , transitions: transitions , numInstances: numInstances  }) {
        this.numInstances = numInstances || 1;
        for(const attributeName in attributes){
            const attribute = attributes[attributeName];
            const settings = attribute.getTransitionSetting(transitions);
            if (!settings) continue;
            this._updateAttribute(attributeName, attribute, settings);
        }
        for(const attributeName1 in this.transitions){
            const attribute = attributes[attributeName1];
            if (!attribute || !attribute.getTransitionSetting(transitions)) this._removeTransition(attributeName1);
        }
    }
    hasAttribute(attributeName) {
        const transition = this.transitions[attributeName];
        return transition && transition.inProgress;
    }
    getAttributes() {
        const animatedAttributes = {};
        for(const attributeName in this.transitions){
            const transition = this.transitions[attributeName];
            if (transition.inProgress) animatedAttributes[attributeName] = transition.attributeInTransition;
        }
        return animatedAttributes;
    }
    run() {
        if (!this.isSupported || this.numInstances === 0) return false;
        for(const attributeName in this.transitions){
            const updated = this.transitions[attributeName].update();
            if (updated) this.needsRedraw = true;
        }
        const needsRedraw = this.needsRedraw;
        this.needsRedraw = false;
        return needsRedraw;
    }
    _removeTransition(attributeName) {
        this.transitions[attributeName].cancel();
        delete this.transitions[attributeName];
    }
    _updateAttribute(attributeName, attribute, settings) {
        const transition = this.transitions[attributeName];
        let isNew = !transition || transition.type !== settings.type;
        if (isNew) {
            if (!this.isSupported) {
                (0, $146cba582e8c799f$export$2e2bcd8739ae039).warn("WebGL2 not supported by this browser. Transition for ".concat(attributeName, " is disabled."))();
                return;
            }
            if (transition) this._removeTransition(attributeName);
            const TransitionType = $e3df2d5e12435106$var$TRANSITION_TYPES[settings.type];
            if (TransitionType) this.transitions[attributeName] = new TransitionType({
                attribute: attribute,
                timeline: this.timeline,
                gl: this.gl
            });
            else {
                (0, $146cba582e8c799f$export$2e2bcd8739ae039).error("unsupported transition type '".concat(settings.type, "'"))();
                isNew = false;
            }
        }
        if (isNew || attribute.needsRedraw()) {
            this.needsRedraw = true;
            this.transitions[attributeName].start(settings, this.numInstances);
        }
    }
}


const $1bed349e8c64a1f7$var$TRACE_INVALIDATE = "attributeManager.invalidate";
const $1bed349e8c64a1f7$var$TRACE_UPDATE_START = "attributeManager.updateStart";
const $1bed349e8c64a1f7$var$TRACE_UPDATE_END = "attributeManager.updateEnd";
const $1bed349e8c64a1f7$var$TRACE_ATTRIBUTE_UPDATE_START = "attribute.updateStart";
const $1bed349e8c64a1f7$var$TRACE_ATTRIBUTE_ALLOCATE = "attribute.allocate";
const $1bed349e8c64a1f7$var$TRACE_ATTRIBUTE_UPDATE_END = "attribute.updateEnd";
class $1bed349e8c64a1f7$export$2e2bcd8739ae039 {
    constructor(gl, { id: id = "attribute-manager" , stats: stats , timeline: timeline  } = {}){
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "id", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "gl", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "attributes", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "updateTriggers", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "needsRedraw", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "userData", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "stats", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "attributeTransitionManager", void 0);
        this.id = id;
        this.gl = gl;
        this.attributes = {};
        this.updateTriggers = {};
        this.needsRedraw = true;
        this.userData = {};
        this.stats = stats;
        this.attributeTransitionManager = new (0, $e3df2d5e12435106$export$2e2bcd8739ae039)(gl, {
            id: "".concat(id, "-transitions"),
            timeline: timeline
        });
        Object.seal(this);
    }
    finalize() {
        for(const attributeName in this.attributes)this.attributes[attributeName].delete();
        this.attributeTransitionManager.finalize();
    }
    getNeedsRedraw(opts = {
        clearRedrawFlags: false
    }) {
        const redraw = this.needsRedraw;
        this.needsRedraw = this.needsRedraw && !opts.clearRedrawFlags;
        return redraw && this.id;
    }
    setNeedsRedraw() {
        this.needsRedraw = true;
    }
    add(attributes) {
        this._add(attributes);
    }
    addInstanced(attributes) {
        this._add(attributes, {
            instanced: 1
        });
    }
    remove(attributeNameArray) {
        for (const name of attributeNameArray)if (this.attributes[name] !== undefined) {
            this.attributes[name].delete();
            delete this.attributes[name];
        }
    }
    invalidate(triggerName, dataRange) {
        const invalidatedAttributes = this._invalidateTrigger(triggerName, dataRange);
        (0, $e34c41f170d77ab6$export$2e2bcd8739ae039)($1bed349e8c64a1f7$var$TRACE_INVALIDATE, this, triggerName, invalidatedAttributes);
    }
    invalidateAll(dataRange) {
        for(const attributeName in this.attributes)this.attributes[attributeName].setNeedsUpdate(attributeName, dataRange);
        (0, $e34c41f170d77ab6$export$2e2bcd8739ae039)($1bed349e8c64a1f7$var$TRACE_INVALIDATE, this, "all");
    }
    update({ data: data , numInstances: numInstances , startIndices: startIndices = null , transitions: transitions , props: props = {} , buffers: buffers = {} , context: context = {}  }) {
        let updated = false;
        (0, $e34c41f170d77ab6$export$2e2bcd8739ae039)($1bed349e8c64a1f7$var$TRACE_UPDATE_START, this);
        if (this.stats) this.stats.get("Update Attributes").timeStart();
        for(const attributeName in this.attributes){
            const attribute = this.attributes[attributeName];
            const accessorName = attribute.settings.accessor;
            attribute.startIndices = startIndices;
            attribute.numInstances = numInstances;
            if (props[attributeName]) (0, $146cba582e8c799f$export$2e2bcd8739ae039).removed("props.".concat(attributeName), "data.attributes.".concat(attributeName))();
            if (attribute.setExternalBuffer(buffers[attributeName])) ;
            else if (attribute.setBinaryValue(typeof accessorName === "string" ? buffers[accessorName] : undefined, data.startIndices)) ;
            else if (typeof accessorName === "string" && !buffers[accessorName] && attribute.setConstantValue(props[accessorName])) ;
            else if (attribute.needsUpdate()) {
                updated = true;
                this._updateAttribute({
                    attribute: attribute,
                    numInstances: numInstances,
                    data: data,
                    props: props,
                    context: context
                });
            }
            this.needsRedraw = this.needsRedraw || attribute.needsRedraw();
        }
        if (updated) (0, $e34c41f170d77ab6$export$2e2bcd8739ae039)($1bed349e8c64a1f7$var$TRACE_UPDATE_END, this, numInstances);
        if (this.stats) this.stats.get("Update Attributes").timeEnd();
        this.attributeTransitionManager.update({
            attributes: this.attributes,
            numInstances: numInstances,
            transitions: transitions
        });
    }
    updateTransition() {
        const { attributeTransitionManager: attributeTransitionManager  } = this;
        const transitionUpdated = attributeTransitionManager.run();
        this.needsRedraw = this.needsRedraw || transitionUpdated;
        return transitionUpdated;
    }
    getAttributes() {
        return this.attributes;
    }
    getChangedAttributes(opts = {
        clearChangedFlags: false
    }) {
        const { attributes: attributes , attributeTransitionManager: attributeTransitionManager  } = this;
        const changedAttributes = {
            ...attributeTransitionManager.getAttributes()
        };
        for(const attributeName in attributes){
            const attribute = attributes[attributeName];
            if (attribute.needsRedraw(opts) && !attributeTransitionManager.hasAttribute(attributeName)) changedAttributes[attributeName] = attribute;
        }
        return changedAttributes;
    }
    getShaderAttributes(attributes, excludeAttributes = {}) {
        if (!attributes) attributes = this.getAttributes();
        const shaderAttributes = {};
        for(const attributeName in attributes)if (!excludeAttributes[attributeName]) Object.assign(shaderAttributes, attributes[attributeName].getShaderAttributes());
        return shaderAttributes;
    }
    _add(attributes, extraProps = {}) {
        for(const attributeName in attributes){
            const attribute = attributes[attributeName];
            this.attributes[attributeName] = this._createAttribute(attributeName, attribute, extraProps);
        }
        this._mapUpdateTriggersToAttributes();
    }
    _createAttribute(name, attribute, extraProps) {
        const props = {
            ...attribute,
            id: name,
            size: attribute.isIndexed && 1 || attribute.size || 1,
            divisor: extraProps.instanced ? 1 : attribute.divisor || 0
        };
        return new (0, $b8b4c55857af23f6$export$2e2bcd8739ae039)(this.gl, props);
    }
    _mapUpdateTriggersToAttributes() {
        const triggers = {};
        for(const attributeName in this.attributes){
            const attribute = this.attributes[attributeName];
            attribute.getUpdateTriggers().forEach((triggerName)=>{
                if (!triggers[triggerName]) triggers[triggerName] = [];
                triggers[triggerName].push(attributeName);
            });
        }
        this.updateTriggers = triggers;
    }
    _invalidateTrigger(triggerName, dataRange) {
        const { attributes: attributes , updateTriggers: updateTriggers  } = this;
        const invalidatedAttributes = updateTriggers[triggerName];
        if (invalidatedAttributes) invalidatedAttributes.forEach((name)=>{
            const attribute = attributes[name];
            if (attribute) attribute.setNeedsUpdate(attribute.id, dataRange);
        });
        return invalidatedAttributes;
    }
    _updateAttribute(opts) {
        const { attribute: attribute , numInstances: numInstances  } = opts;
        (0, $e34c41f170d77ab6$export$2e2bcd8739ae039)($1bed349e8c64a1f7$var$TRACE_ATTRIBUTE_UPDATE_START, attribute);
        if (attribute.constant) {
            attribute.setConstantValue(attribute.value);
            return;
        }
        if (attribute.allocate(numInstances)) (0, $e34c41f170d77ab6$export$2e2bcd8739ae039)($1bed349e8c64a1f7$var$TRACE_ATTRIBUTE_ALLOCATE, attribute, numInstances);
        const updated = attribute.updateBuffer(opts);
        if (updated) {
            this.needsRedraw = true;
            (0, $e34c41f170d77ab6$export$2e2bcd8739ae039)($1bed349e8c64a1f7$var$TRACE_ATTRIBUTE_UPDATE_END, attribute, numInstances);
        }
    }
}





class $d0094bf136200100$export$2e2bcd8739ae039 extends (0, $c302e779b9092c62$export$2e2bcd8739ae039) {
    get value() {
        return this._value;
    }
    _onUpdate() {
        const { time: time , settings: { fromValue: fromValue , toValue: toValue , duration: duration , easing: easing  }  } = this;
        const t = easing(time / duration);
        this._value = (0, $53a37c44451cea56$export$3a89f8d6f6bf6c9f)(fromValue, toValue, t);
    }
}



const $df5592b22cd06e80$var$EPSILON = 1e-5;
function $df5592b22cd06e80$var$updateSpringElement(prev, cur, dest, damping, stiffness) {
    const velocity = cur - prev;
    const delta = dest - cur;
    const spring = delta * stiffness;
    const damper = -velocity * damping;
    return spring + damper + velocity + cur;
}
function $df5592b22cd06e80$var$updateSpring(prev, cur, dest, damping, stiffness) {
    if (Array.isArray(dest)) {
        const next = [];
        for(let i = 0; i < dest.length; i++)next[i] = $df5592b22cd06e80$var$updateSpringElement(prev[i], cur[i], dest[i], damping, stiffness);
        return next;
    }
    return $df5592b22cd06e80$var$updateSpringElement(prev, cur, dest, damping, stiffness);
}
function $df5592b22cd06e80$var$distance(value1, value2) {
    if (Array.isArray(value1)) {
        let distanceSquare = 0;
        for(let i = 0; i < value1.length; i++){
            const d = value1[i] - value2[i];
            distanceSquare += d * d;
        }
        return Math.sqrt(distanceSquare);
    }
    return Math.abs(value1 - value2);
}
class $df5592b22cd06e80$export$2e2bcd8739ae039 extends (0, $c302e779b9092c62$export$2e2bcd8739ae039) {
    get value() {
        return this._currValue;
    }
    _onUpdate() {
        const { fromValue: fromValue , toValue: toValue , damping: damping , stiffness: stiffness  } = this.settings;
        const { _prevValue: _prevValue = fromValue , _currValue: _currValue = fromValue  } = this;
        let nextValue = $df5592b22cd06e80$var$updateSpring(_prevValue, _currValue, toValue, damping, stiffness);
        const delta = $df5592b22cd06e80$var$distance(nextValue, toValue);
        const velocity = $df5592b22cd06e80$var$distance(nextValue, _currValue);
        if (delta < $df5592b22cd06e80$var$EPSILON && velocity < $df5592b22cd06e80$var$EPSILON) {
            nextValue = toValue;
            this.end();
        }
        this._prevValue = _currValue;
        this._currValue = nextValue;
    }
}



const $bf7908ceda7e0357$var$TRANSITION_TYPES = {
    interpolation: (0, $d0094bf136200100$export$2e2bcd8739ae039),
    spring: (0, $df5592b22cd06e80$export$2e2bcd8739ae039)
};
class $bf7908ceda7e0357$export$2e2bcd8739ae039 {
    constructor(timeline){
        this.transitions = new Map();
        this.timeline = timeline;
    }
    get active() {
        return this.transitions.size > 0;
    }
    add(key, fromValue, toValue, settings) {
        const { transitions: transitions  } = this;
        if (transitions.has(key)) {
            const transition = transitions.get(key);
            const { value: value = transition.settings.fromValue  } = transition;
            fromValue = value;
            this.remove(key);
        }
        settings = (0, $53f36c75cb59dde5$export$47e87a95cf522e8c)(settings);
        if (!settings) return;
        const TransitionType = $bf7908ceda7e0357$var$TRANSITION_TYPES[settings.type];
        if (!TransitionType) {
            (0, $146cba582e8c799f$export$2e2bcd8739ae039).error("unsupported transition type '".concat(settings.type, "'"))();
            return;
        }
        const transition = new TransitionType(this.timeline);
        transition.start({
            ...settings,
            fromValue: fromValue,
            toValue: toValue
        });
        transitions.set(key, transition);
    }
    remove(key) {
        const { transitions: transitions  } = this;
        if (transitions.has(key)) {
            transitions.get(key).cancel();
            transitions.delete(key);
        }
    }
    update() {
        const propsInTransition = {};
        for (const [key, transition] of this.transitions){
            transition.update();
            propsInTransition[key] = transition.value;
            if (!transition.inProgress) this.remove(key);
        }
        return propsInTransition;
    }
    clear() {
        for (const key of this.transitions.keys())this.remove(key);
    }
}



function $52d5f19794fbf789$export$45855e0dd982478b(props) {
    const propTypes = $52d5f19794fbf789$var$getPropTypes(props);
    for(const propName in propTypes){
        const propType = propTypes[propName];
        const { validate: validate  } = propType;
        if (validate && !validate(props[propName], propType)) throw new Error("Invalid prop ".concat(propName, ": ").concat(props[propName]));
    }
}
function $52d5f19794fbf789$export$8b12422c455acfb9(props, oldProps) {
    const propsChangedReason = $52d5f19794fbf789$export$1557ccb739c4ea87({
        newProps: props,
        oldProps: oldProps,
        propTypes: $52d5f19794fbf789$var$getPropTypes(props),
        ignoreProps: {
            data: null,
            updateTriggers: null,
            extensions: null,
            transitions: null
        }
    });
    const dataChangedReason = $52d5f19794fbf789$var$diffDataProps(props, oldProps);
    let updateTriggersChangedReason = false;
    if (!dataChangedReason) updateTriggersChangedReason = $52d5f19794fbf789$var$diffUpdateTriggers(props, oldProps);
    return {
        dataChanged: dataChangedReason,
        propsChanged: propsChangedReason,
        updateTriggersChanged: updateTriggersChangedReason,
        extensionsChanged: $52d5f19794fbf789$var$diffExtensions(props, oldProps),
        transitionsChanged: $52d5f19794fbf789$var$diffTransitions(props, oldProps)
    };
}
function $52d5f19794fbf789$var$diffTransitions(props, oldProps) {
    if (!props.transitions) return false;
    const result = {};
    const propTypes = $52d5f19794fbf789$var$getPropTypes(props);
    let changed = false;
    for(const key in props.transitions){
        const propType = propTypes[key];
        const type = propType && propType.type;
        const isTransitionable = type === "number" || type === "color" || type === "array";
        if (isTransitionable && $52d5f19794fbf789$var$comparePropValues(props[key], oldProps[key], propType)) {
            result[key] = true;
            changed = true;
        }
    }
    return changed ? result : false;
}
function $52d5f19794fbf789$export$1557ccb739c4ea87({ newProps: newProps , oldProps: oldProps , ignoreProps: ignoreProps = {} , propTypes: propTypes = {} , triggerName: triggerName = "props"  }) {
    if (oldProps === newProps) return false;
    if (typeof newProps !== "object" || newProps === null) return "".concat(triggerName, " changed shallowly");
    if (typeof oldProps !== "object" || oldProps === null) return "".concat(triggerName, " changed shallowly");
    for (const key of Object.keys(newProps))if (!(key in ignoreProps)) {
        if (!(key in oldProps)) return "".concat(triggerName, ".").concat(key, " added");
        const changed = $52d5f19794fbf789$var$comparePropValues(newProps[key], oldProps[key], propTypes[key]);
        if (changed) return "".concat(triggerName, ".").concat(key, " ").concat(changed);
    }
    for (const key1 of Object.keys(oldProps))if (!(key1 in ignoreProps)) {
        if (!(key1 in newProps)) return "".concat(triggerName, ".").concat(key1, " dropped");
        if (!Object.hasOwnProperty.call(newProps, key1)) {
            const changed = $52d5f19794fbf789$var$comparePropValues(newProps[key1], oldProps[key1], propTypes[key1]);
            if (changed) return "".concat(triggerName, ".").concat(key1, " ").concat(changed);
        }
    }
    return false;
}
function $52d5f19794fbf789$var$comparePropValues(newProp, oldProp, propType) {
    let equal = propType && propType.equal;
    if (equal && !equal(newProp, oldProp, propType)) return "changed deeply";
    if (!equal) {
        equal = newProp && oldProp && newProp.equals;
        if (equal && !equal.call(newProp, oldProp)) return "changed deeply";
    }
    if (!equal && oldProp !== newProp) return "changed shallowly";
    return null;
}
function $52d5f19794fbf789$var$diffDataProps(props, oldProps) {
    if (oldProps === null) return "oldProps is null, initial diff";
    let dataChanged = false;
    const { dataComparator: dataComparator , _dataDiff: _dataDiff  } = props;
    if (dataComparator) {
        if (!dataComparator(props.data, oldProps.data)) dataChanged = "Data comparator detected a change";
    } else if (props.data !== oldProps.data) dataChanged = "A new data container was supplied";
    if (dataChanged && _dataDiff) dataChanged = _dataDiff(props.data, oldProps.data) || dataChanged;
    return dataChanged;
}
function $52d5f19794fbf789$var$diffUpdateTriggers(props, oldProps) {
    if (oldProps === null) return {
        all: true
    };
    if ("all" in props.updateTriggers) {
        const diffReason = $52d5f19794fbf789$var$diffUpdateTrigger(props, oldProps, "all");
        if (diffReason) return {
            all: true
        };
    }
    const reason = {};
    let changed = false;
    for(const triggerName in props.updateTriggers)if (triggerName !== "all") {
        const diffReason = $52d5f19794fbf789$var$diffUpdateTrigger(props, oldProps, triggerName);
        if (diffReason) {
            reason[triggerName] = true;
            changed = true;
        }
    }
    return changed ? reason : false;
}
function $52d5f19794fbf789$var$diffExtensions(props, oldProps) {
    if (oldProps === null) return true;
    const oldExtensions = oldProps.extensions;
    const { extensions: extensions  } = props;
    if (extensions === oldExtensions) return false;
    if (!oldExtensions || !extensions) return true;
    if (extensions.length !== oldExtensions.length) return true;
    for(let i = 0; i < extensions.length; i++){
        if (!extensions[i].equals(oldExtensions[i])) return true;
    }
    return false;
}
function $52d5f19794fbf789$var$diffUpdateTrigger(props, oldProps, triggerName) {
    let newTriggers = props.updateTriggers[triggerName];
    newTriggers = newTriggers === undefined || newTriggers === null ? {} : newTriggers;
    let oldTriggers = oldProps.updateTriggers[triggerName];
    oldTriggers = oldTriggers === undefined || oldTriggers === null ? {} : oldTriggers;
    const diffReason = $52d5f19794fbf789$export$1557ccb739c4ea87({
        oldProps: oldTriggers,
        newProps: newTriggers,
        triggerName: triggerName
    });
    return diffReason;
}
function $52d5f19794fbf789$var$getPropTypes(props) {
    const layer = props[0, $434611e3e90ee53e$export$47f4402f338dd1fc];
    const LayerType = layer && layer.constructor;
    return LayerType ? LayerType._propTypes : {};
}



const $d69676cf99634f17$var$ERR_NOT_OBJECT = "count(): argument not an object";
const $d69676cf99634f17$var$ERR_NOT_CONTAINER = "count(): argument not a container";
function $d69676cf99634f17$export$85b9a36db797e02b(container) {
    if (!$d69676cf99634f17$var$isObject(container)) throw new Error($d69676cf99634f17$var$ERR_NOT_OBJECT);
    if (typeof container.count === "function") return container.count();
    if (Number.isFinite(container.size)) return container.size;
    if (Number.isFinite(container.length)) return container.length;
    if ($d69676cf99634f17$var$isPlainObject(container)) return Object.keys(container).length;
    throw new Error($d69676cf99634f17$var$ERR_NOT_CONTAINER);
}
function $d69676cf99634f17$var$isPlainObject(value) {
    return value !== null && typeof value === "object" && value.constructor === Object;
}
function $d69676cf99634f17$var$isObject(value) {
    return value !== null && typeof value === "object";
}







function $b59f746ed15ee2b5$export$95c481ecbbcfbbf1(target, source) {
    if (!source) return target;
    const result = {
        ...target,
        ...source
    };
    if ("defines" in source) result.defines = {
        ...target.defines,
        ...source.defines
    };
    if ("modules" in source) {
        result.modules = (target.modules || []).concat(source.modules);
        if (source.modules.some((module)=>module.name === "project64")) {
            const index = result.modules.findIndex((module)=>module.name === "project32");
            if (index >= 0) result.modules.splice(index, 1);
        }
    }
    if ("inject" in source) {
        if (!target.inject) result.inject = source.inject;
        else {
            const mergedInjection = {
                ...target.inject
            };
            for(const key in source.inject)mergedInjection[key] = (mergedInjection[key] || "") + source.inject[key];
            result.inject = mergedInjection;
        }
    }
    return result;
}








function $a6d9c45e493bd6f1$var$lngLatZToWorldPosition(lngLatZ, viewport, offsetMode = false) {
    const p = viewport.projectPosition(lngLatZ);
    if (offsetMode && viewport instanceof (0, $4ac7d89cb7f1c4ad$export$2e2bcd8739ae039)) {
        const [longitude, latitude, z = 0] = lngLatZ;
        const distanceScales = viewport.getDistanceScales([
            longitude,
            latitude
        ]);
        p[2] = z * distanceScales.unitsPerMeter[2];
    }
    return p;
}
function $a6d9c45e493bd6f1$var$normalizeParameters(opts) {
    const { viewport: viewport , modelMatrix: modelMatrix , coordinateOrigin: coordinateOrigin  } = opts;
    let { coordinateSystem: coordinateSystem , fromCoordinateSystem: fromCoordinateSystem , fromCoordinateOrigin: fromCoordinateOrigin  } = opts;
    if (coordinateSystem === (0, $b42a5b9aa3b1a41f$export$e4ccd0285368e485).DEFAULT) coordinateSystem = viewport.isGeospatial ? (0, $b42a5b9aa3b1a41f$export$e4ccd0285368e485).LNGLAT : (0, $b42a5b9aa3b1a41f$export$e4ccd0285368e485).CARTESIAN;
    if (fromCoordinateSystem === undefined) fromCoordinateSystem = coordinateSystem;
    if (fromCoordinateOrigin === undefined) fromCoordinateOrigin = coordinateOrigin;
    return {
        viewport: viewport,
        coordinateSystem: coordinateSystem,
        coordinateOrigin: coordinateOrigin,
        modelMatrix: modelMatrix,
        fromCoordinateSystem: fromCoordinateSystem,
        fromCoordinateOrigin: fromCoordinateOrigin
    };
}
function $a6d9c45e493bd6f1$export$13d987dcd33aecbe(position, { viewport: viewport , modelMatrix: modelMatrix , coordinateSystem: coordinateSystem , coordinateOrigin: coordinateOrigin , offsetMode: offsetMode  }) {
    let [x, y, z = 0] = position;
    if (modelMatrix) [x, y, z] = $bd1e837fe7e33410$export$5ffbd13800309d59([], [
        x,
        y,
        z,
        1.0
    ], modelMatrix);
    switch(coordinateSystem){
        case (0, $b42a5b9aa3b1a41f$export$e4ccd0285368e485).LNGLAT:
            return $a6d9c45e493bd6f1$var$lngLatZToWorldPosition([
                x,
                y,
                z
            ], viewport, offsetMode);
        case (0, $b42a5b9aa3b1a41f$export$e4ccd0285368e485).LNGLAT_OFFSETS:
            return $a6d9c45e493bd6f1$var$lngLatZToWorldPosition([
                x + coordinateOrigin[0],
                y + coordinateOrigin[1],
                z + (coordinateOrigin[2] || 0)
            ], viewport, offsetMode);
        case (0, $b42a5b9aa3b1a41f$export$e4ccd0285368e485).METER_OFFSETS:
            return $a6d9c45e493bd6f1$var$lngLatZToWorldPosition((0, $f5ef504cb5091e21$export$86ab4399faf187a8)(coordinateOrigin, [
                x,
                y,
                z
            ]), viewport, offsetMode);
        case (0, $b42a5b9aa3b1a41f$export$e4ccd0285368e485).CARTESIAN:
        default:
            return viewport.isGeospatial ? [
                x + coordinateOrigin[0],
                y + coordinateOrigin[1],
                z + coordinateOrigin[2]
            ] : viewport.projectPosition([
                x,
                y,
                z
            ]);
    }
}
function $a6d9c45e493bd6f1$export$a3c26af9c425194b(position, params) {
    const { viewport: viewport , coordinateSystem: coordinateSystem , coordinateOrigin: coordinateOrigin , modelMatrix: modelMatrix , fromCoordinateSystem: fromCoordinateSystem , fromCoordinateOrigin: fromCoordinateOrigin  } = $a6d9c45e493bd6f1$var$normalizeParameters(params);
    const { geospatialOrigin: geospatialOrigin , shaderCoordinateOrigin: shaderCoordinateOrigin , offsetMode: offsetMode  } = (0, $072d6f1b352f2883$export$20f9eb1a42fcd22d)(viewport, coordinateSystem, coordinateOrigin);
    const worldPosition = $a6d9c45e493bd6f1$export$13d987dcd33aecbe(position, {
        viewport: viewport,
        modelMatrix: modelMatrix,
        coordinateSystem: fromCoordinateSystem,
        coordinateOrigin: fromCoordinateOrigin,
        offsetMode: offsetMode
    });
    if (offsetMode) {
        const positionCommonSpace = viewport.projectPosition(geospatialOrigin || shaderCoordinateOrigin);
        $68948bc2139893c7$export$f93b5905241a7cca(worldPosition, worldPosition, positionCommonSpace);
    }
    return worldPosition;
}








const $c810f8af9d0a3d4c$var$DEFAULT_TEXTURE_PARAMETERS = {
    [10241]: 9987,
    [10240]: 9729,
    [10242]: 33071,
    [10243]: 33071
};
const $c810f8af9d0a3d4c$var$internalTextures = {};
function $c810f8af9d0a3d4c$export$37b981a8c575f415(layer, image) {
    const gl = layer.context && layer.context.gl;
    if (!gl || !image) return null;
    if (image instanceof (0, $df31c887249e3faa$export$2e2bcd8739ae039)) return image;
    else if (image.constructor && image.constructor.name !== "Object") image = {
        data: image
    };
    let specialTextureParameters = null;
    if (image.compressed) specialTextureParameters = {
        [10241]: image.data.length > 1 ? 9985 : 9729
    };
    const texture = new (0, $df31c887249e3faa$export$2e2bcd8739ae039)(gl, {
        ...image,
        parameters: {
            ...$c810f8af9d0a3d4c$var$DEFAULT_TEXTURE_PARAMETERS,
            ...specialTextureParameters,
            ...layer.props.textureParameters
        }
    });
    $c810f8af9d0a3d4c$var$internalTextures[texture.id] = true;
    return texture;
}
function $c810f8af9d0a3d4c$export$2ec81868286b17e6(texture) {
    if (!texture || !(texture instanceof (0, $df31c887249e3faa$export$2e2bcd8739ae039))) return;
    if ($c810f8af9d0a3d4c$var$internalTextures[texture.id]) {
        texture.delete();
        delete $c810f8af9d0a3d4c$var$internalTextures[texture.id];
    }
}



const $7057c19ba02f49cd$var$TYPE_DEFINITIONS = {
    boolean: {
        validate (value, propType) {
            return true;
        },
        equal (value1, value2, propType) {
            return Boolean(value1) === Boolean(value2);
        }
    },
    number: {
        validate (value, propType) {
            return Number.isFinite(value) && (!("max" in propType) || value <= propType.max) && (!("min" in propType) || value >= propType.min);
        }
    },
    color: {
        validate (value, propType) {
            return propType.optional && !value || $7057c19ba02f49cd$var$isArray(value) && (value.length === 3 || value.length === 4);
        },
        equal (value1, value2, propType) {
            return $7057c19ba02f49cd$var$arrayEqual(value1, value2);
        }
    },
    accessor: {
        validate (value, propType) {
            const valueType = $7057c19ba02f49cd$var$getTypeOf(value);
            return valueType === "function" || valueType === $7057c19ba02f49cd$var$getTypeOf(propType.value);
        },
        equal (value1, value2, propType) {
            if (typeof value2 === "function") return true;
            return $7057c19ba02f49cd$var$arrayEqual(value1, value2);
        }
    },
    array: {
        validate (value, propType) {
            return propType.optional && !value || $7057c19ba02f49cd$var$isArray(value);
        },
        equal (value1, value2, propType) {
            return propType.compare ? $7057c19ba02f49cd$var$arrayEqual(value1, value2) : value1 === value2;
        }
    },
    object: {
        equal (value1, value2, propType) {
            return propType.compare ? (0, $70a948cba88c73a3$export$9cb4719e2e525b7a)(value1, value2) : value1 === value2;
        }
    },
    function: {
        validate (value, propType) {
            return propType.optional && !value || typeof value === "function";
        },
        equal (value1, value2, propType) {
            return !propType.compare || value1 === value2;
        }
    },
    data: {
        transform: (value, propType, component)=>{
            const { dataTransform: dataTransform  } = component.props;
            return dataTransform && value ? dataTransform(value) : value;
        }
    },
    image: {
        transform: (value, propType, component)=>{
            return (0, $c810f8af9d0a3d4c$export$37b981a8c575f415)(component, value);
        },
        release: (value)=>{
            (0, $c810f8af9d0a3d4c$export$2ec81868286b17e6)(value);
        }
    }
};
function $7057c19ba02f49cd$var$arrayEqual(array1, array2) {
    if (array1 === array2) return true;
    if (!$7057c19ba02f49cd$var$isArray(array1) || !$7057c19ba02f49cd$var$isArray(array2)) return false;
    const len = array1.length;
    if (len !== array2.length) return false;
    for(let i = 0; i < len; i++){
        if (array1[i] !== array2[i]) return false;
    }
    return true;
}
function $7057c19ba02f49cd$export$6335b16489944934(propDefs) {
    const propTypes = {};
    const defaultProps = {};
    const deprecatedProps = {};
    for (const [propName, propDef] of Object.entries(propDefs)){
        const deprecated = propDef === null || propDef === void 0 ? void 0 : propDef.deprecatedFor;
        if (deprecated) deprecatedProps[propName] = Array.isArray(deprecated) ? deprecated : [
            deprecated
        ];
        else {
            const propType = $7057c19ba02f49cd$var$parsePropType(propName, propDef);
            propTypes[propName] = propType;
            defaultProps[propName] = propType.value;
        }
    }
    return {
        propTypes: propTypes,
        defaultProps: defaultProps,
        deprecatedProps: deprecatedProps
    };
}
function $7057c19ba02f49cd$var$parsePropType(name, propDef) {
    switch($7057c19ba02f49cd$var$getTypeOf(propDef)){
        case "object":
            return $7057c19ba02f49cd$var$normalizePropDefinition(name, propDef);
        case "array":
            return $7057c19ba02f49cd$var$normalizePropDefinition(name, {
                type: "array",
                value: propDef,
                compare: false
            });
        case "boolean":
            return $7057c19ba02f49cd$var$normalizePropDefinition(name, {
                type: "boolean",
                value: propDef
            });
        case "number":
            return $7057c19ba02f49cd$var$normalizePropDefinition(name, {
                type: "number",
                value: propDef
            });
        case "function":
            return $7057c19ba02f49cd$var$normalizePropDefinition(name, {
                type: "function",
                value: propDef,
                compare: true
            });
        default:
            return {
                name: name,
                type: "unknown",
                value: propDef
            };
    }
}
function $7057c19ba02f49cd$var$normalizePropDefinition(name, propDef) {
    if (!("type" in propDef)) {
        if (!("value" in propDef)) return {
            name: name,
            type: "object",
            value: propDef
        };
        return {
            name: name,
            type: $7057c19ba02f49cd$var$getTypeOf(propDef.value),
            ...propDef
        };
    }
    return {
        name: name,
        ...$7057c19ba02f49cd$var$TYPE_DEFINITIONS[propDef.type],
        ...propDef
    };
}
function $7057c19ba02f49cd$var$isArray(value) {
    return Array.isArray(value) || ArrayBuffer.isView(value);
}
function $7057c19ba02f49cd$var$getTypeOf(value) {
    if ($7057c19ba02f49cd$var$isArray(value)) return "array";
    if (value === null) return "null";
    return typeof value;
}



function $0d048365c5e17514$export$c94ea207b45fef3a(component, propObjects) {
    const propsPrototype = $0d048365c5e17514$var$getPropsPrototype(component.constructor);
    const propsInstance = Object.create(propsPrototype);
    propsInstance[0, $434611e3e90ee53e$export$47f4402f338dd1fc] = component;
    propsInstance[0, $434611e3e90ee53e$export$c313d789070da88c] = {};
    propsInstance[0, $434611e3e90ee53e$export$40aefa3472633071] = {};
    for(let i = 0; i < propObjects.length; ++i){
        const props = propObjects[i];
        for(const key in props)propsInstance[key] = props[key];
    }
    Object.freeze(propsInstance);
    return propsInstance;
}
function $0d048365c5e17514$var$getPropsPrototype(componentClass) {
    const defaultProps = $0d048365c5e17514$var$getOwnProperty(componentClass, "_mergedDefaultProps");
    if (!defaultProps) {
        $0d048365c5e17514$var$createPropsPrototypeAndTypes(componentClass);
        return componentClass._mergedDefaultProps;
    }
    return defaultProps;
}
function $0d048365c5e17514$var$createPropsPrototypeAndTypes(componentClass) {
    const parent = componentClass.prototype;
    if (!parent) return;
    const parentClass = Object.getPrototypeOf(componentClass);
    const parentDefaultProps = $0d048365c5e17514$var$getPropsPrototype(parentClass);
    const componentDefaultProps = $0d048365c5e17514$var$getOwnProperty(componentClass, "defaultProps") || {};
    const componentPropDefs = (0, $7057c19ba02f49cd$export$6335b16489944934)(componentDefaultProps);
    const defaultProps = $0d048365c5e17514$var$createPropsPrototype(componentPropDefs.defaultProps, parentDefaultProps, componentClass);
    const propTypes = {
        ...parentClass._propTypes,
        ...componentPropDefs.propTypes
    };
    $0d048365c5e17514$var$addAsyncPropsToPropPrototype(defaultProps, propTypes);
    const deprecatedProps = {
        ...parentClass._deprecatedProps,
        ...componentPropDefs.deprecatedProps
    };
    $0d048365c5e17514$var$addDeprecatedPropsToPropPrototype(defaultProps, deprecatedProps);
    componentClass._mergedDefaultProps = defaultProps;
    componentClass._propTypes = propTypes;
    componentClass._deprecatedProps = deprecatedProps;
}
function $0d048365c5e17514$var$createPropsPrototype(props, parentProps, componentClass) {
    const defaultProps = Object.create(null);
    Object.assign(defaultProps, parentProps, props);
    const id = $0d048365c5e17514$var$getComponentName(componentClass);
    delete props.id;
    Object.defineProperties(defaultProps, {
        id: {
            writable: true,
            value: id
        }
    });
    return defaultProps;
}
function $0d048365c5e17514$var$addDeprecatedPropsToPropPrototype(defaultProps, deprecatedProps) {
    for(const propName in deprecatedProps)Object.defineProperty(defaultProps, propName, {
        enumerable: false,
        set (newValue) {
            const nameStr = "".concat(this.id, ": ").concat(propName);
            for (const newPropName of deprecatedProps[propName])if (!$0d048365c5e17514$var$hasOwnProperty(this, newPropName)) this[newPropName] = newValue;
            (0, $146cba582e8c799f$export$2e2bcd8739ae039).deprecated(nameStr, deprecatedProps[propName].join("/"))();
        }
    });
}
function $0d048365c5e17514$var$addAsyncPropsToPropPrototype(defaultProps, propTypes) {
    const defaultValues = {};
    const descriptors = {};
    for(const propName in propTypes){
        const propType = propTypes[propName];
        const { name: name , value: value  } = propType;
        if (propType.async) {
            defaultValues[name] = value;
            descriptors[name] = $0d048365c5e17514$var$getDescriptorForAsyncProp(name);
        }
    }
    defaultProps[0, $434611e3e90ee53e$export$23f7c42255df7b05] = defaultValues;
    defaultProps[0, $434611e3e90ee53e$export$c313d789070da88c] = {};
    Object.defineProperties(defaultProps, descriptors);
}
function $0d048365c5e17514$var$getDescriptorForAsyncProp(name) {
    return {
        enumerable: true,
        set (newValue) {
            if (typeof newValue === "string" || newValue instanceof Promise || (0, $98a5ab1cbad9db41$export$edb10ab8dd75a915)(newValue)) this[0, $434611e3e90ee53e$export$c313d789070da88c][name] = newValue;
            else this[0, $434611e3e90ee53e$export$40aefa3472633071][name] = newValue;
        },
        get () {
            if (this[0, $434611e3e90ee53e$export$40aefa3472633071]) {
                if (name in this[0, $434611e3e90ee53e$export$40aefa3472633071]) {
                    const value = this[0, $434611e3e90ee53e$export$40aefa3472633071][name];
                    return value || this[0, $434611e3e90ee53e$export$23f7c42255df7b05][name];
                }
                if (name in this[0, $434611e3e90ee53e$export$c313d789070da88c]) {
                    const state = this[0, $434611e3e90ee53e$export$47f4402f338dd1fc] && this[0, $434611e3e90ee53e$export$47f4402f338dd1fc].internalState;
                    if (state && state.hasAsyncProp(name)) return state.getAsyncProp(name) || this[0, $434611e3e90ee53e$export$23f7c42255df7b05][name];
                }
            }
            return this[0, $434611e3e90ee53e$export$23f7c42255df7b05][name];
        }
    };
}
function $0d048365c5e17514$var$hasOwnProperty(object, prop) {
    return Object.prototype.hasOwnProperty.call(object, prop);
}
function $0d048365c5e17514$var$getOwnProperty(object, prop) {
    return $0d048365c5e17514$var$hasOwnProperty(object, prop) && object[prop];
}
function $0d048365c5e17514$var$getComponentName(componentClass) {
    const componentName = $0d048365c5e17514$var$getOwnProperty(componentClass, "layerName") || $0d048365c5e17514$var$getOwnProperty(componentClass, "componentName");
    if (!componentName) (0, $146cba582e8c799f$export$2e2bcd8739ae039).once(0, "".concat(componentClass.name, ".componentName not specified"))();
    return componentName || componentClass.name;
}


let $d492c99f5f269d3a$var$counter = 0;
class $d492c99f5f269d3a$export$2e2bcd8739ae039 {
    constructor(...propObjects){
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "id", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "props", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "count", void 0);
        this.props = (0, $0d048365c5e17514$export$c94ea207b45fef3a)(this, propObjects);
        this.id = this.props.id;
        this.count = $d492c99f5f269d3a$var$counter++;
    }
    clone(newProps) {
        const { props: props  } = this;
        const asyncProps = {};
        for(const key in props[0, $434611e3e90ee53e$export$23f7c42255df7b05]){
            if (key in props[0, $434611e3e90ee53e$export$40aefa3472633071]) asyncProps[key] = props[0, $434611e3e90ee53e$export$40aefa3472633071][key];
            else if (key in props[0, $434611e3e90ee53e$export$c313d789070da88c]) asyncProps[key] = props[0, $434611e3e90ee53e$export$c313d789070da88c][key];
        }
        return new this.constructor({
            ...props,
            ...asyncProps,
            ...newProps
        });
    }
}
(0, $037483d1fb5deac8$export$2e2bcd8739ae039)($d492c99f5f269d3a$export$2e2bcd8739ae039, "componentName", "Component");
(0, $037483d1fb5deac8$export$2e2bcd8739ae039)($d492c99f5f269d3a$export$2e2bcd8739ae039, "defaultProps", {});






const $65fd92247c959502$var$EMPTY_PROPS = Object.freeze({});
class $65fd92247c959502$export$2e2bcd8739ae039 {
    constructor(component){
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "component", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "onAsyncPropUpdated", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "asyncProps", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "oldProps", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "oldAsyncProps", void 0);
        this.component = component;
        this.asyncProps = {};
        this.onAsyncPropUpdated = ()=>{};
        this.oldProps = null;
        this.oldAsyncProps = null;
    }
    finalize() {
        for(const propName in this.asyncProps){
            const asyncProp = this.asyncProps[propName];
            if (asyncProp && asyncProp.type && asyncProp.type.release) asyncProp.type.release(asyncProp.resolvedValue, asyncProp.type, this.component);
        }
    }
    getOldProps() {
        return this.oldAsyncProps || this.oldProps || $65fd92247c959502$var$EMPTY_PROPS;
    }
    resetOldProps() {
        this.oldAsyncProps = null;
        this.oldProps = this.component.props;
    }
    hasAsyncProp(propName) {
        return propName in this.asyncProps;
    }
    getAsyncProp(propName) {
        const asyncProp = this.asyncProps[propName];
        return asyncProp && asyncProp.resolvedValue;
    }
    isAsyncPropLoading(propName) {
        if (propName) {
            const asyncProp = this.asyncProps[propName];
            return Boolean(asyncProp && asyncProp.pendingLoadCount > 0 && asyncProp.pendingLoadCount !== asyncProp.resolvedLoadCount);
        }
        for(const key in this.asyncProps){
            if (this.isAsyncPropLoading(key)) return true;
        }
        return false;
    }
    reloadAsyncProp(propName, value) {
        this._watchPromise(propName, Promise.resolve(value));
    }
    setAsyncProps(props) {
        const resolvedValues = props[0, $434611e3e90ee53e$export$40aefa3472633071] || {};
        const originalValues = props[0, $434611e3e90ee53e$export$c313d789070da88c] || props;
        const defaultValues = props[0, $434611e3e90ee53e$export$23f7c42255df7b05] || {};
        for(const propName in resolvedValues){
            const value = resolvedValues[propName];
            this._createAsyncPropData(propName, defaultValues[propName]);
            this._updateAsyncProp(propName, value);
            resolvedValues[propName] = this.getAsyncProp(propName);
        }
        for(const propName1 in originalValues){
            const value = originalValues[propName1];
            this._createAsyncPropData(propName1, defaultValues[propName1]);
            this._updateAsyncProp(propName1, value);
        }
    }
    _fetch(propName, url) {
        return null;
    }
    _onResolve(propName, value) {}
    _onError(propName, error) {}
    _updateAsyncProp(propName, value) {
        if (!this._didAsyncInputValueChange(propName, value)) return;
        if (typeof value === "string") value = this._fetch(propName, value);
        if (value instanceof Promise) {
            this._watchPromise(propName, value);
            return;
        }
        if ((0, $98a5ab1cbad9db41$export$edb10ab8dd75a915)(value)) {
            this._resolveAsyncIterable(propName, value);
            return;
        }
        this._setPropValue(propName, value);
    }
    _freezeAsyncOldProps() {
        if (!this.oldAsyncProps && this.oldProps) {
            this.oldAsyncProps = Object.create(this.oldProps);
            for(const propName in this.asyncProps)Object.defineProperty(this.oldAsyncProps, propName, {
                enumerable: true,
                value: this.oldProps[propName]
            });
        }
    }
    _didAsyncInputValueChange(propName, value) {
        const asyncProp = this.asyncProps[propName];
        if (value === asyncProp.resolvedValue || value === asyncProp.lastValue) return false;
        asyncProp.lastValue = value;
        return true;
    }
    _setPropValue(propName, value) {
        this._freezeAsyncOldProps();
        const asyncProp = this.asyncProps[propName];
        if (asyncProp) {
            value = this._postProcessValue(asyncProp, value);
            asyncProp.resolvedValue = value;
            asyncProp.pendingLoadCount++;
            asyncProp.resolvedLoadCount = asyncProp.pendingLoadCount;
        }
    }
    _setAsyncPropValue(propName, value, loadCount) {
        const asyncProp = this.asyncProps[propName];
        if (asyncProp && loadCount >= asyncProp.resolvedLoadCount && value !== undefined) {
            this._freezeAsyncOldProps();
            asyncProp.resolvedValue = value;
            asyncProp.resolvedLoadCount = loadCount;
            this.onAsyncPropUpdated(propName, value);
        }
    }
    _watchPromise(propName, promise) {
        const asyncProp = this.asyncProps[propName];
        if (asyncProp) {
            asyncProp.pendingLoadCount++;
            const loadCount = asyncProp.pendingLoadCount;
            promise.then((data)=>{
                data = this._postProcessValue(asyncProp, data);
                this._setAsyncPropValue(propName, data, loadCount);
                this._onResolve(propName, data);
            }).catch((error)=>{
                this._onError(propName, error);
            });
        }
    }
    async _resolveAsyncIterable(propName, iterable) {
        if (propName !== "data") {
            this._setPropValue(propName, iterable);
            return;
        }
        const asyncProp = this.asyncProps[propName];
        if (!asyncProp) return;
        asyncProp.pendingLoadCount++;
        const loadCount = asyncProp.pendingLoadCount;
        let data = [];
        let count = 0;
        for await (const chunk of iterable){
            const { dataTransform: dataTransform  } = this.component.props;
            if (dataTransform) data = dataTransform(chunk, data);
            else data = data.concat(chunk);
            Object.defineProperty(data, "__diff", {
                enumerable: false,
                value: [
                    {
                        startRow: count,
                        endRow: data.length
                    }
                ]
            });
            count = data.length;
            this._setAsyncPropValue(propName, data, loadCount);
        }
        this._onResolve(propName, data);
    }
    _postProcessValue(asyncProp, value) {
        const propType = asyncProp.type;
        if (propType) {
            if (propType.release) propType.release(asyncProp.resolvedValue, propType, this.component);
            if (propType.transform) return propType.transform(value, propType, this.component);
        }
        return value;
    }
    _createAsyncPropData(propName, defaultValue) {
        const asyncProp = this.asyncProps[propName];
        if (!asyncProp) {
            const propTypes = this.component && this.component.constructor._propTypes;
            this.asyncProps[propName] = {
                type: propTypes && propTypes[propName],
                lastValue: null,
                resolvedValue: defaultValue,
                pendingLoadCount: 0,
                resolvedLoadCount: 0
            };
        }
    }
}


class $3a7d9a91af406387$export$2e2bcd8739ae039 extends (0, $65fd92247c959502$export$2e2bcd8739ae039) {
    constructor({ attributeManager: attributeManager , layer: layer  }){
        super(layer);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "attributeManager", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "needsRedraw", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "needsUpdate", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "subLayers", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "usesPickingColorCache", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "changeFlags", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "viewport", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "uniformTransitions", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "propsInTransition", void 0);
        this.attributeManager = attributeManager;
        this.needsRedraw = true;
        this.needsUpdate = true;
        this.subLayers = null;
        this.usesPickingColorCache = false;
    }
    get layer() {
        return this.component;
    }
    set layer(layer) {
        this.component = layer;
    }
    _fetch(propName, url) {
        const fetch = this.component.props.fetch;
        if (fetch) return fetch(url, {
            propName: propName,
            layer: this.layer
        });
        return super._fetch(propName, url);
    }
    _onResolve(propName, value) {
        const onDataLoad = this.component.props.onDataLoad;
        if (propName === "data" && onDataLoad) onDataLoad(value, {
            propName: propName,
            layer: this.layer
        });
    }
    _onError(propName, error) {
        this.layer.raiseError(error, "loading ".concat(propName, " of ").concat(this.layer));
    }
}




const $d2bffe6b8ece4bb2$var$TRACE_CHANGE_FLAG = "layer.changeFlag";
const $d2bffe6b8ece4bb2$var$TRACE_INITIALIZE = "layer.initialize";
const $d2bffe6b8ece4bb2$var$TRACE_UPDATE = "layer.update";
const $d2bffe6b8ece4bb2$var$TRACE_FINALIZE = "layer.finalize";
const $d2bffe6b8ece4bb2$var$TRACE_MATCHED = "layer.matched";
const $d2bffe6b8ece4bb2$var$MAX_PICKING_COLOR_CACHE_SIZE = 2 ** 24 - 1;
const $d2bffe6b8ece4bb2$var$EMPTY_ARRAY = Object.freeze([]);
const $d2bffe6b8ece4bb2$var$areViewportsEqual = (0, $1ccdae01919b6bce$export$2e2bcd8739ae039)(({ oldViewport: oldViewport , viewport: viewport  })=>{
    return oldViewport.equals(viewport);
});
let $d2bffe6b8ece4bb2$var$pickingColorCache = new Uint8ClampedArray(0);
const $d2bffe6b8ece4bb2$var$defaultProps = {
    data: {
        type: "data",
        value: $d2bffe6b8ece4bb2$var$EMPTY_ARRAY,
        async: true
    },
    dataComparator: {
        type: "function",
        value: null,
        compare: false,
        optional: true
    },
    _dataDiff: {
        type: "function",
        value: (data)=>data && data.__diff,
        compare: false,
        optional: true
    },
    dataTransform: {
        type: "function",
        value: null,
        compare: false,
        optional: true
    },
    onDataLoad: {
        type: "function",
        value: null,
        compare: false,
        optional: true
    },
    onError: {
        type: "function",
        value: null,
        compare: false,
        optional: true
    },
    fetch: {
        type: "function",
        value: (url, { propName: propName , layer: layer , loaders: loaders , loadOptions: loadOptions , signal: signal  })=>{
            const { resourceManager: resourceManager  } = layer.context;
            loadOptions = loadOptions || layer.getLoadOptions();
            loaders = loaders || layer.props.loaders;
            if (signal) {
                var _loadOptions;
                loadOptions = {
                    ...loadOptions,
                    fetch: {
                        ...(_loadOptions = loadOptions) === null || _loadOptions === void 0 ? void 0 : _loadOptions.fetch,
                        signal: signal
                    }
                };
            }
            let inResourceManager = resourceManager.contains(url);
            if (!inResourceManager && !loadOptions) {
                resourceManager.add({
                    resourceId: url,
                    data: (0, $10b58f50fbeb8045$export$11e63f7b0f3d9900)(url, loaders),
                    persistent: false
                });
                inResourceManager = true;
            }
            if (inResourceManager) return resourceManager.subscribe({
                resourceId: url,
                onChange: (data)=>{
                    var _layer$internalState;
                    return (_layer$internalState = layer.internalState) === null || _layer$internalState === void 0 ? void 0 : _layer$internalState.reloadAsyncProp(propName, data);
                },
                consumerId: layer.id,
                requestId: propName
            });
            return (0, $10b58f50fbeb8045$export$11e63f7b0f3d9900)(url, loaders, loadOptions);
        },
        compare: false
    },
    updateTriggers: {},
    visible: true,
    pickable: false,
    opacity: {
        type: "number",
        min: 0,
        max: 1,
        value: 1
    },
    operation: (0, $b42a5b9aa3b1a41f$export$b56168d831461ce2).DRAW,
    onHover: {
        type: "function",
        value: null,
        compare: false,
        optional: true
    },
    onClick: {
        type: "function",
        value: null,
        compare: false,
        optional: true
    },
    onDragStart: {
        type: "function",
        value: null,
        compare: false,
        optional: true
    },
    onDrag: {
        type: "function",
        value: null,
        compare: false,
        optional: true
    },
    onDragEnd: {
        type: "function",
        value: null,
        compare: false,
        optional: true
    },
    coordinateSystem: (0, $b42a5b9aa3b1a41f$export$e4ccd0285368e485).DEFAULT,
    coordinateOrigin: {
        type: "array",
        value: [
            0,
            0,
            0
        ],
        compare: true
    },
    modelMatrix: {
        type: "array",
        value: null,
        compare: true,
        optional: true
    },
    wrapLongitude: false,
    positionFormat: "XYZ",
    colorFormat: "RGBA",
    parameters: {
        type: "object",
        value: {},
        optional: true,
        compare: true
    },
    transitions: null,
    extensions: [],
    loaders: {
        type: "array",
        value: [],
        optional: true,
        compare: true
    },
    getPolygonOffset: {
        type: "function",
        value: ({ layerIndex: layerIndex  })=>[
                0,
                -layerIndex * 100
            ],
        compare: false
    },
    highlightedObjectIndex: null,
    autoHighlight: false,
    highlightColor: {
        type: "accessor",
        value: [
            0,
            0,
            128,
            128
        ]
    }
};
class $d2bffe6b8ece4bb2$export$2e2bcd8739ae039 extends (0, $d492c99f5f269d3a$export$2e2bcd8739ae039) {
    constructor(...args){
        super(...args);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "internalState", null);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "lifecycle", (0, $434611e3e90ee53e$export$2cb9787dd463cbf4).NO_STATE);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "context", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "state", void 0);
        (0, $037483d1fb5deac8$export$2e2bcd8739ae039)(this, "parent", null);
    }
    get root() {
        let layer = this;
        while(layer.parent)layer = layer.parent;
        return layer;
    }
    toString() {
        const className = this.constructor.layerName || this.constructor.name;
        return "".concat(className, "({id: '").concat(this.props.id, "'})");
    }
    project(xyz) {
        (0, $828c58095cddb61a$export$2e2bcd8739ae039)(this.internalState);
        const viewport = this.internalState.viewport || this.context.viewport;
        const worldPosition = (0, $a6d9c45e493bd6f1$export$13d987dcd33aecbe)(xyz, {
            viewport: viewport,
            modelMatrix: this.props.modelMatrix,
            coordinateOrigin: this.props.coordinateOrigin,
            coordinateSystem: this.props.coordinateSystem
        });
        const [x, y, z] = (0, $f5ef504cb5091e21$export$46d0dd92e8f9a0db)(worldPosition, viewport.pixelProjectionMatrix);
        return xyz.length === 2 ? [
            x,
            y
        ] : [
            x,
            y,
            z
        ];
    }
    unproject(xy) {
        (0, $828c58095cddb61a$export$2e2bcd8739ae039)(this.internalState);
        const viewport = this.internalState.viewport || this.context.viewport;
        return viewport.unproject(xy);
    }
    projectPosition(xyz, params) {
        (0, $828c58095cddb61a$export$2e2bcd8739ae039)(this.internalState);
        const viewport = this.internalState.viewport || this.context.viewport;
        return (0, $a6d9c45e493bd6f1$export$a3c26af9c425194b)(xyz, {
            viewport: viewport,
            modelMatrix: this.props.modelMatrix,
            coordinateOrigin: this.props.coordinateOrigin,
            coordinateSystem: this.props.coordinateSystem,
            ...params
        });
    }
    get isComposite() {
        return false;
    }
    setState(partialState) {
        this.setChangeFlags({
            stateChanged: true
        });
        Object.assign(this.state, partialState);
        this.setNeedsRedraw();
    }
    setNeedsRedraw() {
        if (this.internalState) this.internalState.needsRedraw = true;
    }
    setNeedsUpdate() {
        if (this.internalState) {
            this.context.layerManager.setNeedsUpdate(String(this));
            this.internalState.needsUpdate = true;
        }
    }
    get isLoaded() {
        return this.internalState ? !this.internalState.isAsyncPropLoading() : false;
    }
    get wrapLongitude() {
        return this.props.wrapLongitude;
    }
    isPickable() {
        return this.props.pickable && this.props.visible;
    }
    getModels() {
        return this.state && (this.state.models || this.state.model && [
            this.state.model
        ]) || [];
    }
    setModuleParameters(moduleParameters) {
        for (const model of this.getModels())model.updateModuleSettings(moduleParameters);
    }
    getAttributeManager() {
        return this.internalState && this.internalState.attributeManager;
    }
    getCurrentLayer() {
        return this.internalState && this.internalState.layer;
    }
    getLoadOptions() {
        return this.props.loadOptions;
    }
    use64bitPositions() {
        const { coordinateSystem: coordinateSystem  } = this.props;
        return coordinateSystem === (0, $b42a5b9aa3b1a41f$export$e4ccd0285368e485).DEFAULT || coordinateSystem === (0, $b42a5b9aa3b1a41f$export$e4ccd0285368e485).LNGLAT || coordinateSystem === (0, $b42a5b9aa3b1a41f$export$e4ccd0285368e485).CARTESIAN;
    }
    onHover(info, pickingEvent) {
        if (this.props.onHover) return this.props.onHover(info, pickingEvent) || false;
        return false;
    }
    onClick(info, pickingEvent) {
        if (this.props.onClick) return this.props.onClick(info, pickingEvent) || false;
        return false;
    }
    nullPickingColor() {
        return [
            0,
            0,
            0
        ];
    }
    encodePickingColor(i, target = []) {
        target[0] = i + 1 & 255;
        target[1] = i + 1 >> 8 & 255;
        target[2] = i + 1 >> 8 >> 8 & 255;
        return target;
    }
    decodePickingColor(color) {
        (0, $828c58095cddb61a$export$2e2bcd8739ae039)(color instanceof Uint8Array);
        const [i1, i2, i3] = color;
        const index = i1 + i2 * 256 + i3 * 65536 - 1;
        return index;
    }
    getNumInstances() {
        if (Number.isFinite(this.props.numInstances)) return this.props.numInstances;
        if (this.state && this.state.numInstances !== undefined) return this.state.numInstances;
        return (0, $d69676cf99634f17$export$85b9a36db797e02b)(this.props.data);
    }
    getStartIndices() {
        if (this.props.startIndices) return this.props.startIndices;
        if (this.state && this.state.startIndices) return this.state.startIndices;
        return null;
    }
    getBounds() {
        var _ref;
        const attributeManager = this.getAttributeManager();
        if (!attributeManager) return null;
        const { positions: positions , instancePositions: instancePositions  } = attributeManager.attributes;
        return (_ref = positions || instancePositions) === null || _ref === void 0 ? void 0 : _ref.getBounds();
    }
    getShaders(shaders) {
        for (const extension of this.props.extensions)shaders = (0, $b59f746ed15ee2b5$export$95c481ecbbcfbbf1)(shaders, extension.getShaders.call(this, extension));
        return shaders;
    }
    shouldUpdateState(params) {
        return params.changeFlags.propsOrDataChanged;
    }
    updateState(params) {
        const attributeManager = this.getAttributeManager();
        const { dataChanged: dataChanged  } = params.changeFlags;
        if (dataChanged && attributeManager) {
            if (Array.isArray(dataChanged)) for (const dataRange of dataChanged)attributeManager.invalidateAll(dataRange);
            else attributeManager.invalidateAll();
        }
        const { props: props , oldProps: oldProps  } = params;
        const neededPickingBuffer = Number.isInteger(oldProps.highlightedObjectIndex) || oldProps.pickable;
        const needPickingBuffer = Number.isInteger(props.highlightedObjectIndex) || props.pickable;
        if (neededPickingBuffer !== needPickingBuffer && attributeManager) {
            const { pickingColors: pickingColors , instancePickingColors: instancePickingColors  } = attributeManager.attributes;
            const pickingColorsAttribute = pickingColors || instancePickingColors;
            if (pickingColorsAttribute) {
                if (needPickingBuffer && pickingColorsAttribute.constant) {
                    pickingColorsAttribute.constant = false;
                    attributeManager.invalidate(pickingColorsAttribute.id);
                }
                if (!pickingColorsAttribute.value && !needPickingBuffer) {
                    pickingColorsAttribute.constant = true;
                    pickingColorsAttribute.value = [
                        0,
                        0,
                        0
                    ];
                }
            }
        }
    }
    finalizeState(context) {
        for (const model of this.getModels())model.delete();
        const attributeManager = this.getAttributeManager();
        if (attributeManager) attributeManager.finalize();
        if (this.context) this.context.resourceManager.unsubscribe({
            consumerId: this.id
        });
        if (this.internalState) {
            this.internalState.uniformTransitions.clear();
            this.internalState.finalize();
        }
    }
    draw(opts) {
        for (const model of this.getModels())model.draw(opts);
    }
    getPickingInfo({ info: info , mode: mode , sourceLayer: sourceLayer  }) {
        const { index: index  } = info;
        if (index >= 0) {
            if (Array.isArray(this.props.data)) info.object = this.props.data[index];
        }
        return info;
    }
    raiseError(error, message) {
        var _this$props$onError, _this$props;
        if (message) error.message = "".concat(message, ": ").concat(error.message);
        if (!((_this$props$onError = (_this$props = this.props).onError) !== null && _this$props$onError !== void 0 && _this$props$onError.call(_this$props, error))) {
            var _this$context, _this$context$onError;
            (_this$context = this.context) === null || _this$context === void 0 || (_this$context$onError = _this$context.onError) === null || _this$context$onError === void 0 || _this$context$onError.call(_this$context, error, this);
        }
    }
    getNeedsRedraw(opts = {
        clearRedrawFlags: false
    }) {
        return this._getNeedsRedraw(opts);
    }
    needsUpdate() {
        if (!this.internalState) return false;
        return this.internalState.needsUpdate || this.hasUniformTransition() || this.shouldUpdateState(this._getUpdateParams());
    }
    hasUniformTransition() {
        var _this$internalState;
        return ((_this$internalState = this.internalState) === null || _this$internalState === void 0 ? void 0 : _this$internalState.uniformTransitions.active) || false;
    }
    activateViewport(viewport) {
        if (!this.internalState) return;
        const oldViewport = this.internalState.viewport;
        this.internalState.viewport = viewport;
        if (!oldViewport || !$d2bffe6b8ece4bb2$var$areViewportsEqual({
            oldViewport: oldViewport,
            viewport: viewport
        })) {
            this.setChangeFlags({
                viewportChanged: true
            });
            if (this.isComposite) {
                if (this.needsUpdate()) this.setNeedsUpdate();
            } else this._update();
        }
    }
    invalidateAttribute(name = "all") {
        const attributeManager = this.getAttributeManager();
        if (!attributeManager) return;
        if (name === "all") attributeManager.invalidateAll();
        else attributeManager.invalidate(name);
    }
    updateAttributes(changedAttributes) {
        for (const model of this.getModels())this._setModelAttributes(model, changedAttributes);
    }
    _updateAttributes() {
        const attributeManager = this.getAttributeManager();
        if (!attributeManager) return;
        const props = this.props;
        const numInstances = this.getNumInstances();
        const startIndices = this.getStartIndices();
        attributeManager.update({
            data: props.data,
            numInstances: numInstances,
            startIndices: startIndices,
            props: props,
            transitions: props.transitions,
            buffers: props.data.attributes,
            context: this
        });
        const changedAttributes = attributeManager.getChangedAttributes({
            clearChangedFlags: true
        });
        this.updateAttributes(changedAttributes);
    }
    _updateAttributeTransition() {
        const attributeManager = this.getAttributeManager();
        if (attributeManager) attributeManager.updateTransition();
    }
    _updateUniformTransition() {
        const { uniformTransitions: uniformTransitions  } = this.internalState;
        if (uniformTransitions.active) {
            const propsInTransition = uniformTransitions.update();
            const props = Object.create(this.props);
            for(const key in propsInTransition)Object.defineProperty(props, key, {
                value: propsInTransition[key]
            });
            return props;
        }
        return this.props;
    }
    calculateInstancePickingColors(attribute, { numInstances: numInstances  }) {
        if (attribute.constant) return;
        const cacheSize = Math.floor($d2bffe6b8ece4bb2$var$pickingColorCache.length / 3);
        this.internalState.usesPickingColorCache = true;
        if (cacheSize < numInstances) {
            if (numInstances > $d2bffe6b8ece4bb2$var$MAX_PICKING_COLOR_CACHE_SIZE) (0, $146cba582e8c799f$export$2e2bcd8739ae039).warn("Layer has too many data objects. Picking might not be able to distinguish all objects.")();
            $d2bffe6b8ece4bb2$var$pickingColorCache = (0, $e0cd51e92519f55c$export$2e2bcd8739ae039).allocate($d2bffe6b8ece4bb2$var$pickingColorCache, numInstances, {
                size: 3,
                copy: true,
                maxCount: Math.max(numInstances, $d2bffe6b8ece4bb2$var$MAX_PICKING_COLOR_CACHE_SIZE)
            });
            const newCacheSize = Math.floor($d2bffe6b8ece4bb2$var$pickingColorCache.length / 3);
            const pickingColor = [];
            for(let i = cacheSize; i < newCacheSize; i++){
                this.encodePickingColor(i, pickingColor);
                $d2bffe6b8ece4bb2$var$pickingColorCache[i * 3 + 0] = pickingColor[0];
                $d2bffe6b8ece4bb2$var$pickingColorCache[i * 3 + 1] = pickingColor[1];
                $d2bffe6b8ece4bb2$var$pickingColorCache[i * 3 + 2] = pickingColor[2];
            }
        }
        attribute.value = $d2bffe6b8ece4bb2$var$pickingColorCache.subarray(0, numInstances * 3);
    }
    _setModelAttributes(model, changedAttributes) {
        const attributeManager = this.getAttributeManager();
        const excludeAttributes = model.userData.excludeAttributes || {};
        const shaderAttributes = attributeManager.getShaderAttributes(changedAttributes, excludeAttributes);
        model.setAttributes(shaderAttributes);
    }
    disablePickingIndex(objectIndex) {
        this._disablePickingIndex(objectIndex);
    }
    _disablePickingIndex(objectIndex) {
        const { pickingColors: pickingColors , instancePickingColors: instancePickingColors  } = this.getAttributeManager().attributes;
        const colors = pickingColors || instancePickingColors;
        if (!colors) return;
        const start = colors.getVertexOffset(objectIndex);
        const end = colors.getVertexOffset(objectIndex + 1);
        colors.buffer.subData({
            data: new Uint8Array(end - start),
            offset: start
        });
    }
    restorePickingColors() {
        const { pickingColors: pickingColors , instancePickingColors: instancePickingColors  } = this.getAttributeManager().attributes;
        const colors = pickingColors || instancePickingColors;
        if (!colors) return;
        if (this.internalState.usesPickingColorCache && colors.value.buffer !== $d2bffe6b8ece4bb2$var$pickingColorCache.buffer) colors.value = $d2bffe6b8ece4bb2$var$pickingColorCache.subarray(0, colors.value.length);
        colors.updateSubBuffer({
            startOffset: 0
        });
    }
    _initialize() {
        (0, $828c58095cddb61a$export$2e2bcd8739ae039)(!this.internalState);
        (0, $828c58095cddb61a$export$2e2bcd8739ae039)(Number.isFinite(this.props.coordinateSystem));
        (0, $e34c41f170d77ab6$export$2e2bcd8739ae039)($d2bffe6b8ece4bb2$var$TRACE_INITIALIZE, this);
        const attributeManager = this._getAttributeManager();
        if (attributeManager) attributeManager.addInstanced({
            instancePickingColors: {
                type: 5121,
                size: 3,
                noAlloc: true,
                update: this.calculateInstancePickingColors
            }
        });
        this.internalState = new (0, $3a7d9a91af406387$export$2e2bcd8739ae039)({
            attributeManager: attributeManager,
            layer: this
        });
        this._clearChangeFlags();
        this.state = {};
        Object.defineProperty(this.state, "attributeManager", {
            get: ()=>{
                (0, $146cba582e8c799f$export$2e2bcd8739ae039).deprecated("layer.state.attributeManager", "layer.getAttributeManager()")();
                return attributeManager;
            }
        });
        this.internalState.layer = this;
        this.internalState.uniformTransitions = new (0, $bf7908ceda7e0357$export$2e2bcd8739ae039)(this.context.timeline);
        this.internalState.onAsyncPropUpdated = this._onAsyncPropUpdated.bind(this);
        this.internalState.setAsyncProps(this.props);
        this.initializeState(this.context);
        for (const extension of this.props.extensions)extension.initializeState.call(this, this.context, extension);
        this.setChangeFlags({
            dataChanged: "init",
            propsChanged: "init",
            viewportChanged: true,
            extensionsChanged: true
        });
        this._update();
    }
    _transferState(oldLayer) {
        (0, $e34c41f170d77ab6$export$2e2bcd8739ae039)($d2bffe6b8ece4bb2$var$TRACE_MATCHED, this, this === oldLayer);
        const { state: state , internalState: internalState  } = oldLayer;
        if (this === oldLayer) return;
        this.internalState = internalState;
        this.internalState.layer = this;
        this.state = state;
        this.internalState.setAsyncProps(this.props);
        this._diffProps(this.props, this.internalState.getOldProps());
    }
    _update() {
        const stateNeedsUpdate = this.needsUpdate();
        (0, $e34c41f170d77ab6$export$2e2bcd8739ae039)($d2bffe6b8ece4bb2$var$TRACE_UPDATE, this, stateNeedsUpdate);
        if (!stateNeedsUpdate) return;
        const currentProps = this.props;
        const context = this.context;
        const internalState = this.internalState;
        const currentViewport = context.viewport;
        const propsInTransition = this._updateUniformTransition();
        internalState.propsInTransition = propsInTransition;
        context.viewport = internalState.viewport || currentViewport;
        this.props = propsInTransition;
        try {
            const updateParams = this._getUpdateParams();
            const oldModels = this.getModels();
            if (context.gl) this.updateState(updateParams);
            else try {
                this.updateState(updateParams);
            } catch (error) {}
            for (const extension of this.props.extensions)extension.updateState.call(this, updateParams, extension);
            const modelChanged = this.getModels()[0] !== oldModels[0];
            this._postUpdate(updateParams, modelChanged);
        } finally{
            context.viewport = currentViewport;
            this.props = currentProps;
            this._clearChangeFlags();
            internalState.needsUpdate = false;
            internalState.resetOldProps();
        }
    }
    _finalize() {
        (0, $e34c41f170d77ab6$export$2e2bcd8739ae039)($d2bffe6b8ece4bb2$var$TRACE_FINALIZE, this);
        this.finalizeState(this.context);
        for (const extension of this.props.extensions)extension.finalizeState.call(this, extension);
    }
    _drawLayer({ moduleParameters: moduleParameters = null , uniforms: uniforms = {} , parameters: parameters = {}  }) {
        this._updateAttributeTransition();
        const currentProps = this.props;
        const context = this.context;
        this.props = this.internalState.propsInTransition || currentProps;
        const opacity = this.props.opacity;
        uniforms.opacity = Math.pow(opacity, 1 / 2.2);
        try {
            if (moduleParameters) this.setModuleParameters(moduleParameters);
            const { getPolygonOffset: getPolygonOffset  } = this.props;
            const offsets = getPolygonOffset && getPolygonOffset(uniforms) || [
                0,
                0
            ];
            (0, $54220aa8b6471f1a$export$60752c4a8a24d484)(context.gl, {
                polygonOffset: offsets
            });
            (0, $54220aa8b6471f1a$export$b1e7058a2936b651)(context.gl, parameters, ()=>{
                const opts = {
                    moduleParameters: moduleParameters,
                    uniforms: uniforms,
                    parameters: parameters,
                    context: context
                };
                for (const extension of this.props.extensions)extension.draw.call(this, opts, extension);
                this.draw(opts);
            });
        } finally{
            this.props = currentProps;
        }
    }
    getChangeFlags() {
        var _this$internalState2;
        return (_this$internalState2 = this.internalState) === null || _this$internalState2 === void 0 ? void 0 : _this$internalState2.changeFlags;
    }
    setChangeFlags(flags) {
        if (!this.internalState) return;
        const { changeFlags: changeFlags  } = this.internalState;
        for(const key in flags)if (flags[key]) {
            let flagChanged = false;
            switch(key){
                case "dataChanged":
                    const dataChangedReason = flags[key];
                    const prevDataChangedReason = changeFlags[key];
                    if (dataChangedReason && Array.isArray(prevDataChangedReason)) {
                        changeFlags.dataChanged = Array.isArray(dataChangedReason) ? prevDataChangedReason.concat(dataChangedReason) : dataChangedReason;
                        flagChanged = true;
                    }
                default:
                    if (!changeFlags[key]) {
                        changeFlags[key] = flags[key];
                        flagChanged = true;
                    }
            }
            if (flagChanged) (0, $e34c41f170d77ab6$export$2e2bcd8739ae039)($d2bffe6b8ece4bb2$var$TRACE_CHANGE_FLAG, this, key, flags);
        }
        const propsOrDataChanged = Boolean(changeFlags.dataChanged || changeFlags.updateTriggersChanged || changeFlags.propsChanged || changeFlags.extensionsChanged);
        changeFlags.propsOrDataChanged = propsOrDataChanged;
        changeFlags.somethingChanged = propsOrDataChanged || changeFlags.viewportChanged || changeFlags.stateChanged;
    }
    _clearChangeFlags() {
        this.internalState.changeFlags = {
            dataChanged: false,
            propsChanged: false,
            updateTriggersChanged: false,
            viewportChanged: false,
            stateChanged: false,
            extensionsChanged: false,
            propsOrDataChanged: false,
            somethingChanged: false
        };
    }
    _diffProps(newProps, oldProps) {
        const changeFlags = (0, $52d5f19794fbf789$export$8b12422c455acfb9)(newProps, oldProps);
        if (changeFlags.updateTriggersChanged) {
            for(const key in changeFlags.updateTriggersChanged)if (changeFlags.updateTriggersChanged[key]) this.invalidateAttribute(key);
        }
        if (changeFlags.transitionsChanged) for(const key in changeFlags.transitionsChanged){
            var _newProps$transitions;
            this.internalState.uniformTransitions.add(key, oldProps[key], newProps[key], (_newProps$transitions = newProps.transitions) === null || _newProps$transitions === void 0 ? void 0 : _newProps$transitions[key]);
        }
        return this.setChangeFlags(changeFlags);
    }
    validateProps() {
        (0, $52d5f19794fbf789$export$45855e0dd982478b)(this.props);
    }
    updateAutoHighlight(info) {
        if (this.props.autoHighlight && !Number.isInteger(this.props.highlightedObjectIndex)) this._updateAutoHighlight(info);
    }
    _updateAutoHighlight(info) {
        const pickingModuleParameters = {
            pickingSelectedColor: info.picked ? info.color : null
        };
        const { highlightColor: highlightColor  } = this.props;
        if (info.picked && typeof highlightColor === "function") pickingModuleParameters.pickingHighlightColor = highlightColor(info);
        this.setModuleParameters(pickingModuleParameters);
        this.setNeedsRedraw();
    }
    _getAttributeManager() {
        const context = this.context;
        return new (0, $1bed349e8c64a1f7$export$2e2bcd8739ae039)(context.gl, {
            id: this.props.id,
            stats: context.stats,
            timeline: context.timeline
        });
    }
    _postUpdate(updateParams, forceUpdate) {
        const { props: props , oldProps: oldProps  } = updateParams;
        this.setNeedsRedraw();
        this._updateAttributes();
        const { model: model  } = this.state;
        model === null || model === void 0 || model.setInstanceCount(this.getNumInstances());
        const { autoHighlight: autoHighlight , highlightedObjectIndex: highlightedObjectIndex , highlightColor: highlightColor  } = props;
        if (forceUpdate || oldProps.autoHighlight !== autoHighlight || oldProps.highlightedObjectIndex !== highlightedObjectIndex || oldProps.highlightColor !== highlightColor) {
            const parameters = {};
            if (!autoHighlight) parameters.pickingSelectedColor = null;
            if (Array.isArray(highlightColor)) parameters.pickingHighlightColor = highlightColor;
            if (Number.isInteger(highlightedObjectIndex)) parameters.pickingSelectedColor = Number.isFinite(highlightedObjectIndex) && highlightedObjectIndex >= 0 ? this.encodePickingColor(highlightedObjectIndex) : null;
            this.setModuleParameters(parameters);
        }
    }
    _getUpdateParams() {
        return {
            props: this.props,
            oldProps: this.internalState.getOldProps(),
            context: this.context,
            changeFlags: this.internalState.changeFlags
        };
    }
    _getNeedsRedraw(opts) {
        if (!this.internalState) return false;
        let redraw = false;
        redraw = redraw || this.internalState.needsRedraw && this.id;
        this.internalState.needsRedraw = this.internalState.needsRedraw && !opts.clearRedrawFlags;
        const attributeManager = this.getAttributeManager();
        const attributeManagerNeedsRedraw = attributeManager ? attributeManager.getNeedsRedraw(opts) : false;
        redraw = redraw || attributeManagerNeedsRedraw;
        return redraw;
    }
    _onAsyncPropUpdated() {
        this._diffProps(this.props, this.internalState.getOldProps());
        this.setNeedsUpdate();
    }
}
(0, $037483d1fb5deac8$export$2e2bcd8739ae039)($d2bffe6b8ece4bb2$export$2e2bcd8739ae039, "defaultProps", $d2bffe6b8ece4bb2$var$defaultProps);
(0, $037483d1fb5deac8$export$2e2bcd8739ae039)($d2bffe6b8ece4bb2$export$2e2bcd8739ae039, "layerName", "Layer");






var $c55ed784d5da8e09$export$2e2bcd8739ae039 = "#define SHADER_NAME scatterplot-layer-vertex-shader\n\nattribute vec3 positions;\n\nattribute vec3 instancePositions;\nattribute vec3 instancePositions64Low;\nattribute float instanceRadius;\nattribute float instanceLineWidths;\nattribute vec4 instanceFillColors;\nattribute vec4 instanceLineColors;\nattribute vec3 instancePickingColors;\n\nuniform float opacity;\nuniform float radiusScale;\nuniform float radiusMinPixels;\nuniform float radiusMaxPixels;\nuniform float lineWidthScale;\nuniform float lineWidthMinPixels;\nuniform float lineWidthMaxPixels;\nuniform float stroked;\nuniform bool filled;\nuniform bool antialiasing;\nuniform bool billboard;\nuniform int radiusUnits;\nuniform int lineWidthUnits;\n\nvarying vec4 vFillColor;\nvarying vec4 vLineColor;\nvarying vec2 unitPosition;\nvarying float innerUnitRadius;\nvarying float outerRadiusPixels;\n\n\nvoid main(void) {\n  geometry.worldPosition = instancePositions;\n\n  // Multiply out radius and clamp to limits\n  outerRadiusPixels = clamp(\n    project_size_to_pixel(radiusScale * instanceRadius, radiusUnits),\n    radiusMinPixels, radiusMaxPixels\n  );\n  \n  // Multiply out line width and clamp to limits\n  float lineWidthPixels = clamp(\n    project_size_to_pixel(lineWidthScale * instanceLineWidths, lineWidthUnits),\n    lineWidthMinPixels, lineWidthMaxPixels\n  );\n\n  // outer radius needs to offset by half stroke width\n  outerRadiusPixels += stroked * lineWidthPixels / 2.0;\n\n  // Expand geometry to accomodate edge smoothing\n  float edgePadding = antialiasing ? (outerRadiusPixels + SMOOTH_EDGE_RADIUS) / outerRadiusPixels : 1.0;\n\n  // position on the containing square in [-1, 1] space\n  unitPosition = edgePadding * positions.xy;\n  geometry.uv = unitPosition;\n  geometry.pickingColor = instancePickingColors;\n\n  innerUnitRadius = 1.0 - stroked * lineWidthPixels / outerRadiusPixels;\n  \n  if (billboard) {\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);\n    vec3 offset = edgePadding * positions * outerRadiusPixels;\n    DECKGL_FILTER_SIZE(offset, geometry);\n    gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);\n  } else {\n    vec3 offset = edgePadding * positions * project_pixel_size(outerRadiusPixels);\n    DECKGL_FILTER_SIZE(offset, geometry);\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset, geometry.position);\n  }\n\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n\n  // Apply opacity to instance color, or return instance picking color\n  vFillColor = vec4(instanceFillColors.rgb, instanceFillColors.a * opacity);\n  DECKGL_FILTER_COLOR(vFillColor, geometry);\n  vLineColor = vec4(instanceLineColors.rgb, instanceLineColors.a * opacity);\n  DECKGL_FILTER_COLOR(vLineColor, geometry);\n}\n";


var $3a29ace6ffd96684$export$2e2bcd8739ae039 = "#define SHADER_NAME scatterplot-layer-fragment-shader\n\nprecision highp float;\n\nuniform bool filled;\nuniform float stroked;\nuniform bool antialiasing;\n\nvarying vec4 vFillColor;\nvarying vec4 vLineColor;\nvarying vec2 unitPosition;\nvarying float innerUnitRadius;\nvarying float outerRadiusPixels;\n\nvoid main(void) {\n  geometry.uv = unitPosition;\n\n  float distToCenter = length(unitPosition) * outerRadiusPixels;\n  float inCircle = antialiasing ? \n    smoothedge(distToCenter, outerRadiusPixels) : \n    step(distToCenter, outerRadiusPixels);\n\n  if (inCircle == 0.0) {\n    discard;\n  }\n\n  if (stroked > 0.5) {\n    float isLine = antialiasing ? \n      smoothedge(innerUnitRadius * outerRadiusPixels, distToCenter) :\n      step(innerUnitRadius * outerRadiusPixels, distToCenter);\n\n    if (filled) {\n      gl_FragColor = mix(vFillColor, vLineColor, isLine);\n    } else {\n      if (isLine == 0.0) {\n        discard;\n      }\n      gl_FragColor = vec4(vLineColor.rgb, vLineColor.a * isLine);\n    }\n  } else if (filled) {\n    gl_FragColor = vFillColor;\n  } else {\n    discard;\n  }\n\n  gl_FragColor.a *= inCircle;\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n";


const $1eba0b0ef795af2a$var$DEFAULT_COLOR = [
    0,
    0,
    0,
    255
];
const $1eba0b0ef795af2a$var$defaultProps = {
    radiusUnits: "meters",
    radiusScale: {
        type: "number",
        min: 0,
        value: 1
    },
    radiusMinPixels: {
        type: "number",
        min: 0,
        value: 0
    },
    radiusMaxPixels: {
        type: "number",
        min: 0,
        value: Number.MAX_SAFE_INTEGER
    },
    lineWidthUnits: "meters",
    lineWidthScale: {
        type: "number",
        min: 0,
        value: 1
    },
    lineWidthMinPixels: {
        type: "number",
        min: 0,
        value: 0
    },
    lineWidthMaxPixels: {
        type: "number",
        min: 0,
        value: Number.MAX_SAFE_INTEGER
    },
    stroked: false,
    filled: true,
    billboard: false,
    antialiasing: true,
    getPosition: {
        type: "accessor",
        value: (x)=>x.position
    },
    getRadius: {
        type: "accessor",
        value: 1
    },
    getFillColor: {
        type: "accessor",
        value: $1eba0b0ef795af2a$var$DEFAULT_COLOR
    },
    getLineColor: {
        type: "accessor",
        value: $1eba0b0ef795af2a$var$DEFAULT_COLOR
    },
    getLineWidth: {
        type: "accessor",
        value: 1
    },
    strokeWidth: {
        deprecatedFor: "getLineWidth"
    },
    outline: {
        deprecatedFor: "stroked"
    },
    getColor: {
        deprecatedFor: [
            "getFillColor",
            "getLineColor"
        ]
    }
};
class $1eba0b0ef795af2a$export$2e2bcd8739ae039 extends (0, $d2bffe6b8ece4bb2$export$2e2bcd8739ae039) {
    getShaders() {
        return super.getShaders({
            vs: $c55ed784d5da8e09$export$2e2bcd8739ae039,
            fs: $3a29ace6ffd96684$export$2e2bcd8739ae039,
            modules: [
                (0, $fbfc65ad8db06720$export$2e2bcd8739ae039),
                (0, $1c9ba1aa9caca970$export$2e2bcd8739ae039)
            ]
        });
    }
    initializeState() {
        this.getAttributeManager().addInstanced({
            instancePositions: {
                size: 3,
                type: 5130,
                fp64: this.use64bitPositions(),
                transition: true,
                accessor: "getPosition"
            },
            instanceRadius: {
                size: 1,
                transition: true,
                accessor: "getRadius",
                defaultValue: 1
            },
            instanceFillColors: {
                size: this.props.colorFormat.length,
                transition: true,
                normalized: true,
                type: 5121,
                accessor: "getFillColor",
                defaultValue: [
                    0,
                    0,
                    0,
                    255
                ]
            },
            instanceLineColors: {
                size: this.props.colorFormat.length,
                transition: true,
                normalized: true,
                type: 5121,
                accessor: "getLineColor",
                defaultValue: [
                    0,
                    0,
                    0,
                    255
                ]
            },
            instanceLineWidths: {
                size: 1,
                transition: true,
                accessor: "getLineWidth",
                defaultValue: 1
            }
        });
    }
    updateState(params) {
        super.updateState(params);
        if (params.changeFlags.extensionsChanged) {
            var _this$state$model;
            const { gl: gl  } = this.context;
            (_this$state$model = this.state.model) === null || _this$state$model === void 0 || _this$state$model.delete();
            this.state.model = this._getModel(gl);
            this.getAttributeManager().invalidateAll();
        }
    }
    draw({ uniforms: uniforms  }) {
        const { radiusUnits: radiusUnits , radiusScale: radiusScale , radiusMinPixels: radiusMinPixels , radiusMaxPixels: radiusMaxPixels , stroked: stroked , filled: filled , billboard: billboard , antialiasing: antialiasing , lineWidthUnits: lineWidthUnits , lineWidthScale: lineWidthScale , lineWidthMinPixels: lineWidthMinPixels , lineWidthMaxPixels: lineWidthMaxPixels  } = this.props;
        this.state.model.setUniforms(uniforms).setUniforms({
            stroked: stroked ? 1 : 0,
            filled: filled,
            billboard: billboard,
            antialiasing: antialiasing,
            radiusUnits: (0, $b42a5b9aa3b1a41f$export$97361b7a0c542045)[radiusUnits],
            radiusScale: radiusScale,
            radiusMinPixels: radiusMinPixels,
            radiusMaxPixels: radiusMaxPixels,
            lineWidthUnits: (0, $b42a5b9aa3b1a41f$export$97361b7a0c542045)[lineWidthUnits],
            lineWidthScale: lineWidthScale,
            lineWidthMinPixels: lineWidthMinPixels,
            lineWidthMaxPixels: lineWidthMaxPixels
        }).draw();
    }
    _getModel(gl) {
        const positions = [
            -1,
            -1,
            0,
            1,
            -1,
            0,
            1,
            1,
            0,
            -1,
            1,
            0
        ];
        return new (0, $d4b5fa431316d551$export$2e2bcd8739ae039)(gl, {
            ...this.getShaders(),
            id: this.props.id,
            geometry: new (0, $71650ad4c5341938$export$2e2bcd8739ae039)({
                drawMode: 6,
                vertexCount: 4,
                attributes: {
                    positions: {
                        size: 3,
                        value: new Float32Array(positions)
                    }
                }
            }),
            isInstanced: true
        });
    }
}
(0, $037483d1fb5deac8$export$2e2bcd8739ae039)($1eba0b0ef795af2a$export$2e2bcd8739ae039, "defaultProps", $1eba0b0ef795af2a$var$defaultProps);
(0, $037483d1fb5deac8$export$2e2bcd8739ae039)($1eba0b0ef795af2a$export$2e2bcd8739ae039, "layerName", "ScatterplotLayer");



class $179f1f86def1c801$export$1b8cf9af48396d5d {
    constructor(GraphDrawerOptions3d, graphs){
        this.canvas = GraphDrawerOptions3d.canvas;
        this.width = GraphDrawerOptions3d.width;
        this.height = GraphDrawerOptions3d.height;
        this.layerMap = new Map();
        this.deck;
        // bounds is a global parameter that we change (think about this as scale)
        this.bound = GraphDrawerOptions3d.bounds;
        // graph map is the hash map that holds all the
        // graphs that we are working with together
        this.graphs = new Map();
        // add the default graph to the graph map
        for(let i = 0; i < graphs.length; i++){
            const g = graphs[i];
            this.graphs.set(i, g);
        }
    }
    async init() {
        const INITIAL_VIEW_STATE = {
            latitude: 37.8,
            longitude: -122.45,
            zoom: 15
        };
        this.deck = new (0, $4afbf505f2c4bce1$export$2e2bcd8739ae039)({
            canvas: this.canvas,
            initialViewState: INITIAL_VIEW_STATE,
            controller: true,
            layers: [
                new (0, $1eba0b0ef795af2a$export$2e2bcd8739ae039)({
                    data: [
                        {
                            position: [
                                -122.45,
                                37.8
                            ],
                            color: [
                                255,
                                0,
                                0
                            ],
                            radius: 100
                        }, 
                    ],
                    getColor: (d)=>d.color,
                    getRadius: (d)=>d.radius
                }), 
            ]
        });
    }
}


var $c5c7cc0819666552$export$2e2bcd8739ae039 = {
    GraphDrawer3d: $1560099bec86dda1$export$4aefcc8a99cfbd66,
    GraphDrawerDeck: $179f1f86def1c801$export$1b8cf9af48396d5d
};


// make a simulation class object
// This class ideally does everything
// Which involves three primary things
// change colors and change
class $3e743087f60e0af6$export$156b30a852a4aab {
    constructor(Graph, deltaTick){
        this.Graph = Graph;
        this.deltaTick = deltaTick || 1;
        this.forces = new Map();
    }
    tick() {}
}




var $a10c6fe030ef2f2d$export$614db49f3febe941 = parcelRequire("dPfZ4").Graph;
var $00b8630467633a1d$export$2e2bcd8739ae039 = parcelRequire("03PHD").default;
var $b9f55733e92b0fab$export$2e2bcd8739ae039 = parcelRequire("fXQP4").default;
var $dff1f486beb1bf4c$export$2e2bcd8739ae039 = parcelRequire("je3oj").default;
var $2b9333ccd3e7770b$export$2e2bcd8739ae039 = parcelRequire("3JWOZ").default;
export {$a10c6fe030ef2f2d$export$614db49f3febe941 as Graph, $00b8630467633a1d$export$2e2bcd8739ae039 as GraphMethods, $1929603c63fa12f5$export$2e2bcd8739ae039 as SampleData, $2a82d025d9354169$export$2e2bcd8739ae039 as Constructors, $b9f55733e92b0fab$export$2e2bcd8739ae039 as Drawing, $dff1f486beb1bf4c$export$2e2bcd8739ae039 as Geometry, $2b9333ccd3e7770b$export$2e2bcd8739ae039 as Utilities, $2257d881a60ecbb5$export$2e2bcd8739ae039 as threeDWrapper, $c5c7cc0819666552$export$2e2bcd8739ae039 as GraphDrawer, $3e743087f60e0af6$export$156b30a852a4aab as Simulation};
//# sourceMappingURL=pgl_module.js.map
