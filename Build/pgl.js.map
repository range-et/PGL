{"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;A,I,Y,a,U,a,S,S,E,Y,E,G,E,W;I,S,Q,O;Q,O,mB,M,U,I,I,S,S;Y,U;Q;I;I,O,I,C,O,C,M,O,C,E,S,S,E,Q;Q,S,Y,O;Y,I;gB,O,Y,K;Y,E,O,K;gB,S;Y;Q;Q,S,W,O;Y,I;gB,O,W,C,Q,C;Y,E,O,K;gB,S;Y;Q;Q,S,O,Q;Y,S,O,U,S,S,Q,S,O,K,a;Q;Q,O,A,C,c,Y,M,W,gB,E,C,E;I;A;AASA;;;;;;;;;;CAUG,GACH,SAAe,oBACb,OAAY,EACZ,YAAkB,EAClB,oBAA0B,GAAG,EAC7B,kBAAwB,CAAC,EACzB,mBAAyB,CAAC;I,O,U,I,E,K,G,K,G;QAE1B,MAAM,YAAU,QAAM;QACtB,UAAU;QACV,MAAM,YAA+B,IAAI;QACzC,MAAM,YAA+B,IAAI;QACzC,IAAI,MAAI;QACR,KAAK,MAAM,UAAQ,UAAQ,OAAQ;YACjC,OAAK,KAAK,WAAW;YACrB,OAAK,KAAK,WAAW;YACrB,UAAQ,IAAI,QAAM;YAClB,UAAQ,IAAI,QAAM;QACnB;QACD,mBAAmB;QACnB,IAAK,IAAI,MAAI,GAAG,MAAI,cAAY,MAAK;YACnC,iCAAiC;YACjC,qDAAqD;YACrD,6CAA6C;YAC7C,IAAI;YACJ,IAAI;YACJ,yCAAyC;YACzC,IAAI;YACJ,IAAI;YACJ,+CAA+C;YAC/C,IAAI;YACJ,IAAI;YACJ,2DAA2D;YAC3D,IAAI;YACJ,IAAI;YACJ,IAAI;YACJ,IAAI;YACJ,IAAI;YACJ,IAAI;YACJ,IAAI;YACJ,IAAI;YAEJ,KAAK,MAAM,UAAQ,UAAQ,OAAQ;gBACjC,yCAAyC;gBACzC,mBAAmB;gBACnB,MAAM,eAAa,UAAQ,IAAI;gBAC/B,6CAA6C;gBAC7C,UAAQ,UAAQ,IAAI;gBACpB,UAAQ,UAAQ,IAAI;gBACpB,qBAAqB;gBACrB,QAAM,EAAE;gBACR,qBAAqB;gBACrB,QAAM,EAAE;gBACR,8CAA8C;gBAC9C,aAAW,QAAQ,CAAC;oBAClB,MAAM,YAAU,UAAQ,IAAI;oBAC5B,MAAM,YAAU,UAAQ,IAAI;oBAC5B,MAAI,KAAK;oBACT,MAAI,KAAK;gBACX;gBACA,6BAA6B;gBAC7B,eAAa,CAAA,GAAA,cAAA,EAAU,iBAAiB;gBACxC,eAAa,CAAA,GAAA,cAAA,EAAU,iBAAiB;gBAExC,wCAAwC;gBACxC,QAAM,EAAE;gBACR,QAAM,EAAE;gBACR,IAAI;gBACJ,IAAI;gBACJ,IAAI;gBACJ,IAAI;gBAEJ,wBAAwB;gBACxB,KAAK,MAAM,eAAa,QAAM,MAAM,OAClC,0CAA0C;gBAC1C,IAAI,eAAa,QAAM;oBACrB,6BAA6B;oBAC7B,eAAa,UAAQ,IAAI;oBACzB,eAAa,UAAQ,IAAI;oBACzB,UAAQ,eAAa;oBACrB,UAAQ,eAAa;oBACrB,+BAA+B;oBAC/B,6BAA6B;oBAC7B,MAAI,KAAK;oBACT,MAAI,KAAK;gBACV;gBAEH,8BAA8B;gBAC9B,gBACE,AAAC,mBAAiB,IACjB,CAAA,CAAA,GAAA,cAAA,EAAU,iBAAiB,SAAO,CAAA,GAAA,cAAA,EAAU,iBAAiB,MAAG;gBACnE,gBACE,AAAC,mBAAiB,IACjB,CAAA,CAAA,GAAA,cAAA,EAAU,iBAAiB,SAAO,CAAA,GAAA,cAAA,EAAU,iBAAiB,MAAG;gBAEnE,8CAA8C;gBAC9C,6BAA6B;gBAC7B,2BAAyB,kBAAiB,CAAA,eAAa,OAAA;gBACvD,2BAAyB,kBAAiB,CAAA,eAAa,OAAA;gBAEvD,2DAA2D;gBAC3D,wCAAwC;gBACxC,4BAA0B,kBAAiB,CAAA,IAAI,OAAA;gBAC/C,4BAA0B,kBAAiB,CAAA,IAAI,OAAA;gBAE/C,qDAAqD;gBACrD,MAAM,aACJ,gBAAc,4BAA0B,2BAAyB;gBACnE,MAAM,aACJ,gBAAc,4BAA0B,2BAAyB;gBAEnE,0BAA0B;gBAC1B,UAAQ,IAAI,QAAM;gBAClB,UAAQ,IAAI,QAAM;YACnB;QACF;QACD,sBAAsB;QACtB,uDAAuD;QACvD,+EAA+E;QAC/E,IAAI,WAA6B,IAAI;QACrC,KAAK,MAAM,OAAK,UAAQ,OACtB,SAAO,IAAI,KAAG,IAAI,CAAA,GAAA,cAAA,EAAM,UAAQ,IAAI,MAAK,GAAG,UAAQ,IAAI;QAE1D,sBAAsB;QACtB,kBAAkB;QAClB,oEAAoE;QACpE,sBAAsB;QACtB,MAAM,UAAQ,EAAE;QAChB,MAAM,UAAQ,EAAE;QAChB,MAAM,UAAQ,EAAE;QAChB,IAAI;QACJ,KAAK,MAAM,OAAK,SAAO,OAAQ;YAC7B,iBAAe,SAAO,IAAI;YAC1B,QAAM,KAAK,eAAa;YACxB,QAAM,KAAK,eAAa;YACxB,QAAM,KAAK,eAAa;QACzB;QAED,MAAM,mBAAiB,CAAA,GAAA,cAAA,EAAU,iBAAiB;QAClD,MAAM,mBAAiB,CAAA,GAAA,cAAA,EAAU,iBAAiB;QAClD,MAAM,mBAAiB,CAAA,GAAA,cAAA,EAAU,iBAAiB;QAClD,MAAM,sBAAoB,IAAI,CAAA,GAAA,cAAA,EAC5B,CAAC,kBACD,CAAC,kBACD,CAAC;QAGH,WAAS,SAAS,UAAQ;QAC1B,OAAO;IACT;AAAC;AAED;;;;;;;;CAQG,GACH,SAAS,2BAA2B,OAAY;IAC9C,MAAM,YAAU,QAAM;IACtB,MAAM,YAA+B,IAAI;IACzC,MAAM,YAA+B,IAAI;IACzC,KAAK,MAAM,UAAQ,UAAQ,OAAQ;QACjC,UAAQ,IAAI,QAAM,KAAK,WAAW;QAClC,UAAQ,IAAI,QAAM,KAAK,WAAW;IACnC;IACD,MAAM,WAA6B,IAAI;IACvC,KAAK,MAAM,OAAK,UAAQ,OACtB,SAAO,IAAI,KAAG,IAAI,CAAA,GAAA,cAAA,EAAM,UAAQ,IAAI,MAAK,GAAG,UAAQ,IAAI;IAE1D,OAAO;AACT;AAEA;;;;;;;;;;CAUG,GACH,SAAS,cAAc,OAAY,EAAE,aAAmB;IACtD,yBAAyB;IACzB,MAAM,YAA6B,IAAI;IACvC,IAAI;IACJ,IAAI;IACJ,IAAI;IACJ,KAAK,MAAM,SAAO,QAAM,MAAM,OAAQ;QACpC,SAAO,QAAM,MAAM,IAAI;QACvB,oBAAoB;QACpB,UAAQ,QAAM,MAAM,IAAI,OAAK,OAAQ,KAAK;QAC1C,QAAM,QAAM,MAAM,IAAI,OAAK,KAAM,KAAK;QACtC,MAAM,SAAO,CAAA,GAAA,cAAA,EAAgB,6BAC3B,SACA,OACA;QAEF,UAAQ,IAAI,OAAK;IAClB;IACD,OAAO;AACT;AAEA;;;;;;;;;CASG,GACH,SAAS,uBAAuB,OAAY,EAAE,cAAoB;IAChE,yBAAyB;IACzB,MAAM,YAA6B,IAAI;IACvC,IAAI;IACJ,IAAI;IACJ,IAAI;IACJ,KAAK,MAAM,SAAO,QAAM,MAAM,OAAQ;QACpC,SAAO,QAAM,MAAM,IAAI;QACvB,oBAAoB;QACpB,UAAQ,QAAM,MAAM,IAAI,OAAK,OAAQ,KAAK;QAC1C,QAAM,QAAM,MAAM,IAAI,OAAK,KAAM,KAAK;QACtC,MAAM,SAAO,CAAA,GAAA,cAAA,EAAgB,8BAC3B,SACA,OACA;QAEF,UAAQ,IAAI,OAAK;IAClB;IACD,OAAO;AACT;AAEA;;;;;;;;;CASG,GACH,SAAe,iBACb,SAA0B,EAC1B,YAAkB,EAClB,UAAgB;I,O,U,I,E,K,G,K,G;QAEhB,sCAAsC;QACtC,MAAM,gBAAc,IAAI;QACxB,KAAK,IAAI,SAAO,UAAQ,OACtB,cAAY,IAAI,OAAK,gBAAgB,UAAQ,IAAI;QAEnD,oCAAoC;QACpC,IAAI;QACJ,IAAI;QACJ,IAAI;QACJ,IAAI;QACJ,IAAI;QACJ,IAAI;QACJ,IAAI;QACJ,IAAI;QACJ,IAAI;QACJ,IAAI;QACJ,IAAI;QACJ,IAAI;QACJ,IAAI;QACJ,IAAI;QACJ,2CAA2C;QAC3C,IAAK,IAAI,MAAI,GAAG,MAAI,cAAY,MAC9B,kCAAkC;QAClC,KAAK,IAAI,SAAO,cAAY,OAAQ;YAClC,6CAA6C;YAC7C,SAAO,cAAY,IAAI;YACvB,gFAAgF;YAChF,IAAK,IAAI,OAAK,GAAG,OAAK,OAAK,OAAO,SAAS,GAAG,OAAM;gBAClD,+CAA+C;gBAC/C,QAAM,EAAE;gBACR,QAAM,EAAE;gBACR,QAAM,EAAE;gBACR,QAAM,OAAK,MAAM,CAAC,KAAG;gBACrB,2CAA2C;gBAC3C,KAAK,IAAI,cAAY,cAAY,OAC/B,IAAI,cAAY,OAAK;oBACnB,0BAA0B;oBAC1B,cAAY,cAAY,IAAI;oBAC5B,IAAK,IAAI,QAAM,GAAG,QAAM,YAAU,OAAO,SAAS,GAAG,QAAO;wBAC1D,eAAa,YAAU,MAAM,CAAC,MAAI;wBAClC,MAAI,CAAA,GAAA,cAAA,EAAU,yBAAyB,OAAK;wBAC5C,IAAI,OAAK,KAAK,IAAI,YAAU,IAAI;4BAC9B,QAAM,aAAW,IAAI,MAAI;4BACzB,QAAM,aAAW,IAAI,MAAI;4BACzB,QAAM,aAAW,IAAI,MAAI;4BACzB,MAAI,KAAK;4BACT,MAAI,KAAK;4BACT,MAAI,KAAK;wBACV;oBACF;gBACF;gBAEH,uCAAuC;gBACvC,SAAO,MAAI,IAAI,MAAO,CAAA,CAAA,GAAA,cAAA,EAAU,iBAAiB,UAAQ,CAAA;gBACzD,SAAO,MAAI,IAAI,MAAO,CAAA,CAAA,GAAA,cAAA,EAAU,iBAAiB,UAAQ,CAAA;gBACzD,SAAO,MAAI,IAAI,MAAO,CAAA,CAAA,GAAA,cAAA,EAAU,iBAAiB,UAAQ,CAAA;gBACzD,MAAM,aAAW,IAAI,CAAA,GAAA,cAAA,EAAM,QAAM,QAAM;gBACvC,OAAK,MAAM,CAAC,KAAG,GAAG;YACnB;QACF;QAEH,0BAA0B;QAC1B,OAAO;IACT;AAAC;AAED;;;;;;;;CAQG,GACH,SAAS,gBAAgB,SAA0B,EAAE,cAAoB;IACvE,MAAM,gBAAc,IAAI;IACxB,KAAK,IAAI,SAAO,UAAQ,OACtB,cAAY,IAAI,OAAK,gBAAgB,UAAQ,IAAI;IAEnD,KAAK,MAAM,SAAO,cAAY,OAAQ;QACpC,MAAM,SAAO,cAAY,IAAI;QAC7B,iCAAiC;QACjC,IAAI,OAAK;QACT,IAAK,IAAI,MAAI,GAAG,MAAI,OAAK,OAAO,QAAQ,MAAK;YAC3C,QAAM,OAAK,MAAM,CAAC,IAAE;YACpB,YACE,iBAAe,KAAK,IAAI,AAAC,KAAK,KAAK,MAAM,CAAA,OAAK,OAAO,SAAS,CAAA;YAChE,MAAI,IAAI,MAAI,IAAI;QACjB;IACF;IACD,OAAO;AACT;AAEA;;;;;;;CAOG,GACH,SAAS,iBACP,KAAY,EACZ,SAAiB,EACjB,YAAoB;IAEpB,IAAI,MAAc;IAClB,IAAI,OAAe;IACnB,kDAAkD;IAClD,KAAK,IAAI,QAAQ,MAAM,MAAM,SAAU;QACrC,QAAQ,KAAK,eAAe;QAC5B,IAAI,SAAS,KACX,MAAM;IAET;IACD,gDAAgD;IAChD,KAAK,MAAM,QAAQ,MAAM,MAAM,SAAU;QACvC,QAAQ,KAAK,eAAe;QAC5B,gBAAgB,AAAC,QAAQ,MAAO;QAChC,oFAAoF;QACpF,gBAAgB,KAAK,IAAI,GAAG,gBAAgB,4CAA4C;QACxF,gBAAgB,KAAK,IAAI,cAAc,gBAAgB,yCAAyC;QAChG,KAAK,KAAK,IAAI,IAAI;IACnB;AACH;AAEA;;;;;;;;;CASG,GACH,SAAe,SACb,OAAY,EACZ,cAAoB,EACpB,MAAY,EACZ,eAAoB;I,O,U,I,E,K,G,K,G;QAEpB,MAAM,QAAM,QAAM;QAClB,MAAM,kBAAgB,MAAM,CAAA,GAAA,cAAA,EAAa,SAAS,SAAO;QACzD,4DAA4D;QAC5D,MAAM,UAAQ,KAAK,OAAO;eAAI,gBAAc;SAAS;QACrD,WAAW;QACX,MAAM,YAAU,IAAI;QACpB,qCAAqC;QACrC,IAAK,IAAI,MAAI,GAAG,OAAK,SAAO,MAAK;YAC/B,MAAM,UAAQ,EAAE;YAChB,KAAK,MAAM,UAAQ,gBAAc,OAC/B,IAAI,OAAK,gBAAc,IAAI,SACzB,QAAM,KAAK;YAGf,UAAQ,IAAI,KAAG;QAChB;QACD,wBAAwB;QACxB,MAAM,SAAO,IAAI;QACjB,uCAAuC;QACvC,0BAA0B;QAC1B,MAAM,SAAO,gBAAc,KAAK;QAChC,MAAM,SAAO,gBAAc,KAAK;QAChC,MAAM,SAAO,gBAAc,KAAK;QAChC,oBAAoB;QACpB,KAAK,MAAM,UAAQ,MAAI,OAAQ;YAC7B,MAAM,SAAO,gBAAc,IAAI,UAAS;YACxC,MAAM,aAAW,UAAQ,IAAI,gBAAc,IAAI;YAC/C,MAAM,UAAQ,IAAI,KAAK,KAAM,CAAA,WAAS,QAAQ,UAAQ,WAAS,MAAA;YAC/D,MAAM,SAAO,KAAK,IAAI,WAAS;YAC/B,MAAM,SAAO,KAAK,IAAI,WAAS;YAC/B,wBAAwB;YACxB,MAAM,QAAM,IAAI,CAAA,GAAA,cAAA,EAAM,SAAO,QAAM,CAAC,SAAO,QAAM,SAAO;YACxD,OAAK,IAAI,QAAM;QAChB;QACD,qBAAqB;QACrB,QAAM,mBAAmB;QACzB,MAAM,SAAO,cAAc,SAAO;QAClC,MAAM,YAAU,MAAM,iBAAiB,QAAM,IAAI;QACjD,OAAO;YAAE,MAAM;YAAM,MAAM;QAAO;IACpC;AAAC;AAED;;;;;CAKG,GACH,SAAS,UAAU,OAAY,EAAE,aAAkB;IACjD,MAAM,SAAO,QAAM;IACnB,MAAM,YAAU,SAAS,OAAK,MAAM;IACpC,MAAM,YAAU,SAAS,OAAK,MAAM;IACpC,QAAM,mBAAmB;QAAE,MAAM;QAAS,MAAM;IAAO;AACzD;AAEA;;;;;;;;CAQG,GACH,SAAS,SAAS,SAA2B,EAAE,cAAmB;IAChE,MAAM,YAA8B,IAAI;IACxC,KAAK,IAAI,UAAQ,UAAQ,OAAQ;QAC/B,MAAM,MAAI,UAAQ,IAAI;QACtB,IAAE,UAAU;QACZ,UAAQ,IAAI,QAAM;IACnB;IACD,OAAO;AACT;AAEA;;;;;;;CAOG,GACH,SAAS,SAAS,SAA0B,EAAE,aAAkB;IAC9D,MAAM,YAA6B,IAAI;IACvC,qCAAqC;IACrC,IAAI;IACJ,IAAI;IACJ,IAAI;IACJ,KAAK,IAAI,gBAAc,UAAQ,OAAQ;QACrC,2BAA2B;QAC3B,kBAAgB,EAAE;QAClB,eAAe;QACf,gBAAc,UAAQ,IAAI;QAC1B,sBAAsB;QACtB,KAAK,IAAI,SAAO,cAAY,OAAQ;YAClC,MAAI,UAAU;YACd,qCAAqC;YACrC,gBAAc,KAAK;QACpB;QACD,oBAAoB;QACpB,YAAU,IAAI,CAAA,GAAA,cAAA,EAAK;QACnB,0BAA0B;QAC1B,UAAQ,IAAI,cAAY;IACzB;IACD,OAAO;AACT;AAEA,wCAAwC;AACxC;;;;AAIE,GACF,iDAAiD;AACjD,qDAAqD;AACrD,2CAA2C;AAC3C;;;;;;CAMG,GACH,SAAS,oBAAoB,OAAY,EAAE,aAAmB;IAC5D,IAAI;IACJ,IAAI;IACJ,IAAI;IACJ,IAAI;IACJ,KAAK,MAAM,SAAO,QAAM,MAAM,OAAQ;QACpC,SAAO,QAAM,MAAM,IAAI;QACvB,oBAAoB;QACpB,UAAQ,QAAM,MAAM,IAAI,OAAK,OAAQ,KAAK;QAC1C,QAAM,QAAM,MAAM,IAAI,OAAK,KAAM,KAAK;QACtC,SAAO,CAAA,GAAA,cAAA,EAAgB,6BACrB,SACA,OACA;QAEF,OAAK,KAAK,QAAQ;IACnB;AACH;AAEA;;;;;;CAMG,GACH,SAAS,oBAAoB,OAAY,EAAE,MAAY;IACrD,IAAI;IACJ,IAAI;IACJ,IAAI;IACJ,IAAI;IACJ,KAAK,MAAM,SAAO,QAAM,MAAM,OAAQ;QACpC,SAAO,QAAM,MAAM,IAAI;QACvB,oBAAoB;QACpB,UAAQ,QAAM,MAAM,IAAI,OAAK,OAAQ,KAAK;QAC1C,QAAM,QAAM,MAAM,IAAI,OAAK,KAAM,KAAK;QACtC,SAAO,CAAA,GAAA,cAAA,EAAgB,8BAA8B,SAAO,OAAK;QACjE,OAAK,KAAK,QAAQ;IACnB;AACH;IAEA,2CAAe;yBACb;mBACA;4BACA;sBACA;cACA;qBACA;eACA;gCACA;sBACA;yBAEA,AADA,kCAAkC;IAClC;yBACA;AACD;;;;;;AC5kBD,oBAAoB;AACpB;;;;CAIG,GACH,SAAS,uCAAiB,GAAa;IACrC,IAAI,aAAa;IACjB,IAAK,IAAI,IAAI,GAAG,IAAI,IAAI,QAAQ,IAC9B,aAAa,aAAa,GAAG,CAAC,EAAE;IAElC,MAAM,MAAM,aAAa,IAAI;IAC7B,IAAI,OAAO,MAAM,MACf,OAAO;IAET,OAAO;AACT;AAEA,wCAAwC;AACxC;;;;;CAKG,GACH,SAAS,wCAAkB,EAAS,EAAE,EAAS;IAC7C,MAAM,IAAI,KAAK,IACb,KAAK,IAAI,GAAG,IAAI,GAAG,GAAG,KACpB,KAAK,IAAI,GAAG,IAAI,GAAG,GAAG,KACtB,KAAK,IAAI,GAAG,IAAI,GAAG,GAAG,IACxB;IAEF,OAAO;AACT;AAEA,2DAA2D;AAC3D,wCAAwC;AACxC;;;;;CAKG,GACH,SAAS,+CAAyB,EAAS,EAAE,EAAS;IACpD,MAAM,IACJ,KAAK,IAAI,GAAG,IAAI,GAAG,GAAG,KACtB,KAAK,IAAI,GAAG,IAAI,GAAG,GAAG,KACtB,KAAK,IAAI,GAAG,IAAI,GAAG,GAAG;IACxB,OAAO;AACT;AAEA,0DAA0D;AAC1D,4DAA4D;AAC5D;;;;;CAKG,GACH,SAAS,sCAAgB,GAAU,EAAE,CAAS;IAC5C,IAAI,SAAS,IAAI,MAAM,IACrB,MAAM,IAAI,QACV,QAAQ,IAAI,MAAM;IACpB,IAAI,IAAI,KACN,MAAM,IAAI,WAAW;IACvB,MAAO,IAAK;QACV,IAAI,IAAI,KAAK,MAAM,KAAK,WAAW;QACnC,MAAM,CAAC,EAAE,GAAG,GAAG,CAAC,KAAK,QAAQ,KAAK,CAAC,EAAE,GAAG,EAAE;QAC1C,KAAK,CAAC,EAAE,GAAG,EAAE,OAAO,QAAQ,KAAK,CAAC,IAAI,GAAG;IAC1C;IACD,OAAO;AACT;AAEA;;;;;;;CAOG,GACH,SAAS,0CAAoB,GAAqB,EAAE,CAAS;IAC3D,MAAM,SAAS,IAAI;IACnB,IAAI;IACJ,KAAK,MAAM,QAAQ,IAAI,OAAQ;QAC7B,OAAO,KAAK;QACZ,IAAI,OAAO,GACT,OAAO,IAAI,MAAM,IAAI,IAAI;IAE5B;IACD,OAAO;AACT;IAEA,2CAAe;sBACb;uBACA;8BACA;qBACA;yBACA;AACD;;;;;;;;;;;;;ACjGD;;;;;;;CAOG,GACH,SAAS,oDACP,KAAY,EACZ,GAAU,EACV,SAAiB;IAEjB,8BAA8B;IAC9B,MAAM,QAAQ,IAAI,CAAA,GAAA,cAAA,EAAM,MAAM,GAAG,MAAM,GAAG,MAAM;IAChD,MAAM,MAAM,IAAI,CAAA,GAAA,cAAA,EAAM,IAAI,GAAG,IAAI,GAAG,IAAI;IACxC,sBAAsB;IACtB,MAAM,SAAkB,EAAE;IAC1B,YAAY;IACZ,IAAK,IAAI,IAAI,GAAG,KAAK,WAAW,IAAK;QACnC,MAAM,WAAW,IAAI;QACrB,MAAM,OAAO,WAAW,MAAM,IAAI,AAAC,CAAA,IAAI,QAAA,IAAY,IAAI;QACvD,MAAM,OAAO,WAAW,MAAM,IAAI,AAAC,CAAA,IAAI,QAAA,IAAY,IAAI;QACvD,MAAM,OAAO,WAAW,MAAM,IAAI,AAAC,CAAA,IAAI,QAAA,IAAY,IAAI;QACvD,MAAM,WAAW,IAAI,CAAA,GAAA,cAAA,EAAM,MAAM,MAAM;QACvC,OAAO,KAAK;IACb;IACD,oBAAoB;IACpB,MAAM,iBAAiB,IAAI,CAAA,GAAA,cAAA,EAAK;IAChC,OAAO;AACT;AAEA;;;;;;CAMG,GACH,SAAS,mDACP,KAAY,EACZ,GAAU,EACV,QAAgB;IAEhB,MAAM,OAAO,CAAA,GAAA,cAAA,EAAU,kBAAkB,OAAO;IAChD,MAAM,OAAO,KAAK,MAAM,OAAO,YAAY;IAC3C,MAAM,aAAa,oDAA8B,OAAO,KAAK;IAC7D,OAAO;AACT;AAEA;;;;CAIG,GACH,SAAS,+BAAS,MAAe;IAC/B,IAAI,KAAK;IACT,IAAI,KAAK;IACT,IAAI,KAAK;IACT,OAAO,QAAQ,CAAC;QACd,MAAM,QAAQ;QACd,MAAM,QAAQ;QACd,MAAM,QAAQ;IAChB;IACA,KAAK,KAAK,OAAO;IACjB,KAAK,KAAK,OAAO;IACjB,KAAK,KAAK,OAAO;IACjB,MAAM,WAAW,IAAI,CAAA,GAAA,cAAA,EAAM,IAAI,IAAI;IACnC,OAAO;AACT;IAEA,2CAAe;mCACb;kCACA;cACA;AACD;;;;;;ACzED,MAAM;IACJ;;;;;KAKG,GACH,YAAY,CAAQ,EAAE,CAAQ,EAAE,CAAQ,CAAxC;QACE,IAAI,CAAC,IAAI;QACT,IAAI,CAAC,IAAI;QACT,IAAI,CAAC,IAAI;IACX;IAEA,kDAAkD;IAClD,wDAAwD;IACxD,OAAO;IACP;;;KAGG,GACH,UAAU,KAAW,EAArB;QACE,IAAI,CAAC,IAAI,IAAI,CAAC,IAAI,MAAM;QACxB,IAAI,CAAC,IAAI,IAAI,CAAC,IAAI,MAAM;QACxB,IAAI,CAAC,IAAI,IAAI,CAAC,IAAI,MAAM;IAC1B;AACD;IAED,2CAAe;;;;;;;;;AC3Bf,MAAM;IACJ;;;KAGG,GACH,YAAY,MAAe,CAA3B;QACE,IAAI,CAAC,SAAS,EAAE;QAChB,OAAO,QAAQ,CAAC;YACd,MAAM,QAAQ,IAAI,CAAA,GAAA,cAAA,EAAM,EAAE,GAAG,EAAE,GAAG,EAAE;YACpC,IAAI,CAAC,OAAO,KAAK;QACnB;IACF;AACD;IAED,2CAAe;;;;;;;;;;A,I,kC,a,U,a,S,O,E,U,E,C,E,S;I,S,M,K;Q,O,iB,I,Q,I,E,S,O;Y,Q;Q;I;I,O,I,C,K,C,I,O,C,E,S,O,E,M;Q,S,U,K;Y,I;gB,K,U,K;Y,E,O,G;gB,O;Y;Q;Q,S,S,K;Y,I;gB,K,S,C,Q,C;Y,E,O,G;gB,O;Y;Q;Q,S,K,M;Y,O,O,Q,O,S,M,O,O,K,W;Q;Q,K,A,C,Y,U,M,S,c,E,C,E;I;A;AChBf,2CAA2C;AAC3C,2DAA2D;AAC3D,0BAA0B;AAC1B,sDAAsD;AACtD;;;;;;;CAOG,GACH,SAAe,gCAAU,KAAW,EAAE,IAAW;I,O,gC,I,E,K,G,K,G;QAC/C,MAAM,MAAM,MAAM;QAClB,MAAM,kBAAqC,IAAI;QAE/C,MAAM,WAAW,IAAI,IAAY;YAAC;SAAK;QACvC,MAAM,QAAkB;YAAC;SAAK;QAC9B,gBAAgB,IAAI,MAAM;QAE1B,MAAO,MAAM,SAAS,EAAG;YACvB,MAAM,cAAc,MAAM;YAC1B,MAAM,aAAa,IAAI,IAAI;YAC3B,IAAK,IAAI,IAAI,GAAG,IAAI,WAAY,QAAQ,IAAK;gBAC3C,MAAM,YAAY,UAAW,CAAC,EAAE;gBAChC,IAAI,CAAC,SAAS,IAAI,YAAY;oBAC5B,SAAS,IAAI;oBACb,MAAM,KAAK;oBACX,gBAAgB,IAAI,WAAW;gBAChC;YACF;QACF;QACD,oCAAoC;QACpC,OAAO;IACT;AAAC;AAED,oCAAoC;AACpC;;;;;;;CAOG,GACH,SAAe,+BAAS,KAAW,EAAE,IAAW;I,O,gC,I,E,K,G,K,G;QAC9C,MAAM,MAAM,MAAM;QAClB,MAAM,OAA2B,IAAI;QACrC,MAAM,kBAAkB,MAAM,gCAAU,OAAO;QAC/C,KAAK,MAAM,KAAK,IAAI,OAAQ;YAC1B,IAAI,CAAC,gBAAgB,IAAI,IAAI,UAAU,6BAA6B;YACpE,IAAI,IAAI;YACR,IAAI,eAAmC,gBAAgB,IAAI;YAC3D,MAAO,iBAAiB,aAAa,iBAAiB,GAAI;gBACxD,eAAe,gBAAgB,IAAI;gBACnC,KAAK;YACN;YACD,KAAK,IAAI,GAAG;QACb;QACD,OAAO;IACT;AAAC;AAED,uCAAuC;AACvC,2BAA2B;AAC3B,8DAA8D;AAC9D,kBAAkB;AAClB;;;;;;CAMG,GACH,SAAe,oCAAc,KAAW;I,O,gC,I,E,K,G,K,G;QACtC,MAAM,UAAU;eAAI,MAAM,MAAM;SAAO;QACvC,IAAI,QAAQ,WAAW,GAAG,OAAO;YAAE,OAAO;YAAG,KAAK;YAAG,UAAU;QAAC;QAChE,IAAI,QAAQ,WAAW,GAAG,OAAO;YAAE,OAAO,OAAO,CAAC,EAAE;YAAE,KAAK,OAAO,CAAC,EAAE;YAAE,UAAU;QAAC;QAElF,MAAM,MAAM,MAAM;QAClB,MAAM,gBAAgB,QAAQ,OAAO,CAAC;YAAM,IAAA,IAAA;YAAC,OAAA,AAAC,CAAA,AAAA,CAAA,KAAA,AAAA,CAAA,KAAA,IAAI,IAAI,GAAE,MAAC,QAAA,OAAA,KAAA,IAAA,KAAA,IAAA,GAAE,MAAA,MAAM,QAAA,OAAA,KAAA,IAAA,KAAI,CAAA,IAAK;QAAC;QAC3E,MAAM,WAAW,cAAc,SAAS,IAAI,gBAAgB;QAC5D,IAAI,OAAO,QAAQ,CAAC,KAAK,MAAM,KAAK,WAAW,SAAS,QAAQ;QAEhE,IAAI,SAAS,MAAM,+BAAS,OAAO;QACnC,IAAI,kBAAkB;QACtB,KAAK,MAAM,KAAK,OAAO,OAAQ;YAC7B,MAAM,OAAO,OAAO,IAAI;YACxB,IAAI,OAAO,iBAAiB;gBAC1B,OAAO;gBACP,kBAAkB;YACnB;QACF;QACD,MAAM,WAAW;QACjB,SAAS,MAAM,+BAAS,OAAO;QAC/B,kBAAkB;QAClB,KAAK,MAAM,KAAK,OAAO,OAAQ;YAC7B,MAAM,OAAO,OAAO,IAAI;YACxB,IAAI,OAAO,iBAAiB;gBAC1B,OAAO;gBACP,kBAAkB;YACnB;QACF;QACD,OAAO;YAAE,OAAO;YAAU,KAAK;YAAM,UAAU;QAAe;IAChE;AAAC;AAED,oBAAoB;AACpB,sDAAsD;AACtD;;;;;;;CAOG,GACH,SAAe,qCAAe,KAAW,EAAE,QAAiB;I,O,gC,I,E,K,G,K,G;QAC1D,MAAM,cAAgC,IAAI;QAC1C,MAAM,cAAgC,IAAI;QAC1C,gCAAgC;QAChC,SAAS,QAAQ,CAAC;YAChB,8CAA8C;YAC9C,4CAA4C;YAC5C,MAAM,QAAQ,MAAM,MAAM,IAAI;YAC9B,YAAY,IAAI,SAAS;QAC3B;QAEA,4BAA4B;QAC5B,IAAI,IAAI;QACR,KAAK,MAAM,QAAQ,MAAM,MAAM,OAAQ;YACrC,MAAM,WAAW,MAAM,MAAM,IAAI;YACjC,IAAI,SAAS,SAAS,SAAS,UAAU,SAAS,SAAS,SAAS,MAAM;gBACxE,YAAY,IAAI,GAAG;gBACnB,KAAK;YACN;QACF;QAED,sDAAsD;QACtD,MAAM,WAAW,MAAM,CAAA,GAAA,cAAA,EAAM,OAAO,aAAa;QACjD,OAAO;IACT;AAAC;IAED,mCAAmC;AACnC,2CAAe;mBAAE;cAAe;eAAU;oBAAW;AAAc;;;;;;;;A,I,kC,a,U,a,S,O,E,U,E,C,E,S;I,S,M,K;Q,O,iB,I,Q,I,E,S,O;Y,Q;Q;I;I,O,I,C,K,C,I,O,C,E,S,O,E,M;Q,S,U,K;Y,I;gB,K,U,K;Y,E,O,G;gB,O;Y;Q;Q,S,S,K;Y,I;gB,K,S,C,Q,C;Y,E,O,G;gB,O;Y;Q;Q,S,K,M;Y,O,O,Q,O,S,M,O,O,K,W;Q;Q,K,A,C,Y,U,M,S,c,E,C,E;I;A;ACxInE;;;CAGG,GACH,MAAM;IACJ;;;;;;KAMG,GACH,YAAY,KAAyB,EAAE,KAAwB,CAA/D;QACE,IAAI,CAAC,QAAQ;QACb,IAAI,CAAC,QAAQ;IACb,2BAA2B;IAC3B,oBAAoB;IACtB;IAEA,gBAAgB;IAChB;;KAEG,GACH,YAAA;QACE,MAAM,UACJ,0BACA,IAAI,CAAC,MAAM,OACX,gBACA,IAAI,CAAC,MAAM,OACX;QACF,QAAQ,IAAI;IACd;IAEA,aAAa;IACb;;KAEG,GACG,aAAA;Q,O,gC,I,E,K,G,K,G;YACJ,MAAM,IAAI,CAAC;QACb;IAAC;IAED,oBAAoB;IACpB;;;;;;;;KAQG,GACH,OAAa,OAAO,KAAyB,EAAE,KAAwB,EAAvE;Q,O,gC,I,E,K,G,K,G;YACE,MAAM,IAAI,IAAI,4BAAM,OAAO;YAC3B,MAAM,EAAE;YACR,OAAO;QACT;IAAC;IAED,6CAA6C;IAC7C;;KAEG,GACG,yBAAA;Q,O,gC,I,E,K,G,K,G;YACJ,mEAAmE;YACnE,IAAI,CAAC,MAAM,QAAQ,CAAC;gBAClB,MAAM,QAAQ,KAAK;gBACnB,MAAM,MAAM,KAAK;gBACjB,IAAI,IAAI,CAAC,MAAM,IAAI,QAAQ,IAAI,CAAC,MAAM,IAAI,OAAQ,WAAW,KAAK;gBAClE,IAAI,IAAI,CAAC,MAAM,IAAI,MAAM,IAAI,CAAC,MAAM,IAAI,KAAM,WAAW,KAAK;YAChE;YACA,oDAAoD;YACpD,KAAK,MAAM,OAAO,IAAI,CAAC,MAAM,OAAQ;gBACnC,MAAM,SAAS,IAAI,CAAC,MAAM,IAAI,KAAM;gBACpC,MAAM,YAAY;uBAAI,IAAI,IAAI;iBAAQ;gBACtC,MAAM,YAAY,UAAU,QAAQ;gBACpC,IAAI,YAAY,IACd,UAAU,OAAO,WAAW,IAAI,2CAA2C;gBAE7E,IAAI,CAAC,MAAM,IAAI,KAAM,aAAa;YACnC;QACH;IAAC;IAED,aAAa;IACb;;;;KAIG,GACH,SAAS,MAAc,EAAE,IAAW,EAApC;QACE,IAAI,CAAC,MAAM,IAAI,QAAQ;IACzB;IAEA,cAAc;IACd;;;;;KAKG,GACH,SAAS,KAAa,EAAE,GAAW,EAAE,IAAS,EAA9C;QACE,MAAM,UAAU,IAAI,CAAA,GAAA,cAAA,EAAK,OAAO,KAAK;QACrC,IAAI,CAAC,MAAM,IAAI,IAAI,CAAC,MAAM,MAAM;QAChC,mEAAmE;QACnE,MAAM,YAAY,IAAI,CAAC,MAAM,IAAI;QACjC,MAAM,UAAU,IAAI,CAAC,MAAM,IAAI;QAC/B,IAAI,WAAW,UAAU,WAAW,KAAK;QACzC,IAAI,SAAS,QAAQ,WAAW,KAAK;IACvC;IAEA,kDAAkD;IAClD,oDAAoD;IACpD,8CAA8C;IAC9C;;;KAGG,GACH,gBAAA;QACE,MAAM,YAAmC,IAAI;QAC7C,gCAAgC;QAChC,KAAK,MAAM,OAAO,IAAI,CAAC,MAAM,OAC3B,UAAU,IAAI,KAAK,IAAI,CAAC,MAAM,IAAI,KAAM;QAE1C,OAAO;IACT;IAEA,8CAA8C;IAC9C,gDAAgD;IAChD;;;KAGG,GACH,mBAAmB,IAAwB,EAA3C;QACE,KAAK,IAAI,KAAK,KAAK,OACjB,IAAI,CAAC,MAAM,IAAI,GAAI,OAAI,OAAA,OAAA,OAAA,OAAA,CAAA,GAClB,IAAI,CAAC,MAAM,IAAI,GAAI,OAAI;YAC1B,KAAK,KAAK,IAAI;QAAE;IAGtB;IAEA,qCAAqC;IACrC,0CAA0C;IAC1C;;;KAGG,GACH,oBAAoB,IAAuB,EAA3C;QACE,KAAK,IAAI,OAAO,KAAK,OACnB,IAAI,CAAC,MAAM,IAAI,KAAM,OAAI,OAAA,OAAA,OAAA,OAAA,CAAA,GACpB,IAAI,CAAC,MAAM,IAAI,KAAM,OAAI;YAC5B,OAAO,KAAK,IAAI;QAAI;IAG1B;IAEA,oBAAoB;IACpB,yCAAyC;IACzC;;;KAGG,GACH,eAAA;QACE,MAAM,QAA2B,IAAI;QACrC,KAAK,MAAM,OAAO,IAAI,CAAC,MAAM,OAAQ;YACnC,MAAM,QAAQ,IAAI,CAAC,MAAM,IAAI,KAAM,KAAK;YACxC,IAAI,SAAS,MAAM,MAAM,IAAI,KAAK;QACnC;QACD,OAAO;IACT;IAEA,+BAA+B;IAC/B;;;KAGG,GACH,mBAAmB,MAGlB,EAHD;QAIE,IAAI,OAAO,MACT,IAAI,CAAC,mBAAmB,OAAO;QAEjC,IAAI,OAAO,MACT,IAAI,CAAC,oBAAoB,OAAO;IAEpC;IAEA,mCAAmC;IACnC;;;KAGG,GACH,UAAA;QACE,OAAO;YACL,MAAM,IAAI,CAAC;YACX,MAAM,IAAI,CAAC;QACZ;IACH;IAEA;;;KAGG,GACH,mBAAA;QACE,MAAM,OAA2B,IAAI;QACrC,KAAK,MAAM,QAAQ,IAAI,CAAC,MAAM,OAC5B,KAAK,IAAI,MAAM,IAAI,CAAC,MAAM,IAAI,MAAO,KAAK;QAE5C,OAAO;IACT;AACD;IAED,2BAA2B;AAC3B,2CAAe;;;;;;ACxNf;;CAEG,GACH,MAAM;IACJ;;;;;;;KAOG,GACH,YAAY,KAAY,EAAE,GAAU,EAAE,IAAQ,CAA9C;QACE,IAAI,CAAC,QAAQ;QACb,IAAI,CAAC,MAAM;QACX,IAAI,CAAC,OAAI,OAAA,OAAA,CAAA,GAAQ;IACnB;AACD;IAED,2CAAe;;;;;;;;;;;;;;;;;;;;;A,I,Y,a,U,a,S,S,E,Y,E,G,E,W;I,S,Q,O;Q,O,mB,M,U,I,I,S,S;Y,U;Q;I;I,O,I,C,O,C,M,O,C,E,S,S,E,Q;Q,S,Y,O;Y,I;gB,O,Y,K;Y,E,O,K;gB,S;Y;Q;Q,S,W,O;Y,I;gB,O,W,C,Q,C;Y,E,O,K;gB,S;Y;Q;Q,S,O,Q;Y,S,O,U,S,S,Q,S,O,K,a;Q;Q,O,A,C,c,Y,M,W,gB,E,C,E;I;A;ACdf,4CAA4C;AAC5C,uBAAuB;AACvB;;;;;;;;;;CAUG,GACH,SAAS,uBACP,OAAY,EACZ,WAAiB,CAAC,EAClB,SAA0B,CAAC,EAC3B,UAAgB,QAAQ,EACxB,UAAgB,CAAC;IAEjB,MAAM,sBAA8B,EAAE;IACtC,oCAAoC;IACpC,MAAM,SAAO,QAAM;IACnB,+BAA+B;IAC/B,IAAI;IACJ,IAAI;IACJ,IAAI,OAAO,UAAQ,UACjB,UAAQ,MAAM,QAAM,MAAM,MAAM,KAAK;SAErC,UAAQ;IAEV,WAAS,MAAM,QAAM,MAAM,MAAM,KAAK;IACtC,MAAM,WAAS,EAAE;IACjB,MAAM,aAAW,IAAI;IACrB,WAAS,OAAO,KAAK,KAAK,MAAM,uBAAuB;IACvD,uBAAuB;IACvB,IAAI,MAAI;IACR,IAAI;IACJ,KAAK,IAAI,UAAQ,QAAM,MAAM,OAAQ;QACnC,aAAW,OAAK,IAAI;QACpB,oBAAkB,KAChB,WAAS,IAAI,UACb,WAAS,IAAI,UACb,WAAS,IAAI;QAGf,WAAS,QAAQ,UAAQ,MAAI;QAC7B,SAAO,KAAK;QACZ,OAAK;IACN;IAED,MAAM,aAAW,IAAI;IACrB,qBAAqB;IACrB,WAAS,aACP,YACA,IAAI,oCAA6B,qBAAmB;IAEtD,kBAAkB;IAClB,WAAS,aACP,eACA,IAAI,oCAA6B,UAAQ;IAE3C,iBAAiB;IACjB,WAAS,aAAa,QAAQ,IAAI,oCAA6B,SAAO;IACtE,kBAAkB;IAClB,WAAS,aAAa,SAAS,IAAI,kCAA2B,UAAQ;IACtE,WAAS,OAAO;IAEhB,mBAAmB;IACnB,MAAM,kBAAgB,IAAI,4BAAqB;QAC7C,UAAU;YACR,OAAO;gBAAE,OAAO,IAAI,mBAAY;YAAS;YACzC,cAAc;gBACZ,OAAO,IAAI,6BAAsB,KAAK;YACvC;YACD,WAAW;gBAAE,OAAO;YAAK;QAC1B;QACD,cAAc,CAAA,GAAA,mBAAA;QACd,gBAAgB,CAAA,GAAA,qBAAA;IACjB;IAED,MAAM,aAAW,IAAI;IACrB,WAAS,IAAI,IAAI,oBAAa,YAAU;IACxC,OAAO;AACT;AAEA,0DAA0D;AAC1D;;;;;;;;;CASG,GACH,SAAS,yBACP,OAAY,EACZ,WAAiB,CAAC,EAClB,UAAQ,QAAQ,EAChB,cAAoB,GAAG;IAEvB,iCAAiC;IACjC,MAAM,YAAU,QAAM;IACtB,OAAO,0BAA0B,WAAS,UAAQ,SAAO;AAC3D;AAEA,iEAAiE;AACjE;;;;;;;;;CASG,GACH,SAAS,0BACP,SAA0B,EAC1B,QAAc,EACd,UAAgB,QAAQ,EACxB,cAAoB,GAAG;IAEvB,OAAO,CAAA,GAAA,4BAAA,EAAsB,WAAS,UAAQ,SAAO;AACvD;AAEA,mDAAmD;AACnD;;;;;;;;CAQG,GACH,SAAS,wBACP,OAAY,EACZ,WAAiB,CAAC,EAClB,UAAgB,QAAQ;IAExB,mCAAmC;IACnC,MAAM,SAAO,QAAM;IACnB,OAAO,yBAAyB,QAAM,UAAQ;AAChD;AAEA;;;;;;;;;CASG,GACH,SAAS,yBACP,OAAY,EACZ,QAAc,EACd,aAAqB,EACrB,UAAgB,QAAQ,EACxB,cAAoB,CAAC;IAErB,MAAM,SAAO,QAAM;IACnB,MAAM,eAAa,cAAY,IAAI,CAAC,OAAO,OAAK,IAAI,OAAK,OAAO,CAAC,MAAkB,OAAK;IACxF,IAAI,aAAW,SAAS,GAAG,OAAO,IAAI;IACtC,MAAM,aAAW,IAAI,CAAA,GAAA,cAAA,EAAK;IAC1B,OAAO,CAAA,GAAA,4BAAA,EAAsB,IAAI,IAAI;QAAC;YAAC;YAAG;SAAS;KAAC,GAAG,UAAQ,SAAO;AACxE;AAEA,uCAAuC;AACvC;;;;;;;;CAQG,GACH,SAAS,yBACP,SAA0B,EAC1B,WAAiB,CAAC,EAClB,UAAgB,QAAQ;IAExB,MAAM,aAAW,IAAI,+BAAwB;QAC3C,OAAO;IACR;IACD,MAAM,UAAQ,IAAI;IAClB,IAAI;IACJ,KAAK,MAAM,UAAQ,UAAQ,SAAU;QACnC,WAAS,EAAE;QACX,oBAAoB;QACpB,MAAM,UAAQ,OAAK;QACnB,QAAM,QAAQ,CAAC;YACb,SAAO,KACL,IAAI,qBACF,UAAQ,IAAI,UACZ,UAAQ,IAAI,UACZ,UAAQ,IAAI;QAGlB;QACA,2BAA2B;QAC3B,MAAM,aAAW,IAAI,8BAAuB,cAAc;QAC1D,MAAM,SAAO,IAAI,kBAAW,YAAU;QACtC,QAAM,IAAI;IACX;IACD,OAAO;AACT;AAEA,+BAA+B;AAC/B;;;;;;;;;CASG,GACH,SAAS,mBACP,SAA2B,EAC3B,WAAiB,CAAC,EAClB,UAAgB,QAAQ,EACxB,SAA0B,EAAE;IAE5B,2BAA2B;IAC3B,IAAI;IACJ,IAAI,OAAO,UAAQ,UACjB,UAAQ,MAAM,UAAQ,MAAM,KAAK;SAEjC,UAAQ;IAEV,iEAAiE;IACjE,MAAM,UAAQ,IAAI;IAClB,MAAM,aAAW,IAAI,+BAAwB;QAAE,OAAO;IAAK;IAC3D,IAAI,MAAI;IACR,KAAK,MAAM,CAAC,MAAI,WAAS,IAAI,UAAS;QACpC,MAAM,MAAI,OAAO,YAAU,WAAW,UAAQ,OAAK,CAAC,IAAE;QACtD,MAAM,aAAW,IAAI,yBAAkB,KAAG,KAAG;QAC7C,WAAS,OAAO,OAAO;QACvB,MAAM,aAAW,IAAI,kBAAW,YAAU;QAC1C,WAAS,SAAS,IAChB,WAAS,IAAI,UACb,WAAS,IAAI,UACb,WAAS,IAAI;QAEf,QAAM,IAAI;QACV,OAAK;IACN;IACD,OAAO;AACT;AAEA,qCAAqC;AACrC;;;;;;;;;CASG,GACH,SAAS,0BACP,OAAY,EACZ,WAAiB,CAAC,EAClB,UAAgB,QAAQ,EACxB,SAA0B,EAAE;IAE5B,MAAM,SAAO,QAAM;IACnB,MAAM,WAAS,mBAAmB,QAAM,UAAQ,SAAO;IACvD,OAAO;AACT;AAEA,gCAAgC;AAChC;;;;;;;;;CASG,GACH,SAAS,wBACP,SAA2B,EAC3B,kBAAwB,EAAE,EAC1B,UAAgB,QAAQ,EACxB,SAA0B,EAAE;IAE5B,2BAA2B;IAC3B,IAAI;IACJ,IAAI,OAAO,UAAQ,UACjB,UAAQ,MAAM,UAAQ,MAAM,KAAK;SAEjC,UAAQ;IAEV,iEAAiE;IACjE,MAAM,UAAQ,IAAI;IAClB,MAAM,aAAW,IAAI,+BAAwB;QAAE,OAAO;IAAK;IAC3D,IAAI,MAAI;IACR,KAAK,MAAM,CAAC,MAAI,WAAS,IAAI,UAAS;QACpC,MAAM,WAAS,OAAO,YAAU,WAAW,UAAQ,OAAK,CAAC,IAAE;QAC3D,MAAM,kBAAgB,IAAI,WAAS,KAAK;QACxC,MAAM,aAAW,KAAK,KAAK,kBAAgB;QAC3C,MAAM,aAAW,IAAI,8BAAuB,UAAQ,UAAQ,IAAI;QAChE,WAAS,OAAO,OAAO;QACvB,MAAM,aAAW,IAAI,kBAAW,YAAU;QAC1C,WAAS,SAAS,IAAI,WAAS,GAAG,WAAS,GAAG,WAAS;QACvD,QAAM,IAAI;QACV,OAAK;IACN;IACD,OAAO;AACT;AAEA,kCAAkC;AAClC,iEAAiE;AACjE;;;;;;;CAOG,GACH,SAAe,gCACb,KAAY,EACZ,YAAoB;I,O,U,I,E,K,G,K,G;QAEpB,6BAA6B;QAC7B,MAAM,SAAgC,IAAI;QAC1C,IAAI;QACJ,IAAI;QACJ,KAAK,IAAI,QAAQ,MAAM,MAAM,OAAQ;YACnC,QAAQ,MAAM,MAAM,IAAI;YACxB,aAAa,KAAK,CAAA,WAAA,EAAc,aAAY,CAAE;YAC9C,IAAI,OAAO,IAAI,aACb,OAAO,IAAI,YAAa,KAAK;iBAE7B,OAAO,IAAI,YAAY;gBAAC;aAAK;QAEhC;QACD,sCAAsC;QACtC,MAAM,oBAA8C,IAAI;QACxD,MAAM,iBAA2C,IAAI;QACrD,IAAI;QACJ,IAAI;QACJ,IAAI;QACJ,IAAI;QACJ,KAAK,IAAI,mBAAmB,OAAO,OAAQ;YACzC,gBAAgB,OAAO,IAAI;YAC3B,mBAAmB;YACnB,WAAW,MAAM,CAAA,GAAA,cAAA,EAAa,eAAe,OAAO;YACpD,6BAA6B;YAC7B,WAAW,uBAAuB,UAAU;YAC5C,kBAAkB,IAAI,iBAAiB;YACvC,iBAAiB;YACjB,QAAQ,oBAAoB,UAAU;YACtC,eAAe,IAAI,iBAAiB;QACrC;QACD,MAAM,OAAO;YACX,YAAY;YACZ,YAAY;QACb;QACD,OAAO;IACT;AAAC;AAED;;;;;;;;CAQG,GACH,SAAS,oBACP,OAAY,EACZ,QAAc,EACd,UAAgB,QAAQ;IAExB,MAAM,cAAY,IAAI;IACtB,MAAM,aAAW,IAAI,+BAAwB;QAAE,OAAO;IAAK;IAC3D,IAAI;IACJ,IAAI;IACJ,IAAI;IACJ,KAAK,IAAI,UAAQ,QAAM,MAAM,SAC3B,IAAI,KAAK,YAAY,UAAQ;QAC3B,UAAQ,QAAM,MAAM,IAAI,OAAK,OAAQ,KAAK;QAC1C,QAAM,QAAM,MAAM,IAAI,OAAK,KAAM,KAAK;QACtC,WAAS,EAAE;QACX,SAAO,KAAK,IAAI,qBAAc,QAAM,GAAG,QAAM,GAAG,QAAM;QACtD,SAAO,KAAK,IAAI,qBAAc,MAAI,GAAG,MAAI,GAAG,MAAI;QAChD,MAAM,aAAW,IAAI,8BAAuB,cAAc;QAC1D,MAAM,SAAO,IAAI,kBAAW,YAAU;QACtC,YAAU,IAAI;IACf;IAEH,OAAO;AACT;AAEA;;;;;;CAMG,GACH,SAAS,uBACP,UAAoC,EACpC,YAAoB,EACpB,OAAa;IAEb,IAAI;QACF,MAAM,WAAU,sBAAoB,qBAAc,WAAS,QAAQ,CAAC,EAAE,GAAG;QACzE,MAAM,SAAO,aAAM,QAAN,aAAM,KAAA,IAAA,KAAA,IAAN,SAAQ;QACrB,IAAI,CAAC,CAAA,WAAI,QAAJ,WAAI,KAAA,IAAA,KAAA,IAAJ,OAAM,UAAA,GAAY;QACvB,MAAM,gBAAc,OAAK,WAAW;QACpC,MAAM,QAAM,kBAAW,QAAX,kBAAW,KAAA,IAAA,KAAA,IAAX,cAAa;QACzB,IAAI,CAAC,SAAO,MAAI,WAAW,GAAG;QAC9B,MAAM,QAAM,IAAI,mBAAY;QAC5B,MAAM,cAAY,OAAK,WAAW;QAClC,MAAM,WAAS,gBAAS,QAAT,gBAAS,KAAA,IAAA,KAAA,IAAT,YAAW;QAE1B,IAAI,YAAU,SAAO,SAAS,GAC5B,qDAAqD;QACrD,aAAW,QAAQ,CAAC;YAClB,IAAK,IAAI,MAAI,GAAG,MAAI,SAAO,QAAQ,MACjC,IAAI,QAAM,CAAC,IAAE,KAAK,UAAQ;gBACxB,MAAM,MAAI,MAAI;gBACd,IAAI,MAAI,IAAI,MAAI,QAAQ;oBACtB,KAAG,CAAC,IAAE,GAAG,MAAI;oBACb,KAAG,CAAC,MAAI,EAAE,GAAG,MAAI;oBACjB,KAAG,CAAC,MAAI,EAAE,GAAG,MAAI;gBAClB;gBACD;YACD;QAEL;aAEA,+CAA+C;QAC/C,aAAW,QAAQ,CAAC;YAClB,MAAM,MAAI,SAAO;YACjB,IAAI,MAAI,IAAI,MAAI,QAAQ;gBACtB,KAAG,CAAC,IAAE,GAAG,MAAI;gBACb,KAAG,CAAC,MAAI,EAAE,GAAG,MAAI;gBACjB,KAAG,CAAC,MAAI,EAAE,GAAG,MAAI;YAClB;QACH;QAEF,IAAI,eAAa,cAAY,cAAc;IAC5C,EAAC,OAAA,MAAM;IACN,6DAA6D;IAC9D;AACH;AAEA;;;CAGG,GACH,SAAS,kBAAkB,UAAoC;I,I,M,M;IAC7D,IAAI;QACF,MAAM,WAAU,sBAAoB,qBAAc,WAAS,QAAQ,CAAC,EAAE,GAAG;QACzE,MAAM,gBAAc,AAAA,CAAA,OAAA,AAAA,CAAA,OAAA,aAAM,QAAN,aAAM,KAAA,IAAA,KAAA,IAAN,SAAQ,QAAA,MAAQ,QAAA,SAAA,KAAA,IAAA,KAAA,IAAA,KAAE,UAAA,MAAU,QAAA,SAAA,KAAA,IAAA,KAAA,IAAA,KAAE;QAClD,MAAM,QAAM,kBAAW,QAAX,kBAAW,KAAA,IAAA,KAAA,IAAX,cAAa;QACzB,IAAI,CAAC,SAAO,MAAI,WAAW,GAAG;QAC9B,MAAM,UAAQ,AAAA,CAAA,OAAA,kBAAW,QAAX,kBAAW,KAAA,IAAA,KAAA,IAAX,cAAa,KAAA,MAAK,QAAA,SAAA,KAAA,IAAA,OAAI,KAAK,MAAM,MAAI,SAAS;QAC5D,IAAK,IAAI,MAAI,GAAG,MAAI,SAAO,MAAK;YAC9B,MAAM,MAAI,MAAI;YACd,KAAG,CAAC,IAAE,GAAG;YACT,KAAG,CAAC,MAAI,EAAE,GAAG;YACb,KAAG,CAAC,MAAI,EAAE,GAAG;QACd;QACD,IAAI,eAAa,cAAY,cAAc;IAC5C,EAAC,OAAA,MAAM;IACN,4CAA4C;IAC7C;AACH;IAEA,2CAAe;4BACb;8BACA;6BACA;8BACA;wBACA;qCACA;8BACA;+BACA;6BACA;yBACA;4BACA;uBACA;+BACA;AACD;;;;;;AC9fD;;;;CAIG;;;;;AAOH,gDAAA,GACA,MAAM,8CAAwB;AAC9B,4EAAA,GACA,MAAM,2CAAqB,IAAI,qBAAc,KAAK;AAc5C,SAAU,0CACd,IAAU,EACV,MAAc,EACd,KAAa,EACb,cAAsB,2CAAqB,EAC3C,UAA0B;IAE1B,IAAI,KAAK,OAAO,SAAS,GAAG;QAC1B,MAAM,MAAM,IAAI;QAChB,OAAO,IAAI,kBAAW,KAAK,IAAI,+BAAwB;mBAAE;QAAK;IAC/D;IAED,MAAM,YAAY,KAAK,OAAO,IAC5B,CAAC,IAAM,IAAI,qBAAc,EAAE,IAAI,QAAQ,EAAE,IAAI,QAAQ,EAAE,IAAI;IAE7D,MAAM,WAAW,CAAA,GAAA,4BAAA,EAAsB;IACvC,MAAM,WAAW,CAAA,GAAA,6BAAA,EAAuB;eACtC;QACA,WAAW;QACX,YAAY,eAAU,QAAV,eAAU,KAAA,IAAV,aAAc;IAC3B;IACD,OAAO,IAAI,kBAAW,UAAU;AAClC;AAEA;;;;;;;;;;CAUG,GACH;;CAEG,GACH,SAAS,mCAAa,SAAiB;IACrC,IAAI,aAAa,GAAG,OAAO,KAAK,IAAI,GAAG,KAAK,MAAM;IAClD,OAAO,KAAK,IAAI,GAAG,KAAK,MAAM,YAAY;AAC5C;AAEM,SAAU,0CACd,OAA0B,EAC1B,MAAc,EACd,KAAa,EACb,YAAoB,2CAAqB,EACzC,UAA0B;IAE1B,MAAM,cAAc,mCAAa;IACjC,MAAM,QAAQ,IAAI;IAClB,KAAK,MAAM,QAAQ,QAAQ,SAAU;QACnC,IAAI,CAAC,CAAA,SAAI,QAAJ,SAAI,KAAA,IAAA,KAAA,IAAJ,KAAM,MAAA,KAAU,KAAK,OAAO,SAAS,GAAG;QAC7C,MAAM,IAAI,0CAAoB,MAAM,QAAQ,OAAO,aAAa;IACjE;IACD,OAAO;AACT;;;;;;ACrFA;;;;CAIG;AAQG,SAAU,0CAAsB,SAA0B;IAC9D,MAAM,IAAI,UAAU;IACpB,IAAI,IAAI,GACN,OAAO,IAAI;IAGb,MAAM,SAAmB,EAAE;IAC3B,MAAM,UAAoB,EAAE;IAC5B,MAAM,UAAoB,EAAE;IAC5B,MAAM,UAAoB,EAAE;IAE5B,IAAK,IAAI,IAAI,GAAG,IAAI,GAAG,IAAK;QAC1B,MAAM,IAAI,SAAS,CAAC,EAAE;QACtB,MAAM,QAAQ,IAAI,IAAI,SAAS,CAAC,IAAI,EAAE,GAAG;QACzC,MAAM,QAAQ,IAAI,IAAI,IAAI,SAAS,CAAC,IAAI,EAAE,GAAG;QAE7C,mBAAmB;QACnB,OAAO,KAAK,EAAE,GAAG,EAAE,GAAG,EAAE;QACxB,QAAQ,KAAK,MAAM,GAAG,MAAM,GAAG,MAAM;QACrC,QAAQ,KAAK,MAAM,GAAG,MAAM,GAAG,MAAM;QACrC,QAAQ,KAAK;QAEb,oBAAoB;QACpB,OAAO,KAAK,EAAE,GAAG,EAAE,GAAG,EAAE;QACxB,QAAQ,KAAK,MAAM,GAAG,MAAM,GAAG,MAAM;QACrC,QAAQ,KAAK,MAAM,GAAG,MAAM,GAAG,MAAM;QACrC,QAAQ,KAAK;IACd;IAED,MAAM,WAAW,IAAI;IACrB,SAAS,aAAa,YAAY,IAAI,oCAA6B,QAAQ;IAC3E,SAAS,aAAa,gBAAgB,IAAI,oCAA6B,SAAS;IAChF,SAAS,aAAa,gBAAgB,IAAI,oCAA6B,SAAS;IAChF,SAAS,aAAa,QAAQ,IAAI,oCAA6B,SAAS;IAExE,yEAAyE;IACzE,MAAM,UAAoB,EAAE;IAC5B,IAAK,IAAI,IAAI,GAAG,IAAI,IAAI,GAAG,IAAK;QAC9B,MAAM,IAAI,IAAI;QACd,QAAQ,KAAK,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI;IACjD;IACD,SAAS,SAAS;IAClB,SAAS;IAET,OAAO;AACT;;;;;;;ACzDA;;;;CAIG;AAIH,MAAM,wCAAkB,CAAxB;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4BC,CAAA;AAED,MAAM,0CAAoB,CAA1B;;;;;;AAMC,CAAA;AAYK,SAAU,0CAAuB,UAAmC,CAAA,CAAE;I,I,I,I;IAC1E,MAAM,QAAQ,AAAA,CAAA,KAAA,QAAQ,KAAA,MAAK,QAAA,OAAA,KAAA,IAAA,KAAI;IAC/B,MAAM,YAAY,AAAA,CAAA,KAAA,QAAQ,SAAA,MAAS,QAAA,OAAA,KAAA,IAAA,KAAI;IACvC,MAAM,aAAa,AAAA,CAAA,KAAA,QAAQ,UAAA,MAAU,QAAA,OAAA,KAAA,IAAA,KAAI,IAAI,qBAAc,KAAK;IAEhE,MAAM,aAAa,IAAI,mBAAY;IACnC,OAAO,IAAI,4BAAqB;QAC9B,UAAU;YACR,YAAY;gBAAE,OAAO;YAAU;YAC/B,WAAW;gBAAE,OAAO;YAAS;YAC7B,OAAO;gBAAE,OAAO,IAAI,qBAAc,WAAW,GAAG,WAAW,GAAG,WAAW;YAAE;QAC5E;QACD,cAAc;QACd,gBAAgB;QAChB,aAAa;QACb,WAAW;QACX,MAAM;IACP;AACH;;;;;;;;AC1EA,MAAM,4CAAe,CAArB;;;;;;;;;;;;AAYC,CAAA;;;;;;;ACZD,MAAM,2CAAiB,CAAvB;;;;;;;;;;;;AAYC,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AMZD,MAAM,4CAAM;IACV,OAAO;QACL;QAAG;QAAG;QAAG;QAAG;QAAG;QAAG;QAAG;QAAG;QAAG;QAAG;QAAI;QAAI;QAAI;QAAI;QAAI;QAAI;QAAI;QAAI;QAAI;QAAI;QACtE;QAAI;QAAI;QAAI;QAAI;QAAI;QAAI;QAAI;QAAI;QAAI;QAAI;QAAI;QAAI;KACjD;IACD,OAAO;QACL;YAAC;YAAG;SAAE;QACN;YAAC;YAAG;SAAE;QACN;YAAC;YAAG;SAAE;QACN;YAAC;YAAG;SAAE;QACN;YAAC;YAAG;SAAE;QACN;YAAC;YAAG;SAAE;QACN;YAAC;YAAG;SAAE;QACN;YAAC;YAAG;SAAE;QACN;YAAC;YAAG;SAAG;QACP;YAAC;YAAG;SAAG;QACP;YAAC;YAAG;SAAG;QACP;YAAC;YAAG;SAAG;QACP;YAAC;YAAG;SAAG;QACP;YAAC;YAAG;SAAG;QACP;YAAC;YAAG;SAAG;QACP;YAAC;YAAG;SAAG;QACP;YAAC;YAAG;SAAE;QACN;YAAC;YAAG;SAAE;QACN;YAAC;YAAG;SAAE;QACN;YAAC;YAAG;SAAG;QACP;YAAC;YAAG;SAAG;QACP;YAAC;YAAG;SAAG;QACP;YAAC;YAAG;SAAG;QACP;YAAC;YAAG;SAAG;QACP;YAAC;YAAG;SAAE;QACN;YAAC;YAAG;SAAE;QACN;YAAC;YAAG;SAAE;QACN;YAAC;YAAG;SAAE;QACN;YAAC;YAAG;SAAG;QACP;YAAC;YAAG;SAAG;QACP;YAAC;YAAG;SAAG;QACP;YAAC;YAAG;SAAG;QACP;YAAC;YAAG;SAAE;QACN;YAAC;YAAG;SAAG;QACP;YAAC;YAAG;SAAG;QACP;YAAC;YAAG;SAAE;QACN;YAAC;YAAG;SAAG;QACP;YAAC;YAAG;SAAE;QACN;YAAC;YAAG;SAAG;QACP;YAAC;YAAG;SAAG;QACP;YAAC;YAAG;SAAG;QACP;YAAC;YAAG;SAAG;QACP;YAAC;YAAG;SAAG;QACP;YAAC;YAAG;SAAG;QACP;YAAC;YAAG;SAAG;QACP;YAAC;YAAI;SAAG;QACR;YAAC;YAAI;SAAG;QACR;YAAC;YAAI;SAAG;QACR;YAAC;YAAI;SAAG;QACR;YAAC;YAAI;SAAG;QACR;YAAC;YAAI;SAAG;QACR;YAAC;YAAI;SAAG;QACR;YAAC;YAAI;SAAG;QACR;YAAC;YAAI;SAAG;QACR;YAAC;YAAI;SAAG;QACR;YAAC;YAAI;SAAG;QACR;YAAC;YAAI;SAAG;QACR;YAAC;YAAI;SAAG;QACR;YAAC;YAAI;SAAG;QACR;YAAC;YAAI;SAAG;QACR;YAAC;YAAI;SAAG;QACR;YAAC;YAAI;SAAG;QACR;YAAC;YAAI;SAAG;QACR;YAAC;YAAI;SAAG;QACR;YAAC;YAAI;SAAG;QACR;YAAC;YAAI;SAAG;QACR;YAAC;YAAI;SAAG;QACR;YAAC;YAAI;SAAG;QACR;YAAC;YAAI;SAAG;QACR;YAAC;YAAI;SAAG;QACR;YAAC;YAAI;SAAG;QACR;YAAC;YAAI;SAAG;QACR;YAAC;YAAI;SAAG;QACR;YAAC;YAAI;SAAG;QACR;YAAC;YAAI;SAAG;QACR;YAAC;YAAI;SAAG;QACR;YAAC;YAAI;SAAG;QACR;YAAC;YAAI;SAAG;KACT;AACF;;;ACrFD,MAAM,4CAAgB;IACpB,OAAO;QACL;YAAE,IAAI;YAAG,IAAI;YAAqB,IAAI;YAAmB,QAAQ;QAAC;QAClE;YAAE,IAAI;YAAG,IAAI;YAAqB,IAAI;YAAoB,QAAQ;QAAC;QACnE;YAAE,IAAI;YAAG,IAAI;YAAqB,IAAI;YAAuB,QAAQ;QAAC;QACtE;YAAE,IAAI;YAAG,IAAI;YAAoB,IAAI;YAAoB,QAAQ;QAAC;QAClE;YAAE,IAAI;YAAG,IAAI;YAAoB,IAAI;YAAmB,QAAQ;QAAC;QACjE;YAAE,IAAI;YAAG,IAAI;YAAoB,IAAI;YAAoB,QAAQ;QAAC;QAClE;YAAE,IAAI;YAAG,IAAI;YAAuB,IAAI;YAAmB,QAAQ;QAAC;QACpE;YAAE,IAAI;YAAG,IAAI;YAAoB,IAAI;YAAoB,QAAQ;QAAC;QAClE;YAAE,IAAI;YAAG,IAAI;YAAqB,IAAI;YAAsB,QAAQ;QAAC;QACrE;YAAE,IAAI;YAAG,IAAI;YAAqB,IAAI;YAAoB,QAAQ;QAAC;QACnE;YAAE,IAAI;YAAI,IAAI;YAAoB,IAAI;YAAoB,QAAQ;QAAC;QACnE;YAAE,IAAI;YAAI,IAAI;YAAqB,IAAI;YAAoB,QAAQ;QAAC;QACpE;YAAE,IAAI;YAAI,IAAI;YAAoB,IAAI;YAAoB,QAAQ;QAAC;QACnE;YAAE,IAAI;YAAI,IAAI;YAAqB,IAAI;YAAqB,QAAQ;QAAC;QACrE;YAAE,IAAI;YAAI,IAAI;YAAqB,IAAI;YAAqB,QAAQ;QAAC;QACrE;YAAE,IAAI;YAAI,IAAI;YAAoB,IAAI;YAAqB,QAAQ;QAAC;QACpE;YAAE,IAAI;YAAI,IAAI;YAAoB,IAAI;YAAK,QAAQ;QAAC;QACpD;YAAE,IAAI;YAAI,IAAI;YAAqB,IAAI;YAAmB,QAAQ;QAAC;QACnE;YAAE,IAAI;YAAI,IAAI;YAAoB,IAAI;YAAoB,QAAQ;QAAC;QACnE;YAAE,IAAI;YAAI,IAAI;YAAqB,IAAI;YAAqB,QAAQ;QAAC;QACrE;YAAE,IAAI;YAAI,IAAI;YAAqB,IAAI;YAAqB,QAAQ;QAAC;QACrE;YAAE,IAAI;YAAI,IAAI;YAAqB,IAAI;YAAmB,QAAQ;QAAC;QACnE;YAAE,IAAI;YAAI,IAAI;YAAqB,IAAI;YAAqB,QAAQ;QAAC;QACrE;YAAE,IAAI;YAAI,IAAI;YAAoB,IAAI;YAAoB,QAAQ;QAAC;QACnE;YAAE,IAAI;YAAI,IAAI;YAAoB,IAAI;YAAqB,QAAQ;QAAC;QACpE;YAAE,IAAI;YAAI,IAAI;YAAoB,IAAI;YAAqB,QAAQ;QAAC;QACpE;YAAE,IAAI;YAAI,IAAI;YAAqB,IAAI;YAAqB,QAAQ;QAAC;QACrE;YAAE,IAAI;YAAI,IAAI;YAAoB,IAAI;YAAqB,QAAQ;QAAC;QACpE;YAAE,IAAI;YAAI,IAAI;YAAoB,IAAI;YAAoB,QAAQ;QAAC;QACnE;YAAE,IAAI;YAAI,IAAI;YAAoB,IAAI;YAAoB,QAAQ;QAAC;QACnE;YAAE,IAAI;YAAI,IAAI;YAAqB,IAAI;YAAsB,QAAQ;QAAC;QACtE;YAAE,IAAI;YAAI,IAAI;YAAoB,IAAI;YAAqB,QAAQ;QAAC;QACpE;YAAE,IAAI;YAAI,IAAI;YAAqB,IAAI;YAAqB,QAAQ;QAAC;QACrE;YAAE,IAAI;YAAI,IAAI;YAAqB,IAAI;YAAqB,QAAQ;QAAC;KACtE;IACD,OAAO;QACL;YAAC;YAAG;SAAE;QACN;YAAC;YAAG;SAAE;QACN;YAAC;YAAG;SAAE;QACN;YAAC;YAAG;SAAE;QACN;YAAC;YAAG;SAAE;QACN;YAAC;YAAG;SAAE;QACN;YAAC;YAAG;SAAE;QACN;YAAC;YAAG;SAAE;QACN;YAAC;YAAG;SAAG;QACP;YAAC;YAAG;SAAG;QACP;YAAC;YAAG;SAAG;QACP;YAAC;YAAG;SAAG;QACP;YAAC;YAAG;SAAG;QACP;YAAC;YAAG;SAAG;QACP;YAAC;YAAG;SAAG;QACP;YAAC;YAAG;SAAG;QACP;YAAC;YAAG;SAAE;QACN;YAAC;YAAG;SAAE;QACN;YAAC;YAAG;SAAE;QACN;YAAC;YAAG;SAAG;QACP;YAAC;YAAG;SAAG;QACP;YAAC;YAAG;SAAG;QACP;YAAC;YAAG;SAAG;QACP;YAAC;YAAG;SAAG;QACP;YAAC;YAAG;SAAE;QACN;YAAC;YAAG;SAAE;QACN;YAAC;YAAG;SAAE;QACN;YAAC;YAAG;SAAE;QACN;YAAC;YAAG;SAAG;QACP;YAAC;YAAG;SAAG;QACP;YAAC;YAAG;SAAG;QACP;YAAC;YAAG;SAAG;QACP;YAAC;YAAG;SAAE;QACN;YAAC;YAAG;SAAG;QACP;YAAC;YAAG;SAAG;QACP;YAAC;YAAG;SAAE;QACN;YAAC;YAAG;SAAG;QACP;YAAC;YAAG;SAAE;QACN;YAAC;YAAG;SAAG;QACP;YAAC;YAAG;SAAG;QACP;YAAC;YAAG;SAAG;QACP;YAAC;YAAG;SAAG;QACP;YAAC;YAAG;SAAG;QACP;YAAC;YAAG;SAAG;QACP;YAAC;YAAG;SAAG;QACP;YAAC;YAAI;SAAG;QACR;YAAC;YAAI;SAAG;QACR;YAAC;YAAI;SAAG;QACR;YAAC;YAAI;SAAG;QACR;YAAC;YAAI;SAAG;QACR;YAAC;YAAI;SAAG;QACR;YAAC;YAAI;SAAG;QACR;YAAC;YAAI;SAAG;QACR;YAAC;YAAI;SAAG;QACR;YAAC;YAAI;SAAG;QACR;YAAC;YAAI;SAAG;QACR;YAAC;YAAI;SAAG;QACR;YAAC;YAAI;SAAG;QACR;YAAC;YAAI;SAAG;QACR;YAAC;YAAI;SAAG;QACR;YAAC;YAAI;SAAG;QACR;YAAC;YAAI;SAAG;QACR;YAAC;YAAI;SAAG;QACR;YAAC;YAAI;SAAG;QACR;YAAC;YAAI;SAAG;QACR;YAAC;YAAI;SAAG;QACR;YAAC;YAAI;SAAG;QACR;YAAC;YAAI;SAAG;QACR;YAAC;YAAI;SAAG;QACR;YAAC;YAAI;SAAG;QACR;YAAC;YAAI;SAAG;QACR;YAAC;YAAI;SAAG;QACR;YAAC;YAAI;SAAG;QACR;YAAC;YAAI;SAAG;QACR;YAAC;YAAI;SAAG;QACR;YAAC;YAAI;SAAG;QACR;YAAC;YAAI;SAAG;QACR;YAAC;YAAI;SAAG;KACT;AACF;;;;;;;;AE5GD;;;CAGG,GACH,MAAM;IACJ;;;KAGG,GACH,YAAY,IAAQ,CAApB;QACE,qEAAqE;QACrE,IAAI,CAAC,OAAI,OAAA,OAAA,CAAA,GAAQ;QACjB,4DAA4D;QAC5D,IAAI,CAAC,aAAa,EAAE;IACtB;AACD;IAED,2CAAe;;;;;A,I,kC,a,U,a,S,O,E,U,E,C,E,S;I,S,M,K;Q,O,iB,I,Q,I,E,S,O;Y,Q;Q;I;I,O,I,C,K,C,I,O,C,E,S,O,E,M;Q,S,U,K;Y,I;gB,K,U,K;Y,E,O,G;gB,O;Y;Q;Q,S,S,K;Y,I;gB,K,S,C,Q,C;Y,E,O,G;gB,O;Y;Q;Q,S,K,M;Y,O,O,Q,O,S,M,O,O,K,W;Q;Q,K,A,C,Y,U,M,S,c,E,C,E;I;A;ADtBf,8CAA8C;AAC9C;;;;;CAKG,GACH,SAAe,kDAA4B,KAAW,EAAE,KAAW;I,O,gC,I,E,K,G,K,G;QACjE,kBAAkB;QAClB,MAAM,UAAU,IAAI;QACpB,IAAK,IAAI,IAAI,GAAG,IAAI,MAAM,QAAQ,IAAK;YACrC,MAAM,IAAI,IAAI,CAAA,GAAA,wCAAA,EAAM,KAAK,CAAC,EAAE,CAAC;YAC7B,QAAQ,IAAI,KAAK,CAAC,EAAE,EAAE;QACvB;QACD,sBAAsB;QACtB,MAAM,UAAU,IAAI;QACpB,IAAK,IAAI,IAAI,GAAG,IAAI,MAAM,QAAQ,IAAK;YACrC,MAAM,IAAI,IAAI,CAAA,GAAA,cAAA,EAAK,KAAK,CAAC,EAAE,CAAC,EAAE,EAAE,KAAK,CAAC,EAAE,CAAC,EAAE,EAAE,KAAK,CAAC,EAAE,CAAC;YACtD,QAAQ,IAAI,GAAG;QAChB;QACD,sBAAsB;QACtB,MAAM,IAAI,MAAM,CAAA,GAAA,cAAA,EAAM,OAAO,SAAS;QACtC,OAAO;IACT;AAAC;IAED,2CAAe;iCAAE;AAA2B;;;;;;;;;;;;A,I,kC,a,U,a,S,O,E,U,E,C,E,S;I,S,M,K;Q,O,iB,I,Q,I,E,S,O;Y,Q;Q;I;I,O,I,C,K,C,I,O,C,E,S,O,E,M;Q,S,U,K;Y,I;gB,K,U,K;Y,E,O,G;gB,O;Y;Q;Q,S,S,K;Y,I;gB,K,S,C,Q,C;Y,E,O,G;gB,O;Y;Q;Q,S,K,M;Y,O,O,Q,O,S,M,O,O,K,W;Q;Q,K,A,C,Y,U,M,S,c,E,C,E;I;A;AHnB5C;;;CAGG,GACH,SAAe;I,O,gC,I,E,K,G,K,G;QACb,qCAAqC;QACrC,MAAM,OAAO,CAAA,GAAA,yCAAA;QACb,MAAM,IAAI,MAAM,CAAA,GAAA,iCAAA,EAAkB,4BAA4B,KAAK,OAAO,KAAK;QAC/E,OAAO;IACT;AAAC;AAED;;;CAGG,GACH,SAAe;I,O,gC,I,E,K,G,K,G;QACb,aAAa;QACb,MAAM,OAAO,CAAA,GAAA,yCAAA;QACb,MAAM,QAAQ,IAAI;QAClB,MAAM,QAAQ,IAAI;QAClB,mBAAmB;QACnB,KAAK,MAAM,QAAQ,CAAC;YAClB,MAAM,KAAK,KAAK;YAChB,MAAM,MAAM,IAAI,CAAA,GAAA,cAAA,EAAM,KAAK,KAAG,IAAI,GAAG,KAAK,KAAG;YAC7C,MAAM,aAAa,KAAK;YACxB,MAAM,IAAI,IAAI,CAAA,GAAA,wCAAA,EAAM;gBAAE,KAAK;gBAAK,MAAK;gBAAI,MAAK;gBAAa,YAAW;YAAU;YAChF,MAAM,IAAI,IAAI;QAChB;QACA,mBAAmB;QACnB,IAAK,IAAI,IAAI,GAAG,IAAI,KAAK,MAAM,QAAQ,IAAK;YAC1C,MAAM,OAAO,KAAK,KAAK,CAAC,EAAE;YAC1B,MAAM,QAAQ,IAAI,CAAC,EAAE;YACrB,MAAM,MAAM,IAAI,CAAC,EAAE;YACnB,MAAM,IAAI,IAAI,CAAA,GAAA,cAAA,EAAK,OAAO,KAAK,CAAA;YAC/B,MAAM,IAAI,GAAG;QACd;QACD,sBAAsB;QACtB,MAAM,IAAI,MAAM,CAAA,GAAA,cAAA,EAAM,OAAO,OAAO;QACpC,MAAM,OAAO,CAAA,GAAA,cAAA,EAAQ,cAAc,GAAG;QACtC,EAAE,oBAAoB;QACtB,OAAO;IACT;AAAC;IAED,UAAU;AACV,2CAAe;aAAE;sBAAS;AAAgB;;;;;;;;;;;;;;;;;;;A,I,kC,a,U,a,S,O,E,U,E,C,E,S;I,S,M,K;Q,O,iB,I,Q,I,E,S,O;Y,Q;Q;I;I,O,I,C,K,C,I,O,C,E,S,O,E,M;Q,S,U,K;Y,I;gB,K,U,K;Y,E,O,G;gB,O;Y;Q;Q,S,S,K;Y,I;gB,K,S,C,Q,C;Y,E,O,G;gB,O;Y;Q;Q,S,K,M;Y,O,O,Q,O,S,M,O,O,K,W;Q;Q,K,A,C,Y,U,M,S,c,E,C,E;I;A;AKnC1C;;CAEG,GACH,MAAM;IACJ;;;;;;;;;;;;;;KAcG,GACH,YAAY,oBAWX,CAXD;QAYE,IAAI,CAAC,SAAS,qBAAqB;QACnC,IAAI,CAAC,QAAQ,qBAAqB;QAClC,IAAI,CAAC,SAAS,qBAAqB;QACnC,0BAA0B;QAC1B,iDAAiD;QACjD,wBAAwB;QACxB,IAAI,CAAC,cAAc,IAAI;QACvB,IAAI,CAAC,cAAc,IAAI;QACvB,IAAI,CAAC,UAAU,IAAI;QACnB,IAAI,CAAC;QACL,IAAI,CAAC;QACL,IAAI,CAAC;QACL,IAAI,CAAC;QACL,+CAA+C;QAC/C,2CAA2C;QAC3C,IAAI,CAAC,SAAS,IAAI;IACpB;IAEA;;;KAGG,GACG,OAAA;Q,O,gC,I,E,K,G,K,G;YACJ,MAAM,KAAK,YAAY;YAEvB,IAAI,CAAC,SAAS,IAAI;YAElB,uBAAuB;YACvB,IAAI,CAAC,QAAQ,IAAI;YAEjB,oBAAoB;YACpB,IAAI,CAAC,WAAW,IAAI,2BAAoB;gBACtC,QAAQ,IAAI,CAAC;gBACb,WAAW;YACZ;YACD,IAAI,CAAC,SAAS,QAAQ,IAAI,CAAC,OAAO,IAAI,CAAC;YACvC,IAAI,CAAC,SAAS,cAAc,UAAU;YAEtC,iBAAiB;YACjB,IAAI,CAAC,MAAM,IAAI,IAAI,0BAAmB;YACtC,kBAAkB;YAClB,MAAM,mBAAmB,IAAI,8BAAuB,UAAU;YAC9D,iBAAiB,SAAS,IAAI,GAAG,IAAI;YACrC,IAAI,CAAC,MAAM,IAAI;YAEf,4BAA4B;YAC5B,IAAI,CAAC,WAAW,IAAI,CAAA,GAAA,0DAAA,EAAc,IAAI,CAAC,QAAQ,IAAI,CAAC,SAAS;YAC7D,IAAI,CAAC,OAAO,SAAS,IAAI,GAAG,KAAK;YACjC,IAAI,CAAC,SAAS,aAAa;YAC3B,IAAI,CAAC,SAAS,gBAAgB,KAAK,KAAK;YACxC,IAAI,CAAC,SAAS,cAAc;YAC5B,IAAI,CAAC,SAAS,cAAc;YAC5B,IAAI,CAAC,SAAS;YAEd,yDAAyD;YACzD,MAAM,KAAK,YAAY;YACvB,QAAQ,IAAI;YACZ,QAAQ,IAAI,CAAA,mBAAA,EAAsB,KAAK,GAAE,aAAA,CAAe;QAC1D;IAAC;IAED,WAAW;IACX,8CAA8C;IAC9C;;;;;KAKG,GACH,cAAc,OAAgD,EAA9D;QACE,IAAI,CAAC,MAAM,IAAI;IACjB;IAEA,gDAAgD;IAChD;;;KAGG,GACH,aAAA;QACE,+BAA+B;QAC/B,IAAI,CAAC,SAAS,OAAO,IAAI,CAAC,OAAO,IAAI,CAAC;QACtC,IAAI,CAAC,SAAS;IAChB;AACD;IAED,2CAAe;mBACb;AACD;;;;;;AExID,iDAAiD;AACjD,6DAA6D;AAC7D,+FAA+F;;;;;;A,I,kC,a,U,a,S,O,E,U,E,C,E,S;I,S,M,K;Q,O,iB,I,Q,I,E,S,O;Y,Q;Q;I;I,O,I,C,K,C,I,O,C,E,S,O,E,M;Q,S,U,K;Y,I;gB,K,U,K;Y,E,O,G;gB,O;Y;Q;Q,S,S,K;Y,I;gB,K,S,C,Q,C;Y,E,O,G;gB,O;Y;Q;Q,S,K,M;Y,O,O,Q,O,S,M,O,O,K,W;Q;Q,K,A,C,Y,U,M,S,c,E,C,E;I;A;AAM/F;;;;;;CAMG,GACH,SAAe,6CAAuB,CAAS,EAAE,CAAS;I,O,gC,I,E,K,G,K,G;QACxD,+BAA+B;QAC/B,MAAM,QAAQ,IAAI;QAClB,MAAM,QAAQ,IAAI;QAClB,IAAI,MAAM,uCAAuC;QACjD,IAAK,IAAI,IAAI,GAAG,IAAI,GAAG,IAAK;YAC1B,OAAO,IAAI,CAAA,GAAA,wCAAA,EAAM,CAAA;YACjB,gBAAgB;YAChB,MAAM,IAAI,GAAG;QACd;QACD,2CAA2C;QAC3C,8CAA8C;QAC9C,kBAAkB;QAClB,IAAI;QACJ,IAAI;QACJ,IAAI,QAAQ;QACZ,IAAK,IAAI,IAAI,GAAG,IAAI,GAAG,IAAK;YAC1B,IAAK,IAAI,KAAK,GAAG,KAAK,GAAG,KACvB,oDAAoD;YACpD,mCAAmC;YACnC,IAAI,KAAK,IAAI;gBACX,WAAW,KAAK;gBAChB,IAAI,IAAI,UAAU;oBAChB,8DAA8D;oBAC9D,OAAO,IAAI,CAAA,GAAA,cAAA,EAAK,GAAG,IAAI,CAAA;oBACvB,MAAM,IAAI,OAAO;oBACjB,SAAS;gBACV;YACF;QAEJ;QACD,8BAA8B;QAC9B,MAAM,IAAI,IAAI,CAAA,GAAA,cAAA,EAAM,OAAO;QAC3B,0BAA0B;QAC1B,OAAO;IACT;AAAC;IAED,2CAAe;4BAAE;AAAsB;;;;;;;;;;ACpDvC;;;ACAA;;;;CAGG;ACHH;;;CAGG,GASH,SAAS,6BAAO,CAAQ,EAAE,CAAQ;IAChC,MAAM,KAAK,EAAE,IAAI,EAAE;IACnB,MAAM,KAAK,EAAE,IAAI,EAAE;IACnB,MAAM,KAAK,EAAE,IAAI,EAAE;IACnB,OAAO,KAAK,KAAK,KAAK,KAAK,KAAK;AAClC;AAEA,SAAS,iCAAW,KAAa;IAC/B,MAAM,OAA+B;QAAC;QAAK;QAAK;KAAI;IACpD,OAAO,IAAI,CAAC,QAAQ,EAAE;AACxB;AAEA;;;CAGG,GACH,SAAS,+BACP,KAAoB,EACpB,KAAa;IAEb,IAAI,MAAM,WAAW,GAAG,OAAO;IAC/B,IAAI,MAAM,WAAW,GAAG,OAAO;QAAE,MAAM,KAAK,CAAC,EAAE;IAAA;IAE/C,MAAM,OAAO,iCAAW;IACxB,MAAM,SAAS;WAAI;KAAM,CAAC,KAAK,CAAC,GAAG,IAAM,EAAE,KAAK,CAAC,KAAK,GAAG,EAAE,KAAK,CAAC,KAAK;IACtE,MAAM,MAAM,KAAK,MAAM,OAAO,SAAS;IACvC,MAAM,SAAS,MAAM,CAAC,IAAI;IAE1B,MAAM,OAAO,MAAM,IAAI,+BAAS,OAAO,MAAM,GAAG,MAAM,QAAQ,KAAK;IACnE,MAAM,QACJ,MAAM,IAAI,OAAO,SAAS,+BAAS,OAAO,MAAM,MAAM,IAAI,QAAQ,KAAK;IAEzE,OAAO;QAAE,MAAM,SAAI,QAAJ,SAAI,KAAA,IAAJ,OAAQ;QAAW,OAAO,UAAK,QAAL,UAAK,KAAA,IAAL,QAAS;QAAW,MAAM;IAAM;AAC3E;AAEA;;;CAGG,GACH,SAAS,iCACP,IAAiC,EACjC,MAAa,EACb,GAAW,EACX,KAAa,EACb,GAAa;IAEb,IAAI,SAAS,MAAM;IAEnB,MAAM,OAAO,iCAAW;IACxB,MAAM,OAAO,6BAAO,QAAQ,KAAK,KAAK;IACtC,IAAI,QAAQ,KAAK,IAAI,KAAK,KAAK,KAAK;IAEpC,MAAM,YAAY,MAAM,CAAC,KAAK,GAAG,KAAK,KAAK,KAAK,CAAC,KAAK;IACtD,MAAM,cAAc,YAAY;IAEhC,IAAI,aAAa,GAAG;QAClB,IAAI,KAAK,MAAM,iCAAW,KAAK,MAAM,QAAQ,KAAK,QAAQ,GAAG;QAC7D,IAAI,KAAK,SAAS,eAAe,KAAK,iCAAW,KAAK,OAAO,QAAQ,KAAK,QAAQ,GAAG;IACtF,OAAM;QACL,IAAI,KAAK,OAAO,iCAAW,KAAK,OAAO,QAAQ,KAAK,QAAQ,GAAG;QAC/D,IAAI,KAAK,QAAQ,eAAe,KAAK,iCAAW,KAAK,MAAM,QAAQ,KAAK,QAAQ,GAAG;IACpF;AACH;AAMM,SAAU,0CACd,KAAoB,EACpB,MAAc;IAEd,MAAM,OAAO,+BAAS,OAAO;IAC7B,MAAM,WAAW,SAAS;IAC1B,MAAM,SAAS,IAAI;IAEnB,KAAK,MAAM,SAAE,KAAK,UAAE,MAAM,EAAE,IAAI,MAAO;QACrC,MAAM,MAAgB,EAAE;QACxB,IAAI,MAAM,iCAAW,MAAM,OAAO,UAAU,GAAG;QAC/C,OAAO,IAAI,QAAQ;IACpB;IAED,OAAO;AACT;;;ADlFA,MAAM;IAAN,aAAA;QACU,IAAA,CAAA,SAA8B,IAAI;IAe5C;IAbE,KAAK,CAAS,EAAd;QACE,IAAI,CAAC,IAAI,CAAC,OAAO,IAAI,IAAI,IAAI,CAAC,OAAO,IAAI,GAAG;QAC5C,IAAI,IAAI,CAAC,OAAO,IAAI,OAAO,GACzB,IAAI,CAAC,OAAO,IAAI,GAAG,IAAI,CAAC,KAAK,IAAI,CAAC,OAAO,IAAI;QAE/C,OAAO,IAAI,CAAC,OAAO,IAAI;IACzB;IAEA,MAAM,CAAS,EAAE,CAAS,EAA1B;QACE,MAAM,KAAK,IAAI,CAAC,KAAK;QACrB,MAAM,KAAK,IAAI,CAAC,KAAK;QACrB,IAAI,OAAO,IAAI,IAAI,CAAC,OAAO,IAAI,IAAI;IACrC;AACD;AAKK,SAAU;IACd,OAAO;QACL,SAAQ,KAAY,EAAE,OAAiC;YACrD,MAAM,qBAAE,iBAAiB,EAAE,GAAG;YAC9B,MAAM,OAAO,MAAM;YACnB,MAAM,QAAiD,EAAE;YACzD,KAAK,MAAM,CAAC,QAAQ,MAAM,IAAI,KAC5B,MAAM,KAAK;uBAAE;wBAAO;YAAM;YAG5B,IAAI,MAAM,WAAW,GACnB,OAAO;gBAAE,eAAe,IAAI;gBAAO,kBAAkB,IAAI;gBAAO,YAAY,EAAE;YAAA;YAGhF,MAAM,eAAe,CAAA,GAAA,yCAAA,EAAmB,OAAO;YAC/C,MAAM,KAAK,IAAI;YAEf,KAAK,MAAM,CAAC,QAAQ,UAAU,IAAI,aAChC,KAAK,MAAM,SAAS,UAClB,GAAG,MAAM,QAAQ;YAIrB,MAAM,kBAAkB,IAAI;YAC5B,IAAI,SAAS;YACb,MAAM,gBAAgB,IAAI;YAC1B,MAAM,iBAAiB,IAAI;YAE3B,KAAK,MAAM,UAAE,MAAM,EAAE,IAAI,MAAO;gBAC9B,MAAM,OAAO,GAAG,KAAK;gBACrB,IAAI,CAAC,gBAAgB,IAAI,OACvB,gBAAgB,IAAI,MAAM;gBAE5B,MAAM,MAAM,gBAAgB,IAAI;gBAChC,cAAc,IAAI,QAAQ;gBAC1B,IAAI,CAAC,eAAe,IAAI,MAAM,eAAe,IAAI,KAAK,EAAE;gBACxD,eAAe,IAAI,KAAM,KAAK;YAC/B;YAED,MAAM,mBAAmB,IAAI;YAC7B,KAAK,MAAM,CAAC,KAAK,KAAK,IAAI,eAAgB;gBACxC,MAAM,SAAS,KAAK,IAAI,CAAC,KAAO,KAAK,IAAI;gBACzC,iBAAiB,IAAI,KAAK,CAAA,GAAA,cAAA,EAAgB,SAAS;YACpD;YAED,MAAM,aAAa;mBAAI,eAAe;aAAO;YAE7C,OAAO;+BAAE;kCAAe;4BAAkB;YAAU;QACtD;IACD;AACH;;CDjFG;;;;AGHH;;;;CAGG;;;;A,I,kC,a,U,a,S,O,E,U,E,C,E,S;I,S,M,K;Q,O,iB,I,Q,I,E,S,O;Y,Q;Q;I;I,O,I,C,K,C,I,O,C,E,S,O,E,M;Q,S,U,K;Y,I;gB,K,U,K;Y,E,O,G;gB,O;Y;Q;Q,S,S,K;Y,I;gB,K,S,C,Q,C;Y,E,O,G;gB,O;Y;Q;Q,S,K,M;Y,O,O,Q,O,S,M,O,O,K,W;Q;Q,K,A,C,Y,U,M,S,c,E,C,E;I;A;AAWG,SAAgB,yCACpB,aAAoB,EACpB,aAA4B;I,I;I,O,gC,I,E,K,G,K,G;QAE5B,MAAM,iBAAE,aAAa,oBAAE,gBAAgB,cAAE,UAAU,EAAE,GAAG;QACxD,MAAM,QAAQ,IAAI;QAClB,MAAM,QAAQ,IAAI;QAElB,KAAK,MAAM,OAAO,WAAY;YAC5B,MAAM,MAAM,iBAAiB,IAAI;YACjC,MAAM,IAAI,IAAI,CAAA,GAAA,wCAAA,EAAM;qBAAE;YAAG;YACzB,MAAM,IAAI,KAAK;QAChB;QAED,MAAM,YAAY,IAAI;QACtB,MAAM,MAAM,CAAC,GAAW,IAAe,KAAK,IAAI,CAAA,EAAG,EAAC,CAAA,EAAI,EAAC,CAAE,GAAG,CAAA,EAAG,EAAC,CAAA,EAAI,EAAC,CAAE;QAEzE,KAAK,MAAM,GAAG,KAAK,IAAI,cAAc,MAAO;YAC1C,MAAM,KAAK,cAAc,IAAI,KAAK;YAClC,MAAM,KAAK,cAAc,IAAI,KAAK;YAClC,IAAI,OAAO,aAAa,OAAO,WAAW;YAC1C,IAAI,OAAO,IAAI;YACf,MAAM,IAAI,IAAI,IAAI;YAClB,UAAU,IAAI,GAAG,AAAC,CAAA,AAAA,CAAA,KAAA,UAAU,IAAI,EAAC,MAAC,QAAA,OAAA,KAAA,IAAA,KAAI,CAAA,IAAK;QAC5C;QAED,IAAI,MAAM;QACV,KAAK,MAAM,CAAC,GAAG,MAAM,IAAI,UAAW;YAClC,MAAM,CAAC,GAAG,EAAE,GAAG,EAAE,MAAM,KAAK,IAAI;YAChC,MAAM,IAAI,OAAO,IAAI,CAAA,GAAA,cAAA,EAAK,GAAG,GAAG;uBAAE;YAAK;QACxC;QAED,MAAM,aAAa,IAAI,CAAA,GAAA,cAAA,EAAM,OAAO;QACpC,MAAM,WAAW;QACjB,OAAO;I;AACR;;;A,I,kC,a,U,a,S,O,E,U,E,C,E,S;I,S,M,K;Q,O,iB,I,Q,I,E,S,O;Y,Q;Q;I;I,O,I,C,K,C,I,O,C,E,S,O,E,M;Q,S,U,K;Y,I;gB,K,U,K;Y,E,O,G;gB,O;Y;Q;Q,S,S,K;Y,I;gB,K,S,C,Q,C;Y,E,O,G;gB,O;Y;Q;Q,S,K,M;Y,O,O,Q,O,S,M,O,O,K,W;Q;Q,K,A,C,Y,U,M,S,c,E,C,E;I;A;AHvCD;;;;;;;CAOG,GACH,SAAe,wCACb,KAAY,EACZ,OAAiC;I,O,gC,I,E,K,G,K,G;QAEjC,MAAM,WAAW,CAAA,GAAA,yCAAA;QACjB,MAAM,SAAS,SAAS,QAAQ,OAAO;QACvC,OAAO,CAAA,GAAA,8CAAA,EAAqB,OAAO;IACrC;AAAC;AAED;;;;;;;CAOG,GACH,SAAe,wCACb,KAAY,EACZ,QAAyB,EACzB,OAAgC;I,O,gC,I,E,K,G,K,G;QAEhC,MAAM,SAAS,SAAS,QAAQ,OAAO;QACvC,OAAO,CAAA,GAAA,8CAAA,EAAqB,OAAO;IACrC;AAAC;IAKD,2CAAe;uBACb;uBACA;AACD;;","sources":["Src/Drawing/Drawing.ts","Src/HelperClasses/Utilities.ts","Src/HelperClasses/GeometryHelpers.ts","Src/HelperClasses/Point.ts","Src/HelperClasses/Line.ts","Src/GraphAlgorithms/GraphMethods.ts","Src/Core/Graph.ts","Src/Core/Edge.ts","Src/Drawing/ThreeJSDrawer.ts","Src/Drawing/ThickLine.ts","Src/Drawing/MeshLineGeometry.ts","Src/Drawing/MeshLineMaterial.ts","Src/Shaders/vertexShader.glsl.ts","Src/Shaders/fragmentShader.glsl.ts","Src/index.ts","Src/Core/index.ts","Src/GraphAlgorithms/index.ts","Src/SampleData/index.ts","Src/SampleData/DataLoader.ts","Src/SampleData/ZKC.ts","Src/SampleData/ZKC_simulated.ts","Src/HelperClasses/GraphConstructors.ts","Src/Core/_Node.ts","Src/Drawing/GraphDrawer.ts","Src/Models/index.ts","Src/Models/ErdosRenyiModel.ts","Src/Hierarchy/index.ts","Src/Hierarchy/KDDistanceStrategy.ts","Src/Hierarchy/KDTree.ts","Src/Hierarchy/buildSimplifiedGraph.ts"],"sourcesContent":["import Utilities from \"../HelperClasses/Utilities\";\nimport GeometryHelpers from \"../HelperClasses/GeometryHelpers\";\nimport Point from \"../HelperClasses/Point\";\nimport Line from \"../HelperClasses/Line\";\nimport Edge from \"../Core/Edge\";\nimport GraphMethods from \"../GraphAlgorithms/GraphMethods\";\nimport Graph from \"../Core/Graph\";\nimport _Node from \"../Core/_Node\";\n\n/**\n * Simulates Kamada kawai for a network in 2d. 3d is not supported yet\n * Note: This is an async function as it take time for some of the large graphs\n *\n * @param Graph - The first input number\n * @param iterations - The second input number\n *  @param simulationBound - The bounds of simulation (Mostly a global number to scale the graph up or down)\n *  @param cohesionValue - How sticky the nodes are i.r. how much they cluster together\n * @returns And node map of all the nodes and their simulated positions - Please note: position maps have to to be applied to the graph!\n *\n */\nasync function SimulateKamadaKawai(\n  Graph: Graph,\n  iterations: number,\n  simulationBound: number = 100,\n  cohesionValue: number = 1,\n  repulsionValue: number = 1\n) {\n  const adjList = Graph.get_adjacency();\n  // pos map\n  const PosMapX: Map<number, number> = new Map();\n  const PosMapY: Map<number, number> = new Map();\n  let rx, ry;\n  for (const node of adjList.keys()) {\n    rx = Math.random() * simulationBound;\n    ry = Math.random() * simulationBound;\n    PosMapX.set(node, rx);\n    PosMapY.set(node, ry);\n  }\n  // start simulation\n  for (let i = 0; i < iterations; i++) {\n    // calculate the clustering force\n    // these two keep track of the node being simulated's\n    // position - redeclaring is sorta unncessary\n    let nodeX: number;\n    let nodeY: number;\n    // also keep track of all the x_s and y_s\n    let x_s: number[];\n    let y_s: number[];\n    // also the same thing for the clustering force\n    let y_r: number[];\n    let x_r: number[];\n    // same thing for the cohesion values that get recalculated\n    let new_c_xpos_dispacement: number;\n    let new_c_ypos_dispacement: number;\n    let new_x_r_pos: number;\n    let new_y_r_pos: number;\n    let new_c_xpos: number;\n    let new_c_ypos: number;\n    let new_g_xpos_displacement: number;\n    let new_g_ypos_displacement: number;\n\n    for (const node of adjList.keys()) {\n      // this chunk is for the attraction force\n      // get the node pos\n      const neighbours = adjList.get(node)!;\n      // remember always declare this nodes details\n      nodeX = PosMapX.get(node)!;\n      nodeY = PosMapY.get(node)!;\n      // get the set of x's\n      x_s = [];\n      // get the set of y's\n      y_s = [];\n      // now iterate through the pos list and append\n      neighbours.forEach((n_s) => {\n        const n_pos_x = PosMapX.get(n_s)!;\n        const n_pos_y = PosMapY.get(n_s)!;\n        x_s.push(n_pos_x);\n        y_s.push(n_pos_y);\n      });\n      // now average out the values\n      new_c_xpos = Utilities.calculateAverage(x_s);\n      new_c_ypos = Utilities.calculateAverage(y_s);\n\n      // this chunk is for the repelling force\n      y_r = [];\n      x_r = [];\n      let diffx: number;\n      let diffy: number;\n      let othernodeX: number;\n      let othernodeY: number;\n\n      // then find the element\n      for (const otherNode of Graph.nodes.keys()) {\n        // get the position of all the other nodes\n        if (otherNode != node) {\n          // calculate inverse distance\n          othernodeX = PosMapX.get(otherNode)!;\n          othernodeY = PosMapY.get(otherNode)!;\n          diffx = othernodeX - nodeX;\n          diffy = othernodeY - nodeY;\n          // get the inverse square value\n          // add that to the *_r arrays\n          x_r.push(diffx);\n          y_r.push(diffy);\n        }\n      }\n      // this is the repulsion value\n      new_x_r_pos =\n        (repulsionValue * 1) /\n        (Utilities.calculateAverage(x_r) * Utilities.calculateAverage(x_r));\n      new_y_r_pos =\n        (repulsionValue * 1) /\n        (Utilities.calculateAverage(y_r) * Utilities.calculateAverage(y_r));\n\n      // calculate the dispacement amount in c/y pos\n      // this is the cohesion value\n      new_c_xpos_dispacement = cohesionValue * (new_c_xpos - nodeX);\n      new_c_ypos_dispacement = cohesionValue * (new_c_ypos - nodeY);\n\n      // Also move all the points towards the center a little bit\n      // so that the graph doesent explode out\n      new_g_xpos_displacement = cohesionValue * (0 - nodeX);\n      new_g_ypos_displacement = cohesionValue * (0 - nodeY);\n\n      // then add the x and y components of the two vectors\n      const new_xpos =\n        new_x_r_pos + new_g_xpos_displacement + new_c_xpos_dispacement + nodeX;\n      const new_ypos =\n        new_y_r_pos + new_g_ypos_displacement + new_c_ypos_dispacement + nodeY;\n\n      // now set these positions\n      PosMapX.set(node, new_xpos);\n      PosMapY.set(node, new_ypos);\n    }\n  }\n  // return the position\n  // keep in mind three JS works with Y upwards and not Z\n  // in my head I work the other way round so Im swapping the Z and Y values here\n  let PosMap: Map<number, Point> = new Map();\n  for (const p of PosMapX.keys()) {\n    PosMap.set(p, new Point(PosMapX.get(p)!, 0, PosMapY.get(p)!));\n  }\n  // get / set positions\n  // move the points\n  // Since this simulation might have moved the whole graph off screen\n  // get the average pos\n  const sim_x = [];\n  const sim_y = [];\n  const sim_z = [];\n  let interimPoint;\n  for (const p of PosMap.keys()) {\n    interimPoint = PosMap.get(p)!;\n    sim_x.push(interimPoint.x);\n    sim_y.push(interimPoint.y);\n    sim_z.push(interimPoint.z);\n  }\n\n  const x_displacement = Utilities.calculateAverage(sim_x);\n  const y_displacement = Utilities.calculateAverage(sim_y);\n  const z_displacement = Utilities.calculateAverage(sim_z);\n  const dispacementVector = new Point(\n    -x_displacement,\n    -y_displacement,\n    -z_displacement\n  );\n\n  PosMap = MovePmap(PosMap, dispacementVector);\n  return PosMap;\n}\n\n/**\n *\n * Randomly sets all the positions for a graph\n * Not really very useful but I've used it in some cases and have kept it around\n *\n *  @param Graph - The graph who's nodes you would want to reposition\n *\n * @return A position map of all the nodes and its corresponding positions\n */\nfunction InstanciateRandomPositions(Graph: Graph) {\n  const adjList = Graph.get_adjacency();\n  const PosMapX: Map<number, number> = new Map();\n  const PosMapY: Map<number, number> = new Map();\n  for (const node of adjList.keys()) {\n    PosMapX.set(node, Math.random() * 200);\n    PosMapY.set(node, Math.random() * 200);\n  }\n  const PosMap: Map<number, Point> = new Map();\n  for (const p of PosMapX.keys()) {\n    PosMap.set(p, new Point(PosMapX.get(p)!, 0, PosMapY.get(p)!));\n  }\n  return PosMap;\n}\n\n/**\n *\n * Constructs the edges as lines, Note: these are just a representation of the lines\n * they then have to be visulized using one of the Three JS Drawer functions like\n * draw a thick line or a thin line. This draws out the edges divided by some number of\n * divisions that you specify\n *\n * @param Graph - The graph whos edges are getting drawn\n * @param divDistance - How many divisions (distance) to make along the edge\n * @returns A line map - which holds a map of all the edge indices and the corresponding line representations\n */\nfunction DrawEdgeLines(Graph: Graph, divDistance: number) {\n  // this is the return map\n  const lineMap: Map<number, Line> = new Map();\n  let edge: Edge;\n  let start: Point;\n  let end: Point;\n  for (const key of Graph.edges.keys()) {\n    edge = Graph.edges.get(key)!;\n    // get the start pos\n    start = Graph.nodes.get(edge.start)!.data.pos;\n    end = Graph.nodes.get(edge.end)!.data.pos;\n    const Line = GeometryHelpers.line_from_start_end_distance(\n      start,\n      end,\n      divDistance\n    );\n    lineMap.set(key, Line);\n  }\n  return lineMap;\n}\n\n/**\n *\n * Constructs the edges as lines, Note: these are just a representation of the lines\n * they then have to be visulized using one of the Three JS Drawer functions like\n * draw a thick line or a thin line - this draws them based on the number of divisions\n * you would like them to have\n * @param Graph - The graph whos edges are getting drawn\n * @param numberOfDivs - How many divisions to make along the edge\n * @returns A line map - which holds a map of all the edge indices and the corresponding line representations\n */\nfunction DrawEdgeLinesDivisions(Graph: Graph, numberOfDivs: number) {\n  // this is the return map\n  const lineMap: Map<number, Line> = new Map();\n  let edge: Edge;\n  let start: Point;\n  let end: Point;\n  for (const key of Graph.edges.keys()) {\n    edge = Graph.edges.get(key)!;\n    // get the start pos\n    start = Graph.nodes.get(edge.start)!.data.pos;\n    end = Graph.nodes.get(edge.end)!.data.pos;\n    const Line = GeometryHelpers.line_from_start_end_divisions(\n      start,\n      end,\n      numberOfDivs\n    );\n    lineMap.set(key, Line);\n  }\n  return lineMap;\n}\n\n/**\n *\n * Edge bundling - this isnt as fast as the current KDE based methods - but it provides a basic  method of\n * Visualizing large edge flows. Note: This is an aysnc function as it takes a while for the edge bundling to happen\n *\n * @param LineMap - The map of edges as a line map\n * @param iterations - The number of iterations to run edge bundling\n * @param distance - A shorthand for how close together the vertices need to be before they get influnced by each other\n * @returns A line map with all the updated positions of the line (Where they are bundled together) Again - this needs to be applied to the graph!\n */\nasync function DrawEdgeBundling(\n  LineMap: Map<number, Line>,\n  iterations: number,\n  distance: number\n) {\n  // first create a deep copy of the map\n  const returnArray = new Map<number, Line>();\n  for (let key of LineMap.keys()) {\n    returnArray.set(key, structuredClone(LineMap.get(key)!));\n  }\n  // variables that are getting reused\n  let line: Line;\n  let otherLine: Line;\n  let x_s: number[];\n  let y_s: number[];\n  let z_s: number[];\n  let pnt: Point;\n  let otherpoint: Point;\n  let d: number;\n  let x_d: number;\n  let y_d: number;\n  let z_d: number;\n  let avgx: number;\n  let avgy: number;\n  let avgz: number;\n  // run it for whatever number of iterations\n  for (let i = 0; i < iterations; i++) {\n    // then iterate through every line\n    for (let key of returnArray.keys()) {\n      // then get the line that we are working with\n      line = returnArray.get(key)!;\n      // then for each point in the line we have to move it closer to the other points\n      for (let ii = 1; ii < line.points.length - 1; ii++) {\n        // then get the point that we need to work with\n        x_s = [];\n        y_s = [];\n        z_s = [];\n        pnt = line.points[ii];\n        // then run the point accumulation algoritm\n        for (let otherKey of returnArray.keys()) {\n          if (otherKey != key) {\n            // then get the other line\n            otherLine = returnArray.get(otherKey)!;\n            for (let iii = 1; iii < otherLine.points.length - 1; iii++) {\n              otherpoint = otherLine.points[iii];\n              d = Utilities.calculateSquaredDistance(pnt, otherpoint);\n              if (d <= Math.pow(distance, 2)) {\n                x_d = otherpoint.x - pnt.x;\n                y_d = otherpoint.y - pnt.y;\n                z_d = otherpoint.z - pnt.z;\n                x_s.push(x_d);\n                y_s.push(y_d);\n                z_s.push(z_d);\n              }\n            }\n          }\n        }\n        // now create a new displacement amount\n        avgx = pnt.x + 0.8 * (Utilities.calculateAverage(x_s) || 0);\n        avgy = pnt.y + 0.8 * (Utilities.calculateAverage(y_s) || 0);\n        avgz = pnt.z + 0.8 * (Utilities.calculateAverage(z_s) || 0);\n        const newPoint = new Point(avgx, avgy, avgz);\n        line.points[ii] = newPoint;\n      }\n    }\n  }\n  // now return that new map\n  return returnArray;\n}\n\n/**\n *\n * Displace the edges vertically, almost akin to the Deck.gl arcs\n * The displacement is done in a sin curve with the ends still touching the nodes\n * Note: This is an inplace modification of the edges\n *\n * @param LineMap - The map of edges as a line map\n * @param displacement - the amount of vertical displacement\n */\nfunction DisplaceEdgeInY(LineMap: Map<number, Line>, displacement: number) {\n  const returnArray = new Map<number, Line>();\n  for (let key of LineMap.keys()) {\n    returnArray.set(key, structuredClone(LineMap.get(key)!));\n  }\n  for (const key of returnArray.keys()) {\n    const line = returnArray.get(key)!;\n    // now for all the points in this\n    let pnt, ydisval;\n    for (let i = 0; i < line.points.length; i++) {\n      pnt = line.points[i];\n      ydisval =\n        displacement * Math.sin((Math.PI * i) / (line.points.length - 1));\n      pnt.y = pnt.y + ydisval;\n    }\n  }\n  return returnArray;\n}\n\n/**\n *\n * Displace the vertices vertically based on some prameter (For example degree or modularity)\n *\n * @param Graph - the graph whos nodes have to be displaced\n * @param parameter - the prameter based on which you want to modify the\n * @param displacement - the maximum amunt of displacement, all the other values are rescaled linerly\n */\nfunction DisplaceVertices(\n  Graph: Graph,\n  parameter: string,\n  displacement: number\n) {\n  let max: number = 0;\n  let value: number, ydisplacement: number;\n  // go through the thing and set the min max values\n  for (let node of Graph.nodes.values()) {\n    value = eval(\"node.data.\" + parameter);\n    if (value >= max) {\n      max = value;\n    }\n  }\n  // go through the nodes again and set the values\n  for (const node of Graph.nodes.values()) {\n    value = eval(\"node.data.\" + parameter);\n    ydisplacement = (value / max) * displacement;\n    // now filter the values so that we know that the values are between a max and a min\n    ydisplacement = Math.max(0, ydisplacement); // this sets the lower bound to be something\n    ydisplacement = Math.min(displacement, ydisplacement); // this sets the upper bound of the thing\n    node.data.pos.y = ydisplacement;\n  }\n}\n\n/**\n *\n * Generates a hive plot for a graph, this includes the option to displace the graph vertically based on degrees and how far away each node is\n *\n * @param Graph - The graph\n * @param selectedNode - the node around which the hive plot is generated\n * @param step - If the hive should step up or down if yes then by what increments\n * @param startPosition - Starting position\n * @returns\n */\nasync function HivePlot(\n  Graph: Graph,\n  selectedNode: number,\n  step: number,\n  startPosition: Point\n) {\n  const adj = Graph.get_adjacency();\n  const DijkstraDepth = await GraphMethods.Dijkstra(Graph, selectedNode);\n  // calculate the number of steps that I am searching through\n  const steps = Math.max(...[...DijkstraDepth.values()]);\n  // step map\n  const stepMap = new Map();\n  // now create a stepped ring of stuff\n  for (let i = 0; i <= steps; i++) {\n    const ntier = [];\n    for (const nkey of DijkstraDepth.keys()) {\n      if (i == DijkstraDepth.get(nkey)) {\n        ntier.push(nkey);\n      }\n    }\n    stepMap.set(i, ntier);\n  }\n  // the returning pos map\n  const Pmap = new Map();\n  // now find the relevant node Positions\n  // get the start positions\n  const xoff = startPosition.x || 0;\n  const yoff = startPosition.y || 0;\n  const zoff = startPosition.z || 0;\n  // set the positions\n  for (const node of adj.keys()) {\n    const yval = DijkstraDepth.get(node)! * step;\n    const depthArr = stepMap.get(DijkstraDepth.get(node));\n    const angle = 2 * Math.PI * (depthArr.indexOf(node) / depthArr.length);\n    const xval = Math.sin(angle) * yval;\n    const zval = Math.cos(angle) * yval;\n    // construct a new point\n    const pnt = new Point(xval + xoff, -yval + yoff, zval + zoff);\n    Pmap.set(node, pnt);\n  }\n  // simulate the lines\n  Graph.apply_position_map(Pmap);\n  const lmap = DrawEdgeLines(Graph, 1);\n  const newLmap = await DrawEdgeBundling(lmap, 12, 5);\n  return { pmap: Pmap, emap: newLmap };\n}\n\n/**\n * Move a graph somewhere (like the physical location) - This is an inplace movement and overwrites existing values\n *\n * @param Graph - The graph that has to be moved\n * @param dispacement - This is a point and I end up using Point and Vector interchangably. So here the xyz values from the point are used to displace the nodes\n */\nfunction MoveGraph(Graph: Graph, dispacement: Point) {\n  const Gmap = Graph.get_map();\n  const NewPmap = MovePmap(Gmap.pmap, dispacement);\n  const NewEmap = MoveEmap(Gmap.emap, dispacement);\n  Graph.apply_drawing_maps({ pmap: NewPmap, emap: NewEmap });\n}\n\n/**\n *\n * Move the nodes somewhere (Or the nodemap corresponding to the graph) - This is not an overwrite rather returns a new position map for the nodes to moved\n *\n * @param NodeM\n * ap - The Current position map of the graph\n * @param displacement - The Displacement vector\n * @returns - A new position map\n */\nfunction MovePmap(NodeMap: Map<number, Point>, displacement: Point) {\n  const newPmap: Map<number, Point> = new Map();\n  for (let node of NodeMap.keys()) {\n    const p = NodeMap.get(node)!;\n    p.translate(displacement);\n    newPmap.set(node, p);\n  }\n  return newPmap;\n}\n\n/**\n *\n * Move the edges somewhere (the edgemap corresponding to the graph) - This is not an overwrite and returns a new edge map for the edges to be moved too\n *\n * @param LineMap - The current line map, this is made up of lines\n * @param dispacement - The displacement vector\n * @returns - The new line map\n */\nfunction MoveEmap(LineMap: Map<number, Line>, dispacement: Point) {\n  const newEmap: Map<number, Line> = new Map();\n  // variables - instead of redeclaring\n  let interimPoints: Point[];\n  let interimLine: Line;\n  let newLine: Line;\n  for (let lineNumber of LineMap.keys()) {\n    // reset the interim points\n    interimPoints = [];\n    // get the line\n    interimLine = LineMap.get(lineNumber)!;\n    // move all the points\n    for (let pnt of interimLine.points) {\n      pnt.translate(dispacement);\n      // add this to the new stack of lines\n      interimPoints.push(pnt);\n    }\n    // create a new line\n    newLine = new Line(interimPoints);\n    // add this to the new map\n    newEmap.set(lineNumber, newLine);\n  }\n  return newEmap;\n}\n\n// THIS IS THE BIT THATS A BIT CONFUSING\n/*\nData for visualization is store in the graph under the elements data\nSo for example - the position data under a point in the graph is under \n- Graph.nodes.get(whatever node).data.pos \n*/\n// commenting out because appears to be redundant\n// update edge lines after moving points or something\n// this redraws the lines based on distance\n/**\n *\n *  Draw new lines from edges, and draw them based on the distance of divisions (i.e. divide the line up every 10 units) Note: This is an in place update that takes place on the graph - it overwrites the existing data.\n *\n * @param Graph - The grapht who's edges have to be updated\n * @param divDistance - The distance by which the divisions are made\n */\nfunction UpdateEdgeLinesDist(Graph: Graph, divDistance: number) {\n  let edge: Edge;\n  let start: Point;\n  let end: Point;\n  let line: Line;\n  for (const key of Graph.edges.keys()) {\n    edge = Graph.edges.get(key)!;\n    // get the start pos\n    start = Graph.nodes.get(edge.start)!.data.pos;\n    end = Graph.nodes.get(edge.end)!.data.pos;\n    line = GeometryHelpers.line_from_start_end_distance(\n      start,\n      end,\n      divDistance\n    );\n    edge.data.ldata = line;\n  }\n}\n\n/**\n * \n * Draw new lines from edges, and draw them based on divisions (i.e. divide the line into 10 units) Note: This is an in place update that takes place on the graph - it overwrites the existing data.\n\n * @param Graph - The grapht who's edges have to be updated\n * @param Divs - The number of divisions to be made\n */\nfunction UpdateEdgeLinesDivs(Graph: Graph, Divs: number) {\n  let edge: Edge;\n  let start: Point;\n  let end: Point;\n  let line: Line;\n  for (const key of Graph.edges.keys()) {\n    edge = Graph.edges.get(key)!;\n    // get the start pos\n    start = Graph.nodes.get(edge.start)!.data.pos;\n    end = Graph.nodes.get(edge.end)!.data.pos;\n    line = GeometryHelpers.line_from_start_end_divisions(start, end, Divs);\n    edge.data.ldata = line;\n  }\n}\n\nexport default {\n  SimulateKamadaKawai,\n  DrawEdgeLines,\n  DrawEdgeLinesDivisions,\n  DrawEdgeBundling,\n  HivePlot,\n  DisplaceEdgeInY,\n  MoveGraph,\n  InstanciateRandomPositions,\n  DisplaceVertices,\n  // these two are special functions\n  UpdateEdgeLinesDist,\n  UpdateEdgeLinesDivs,\n};\n","import Point from \"./Point\";\n\n// Calculate average\n/**\n * calculate the average of an array of numberss\n * @param arr an array of number whose average has to be calculated\n * @returns the average\n */\nfunction calculateAverage(arr: number[]) {\n  let runningSum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    runningSum = runningSum + arr[i];\n  }\n  const avg = runningSum / arr.length;\n  if (Number.isNaN(avg)) {\n    return 0;\n  }\n  return avg;\n}\n\n// calculate distance between two points\n/**\n * Calculate the distance betweeen two points\n * @param p1 the first point\n * @param p2 the second point\n * @returns the distance between the points\n */\nfunction calculateDistance(p1: Point, p2: Point) {\n  const d = Math.pow(\n    Math.pow(p1.x - p2.x, 2) +\n      Math.pow(p1.y - p2.y, 2) +\n      Math.pow(p1.z - p2.z, 2),\n    0.5\n  );\n  return d;\n}\n\n// calculate squared distance sometimes we dont really need\n// the actual root but just a rough idea\n/**\n * Calculate the squared distance between two points\n * @param p1 the first point\n * @param p2 the second point\n * @returns the squared distance between the two points\n */\nfunction calculateSquaredDistance(p1: Point, p2: Point) {\n  const d =\n    Math.pow(p1.x - p2.x, 2) +\n    Math.pow(p1.y - p2.y, 2) +\n    Math.pow(p1.z - p2.z, 2);\n  return d;\n}\n\n// get a random subset of something from a array of things\n// must provide the number of things we want from that array\n/**\n * get a random subset of something from a array of things must provide the number of things we want from that array\n * @param arr the array from which the subset has to be made\n * @param n number of items to select\n * @returns a new array made up of a random sample from the original array\n */\nfunction getRandomSubset(arr: any[], n: number) {\n  var result = new Array(n),\n    len = arr.length,\n    taken = new Array(len);\n  if (n > len)\n    throw new RangeError(\"getRandom: more elements taken than available\");\n  while (n--) {\n    var x = Math.floor(Math.random() * len);\n    result[n] = arr[x in taken ? taken[x] : x];\n    taken[x] = --len in taken ? taken[len] : len;\n  }\n  return result;\n}\n\n/**\n * This is a super useful method to get a random number of edges or something that you would like to draw\n * this is primarily done because there are way too many edges sometimes and and the number of edges is really\n * What slows the whole rendering process down\n * @param map - the map that youd like to reduce\n * @param n - the fraction of items that youd like to return from this map\n * @returns A reduced map with a fractio of those many entries\n */\nfunction getRandomSubset_map(map: Map<number, any>, n: number) {\n  const newMap = new Map();\n  let prob;\n  for (const item of map.keys()) {\n    prob = Math.random();\n    if (prob < n) {\n      newMap.set(item, map.get(item));\n    }\n  }\n  return newMap;\n}\n\nexport default {\n  calculateAverage,\n  calculateDistance,\n  calculateSquaredDistance,\n  getRandomSubset,\n  getRandomSubset_map,\n};\n","import Point from \"./Point\";\nimport Line  from \"./Line\";\nimport Utilities from \"./Utilities\";\n\n/**\n * Creates a line based on the number of divisons\n *\n * @param start the start point\n * @param end the end point\n * @param divisions the number of divisions\n * @returns the line object\n */\nfunction line_from_start_end_divisions(\n  start: Point,\n  end: Point,\n  divisions: number\n) {\n  // create a start and end time\n  const Start = new Point(start.x, start.y, start.z);\n  const End = new Point(end.x, end.y, end.z);\n  // interpolated points\n  const points: Point[] = [];\n  // divisions\n  for (let i = 0; i <= divisions; i++) {\n    const interVar = i / divisions;\n    const newx = interVar * Start.x + (1 - interVar) * End.x;\n    const newy = interVar * Start.y + (1 - interVar) * End.y;\n    const newz = interVar * Start.z + (1 - interVar) * End.z;\n    const newPoint = new Point(newx, newy, newz);\n    points.push(newPoint);\n  }\n  // create a new line\n  const SubdividedLine = new Line(points);\n  return SubdividedLine;\n}\n\n/**\n * Divides the line into a number of divisions based on distance\n * @param start - the start point\n * @param end - the end point\n * @param distance - the distance at which this line must be divided\n * @returns A line object with the right number of points\n */\nfunction line_from_start_end_distance(\n  start: Point,\n  end: Point,\n  distance: number\n) {\n  const dist = Utilities.calculateDistance(start, end);\n  const divs = Math.round(dist / distance) + 2;\n  const subdivline = line_from_start_end_divisions(start, end, divs);\n  return subdivline;\n}\n\n/**\n * Calculates the centroid of an array of points\n * @param points An array of points\n * @returns the central point of the array of points\n */\nfunction centroid(points: Point[]) {\n  let rx = 0;\n  let ry = 0;\n  let rz = 0;\n  points.forEach((element) => {\n    rx += element.x;\n    ry += element.y;\n    rz += element.z;\n  });\n  rx = rx / points.length;\n  ry = ry / points.length;\n  rz = rz / points.length;\n  const centroid = new Point(rx, ry, rz);\n  return centroid;\n}\n\nexport default {\n  line_from_start_end_divisions,\n  line_from_start_end_distance,\n  centroid,\n};\n","interface Point {\n  x: number;\n  y: number;\n  z: number;\n}\n\nclass Point {\n  /**\n   * Constructs a point based on the x y z values\n   * @param x x value \n   * @param y y value\n   * @param z z value \n   */\n  constructor(x:number, y:number, z:number) {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n  }\n\n  // Points are somewhat the same thing as a vector \n  // So im using the same type instead of redeclaring the \n  // Type\n  /**\n   * Displaces a point - note this method moves the existing point\n   * @param Point - Displacement vector (used as a point)\n   */\n  translate(Point:Point) {\n    this.x = this.x + Point.x;\n    this.y = this.y + Point.y;\n    this.z = this.z + Point.z;\n  }\n}\n\nexport default Point;\n","import Point from \"./Point\";\n\ninterface Line {\n  points: Point[];\n}\n\nclass Line {\n  /**\n   * Constructs a line from an array of points\n   * @param points an array of points\n   */\n  constructor(points: Point[]) {\n    this.points = [];\n    points.forEach((p) => {\n      const point = new Point(p.x, p.y, p.z);\n      this.points.push(point);\n    });\n  }\n}\n\nexport default Line;\n","import Edge from \"../Core/Edge\";\nimport Graph from \"../Core/Graph\";\nimport _Node from \"../Core/_Node\";\n\n// do a BFS Search Starting from some point\n// searches the whole graph and returns a map of which node\n// was searched from where\n// to speed this up all the nodes are actually numbers\n/**\n * \n * Performs a BFS search on a graph - Async because it takes a while on large graphs\n * \n * @param Graph - The graph which has to be searched using the BFS algorithm\n * @param node - The node form which to start \n * @returns - A map of which node was explored from which other node\n */\nasync function BFSSearch(Graph:Graph, node:number) {\n  const adj = Graph.get_adjacency();\n  const exploredFromMap:Map<number,number> = new Map();\n\n  const explored = new Set<number>([node]);\n  const queue: number[] = [node];\n  exploredFromMap.set(node, -1);\n\n  while (queue.length > 0) {\n    const currentNode = queue.shift()!;\n    const neighbours = adj.get(currentNode);\n    for (let i = 0; i < neighbours!.length; i++) {\n      const neighbour = neighbours![i];\n      if (!explored.has(neighbour)) {\n        explored.add(neighbour);\n        queue.push(neighbour);\n        exploredFromMap.set(neighbour, currentNode);\n      }\n    }\n  }\n  // then return the explored from map\n  return exploredFromMap;\n}\n\n// do a dijkstra Search Distance map\n/**\n * \n * Performs a dijkstra search on a graph\n * \n * @param Graph - The graph on which to perform the Dijkstra search \n * @param Node - The node from which to start\n * @returns - Map from which each one of the nodes was searched from\n */\nasync function Dijkstra(Graph:Graph, Node:number) {\n  const adj = Graph.get_adjacency();\n  const Dmap:Map<number, number> = new Map();\n  const exploredFromMap = await BFSSearch(Graph, Node);\n  for (const n of adj.keys()) {\n    if (!exploredFromMap.has(n)) continue; // unreachable (disconnected)\n    let i = 0;\n    let exploredFrom: number | undefined = exploredFromMap.get(n);\n    while (exploredFrom !== undefined && exploredFrom !== -1) {\n      exploredFrom = exploredFromMap.get(exploredFrom);\n      i += 1;\n    }\n    Dmap.set(n, i);\n  }\n  return Dmap;\n}\n\n// This file contains basic things like\n// Graph searches and stuff\n// this only returns one of the diameters that is the longest \n// not all of them\n/**\n * \n * Finds the diameter of the graph\n * \n * @param Graph \n * @returns returns an object with a start, end - the two points of a graph and the diameter of the graph\n */\nasync function GraphDiameter(Graph:Graph) {\n  const nodeIds = [...Graph.nodes.keys()];\n  if (nodeIds.length === 0) return { start: 0, end: 0, distance: 0 };\n  if (nodeIds.length === 1) return { start: nodeIds[0], end: nodeIds[0], distance: 0 };\n\n  const adj = Graph.get_adjacency();\n  const withNeighbors = nodeIds.filter((id) => (adj.get(id)?.length ?? 0) > 0);\n  const pickFrom = withNeighbors.length > 0 ? withNeighbors : nodeIds;\n  let seed = pickFrom[Math.floor(Math.random() * pickFrom.length)];\n\n  let Dstart = await Dijkstra(Graph, seed);\n  let currentDistance = -1;\n  for (const n of Dstart.keys()) {\n    const dval = Dstart.get(n)!;\n    if (dval > currentDistance) {\n      seed = n;\n      currentDistance = dval;\n    }\n  }\n  const newStart = seed;\n  Dstart = await Dijkstra(Graph, seed);\n  currentDistance = -1;\n  for (const n of Dstart.keys()) {\n    const dval = Dstart.get(n)!;\n    if (dval > currentDistance) {\n      seed = n;\n      currentDistance = dval;\n    }\n  }\n  return { start: newStart, end: seed, distance: currentDistance };\n}\n\n// Select a subrgaph\n// you must specify a list of nodes that you passed in\n/**\n * \n * Select a subgraph\n * \n * @param graph - The main graph to select from\n * @param nodeList - The selection of nodes that we want to select from this graph\n * @returns A graph object that contains this subgraph\n */\nasync function SelectSubgraph(graph:Graph, nodeList:number[]) {\n  const prunedNodes:Map<number,_Node> = new Map();\n  const prunedEdges:Map<number, Edge> = new Map();\n  // set the prunded vertices list\n  nodeList.forEach((element) => {\n    // get the element from the graph and set that\n    // data element in the  prunded vertices map\n    const ndata = graph.nodes.get(element)!;\n    prunedNodes.set(element, ndata);\n  });\n\n  // set the pruned edges list\n  let i = 0;\n  for (const edge of graph.edges.keys()) {\n    const edgeData = graph.edges.get(edge)!;\n    if (nodeList.includes(edgeData.start) && nodeList.includes(edgeData.end)) {\n      prunedEdges.set(i, edgeData);\n      i += 1;\n    }\n  }\n\n  // construct a new graph that represents the new graph\n  const newGraph = await Graph.create(prunedNodes, prunedEdges);\n  return newGraph;\n}\n\n// this is where the exports happen\nexport default { GraphDiameter, Dijkstra, BFSSearch, SelectSubgraph };\n","import Line from \"../HelperClasses/Line\";\nimport Point from \"../HelperClasses/Point\";\nimport _Node from \"./_Node\";\nimport Edge from \"./Edge\";\n\ninterface Graph {\n  nodes: Map<number, _Node>;\n  edges: Map<number, Edge>;\n}\n\n/**\n * The main graph object: contains nodes and edges that get modified with different\n * operations (layout, clustering, etc.).\n */\nclass Graph {\n  /**\n   *\n   * Construct a graph object (no initializing)\n   *\n   * @param nodes - Map of all the nodes associated with the graph\n   * @param edges - Map of all the edges associated with the graph\n   */\n  constructor(nodes: Map<number, _Node>, edges: Map<number, Edge>) {\n    this.nodes = nodes;\n    this.edges = edges;\n    // execute Internal methods\n    // this.printData();\n  }\n\n  // test function\n  /**\n   * Prints out a snapshot of data associated with this graph like how many nodes and how many edges\n   */\n  printData() {\n    const message =\n      \"This is a graph with \" +\n      this.nodes.size +\n      \" nodes and \" +\n      this.edges.size +\n      \" edges\";\n    console.log(message);\n  }\n\n  // initialize\n  /**\n   * Initializes the graph and constructs the node adjacency list.\n   */\n  async initialize() {\n    await this.constructAdjacencyList();\n  }\n\n  // new create method\n  /**\n   *\n   * This is the official create method to make a graph based on a set of nodes and edges\n   * It also auto-initializes the graph and sets all the adjacency lists in memory.\n   *\n   * @param nodes - map of nodes\n   * @param edges - map of edges\n   * @returns\n   */\n  static async create(nodes: Map<number, _Node>, edges: Map<number, Edge>) {\n    const g = new Graph(nodes, edges);\n    await g.initialize();\n    return g;\n  }\n\n  // construct the adjacency list represntation\n  /**\n   * Constructs the adjacency associated with the graph\n   */\n  async constructAdjacencyList() {\n    // I'm constructing a Graph here so some of the stuff doesnt matter\n    this.edges.forEach((edge) => {\n      const start = edge.start;\n      const end = edge.end;\n      if (this.nodes.get(start)) this.nodes.get(start)!.neighbours.push(end);\n      if (this.nodes.get(end)) this.nodes.get(end)!.neighbours.push(start);\n    });\n    // then for each node then get the unique neighbours\n    for (const key of this.nodes.keys()) {\n      const neighs = this.nodes.get(key)!.neighbours;\n      const new_neigh = [...new Set(neighs)];\n      const selfIndex = new_neigh.indexOf(key);\n      if (selfIndex > -1) {\n        new_neigh.splice(selfIndex, 1); // 2nd parameter means remove one item only\n      }\n      this.nodes.get(key)!.neighbours = new_neigh;\n    }\n  }\n\n  // add a node\n  /**\n   * Add a node to the graph.\n   * @param nodeID - The node ID\n   * @param data - Data associated with the node\n   */\n  add_node(nodeID: number, data: _Node) {\n    this.nodes.set(nodeID, data);\n  }\n\n  // add an edge\n  /**\n   * Add an edge to the graph\n   * @param start - Starting index of the edge\n   * @param end - The end index of the edge\n   * @param data - data associated with the edge\n   */\n  add_edge(start: number, end: number, data: any) {\n    const newEdge = new Edge(start, end, data);\n    this.edges.set(this.edges.size, newEdge);\n    // keep adjacency consistent for undirected graph (both directions)\n    const startNode = this.nodes.get(start);\n    const endNode = this.nodes.get(end);\n    if (startNode) startNode.neighbours.push(end);\n    if (endNode) endNode.neighbours.push(start);\n  }\n\n  // get an adjacency list reprentation of the graph\n  // this onlu has the indices and not the actual data\n  // associated with the node to speed things up\n  /**\n   *\n   * @returns The adjacency lists associated with the graph\n   */\n  get_adjacency() {\n    const SparseMap: Map<number, number[]> = new Map();\n    // iterate through the node list\n    for (const key of this.nodes.keys()) {\n      SparseMap.set(key, this.nodes.get(key)!.neighbours);\n    }\n    return SparseMap;\n  }\n\n  // set position based on an array of positions\n  // this could be anything (we use kamada kawai )\n  /**\n   * Apply a position map based on some data\n   * @param data - the position map that has to be applied to the graph\n   */\n  apply_position_map(data: Map<number, Point>) {\n    for (let n of data.keys()) {\n      this.nodes.get(n)!.data = {\n        ...this.nodes.get(n)!.data,\n        pos: data.get(n),\n      };\n    }\n  }\n\n  // create new edge pos representation\n  // same approach for applying the key data\n  /**\n   * Apply an line map to a graph\n   * @param data Line data that has to be applied to the graph\n   */\n  apply_edge_pos_maps(data: Map<number, Line>) {\n    for (let key of data.keys()) {\n      this.edges.get(key)!.data = {\n        ...this.edges.get(key)!.data,\n        ldata: data.get(key),\n      };\n    }\n  }\n\n  // get the edge reps\n  // this returns all the edge map readings\n  /**\n   * get the current edge map\n   * @returns The current set of edges associated with the graph\n   */\n  get_edge_map() {\n    const lines: Map<number, Line> = new Map();\n    for (const key of this.edges.keys()) {\n      const ldata = this.edges.get(key)!.data.ldata;\n      if (ldata != null) lines.set(key, ldata);\n    }\n    return lines;\n  }\n\n  // graph apply pos and edge map\n  /**\n   * Applies all the maps to the graph\n   * @param layout - Applies an object of maps associated with with a graph is made up of {pmap:(the position map), emap:{the edge map}}\n   */\n  apply_drawing_maps(layout: {\n    pmap: Map<number, Point>;\n    emap: Map<number, Line>;\n  }) {\n    if (layout.pmap) {\n      this.apply_position_map(layout.pmap);\n    }\n    if (layout.emap) {\n      this.apply_edge_pos_maps(layout.emap);\n    }\n  }\n\n  // get the positon map of the graph\n  /**\n   * Gets the position map and the edge map respectively\n   * @returns The position map and the edge map as pmap and emap\n   */\n  get_map() {\n    return {\n      pmap: this.get_position_map(),\n      emap: this.get_edge_map(),\n    };\n  }\n\n  /**\n   * Get the position of the nodes in the graph.\n   * @returns The position map (node ID to Point)\n   */\n  get_position_map() {\n    const pmap: Map<number, Point> = new Map();\n    for (const node of this.nodes.keys()) {\n      pmap.set(node, this.nodes.get(node)!.data.pos);\n    }\n    return pmap;\n  }\n}\n\n// Export the graph Library\nexport default Graph;\n","interface Edge {\n  start: number;\n  end: number;\n  data: any;\n}\n\n/**\n * Edge class: connects two nodes by start/end IDs; can hold optional data (e.g. \"ldata\" for line geometry).\n */\nclass Edge {\n  /**\n   * \n   * Construct an edge\n   * \n   * @param start Start index of the edge based on the array of nodes\n   * @param end End index of the edge based on the array of nodes\n   * @param data - Optional data; \"ldata\" is reserved for line geometry used when drawing the edge\n   */\n  constructor(start:number, end:number, data:any) {\n    this.start = start;\n    this.end = end;\n    this.data = { ...data };\n  }\n}\n\nexport default Edge;\n","import * as THREE from \"three\";\nimport Point from \"../HelperClasses/Point\";\nimport Line from \"../HelperClasses/Line\";\nimport { hexToRgb } from \"../HelperClasses/ColorHelper\";\nimport { createThickEdgesGroup } from \"./ThickLine\";\nimport { vertexShader } from \"../Shaders/vertexShader.glsl\";\nimport { fragmentShader } from \"../Shaders/fragmentShader.glsl\";\nimport GraphMethods from \"../GraphAlgorithms/GraphMethods\";\nimport Graph from \"../Core/Graph\";\nimport _Node from \"../Core/_Node\";\n\n// Draw the graph out as a bunch of vertices\n// As like tiny squares\n/**\n *\n * Draw the veritces of the graph out as a point cloud\n *\n * @param Graph - the graph that has to be drawn out\n * @param bounds - A global scaling parameter defaults to 1 but change to scale up a garph\n * @param size - The size of all the nodes - either input an array the same length of the number of nodes decribing how big each node is, or a global node value as a number or defaults to 1\n * @param color - the color of the node defaults to white\n * @param alpha - the alpha value of the node defaults to 1 (opaque)\n * @returns a three JS group that contains all the vertices as a point cloud or a three js points object that can be added to the scene\n */\nfunction DrawTHREEGraphVertices(\n  Graph: Graph,\n  bounds: number = 1,\n  size: number | number[] = 1,\n  color: number = 0xffffff,\n  alpha: number = 1\n) {\n  const positionAttribute: number[] = [];\n  // get the corresponding points list\n  const pmap = Graph.get_position_map();\n  // declare the sizes and colors\n  let sizes: number[];\n  let colors: number[];\n  if (typeof size == \"number\") {\n    sizes = Array(Graph.nodes.size).fill(size);\n  } else {\n    sizes = size;\n  }\n  colors = Array(Graph.nodes.size).fill(color);\n  const labels = [];\n  const colorVal = new THREE.Color();\n  colorVal.setRGB(255, 255, 255); // white as the default\n  // process the data set\n  let i = 0;\n  let nodeData: Point;\n  for (let node of Graph.nodes.keys()) {\n    nodeData = pmap.get(node)!;\n    positionAttribute.push(\n      nodeData.x * bounds,\n      nodeData.y * bounds,\n      nodeData.z * bounds\n    );\n\n    colorVal.toArray(colors, i * 3);\n    labels.push(node);\n    i += 1;\n  }\n\n  const geometry = new THREE.BufferGeometry();\n  // geometry attribute\n  geometry.setAttribute(\n    \"position\",\n    new THREE.Float32BufferAttribute(positionAttribute, 3)\n  );\n  // color attribute\n  geometry.setAttribute(\n    \"customColor\",\n    new THREE.Float32BufferAttribute(colors, 3)\n  );\n  // size attribute\n  geometry.setAttribute(\"size\", new THREE.Float32BufferAttribute(sizes, 1));\n  // label attribute\n  geometry.setAttribute(\"label\", new THREE.Int32BufferAttribute(labels, 1));\n  geometry.name = \"nodes\";\n\n  // example material\n  const PointMaterial = new THREE.ShaderMaterial({\n    uniforms: {\n      color: { value: new THREE.Color(0xffffff) }, // this is a base color dont mess with this\n      pointTexture: {\n        value: new THREE.TextureLoader().load(\"./Textures/Square.png\"),\n      },\n      alphaTest: { value: alpha },\n    },\n    vertexShader: vertexShader,\n    fragmentShader: fragmentShader,\n  });\n\n  const vertices = new THREE.Group();\n  vertices.add(new THREE.Points(geometry, PointMaterial));\n  return vertices;\n}\n\n// then make a thing which draws out all the edges (THICK)\n/**\n *\n * Draws out all the edges (Thick edges of a graph)\n *\n * @param Graph - The graph whose edges have to be drawn\n * @param bounds - the global scale for all the edges to be drawn defaults to 1\n * @param color - color of the edges defaults to white\n * @param thickness - thickness of the edges (defaults to 0.4; screen-space pixels  thickness  100 for values &lt; 1)\n * @returns a Three Js group of edges that can be added to the scene\n */\nfunction DrawTHREEGraphEdgesThick(\n  Graph: Graph,\n  bounds: number = 1,\n  color = 0xffffff,\n  thickness: number = 0.4\n) {\n  // add the interpolation function\n  const lineMap = Graph.get_edge_map();\n  return DrawThickEdgesFromEdgeMap(lineMap, bounds, color, thickness);\n}\n\n// draw a thing to draw out all the edges from the edge map stuff\n/**\n *\n * Draw thick edges from an edge map\n *\n * @param EdgeMap - The edge map associated with the graph\n * @param bounds - The global scale of the graph - defaults to 1\n * @param color - The color of the edges - defaults to white\n * @param thickness - thickness of the edges (defaults to 0.4; pixels  thickness  100 for values &lt; 1)\n * @returns\n */\nfunction DrawThickEdgesFromEdgeMap(\n  EdgeMap: Map<number, Line>,\n  bounds: number,\n  color: number = 0xffffff,\n  thickness: number = 0.4\n) {\n  return createThickEdgesGroup(EdgeMap, bounds, color, thickness);\n}\n\n// make a thing that draws out all the lines (Thin)\n/**\n *\n * Draw thin lines for all the edges given a graph\n *\n * @param Graph - The graph that has to be drawn\n * @param bounds - The global scale factor for the the edges - defaults to 1\n * @param color - color of the lines - defaults to white\n * @returns\n */\nfunction DrawTHREEGraphEdgesThin(\n  Graph: Graph,\n  bounds: number = 1,\n  color: number = 0xffffff\n) {\n  // first get the edge map positions\n  const emap = Graph.get_edge_map();\n  return DrawThinEdgesFromEdgeMap(emap, bounds, color);\n}\n\n/**\n * Draw a single thick line through an ordered list of node IDs (e.g. a path).\n * Uses graph positions; line width in pixels (pass thickness >= 1 for pixel width).\n *\n * @param Graph - Graph with position map\n * @param bounds - Scale factor for positions\n * @param pathNodeIds - Ordered node IDs (start to end)\n * @param color - Hex color for the path line\n * @param thickness - Line width in pixels (e.g. 5 for a thick path)\n */\nfunction DrawThickPathFromNodeIds(\n  Graph: Graph,\n  bounds: number,\n  pathNodeIds: number[],\n  color: number = 0xffffff,\n  thickness: number = 5\n) {\n  const pmap = Graph.get_position_map();\n  const pathPoints = pathNodeIds.map((id) => pmap.get(id)).filter((p): p is Point => p != null);\n  if (pathPoints.length < 2) return new THREE.Group();\n  const pathLine = new Line(pathPoints);\n  return createThickEdgesGroup(new Map([[0, pathLine]]), bounds, color, thickness);\n}\n\n// function to draw edges from edge map\n/**\n *\n * Draw Line map as lines given the edge map assocaited with the graph\n *\n * @param LineMap - The edge map that has to be drawn out\n * @param bounds - Global scale for the edges to be drawn defaults to 1\n * @param color - Color of the edges defaults to 1\n * @returns\n */\nfunction DrawThinEdgesFromEdgeMap(\n  LineMap: Map<number, Line>,\n  bounds: number = 1,\n  color: number = 0xffffff\n) {\n  const material = new THREE.LineBasicMaterial({\n    color: color,\n  });\n  const lines = new THREE.Group();\n  let points: THREE.Vector3[];\n  for (const edge of LineMap.values()) {\n    points = [];\n    // get the edge data\n    const ldata = edge.points;\n    ldata.forEach((element) => {\n      points.push(\n        new THREE.Vector3(\n          element.x * bounds,\n          element.y * bounds,\n          element.z * bounds\n        )\n      );\n    });\n    // then make the line thing\n    const geometry = new THREE.BufferGeometry().setFromPoints(points);\n    const line = new THREE.Line(geometry, material);\n    lines.add(line);\n  }\n  return lines;\n}\n\n// draw the cube box graph here\n/**\n *\n * Adde boxes where all the boxes are\n *\n * @param nodeMap - a map of all the nodes\n * @param bounds - global scale of the edges to be drawn, defaults to 1\n * @param color - default color of the edges, defaults to white\n * @param size - size of the nodes defaults to 10\n * @returns a group of vertices that contains all of the boxes associated with each one of the vertices\n */\nfunction AddBoxBasedImaging(\n  nodeMap: Map<number, Point>,\n  bounds: number = 1,\n  color: number = 0xffffff,\n  size: number | number[] = 10\n) {\n  // precompute all the sizes\n  let sizes: any;\n  if (typeof size == \"number\") {\n    sizes = Array(nodeMap.size).fill(size);\n  } else {\n    sizes = size;\n  }\n  // returns a group (iterate map entries so any node ID set works)\n  const group = new THREE.Group();\n  const material = new THREE.MeshBasicMaterial({ color: color });\n  let i = 0;\n  for (const [id, nodeData] of nodeMap) {\n    const s = typeof sizes === \"number\" ? sizes : sizes[i];\n    const geometry = new THREE.BoxGeometry(s, s, s);\n    geometry.name = String(id);\n    const nodeMesh = new THREE.Mesh(geometry, material);\n    nodeMesh.position.set(\n      nodeData.x * bounds,\n      nodeData.y * bounds,\n      nodeData.z * bounds\n    );\n    group.add(nodeMesh);\n    i += 1;\n  }\n  return group;\n}\n\n// Draw BoxBased imaging from a graph\n/**\n *\n * Draw box based verices given a graph\n *\n * @param Graph - The graph that needs its vertices drawn\n * @param bounds - A global scale for the graph, defaults to one\n * @param color - Default color of the boxes defaults to white\n * @param size - Default size of the nodes defaults to 10\n * @returns\n */\nfunction DrawTHREEBoxBasedVertices(\n  Graph: Graph,\n  bounds: number = 1,\n  color: number = 0xffffff,\n  size: number | number[] = 10\n) {\n  const pmap = Graph.get_position_map();\n  const Bgroup = AddBoxBasedImaging(pmap, bounds, color, size);\n  return Bgroup;\n}\n\n// draw cylinders where required\n/**\n *\n * Draw cylinders where all the vertices are based on a node map\n *\n * @param nodeMap - the node map assiciate with the graph that has to be drawn out\n * @param divisonLength - the length of the divisions that are there in each one of the cylinder (this is a circumfurence amount), defaults to 16\n * @param color - the default color of the cylinder, defaults to white\n * @param size - the default size of the cylinder, defaults to 10\n * @returns\n */\nfunction AddCylinderBasedImaging(\n  nodeMap: Map<number, Point>,\n  divisonLength: number = 16,\n  color: number = 0xffffff,\n  size: number | number[] = 10\n) {\n  // precompute all the sizes\n  let sizes: number | number[];\n  if (typeof size == \"number\") {\n    sizes = Array(nodeMap.size).fill(size) as number[];\n  } else {\n    sizes = size;\n  }\n  // returns a group (iterate map entries so any node ID set works)\n  const group = new THREE.Group();\n  const material = new THREE.MeshBasicMaterial({ color: color });\n  let i = 0;\n  for (const [id, nodeData] of nodeMap) {\n    const radius = typeof sizes === \"number\" ? sizes : sizes[i];\n    const circumfurence = 2 * radius * Math.PI;\n    const segments = Math.ceil(circumfurence / divisonLength);\n    const geometry = new THREE.CylinderGeometry(radius, radius, 10, segments);\n    geometry.name = String(id);\n    const nodeMesh = new THREE.Mesh(geometry, material);\n    nodeMesh.position.set(nodeData.x, nodeData.y, nodeData.z);\n    group.add(nodeMesh);\n    i += 1;\n  }\n  return group;\n}\n\n// draw the sparse graph as groups\n// this seperates all the points based on some or the other group\n/**\n *\n * Split up a graph and return an boject containing a bunch of node groups and edge groups based on some parameterS\n *\n * @param Graph - the graph that you want to split up\n * @param propertyName - the property that you want to split them on\n * @returns - an object that hasa set of node vertices and a set of edge lines based on the splitting factor\n */\nasync function AddInModularityBasedPointGroups(\n  Graph: Graph,\n  propertyName: string\n) {\n  // returns an array of groups\n  const groups: Map<number, number[]> = new Map();\n  let ndata: _Node;\n  let modularity: number;\n  for (let node of Graph.nodes.keys()) {\n    ndata = Graph.nodes.get(node)!;\n    modularity = eval(`ndata.data.${propertyName}`);\n    if (groups.has(modularity)) {\n      groups.get(modularity)!.push(node);\n    } else {\n      groups.set(modularity, [node]);\n    }\n  }\n  // then counstruct a bunch of subraphs\n  const meshGraphVertices: Map<number, THREE.Group> = new Map();\n  const meshGraphEdges: Map<number, THREE.Group> = new Map();\n  let subgraphGroup: number[];\n  let subgraph: Graph;\n  let pointRep: THREE.Group;\n  let edges: THREE.Group;\n  for (let modularityGroup of groups.keys()) {\n    subgraphGroup = groups.get(modularityGroup)!;\n    // returns an array\n    subgraph = await GraphMethods.SelectSubgraph(Graph, subgraphGroup);\n    // then make the vertex thing\n    pointRep = DrawTHREEGraphVertices(subgraph, 1);\n    meshGraphVertices.set(modularityGroup, pointRep);\n    // make the edges\n    edges = DrawSimplifiedEdges(subgraph, 0.03);\n    meshGraphEdges.set(modularityGroup, edges);\n  }\n  const ROBJ = {\n    nodeGroups: meshGraphVertices,\n    EdgeGroups: meshGraphEdges,\n  };\n  return ROBJ;\n}\n\n/**\n *\n * Draw simplified line edges (thin based) based on some number. This number is a fraction of the total number of edges (so if you specify 0.1 it would draw 10% of the edges)\n *\n * @param Graph - The graph that has to be drawn out\n * @param amount - The fraction of edges to be drawn\n * @param color - color of these edges - defaults to 0.1\n * @returns - a group of simple lines based on all the edges supplied to it\n */\nfunction DrawSimplifiedEdges(\n  Graph: Graph,\n  amount: number,\n  color: number = 0xffffff\n) {\n  const lineGroup = new THREE.Group();\n  const material = new THREE.LineBasicMaterial({ color: color });\n  let start: Point;\n  let end: Point;\n  let points: THREE.Vector3[];\n  for (let edge of Graph.edges.values()) {\n    if (Math.random() <= amount) {\n      start = Graph.nodes.get(edge.start)!.data.pos;\n      end = Graph.nodes.get(edge.end)!.data.pos;\n      points = [];\n      points.push(new THREE.Vector3(start.x, start.y, start.z));\n      points.push(new THREE.Vector3(end.x, end.y, end.z));\n      const geometry = new THREE.BufferGeometry().setFromPoints(points);\n      const line = new THREE.Line(geometry, material);\n      lineGroup.add(line);\n    }\n  }\n  return lineGroup;\n}\n\n/**\n * Set vertex colors by node ID. Uses the geometry's \"label\" attribute (node ID per vertex) to map node IDs to vertex indices; if \"label\" is missing, indexArray is treated as vertex indices.\n *\n * @param vertices - THREE.Points with customColor (and optionally label) attribute, or a Group whose first child is that Points object\n * @param indexArray - Node IDs to color, or vertex indices if geometry has no label attribute\n * @param color - Hex color to apply\n */\nfunction ChangeTheVertexColours(\n  vertices: THREE.Points | THREE.Group,\n  indexArray: number[],\n  color: number\n) {\n  try {\n    const points = (vertices instanceof THREE.Group ? vertices.children[0] : vertices) as THREE.Points | undefined;\n    const geom = points?.geometry;\n    if (!geom?.attributes) return;\n    const customColor = geom.attributes.customColor as THREE.BufferAttribute | undefined;\n    const arr = customColor?.array;\n    if (!arr || arr.length === 0) return;\n    const col = new THREE.Color(color);\n    const labelAttr = geom.attributes.label as THREE.BufferAttribute | undefined;\n    const labels = labelAttr?.array as Int32Array | undefined;\n\n    if (labels && labels.length > 0) {\n      // Map node IDs to vertex indices via label attribute\n      indexArray.forEach((nodeId) => {\n        for (let i = 0; i < labels.length; i++) {\n          if (labels[i] === nodeId) {\n            const k = i * 3;\n            if (k + 2 < arr.length) {\n              arr[k] = col.r;\n              arr[k + 1] = col.g;\n              arr[k + 2] = col.b;\n            }\n            break;\n          }\n        }\n      });\n    } else {\n      // No label: treat indexArray as vertex indices\n      indexArray.forEach((node) => {\n        const k = node * 3;\n        if (k + 2 < arr.length) {\n          arr[k] = col.r;\n          arr[k + 1] = col.g;\n          arr[k + 2] = col.b;\n        }\n      });\n    }\n    if (customColor) customColor.needsUpdate = true;\n  } catch {\n    // Points object or customColor may be missing; skip coloring\n  }\n}\n\n/**\n * Reset all vertex colors to white.\n * @param vertices - THREE.Points with customColor attribute, or a Group whose first child is that Points object\n */\nfunction ResetVertexColors(vertices: THREE.Points | THREE.Group) {\n  try {\n    const points = (vertices instanceof THREE.Group ? vertices.children[0] : vertices) as THREE.Points | undefined;\n    const customColor = points?.geometry?.attributes?.customColor as THREE.BufferAttribute | undefined;\n    const arr = customColor?.array;\n    if (!arr || arr.length === 0) return;\n    const count = customColor?.count ?? Math.floor(arr.length / 3);\n    for (let i = 0; i < count; i++) {\n      const k = i * 3;\n      arr[k] = 1;\n      arr[k + 1] = 1;\n      arr[k + 2] = 1;\n    }\n    if (customColor) customColor.needsUpdate = true;\n  } catch {\n    // skip if wrong object or missing attribute\n  }\n}\n\nexport default {\n  DrawTHREEGraphVertices,\n  DrawTHREEGraphEdgesThick,\n  DrawTHREEGraphEdgesThin,\n  DrawThickPathFromNodeIds,\n  AddBoxBasedImaging,\n  AddInModularityBasedPointGroups,\n  DrawThinEdgesFromEdgeMap,\n  DrawThickEdgesFromEdgeMap,\n  AddCylinderBasedImaging,\n  DrawSimplifiedEdges,\n  ChangeTheVertexColours,\n  ResetVertexColors,\n  DrawTHREEBoxBasedVertices,\n};\n","/**\n * Internal thick-line drawing: billboarded mesh-line (ribbon with screen-space width).\n * No dependency on Three.js examples; geometry and material are maintained in-house.\n * Based on the MeshLine approach (see e.g. threejs-meshline / THREE.MeshLine).\n */\n\nimport * as THREE from \"three\";\nimport type Line from \"../HelperClasses/Line\";\nimport { buildMeshLineGeometry } from \"./MeshLineGeometry\";\nimport { createMeshLineMaterial } from \"./MeshLineMaterial\";\n\n/** Default line width in pixels (screen space) */\nconst DEFAULT_LINE_WIDTH_PX = 2;\n/** Default resolution for material (canvas size); can be updated on resize */\nconst DEFAULT_RESOLUTION = new THREE.Vector2(800, 700);\n\n/**\n * Create a single thick line mesh from a Line (array of points).\n * Uses a ribbon geometry + shader material so the line is billboarded\n * and has consistent pixel width on screen.\n *\n * @param line - Line with .points (Point[])\n * @param bounds - Scale factor applied to point coordinates (same as thin lines)\n * @param color - Hex color\n * @param lineWidthPx - Line width in pixels (screen space)\n * @param resolution - Canvas size for correct scaling (optional)\n * @returns A Three.js Mesh that can be added to the scene\n */\nexport function createThickLineMesh(\n  line: Line,\n  bounds: number,\n  color: number,\n  lineWidthPx: number = DEFAULT_LINE_WIDTH_PX,\n  resolution?: THREE.Vector2\n): THREE.Mesh {\n  if (line.points.length < 2) {\n    const geo = new THREE.BufferGeometry();\n    return new THREE.Mesh(geo, new THREE.MeshBasicMaterial({ color }));\n  }\n\n  const positions = line.points.map(\n    (p) => new THREE.Vector3(p.x * bounds, p.y * bounds, p.z * bounds)\n  );\n  const geometry = buildMeshLineGeometry(positions);\n  const material = createMeshLineMaterial({\n    color,\n    lineWidth: lineWidthPx,\n    resolution: resolution ?? DEFAULT_RESOLUTION,\n  });\n  return new THREE.Mesh(geometry, material);\n}\n\n/**\n * Create a group of thick line meshes from an edge map.\n * Lines are billboarded and drawn with the given pixel width.\n *\n * @param edgeMap - Map of edge id to Line\n * @param bounds - Scale factor for coordinates\n * @param color - Hex color for all lines\n * @param lineWidthPx - Line width in pixels (screen space); default 2\n * @param resolution - Canvas size (optional, for correct pixel scaling)\n * @returns THREE.Group containing one mesh per edge\n */\n/**\n * Convert legacy thickness (world-unit style 0.02, 0.03) to pixel width for screen-space lines.\n */\nfunction toPixelWidth(thickness: number): number {\n  if (thickness >= 1) return Math.max(1, Math.round(thickness));\n  return Math.max(1, Math.round(thickness * 100));\n}\n\nexport function createThickEdgesGroup(\n  edgeMap: Map<number, Line>,\n  bounds: number,\n  color: number,\n  thickness: number = DEFAULT_LINE_WIDTH_PX,\n  resolution?: THREE.Vector2\n): THREE.Group {\n  const lineWidthPx = toPixelWidth(thickness);\n  const group = new THREE.Group();\n  for (const line of edgeMap.values()) {\n    if (!line?.points || line.points.length < 2) continue;\n    group.add(createThickLineMesh(line, bounds, color, lineWidthPx, resolution));\n  }\n  return group;\n}\n","/**\n * Ribbon geometry for billboarded thick lines (MeshLine-style).\n * Each line point becomes two vertices (left/right edge); the material\n * expands them in screen space so the line has visible thickness.\n */\n\nimport * as THREE from \"three\";\n\n/**\n * Build a BufferGeometry for one polyline as a ribbon (strip of quads).\n * Attributes: position, positionPrev, positionNext, side.\n */\nexport function buildMeshLineGeometry(positions: THREE.Vector3[]): THREE.BufferGeometry {\n  const n = positions.length;\n  if (n < 2) {\n    return new THREE.BufferGeometry();\n  }\n\n  const posArr: number[] = [];\n  const prevArr: number[] = [];\n  const nextArr: number[] = [];\n  const sideArr: number[] = [];\n\n  for (let i = 0; i < n; i++) {\n    const p = positions[i];\n    const pPrev = i > 0 ? positions[i - 1] : p;\n    const pNext = i < n - 1 ? positions[i + 1] : p;\n\n    // Left edge vertex\n    posArr.push(p.x, p.y, p.z);\n    prevArr.push(pPrev.x, pPrev.y, pPrev.z);\n    nextArr.push(pNext.x, pNext.y, pNext.z);\n    sideArr.push(-1);\n\n    // Right edge vertex\n    posArr.push(p.x, p.y, p.z);\n    prevArr.push(pPrev.x, pPrev.y, pPrev.z);\n    nextArr.push(pNext.x, pNext.y, pNext.z);\n    sideArr.push(1);\n  }\n\n  const geometry = new THREE.BufferGeometry();\n  geometry.setAttribute(\"position\", new THREE.Float32BufferAttribute(posArr, 3));\n  geometry.setAttribute(\"positionPrev\", new THREE.Float32BufferAttribute(prevArr, 3));\n  geometry.setAttribute(\"positionNext\", new THREE.Float32BufferAttribute(nextArr, 3));\n  geometry.setAttribute(\"side\", new THREE.Float32BufferAttribute(sideArr, 1));\n\n  // Triangle list: each quad (segment) = two triangles (0,1,2) and (2,1,3)\n  const indices: number[] = [];\n  for (let i = 0; i < n - 1; i++) {\n    const a = i * 2;\n    indices.push(a, a + 1, a + 2, a + 2, a + 1, a + 3);\n  }\n  geometry.setIndex(indices);\n  geometry.computeBoundingSphere();\n\n  return geometry;\n}\n","/**\n * Billboarded thick-line material (screen-space width).\n * Adapted from the MeshLine approach: vertex shader expands the ribbon\n * in clip space so lines have consistent pixel width and always face the camera.\n */\n\nimport * as THREE from \"three\";\n\nconst MESHLINE_VERTEX = `\nattribute vec3 positionPrev;\nattribute vec3 positionNext;\nattribute float side;\n\nuniform vec2 resolution;\nuniform float lineWidth;\n\nvoid main() {\n  vec4 clipPos = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n  vec4 clipPrev = projectionMatrix * modelViewMatrix * vec4(positionPrev, 1.0);\n  vec4 clipNext = projectionMatrix * modelViewMatrix * vec4(positionNext, 1.0);\n\n  vec2 ndcCurr = clipPos.xy / clipPos.w;\n  vec2 ndcPrev = clipPrev.xy / clipPrev.w;\n  vec2 ndcNext = clipNext.xy / clipNext.w;\n\n  vec2 dir = normalize(ndcNext - ndcPrev);\n  vec2 perp = vec2(-dir.y, dir.x);\n\n  float w = clipPos.w;\n  float pixelScale = min(resolution.x, resolution.y);\n  float ndcPerPixel = 2.0 / pixelScale;\n  vec2 offsetNdc = perp * side * (lineWidth * 0.5 * ndcPerPixel);\n  clipPos.xy += offsetNdc * w;\n\n  gl_Position = clipPos;\n}\n`;\n\nconst MESHLINE_FRAGMENT = `\nuniform vec3 color;\n\nvoid main() {\n  gl_FragColor = vec4(color, 1.0);\n}\n`;\n\nexport interface MeshLineMaterialOptions {\n  color?: number;\n  lineWidth?: number;\n  resolution?: THREE.Vector2;\n}\n\n/**\n * Material for billboarded thick lines. Width is in pixels (screen space).\n * Requires resolution uniform (canvas size) for correct scaling.\n */\nexport function createMeshLineMaterial(options: MeshLineMaterialOptions = {}): THREE.ShaderMaterial {\n  const color = options.color ?? 0xffffff;\n  const lineWidth = options.lineWidth ?? 2;\n  const resolution = options.resolution ?? new THREE.Vector2(800, 700);\n\n  const threeColor = new THREE.Color(color);\n  return new THREE.ShaderMaterial({\n    uniforms: {\n      resolution: { value: resolution },\n      lineWidth: { value: lineWidth },\n      color: { value: new THREE.Vector3(threeColor.r, threeColor.g, threeColor.b) },\n    },\n    vertexShader: MESHLINE_VERTEX,\n    fragmentShader: MESHLINE_FRAGMENT,\n    transparent: false,\n    depthTest: true,\n    side: THREE.DoubleSide,\n  });\n}\n","const vertexShader = `\nattribute float size;\nattribute vec3 customColor;\n\nvarying vec3 vColor;\n\nvoid main() {\n    vColor = customColor;\n    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n    gl_PointSize = size * ( 300.0 / -mvPosition.z );\n    gl_Position = projectionMatrix * mvPosition;\n}\n`\n\nexport {vertexShader};","const fragmentShader = `\nuniform vec3 color;\nuniform sampler2D pointTexture;\nuniform float alphaTest;\n\nvarying vec3 vColor;\n\nvoid main() {\n    gl_FragColor = vec4( color * vColor, 1.0 );\n    gl_FragColor = gl_FragColor * texture2D( pointTexture, gl_PointCoord );\n    if ( gl_FragColor.a < alphaTest ) discard;\n}\n`;\n\nexport { fragmentShader };\n","export { Graph } from \"./Core\";\nexport { GraphMethods } from \"./GraphAlgorithms\";\nexport { SampleData } from \"./SampleData\";\nexport { default as Constructors } from \"./HelperClasses/GraphConstructors\";\nexport { default as Drawing } from \"./Drawing/Drawing\";\nexport { default as Geometry } from \"./HelperClasses/GeometryHelpers\";\nexport { default as Utilities } from \"./HelperClasses/Utilities\";\nexport { default as ThreeWrapper } from \"./Drawing/ThreeJSDrawer\";\nexport { default as GraphDrawer } from \"./Drawing/GraphDrawer\";\nexport { Models } from \"./Models\";\nexport { default as Hierarchy } from \"./Hierarchy\";\n","export { default as Graph } from \"./Graph\";\n","export { default as GraphMethods } from \"./GraphMethods\";\n","export { default as SampleData } from \"./DataLoader\";\n","// load up the ZKC dataset\nimport { zkc } from \"./ZKC\";\nimport { zkc_simulated } from \"./ZKC_simulated\";\nimport GraphConstructors from \"../HelperClasses/GraphConstructors\";\nimport Graph from \"../Core/Graph\";\nimport Point from \"../HelperClasses/Point\";\nimport _Node from \"../Core/_Node\";\nimport Edge from \"../Core/Edge\";\nimport Drawing from \"../Drawing/Drawing\";\n\n/**\n * \n * @returns the raw ZKC dataset\n */\nasync function LoadZKC() {\n  // load up the dataset representation\n  const data = zkc;\n  const G = await GraphConstructors.ConstructGraphNodeEdgesList(data.nodes, data.edges);\n  return G;\n}\n\n/**\n * \n * @returns the ZKC dataset with the positons simulated before hand\n */\nasync function LoadZKCSimulated() {\n  // make a map\n  const data = zkc_simulated;\n  const nodes = new Map();\n  const edges = new Map();\n  // set the node map\n  data.nodes.forEach((node) => {\n    const id = node.id;\n    const pos = new Point(node.px*50, 0, node.py*50);\n    const modularity = node.member;\n    const n = new _Node({ pos: pos, size:10, info:\"Node Info\", modularity:modularity });\n    nodes.set(id, n);\n  });\n  // set the edge map\n  for (let i = 0; i < data.edges.length; i++) {\n    const edge = data.edges[i];\n    const start = edge[0];\n    const end = edge[1];\n    const e = new Edge(start, end, {});\n    edges.set(i, e);\n  }\n  // make a graph object\n  const G = await Graph.create(nodes, edges);\n  const lmap = Drawing.DrawEdgeLines(G, 20);\n  G.apply_edge_pos_maps(lmap);\n  return G;\n}\n\n// exports\nexport default { LoadZKC, LoadZKCSimulated };\n","const zkc = {\n  nodes: [\n    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20,\n    21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33,\n  ],\n  edges: [\n    [0, 1],\n    [0, 2],\n    [0, 3],\n    [0, 4],\n    [0, 5],\n    [0, 6],\n    [0, 7],\n    [0, 8],\n    [0, 10],\n    [0, 11],\n    [0, 12],\n    [0, 13],\n    [0, 17],\n    [0, 19],\n    [0, 21],\n    [0, 31],\n    [1, 2],\n    [1, 3],\n    [1, 7],\n    [1, 13],\n    [1, 17],\n    [1, 19],\n    [1, 21],\n    [1, 30],\n    [2, 3],\n    [2, 7],\n    [2, 8],\n    [2, 9],\n    [2, 13],\n    [2, 27],\n    [2, 28],\n    [2, 32],\n    [3, 7],\n    [3, 12],\n    [3, 13],\n    [4, 6],\n    [4, 10],\n    [5, 6],\n    [5, 10],\n    [5, 16],\n    [6, 16],\n    [8, 30],\n    [8, 32],\n    [8, 33],\n    [9, 33],\n    [13, 33],\n    [14, 32],\n    [14, 33],\n    [15, 32],\n    [15, 33],\n    [18, 32],\n    [18, 33],\n    [19, 33],\n    [20, 32],\n    [20, 33],\n    [22, 32],\n    [22, 33],\n    [23, 25],\n    [23, 27],\n    [23, 29],\n    [23, 32],\n    [23, 33],\n    [24, 25],\n    [24, 27],\n    [24, 31],\n    [25, 31],\n    [26, 29],\n    [26, 33],\n    [27, 33],\n    [28, 31],\n    [28, 33],\n    [29, 32],\n    [29, 33],\n    [30, 32],\n    [30, 33],\n    [31, 32],\n    [31, 33],\n    [32, 33],\n  ],\n};\n\nexport { zkc };\n","const zkc_simulated = {\n  nodes: [\n    { id: 0, px: 0.09083423378081436, py: 1.164162667707135, member: 0 },\n    { id: 1, px: -0.5395391223661004, py: 0.8787097882002372, member: 0 },\n    { id: 2, px: 0.25483951690897244, py: -0.011894166387290125, member: 0 },\n    { id: 3, px: 0.5292273814873625, py: 0.8137715604013231, member: 0 },\n    { id: 4, px: 0.6759740200024705, py: 2.010590015934319, member: 3 },\n    { id: 5, px: 0.6648725961138767, py: 2.3765595730406712, member: 3 },\n    { id: 6, px: -0.015476857282255526, py: 2.421851366492045, member: 3 },\n    { id: 7, px: 0.9923183157183725, py: 0.7358251458599251, member: 0 },\n    { id: 8, px: -0.6148021363450372, py: -0.03465499210385469, member: 1 },\n    { id: 9, px: 0.24714516178546894, py: -1.012380550604274, member: 0 },\n    { id: 10, px: 1.3293288757439443, py: 1.8641805845025743, member: 3 },\n    { id: 11, px: -0.6571791278403557, py: 2.2163816367270526, member: 0 },\n    { id: 12, px: 1.5181044222926994, py: 1.3282665066698078, member: 0 },\n    { id: 13, px: -0.2979203330003603, py: 0.18438685313887027, member: 0 },\n    { id: 14, px: -1.7502345807734376, py: -1.0935551887354324, member: 1 },\n    { id: 15, px: -1.630224787934251, py: -1.5015879850995024, member: 1 },\n    { id: 16, px: 0.5585243394360673, py: 3.5, member: 3 },\n    { id: 17, px: -0.9776584881745712, py: 1.799718659872538, member: 0 },\n    { id: 18, px: -1.385649185975611, py: -1.870388302312794, member: 1 },\n    { id: 19, px: -0.9638464461397331, py: 0.24226946279518707, member: 0 },\n    { id: 20, px: -1.0268125129631975, py: -2.1543990524894148, member: 1 },\n    { id: 21, px: -1.3061680833745626, py: 1.527228276383933, member: 0 },\n    { id: 22, px: -0.5552461198316926, py: -2.2498070887997685, member: 1 },\n    { id: 23, px: 0.8262268914348979, py: -1.804253160744954, member: 2 },\n    { id: 24, px: 1.9952840970427212, py: -1.0382885070400036, member: 2 },\n    { id: 25, px: 1.9207660053211613, py: -0.5823795272244723, member: 2 },\n    { id: 26, px: -0.1664715343791652, py: -2.6527209168204373, member: 1 },\n    { id: 27, px: 0.9961959436268844, py: -1.0143754028553023, member: 2 },\n    { id: 28, px: 0.6488880579857091, py: -1.024671500275854, member: 2 },\n    { id: 29, px: 0.2398196340697841, py: -2.171491081802323, member: 1 },\n    { id: 30, px: -1.3348117368940753, py: -0.31290471156377053, member: 1 },\n    { id: 31, px: 0.6901260074375327, py: -0.2526601933356052, member: 2 },\n    { id: 32, px: -0.6030949145287146, py: -1.0927507849665647, member: 1 },\n    { id: 33, px: -0.3533395323856202, py: -1.1887389845640028, member: 1 },\n  ],\n  edges: [\n    [0, 1],\n    [0, 2],\n    [0, 3],\n    [0, 4],\n    [0, 5],\n    [0, 6],\n    [0, 7],\n    [0, 8],\n    [0, 10],\n    [0, 11],\n    [0, 12],\n    [0, 13],\n    [0, 17],\n    [0, 19],\n    [0, 21],\n    [0, 31],\n    [1, 2],\n    [1, 3],\n    [1, 7],\n    [1, 13],\n    [1, 17],\n    [1, 19],\n    [1, 21],\n    [1, 30],\n    [2, 3],\n    [2, 7],\n    [2, 8],\n    [2, 9],\n    [2, 13],\n    [2, 27],\n    [2, 28],\n    [2, 32],\n    [3, 7],\n    [3, 12],\n    [3, 13],\n    [4, 6],\n    [4, 10],\n    [5, 6],\n    [5, 10],\n    [5, 16],\n    [6, 16],\n    [8, 30],\n    [8, 32],\n    [8, 33],\n    [9, 33],\n    [13, 33],\n    [14, 32],\n    [14, 33],\n    [15, 32],\n    [15, 33],\n    [18, 32],\n    [18, 33],\n    [19, 33],\n    [20, 32],\n    [20, 33],\n    [22, 32],\n    [22, 33],\n    [23, 25],\n    [23, 27],\n    [23, 29],\n    [23, 32],\n    [23, 33],\n    [24, 25],\n    [24, 27],\n    [24, 31],\n    [25, 31],\n    [26, 29],\n    [26, 33],\n    [27, 33],\n    [28, 31],\n    [28, 33],\n    [29, 32],\n    [29, 33],\n    [30, 32],\n    [30, 33],\n    [31, 32],\n    [31, 33],\n    [32, 33],\n  ],\n};\n\nexport { zkc_simulated };\n","import Graph from \"../Core/Graph\";\nimport _Node from \"../Core/_Node\";\nimport Edge from \"../Core/Edge\";\n\n// construct a graph based on an edge list etc\n/**\n * construct a graph based on an edge list and node list\n * @param nodes nodes as a list\n * @param edges edges as a list \n * @returns A graph that was construct from the list of nodes and edges\n */\nasync function ConstructGraphNodeEdgesList(nodes:any[], edges:any[]) {\n  // make a node OBJ\n  const nodeOBJ = new Map();\n  for (let i = 0; i < nodes.length; i++) {\n    const n = new _Node(nodes[i].data);\n    nodeOBJ.set(nodes[i], n);\n  }\n  // make an edge object\n  const edgeOBJ = new Map();\n  for (let i = 0; i < edges.length; i++) {\n    const e = new Edge(edges[i][0], edges[i][1], edges[i].data);\n    edgeOBJ.set(i, e);\n  }\n  // make a graph object\n  const G = await Graph.create(nodeOBJ, edgeOBJ);\n  return G;\n}\n\nexport default { ConstructGraphNodeEdgesList };\n","// note this file is always reffered to as\n// _Node to not confuse with node (js) and\n// Vertices which are another 3d object that\n// can be changed in three js\ninterface _Node {\n  data: any;\n  neighbours: number[];\n}\n\n/**\n * Node class: each node has an ID (index) and arbitrary data.\n * The data typically includes \"pos\" (Point) for visualization.\n */\nclass _Node {\n  /**\n   * \n   * @param data - Data associated with the node; include \"pos\" (Point) for graph visuals\n   */\n  constructor(data:any) {\n    // this data is an arbitrary thing with which I can create any object\n    this.data = { ...data };\n    // the neighbours bit is explicity set from the code outside\n    this.neighbours = [];\n  }\n}\n\nexport default _Node;\n","import * as THREE from \"three\";\nimport { OrbitControls } from \"three/examples/jsm/controls/OrbitControls\";\nimport Graph from \"../Core/Graph\";\n\n// interface for the graph drawing class\ninterface GraphDrawer3d {\n  canvas: HTMLCanvasElement;\n  width: number;\n  height: number;\n  geometryMap: Map<any, any>;\n  materialMap: Map<any, any>;\n  meshMap: Map<any, any>;\n  controls: OrbitControls;\n  renderer: THREE.WebGLRenderer;\n  camera: THREE.PerspectiveCamera;\n  scene: THREE.Scene;\n  graphs: Map<number, Graph>;\n}\n\n/**\n * This is the main graph drawer class\n */\nclass GraphDrawer3d {\n  /**\n   * To initialize the graph drawer there are a set of graph drawing settings that have to be set.\n   * Here are the details to do the same:\n   * canvas - the html canvas element that you would like to render \n   * height - the the height of the initialized canvas\n   * width - the width of the initialized canvas\n   * geometry map - a map that keeps track of all the geometry in the scene (Optional)\n   * material map - a mapt that keeps track of all the materials in the scene (Optional)\n   * controls - Controls that define how one can navigate this 3d space (Self initialized)\n   * renderer - Renderer element form the three JS library\n   * camera -  A perspective camera from the threeJS library \n   * scene - The three JS scene that gets define automatically\n   * \n   * @param GraphDrawerOptions3d - These above options are construdeted into a single object and passed into the Options elem\n   */\n  constructor(GraphDrawerOptions3d: {\n    canvas: HTMLCanvasElement;\n    width: number;\n    height: number;\n    geometryMap: Map<any, any>;\n    materialMap: Map<any, any>;\n    meshMap: Map<any, any>;\n    controls: OrbitControls;\n    renderer: THREE.WebGLRenderer;\n    camera: THREE.PerspectiveCamera;\n    scene: THREE.Scene;\n  }) {\n    this.canvas = GraphDrawerOptions3d.canvas;\n    this.width = GraphDrawerOptions3d.width;\n    this.height = GraphDrawerOptions3d.height;\n    // these maps are optional\n    // ive kepth them in as a way of managing all the\n    // geometry in the scene\n    this.geometryMap = new Map();\n    this.materialMap = new Map();\n    this.meshMap = new Map();\n    this.controls;\n    this.renderer;\n    this.camera;\n    this.scene;\n    // graph map is the hash map that holds all the\n    // graphs that we are working with together\n    this.graphs = new Map();\n  }\n\n  /**\n   * This essentially initializes the drawing element based on the settings\n   * Remember to do this since if if its not done the scene will not render\n   */\n  async init() {\n    const t1 = performance.now();\n\n    this.camera = new THREE.PerspectiveCamera();\n\n    // start up a new scene\n    this.scene = new THREE.Scene();\n\n    // set up a renderer\n    this.renderer = new THREE.WebGLRenderer({\n      canvas: this.canvas,\n      antialias: true,\n    });\n    this.renderer.setSize(this.width, this.height);\n    this.renderer.setClearColor(0xff00ff, 0);\n\n    // add in a light\n    this.scene.add(new THREE.AmbientLight(0xffffff));\n    // add a spotlight\n    const DirectionalLight = new THREE.DirectionalLight(0xffffff, 1);\n    DirectionalLight.position.set(0, 10, 0);\n    this.scene.add(DirectionalLight);\n\n    // set up the control system\n    this.controls = new OrbitControls(this.camera, this.renderer.domElement);\n    this.camera.position.set(0, 100, 100);\n    this.controls.autoRotate = true;\n    this.controls.maxPolarAngle = Math.PI * 0.5;\n    this.controls.maxDistance = 10000;\n    this.controls.minDistance = 10;\n    this.controls.update();\n\n    // finally print out that the initialization has finished\n    const t2 = performance.now();\n    console.log(\"initialization has finished\");\n    console.log(`Time to initialize ${t2 - t1} milliseconds`);\n  }\n\n  //add graph\n  // this adds a graph to the current visualizer\n  /**\n   * \n   * This is the main way to add elements to the viewer window that gets initialized\n   * \n   * @param element A geomerty element + material element to add to the scene as a group line or point cloud\n   */\n  addVisElement(element: THREE.Group | THREE.Line | THREE.Points) {\n    this.scene.add(element);\n  }\n\n  // this stuff renders out one specific instances\n  /**\n   * This is the render call that is called every frame to update the rendering of the canvas\n   * Remember to do this since this is a common are for bugs to occur\n   */\n  rendercall() {\n    // this is the render draw call\n    this.renderer.render(this.scene, this.camera);\n    this.controls.update();\n  }\n}\n\nexport default {\n  GraphDrawer3d,\n};\n","export { default as Models } from \"./ErdosRenyiModel\";\n","// This essentially generates a erdos reyni graph\n// Super useful for juszt getting a random graph and studying\n// graph structure. Read more https://en.wikipedia.org/wiki/Erd%C5%91s%E2%80%93R%C3%A9nyi_model\n\nimport Edge from \"../Core/Edge\";\nimport Graph from \"../Core/Graph\";\nimport _Node from \"../Core/_Node\";\n\n/**\n * The G ( n , p ) G(n,p) model, a graph is constructed by connecting labeled nodes randomly. Each edge is included in the graph with probability p p, independently from every other edge.\n * https://en.wikipedia.org/wiki/Erd%C5%91s%E2%80%93R%C3%A9nyi_model\n * @param n Number of nodes\n * @param p Probability of two edges to eb connected\n * @returns A Erdos Reyni graph\n */\nasync function GenerateErdosReyni_n_p(n: number, p: number) {\n  // first create a list of nodes\n  const nodes = new Map();\n  const edges = new Map();\n  let node; // define once use many times basically\n  for (let i = 0; i < n; i++) {\n    node = new _Node({});\n    // set this node\n    nodes.set(i, node);\n  }\n  // now that all the nodes have been created\n  // now loop all the node combinations and then\n  // create the edge\n  let interimP;\n  let edge;\n  let index = 0;\n  for (let i = 0; i < n; i++) {\n    for (let ii = 0; ii < n; ii++) {\n      // im skipping self loops so just make sure there is\n      // an if statement for the settings\n      if (i != ii) {\n        interimP = Math.random();\n        if (p > interimP) {\n          // then create and edge and add that edge to the list of edges\n          edge = new Edge(i, ii, {});\n          edges.set(index, edge);\n          index += 1;\n        }\n      }\n    }\n  }\n  // now create the actual graph\n  const G = new Graph(nodes, edges);\n  // lastly return the graph\n  return G;\n}\n\nexport default { GenerateErdosReyni_n_p };\n","/**\n * Hierarchical node combining: cluster nodes (e.g. by distance) and build a simplified graph.\n * Inspired by FlowmapBlue-style location clustering; uses KD-tree distance-based grouping by default.\n */\n\nimport Graph from \"../Core/Graph\";\nimport type { ClusterResult, ClusterStrategy, ClusterByDistanceOptions } from \"./types\";\nimport { createKDDistanceStrategy } from \"./KDDistanceStrategy\";\nimport { buildSimplifiedGraph } from \"./buildSimplifiedGraph\";\n\n/**\n * Cluster the graph by distance (KD-tree based) and return a simplified graph.\n * Nodes within `distanceThreshold` are merged; super-nodes are placed at cluster centroids.\n *\n * @param graph - The graph to cluster\n * @param options - { distanceThreshold: number }\n * @returns A new graph with one node per cluster and aggregated edges between clusters\n */\nasync function clusterByDistance(\n  graph: Graph,\n  options: ClusterByDistanceOptions\n): Promise<Graph> {\n  const strategy = createKDDistanceStrategy();\n  const result = strategy.cluster(graph, options);\n  return buildSimplifiedGraph(graph, result);\n}\n\n/**\n * Cluster the graph using a custom strategy and return a simplified graph.\n *\n * @param graph - The graph to cluster\n * @param strategy - A ClusterStrategy implementation\n * @param options - Strategy-specific options\n * @returns A new graph with one node per cluster and aggregated edges\n */\nasync function clusterByStrategy(\n  graph: Graph,\n  strategy: ClusterStrategy,\n  options: Record<string, unknown>\n): Promise<Graph> {\n  const result = strategy.cluster(graph, options);\n  return buildSimplifiedGraph(graph, result);\n}\n\nexport type { ClusterResult, ClusterStrategy, ClusterByDistanceOptions };\nexport { createKDDistanceStrategy, buildSimplifiedGraph };\n\nexport default {\n  clusterByDistance,\n  clusterByStrategy,\n};\n","/**\n * KD-tree distance-based cluster strategy.\n * Nodes within the given distance threshold are merged into the same cluster.\n */\n\nimport Graph from \"../Core/Graph\";\nimport _Node from \"../Core/_Node\";\nimport Point from \"../HelperClasses/Point\";\nimport GeometryHelpers from \"../HelperClasses/GeometryHelpers\";\nimport type { ClusterResult } from \"./types\";\nimport type { ClusterByDistanceOptions } from \"./types\";\nimport { pointsWithinRadius } from \"./KDTree\";\n\nclass UnionFind {\n  private parent: Map<number, number> = new Map();\n\n  find(x: number): number {\n    if (!this.parent.has(x)) this.parent.set(x, x);\n    if (this.parent.get(x) !== x) {\n      this.parent.set(x, this.find(this.parent.get(x)!));\n    }\n    return this.parent.get(x)!;\n  }\n\n  union(x: number, y: number): void {\n    const px = this.find(x);\n    const py = this.find(y);\n    if (px !== py) this.parent.set(px, py);\n  }\n}\n\n/**\n * Cluster strategy that groups nodes by Euclidean distance using a KD-tree.\n */\nexport function createKDDistanceStrategy(): { cluster: (graph: Graph, options: ClusterByDistanceOptions) => ClusterResult } {\n  return {\n    cluster(graph: Graph, options: ClusterByDistanceOptions): ClusterResult {\n      const { distanceThreshold } = options;\n      const pmap = graph.get_position_map();\n      const items: Array<{ point: Point; nodeId: number }> = [];\n      for (const [nodeId, point] of pmap) {\n        items.push({ point, nodeId });\n      }\n\n      if (items.length === 0) {\n        return { nodeToCluster: new Map(), clusterCentroids: new Map(), clusterIds: [] };\n      }\n\n      const withinRadius = pointsWithinRadius(items, distanceThreshold);\n      const uf = new UnionFind();\n\n      for (const [nodeId, neighbors] of withinRadius) {\n        for (const other of neighbors) {\n          uf.union(nodeId, other);\n        }\n      }\n\n      const rootToClusterId = new Map<number, number>();\n      let nextId = 0;\n      const nodeToCluster = new Map<number, number>();\n      const clusterToNodes = new Map<number, number[]>();\n\n      for (const { nodeId } of items) {\n        const root = uf.find(nodeId);\n        if (!rootToClusterId.has(root)) {\n          rootToClusterId.set(root, nextId++);\n        }\n        const cid = rootToClusterId.get(root)!;\n        nodeToCluster.set(nodeId, cid);\n        if (!clusterToNodes.has(cid)) clusterToNodes.set(cid, []);\n        clusterToNodes.get(cid)!.push(nodeId);\n      }\n\n      const clusterCentroids = new Map<number, Point>();\n      for (const [cid, nids] of clusterToNodes) {\n        const points = nids.map((id) => pmap.get(id)!);\n        clusterCentroids.set(cid, GeometryHelpers.centroid(points));\n      }\n\n      const clusterIds = [...clusterToNodes.keys()];\n\n      return { nodeToCluster, clusterCentroids, clusterIds };\n    },\n  };\n}\n","/**\n * Minimal 3D KD-tree for range queries (points within distance).\n * Used by the distance-based cluster strategy.\n */\n\nimport type Point from \"../HelperClasses/Point\";\n\nexport interface PointWithId {\n  point: Point;\n  nodeId: number;\n}\n\nfunction sqDist(a: Point, b: Point): number {\n  const dx = a.x - b.x;\n  const dy = a.y - b.y;\n  const dz = a.z - b.z;\n  return dx * dx + dy * dy + dz * dz;\n}\n\nfunction selectAxis(depth: number): \"x\" | \"y\" | \"z\" {\n  const axes: Array<\"x\" | \"y\" | \"z\"> = [\"x\", \"y\", \"z\"];\n  return axes[depth % 3];\n}\n\n/**\n * Build a KD-tree from points with node IDs.\n * Returns a tree structure used for range queries.\n */\nfunction buildKDT(\n  items: PointWithId[],\n  depth: number\n): { left?: ReturnType<typeof buildKDT>; right?: ReturnType<typeof buildKDT>; item: PointWithId } | null {\n  if (items.length === 0) return null;\n  if (items.length === 1) return { item: items[0] };\n\n  const axis = selectAxis(depth);\n  const sorted = [...items].sort((a, b) => a.point[axis] - b.point[axis]);\n  const mid = Math.floor(sorted.length / 2);\n  const median = sorted[mid];\n\n  const left = mid > 0 ? buildKDT(sorted.slice(0, mid), depth + 1) : null;\n  const right =\n    mid + 1 < sorted.length ? buildKDT(sorted.slice(mid + 1), depth + 1) : null;\n\n  return { left: left ?? undefined, right: right ?? undefined, item: median };\n}\n\n/**\n * Query all points within squared distance dSq of the given point.\n * Returns array of node IDs.\n */\nfunction rangeQuery(\n  node: ReturnType<typeof buildKDT>,\n  center: Point,\n  dSq: number,\n  depth: number,\n  out: number[]\n): void {\n  if (node === null) return;\n\n  const axis = selectAxis(depth);\n  const dist = sqDist(center, node.item.point);\n  if (dist <= dSq) out.push(node.item.nodeId);\n\n  const planeDist = center[axis] - node.item.point[axis];\n  const planeDistSq = planeDist * planeDist;\n\n  if (planeDist <= 0) {\n    if (node.left) rangeQuery(node.left, center, dSq, depth + 1, out);\n    if (node.right && planeDistSq <= dSq) rangeQuery(node.right, center, dSq, depth + 1, out);\n  } else {\n    if (node.right) rangeQuery(node.right, center, dSq, depth + 1, out);\n    if (node.left && planeDistSq <= dSq) rangeQuery(node.left, center, dSq, depth + 1, out);\n  }\n}\n\n/**\n * Find all point IDs within `radius` of each point in `items`.\n * Returns Map<nodeId, nodeIds[] within radius (including self)>.\n */\nexport function pointsWithinRadius(\n  items: PointWithId[],\n  radius: number\n): Map<number, number[]> {\n  const tree = buildKDT(items, 0);\n  const radiusSq = radius * radius;\n  const result = new Map<number, number[]>();\n\n  for (const { point, nodeId } of items) {\n    const out: number[] = [];\n    if (tree) rangeQuery(tree, point, radiusSq, 0, out);\n    result.set(nodeId, out);\n  }\n\n  return result;\n}\n","/**\n * Build a simplified Graph from a clustering result and the original graph.\n * Super-nodes are placed at cluster centroids; edges between clusters are aggregated.\n */\n\nimport Graph from \"../Core/Graph\";\nimport _Node from \"../Core/_Node\";\nimport Edge from \"../Core/Edge\";\nimport type { ClusterResult } from \"./types\";\n\n/**\n * Build a new graph where each cluster is one node (at its centroid) and edges\n * between clusters are merged (one edge per cluster pair; optional weight/count in data).\n */\nexport async function buildSimplifiedGraph(\n  originalGraph: Graph,\n  clusterResult: ClusterResult\n): Promise<Graph> {\n  const { nodeToCluster, clusterCentroids, clusterIds } = clusterResult;\n  const nodes = new Map<number, _Node>();\n  const edges = new Map<number, Edge>();\n\n  for (const cid of clusterIds) {\n    const pos = clusterCentroids.get(cid)!;\n    const n = new _Node({ pos });\n    nodes.set(cid, n);\n  }\n\n  const edgeCount = new Map<string, number>();\n  const key = (a: number, b: number) => (a <= b ? `${a},${b}` : `${b},${a}`);\n\n  for (const [, edge] of originalGraph.edges) {\n    const ca = nodeToCluster.get(edge.start);\n    const cb = nodeToCluster.get(edge.end);\n    if (ca === undefined || cb === undefined) continue;\n    if (ca === cb) continue;\n    const k = key(ca, cb);\n    edgeCount.set(k, (edgeCount.get(k) ?? 0) + 1);\n  }\n\n  let eid = 0;\n  for (const [k, count] of edgeCount) {\n    const [a, b] = k.split(\",\").map(Number);\n    edges.set(eid++, new Edge(a, b, { count }));\n  }\n\n  const simplified = new Graph(nodes, edges);\n  await simplified.initialize();\n  return simplified;\n}\n"],"names":[],"version":3,"file":"pgl.js.map"}