{"mappings":"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AG;SAAE;QACN;YAAC;YAAG;SAAE;QACN;YAAC;YAAG;SAAE;QACN;YAAC;YAAG;SAAG;QACP;YAAC;YAAG;SAAG;QACP;YAAC;YAAG;SAAG;QACP;YAAC;YAAG;SAAG;QACP;YAAC;YAAG;SAAG;QACP;YAAC;YAAG;SAAG;QACP;YAAC;YAAG;SAAG;QACP;YAAC;YAAG;SAAG;QACP;YAAC;YAAG;SAAE;QACN;YAAC;YAAG;SAAE;QACN;YAAC;YAAG;SAAE;QACN;YAAC;YAAG;SAAG;QACP;YAAC;YAAG;SAAG;QACP;YAAC;YAAG;SAAG;QACP;YAAC;YAAG;SAAG;QACP;YAAC;YAAG;SAAG;QACP;YAAC;YAAG;SAAE;QACN;YAAC;YAAG;SAAE;QACN;YAAC;YAAG;SAAE;QACN;YAAC;YAAG;SAAE;QACN;YAAC;YAAG;SAAG;QACP;YAAC;YAAG;SAAG;QACP;YAAC;YAAG;SAAG;QACP;YAAC;YAAG;SAAG;QACP;YAAC;YAAG;SAAE;QACN;YAAC;YAAG;SAAG;QACP;YAAC;YAAG;SAAG;QACP;YAAC;YAAG;SAAE;QACN;YAAC;YAAG;SAAG;QACP;YAAC;YAAG;SAAE;QACN;YAAC;YAAG;SAAG;QACP;YAAC;YAAG;SAAG;QACP;YAAC;YAAG;SAAG;QACP;YAAC;YAAG;SAAG;QACP;YAAC;YAAG;SAAG;QACP;YAAC;YAAG;SAAG;QACP;YAAC;YAAG;SAAG;QACP;YAAC;YAAI;SAAG;QACR;YAAC;YAAI;SAAG;QACR;YAAC;YAAI;SAAG;QACR;YAAC;YAAI;SAAG;QACR;YAAC;YAAI;SAAG;QACR;YAAC;YAAI;SAAG;QACR;YAAC;YAAI;SAAG;QACR;YAAC;YAAI;SAAG;QACR;YAAC;YAAI;SAAG;QACR;YAAC;YAAI;SAAG;QACR;YAAC;YAAI;SAAG;QACR;YAAC;YAAI;SAAG;QACR;YAAC;YAAI;SAAG;QACR;YAAC;YAAI;SAAG;QACR;YAAC;YAAI;SAAG;QACR;YAAC;YAAI;SAAG;QACR;YAAC;YAAI;SAAG;QACR;YAAC;YAAI;SAAG;QACR;YAAC;YAAI;SAAG;QACR;YAAC;YAAI;SAAG;QACR;YAAC;YA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","sources":["Src/Drawing/Drawing.ts","Src/HelperClasses/Utilities.ts","Src/HelperClasses/GeometryHelpers.ts","Src/HelperClasses/Point.ts","Src/HelperClasses/Line.ts","Src/GraphAlgorithms/GraphMethods.ts","Src/Core/Graph.ts","Src/Core/Edge.ts","Src/Drawing/ThreeJSDrawer.ts","Src/HelperClasses/ColorHelper.ts","Src/Shaders/vertexShader.glsl.ts","Src/Shaders/fragmentShader.glsl.ts","Src/index.ts","Src/SampleData/DataLoader.ts","Src/SampleData/ZKC.ts","Src/SampleData/ZKC_simulated.ts","Src/HelperClasses/GraphConstructors.ts","Src/Core/_Node.ts","Src/Drawing/GraphDrawer.ts"],"sourcesContent":["import Utilities from \"../HelperClasses/Utilities\";\r\nimport GeometryHelpers from \"../HelperClasses/GeometryHelpers\";\r\nimport { Point } from \"../HelperClasses/Point\";\r\nimport { Line } from \"../HelperClasses/Line\";\r\nimport { Edge } from \"../Core/Edge\";\r\nimport GraphMethods from \"../GraphAlgorithms/GraphMethods\";\r\nimport { Graph } from \"../Core/Graph\";\r\nimport { _Node } from \"../Core/_Node\";\r\n\r\n// draw kamada kawai\r\nasync function SimulateKamadaKawai(\r\n  G: Graph,\r\n  iterations: number,\r\n  simulationBound: number = 200,\r\n  cohesionValue: number = 1\r\n) {\r\n  const adjList = G.get_adjacency();\r\n  // pos map\r\n  const PosMapX: Map<number, number> = new Map();\r\n  const PosMapY: Map<number, number> = new Map();\r\n  let rx, ry;\r\n  for (const node of adjList.keys()) {\r\n    rx = Math.random() * simulationBound;\r\n    ry = Math.random() * simulationBound;\r\n    PosMapX.set(node, rx);\r\n    PosMapY.set(node, ry);\r\n  }\r\n  // start simulation\r\n  for (let i = 0; i < iterations; i++) {\r\n    // calculate the clustering force\r\n    // these two keep track of the node being simulated's\r\n    // position - redeclaring is sorta unncessary\r\n    let nodeX: number;\r\n    let nodeY: number;\r\n    // also keep track of all the x_s and y_s\r\n    let x_s: number[];\r\n    let y_s: number[];\r\n    // also the same thing for the clustering force\r\n    let y_r: number[];\r\n    let x_r: number[];\r\n    // same thing for the cohesion values that get recalculated\r\n    let new_c_xpos_dispacement: number;\r\n    let new_c_ypos_dispacement: number;\r\n\r\n    for (const node of adjList.keys()) {\r\n      // this chunk is for the attraction force\r\n      // get the node pos\r\n      const neighbours = adjList.get(node)!;\r\n      // remember always declare this nodes details\r\n      nodeX = PosMapX.get(node)!;\r\n      nodeY = PosMapY.get(node)!;\r\n      // get the set of x's\r\n      x_s = [];\r\n      // get the set of y's\r\n      y_s = [];\r\n      // now iterate through the pos list and append\r\n      neighbours.forEach((n_s) => {\r\n        const n_pos_x = PosMapX.get(n_s)!;\r\n        const n_pos_y = PosMapY.get(n_s)!;\r\n        x_s.push(n_pos_x);\r\n        y_s.push(n_pos_y);\r\n      });\r\n      // now average out the values\r\n      const new_c_xpos = Utilities.calculateAverage(x_s);\r\n      const new_c_ypos = Utilities.calculateAverage(y_s);\r\n\r\n      // this chunk is for the repelling force\r\n      y_r = [];\r\n      x_r = [];\r\n      let diffx: number;\r\n      let diffy: number;\r\n      let othernodeX: number;\r\n      let othernodeY: number;\r\n\r\n      // then find the element\r\n      for (const otherNode of G.nodes.keys()) {\r\n        // get the position of all the other nodes\r\n        if (otherNode != node) {\r\n          // calculate inverse distance\r\n          othernodeX = PosMapX.get(otherNode)!;\r\n          othernodeY = PosMapY.get(otherNode)!;\r\n          diffx = othernodeX - nodeX;\r\n          diffy = othernodeY - nodeY;\r\n          // get the inverse square value\r\n          // add that to the *_r arrays\r\n          x_r.push(diffx);\r\n          y_r.push(diffy);\r\n        }\r\n      }\r\n      // this is the repulsion value\r\n      const A_mult = 2;\r\n      const new_x_r_pos =\r\n        (A_mult * 1) /\r\n        (Utilities.calculateAverage(x_r) * Utilities.calculateAverage(x_r));\r\n      const new_y_r_pos =\r\n        (A_mult * 1) /\r\n        (Utilities.calculateAverage(y_r) * Utilities.calculateAverage(y_r));\r\n\r\n      // calculate the dispacement amount in c/y pos\r\n      // this is the cohesion value\r\n      const new_c_xpos_dispacement = cohesionValue * (new_c_xpos - nodeX);\r\n      const new_c_ypos_dispacement = cohesionValue * (new_c_ypos - nodeY);\r\n\r\n      // then add the x and y components of the two vectors\r\n      const new_xpos = new_x_r_pos + new_c_xpos_dispacement + nodeX;\r\n      const new_ypos = new_y_r_pos + new_c_ypos_dispacement + nodeY;\r\n\r\n      // now set these positions\r\n      PosMapX.set(node, new_xpos);\r\n      PosMapY.set(node, new_ypos);\r\n    }\r\n  }\r\n  // return the position\r\n  // keep in mind three JS works with Y upwards and not Z\r\n  // in my head I work the other way round so Im swapping the Z and Y values here\r\n  let PosMap: Map<number, Point> = new Map();\r\n  for (const p of PosMapX.keys()) {\r\n    PosMap.set(p, new Point(PosMapX.get(p)!, 0, PosMapY.get(p)!));\r\n  }\r\n  // get / set positions\r\n  // move the points\r\n  // Since this simulation might have moved the whole graph off screen\r\n  // get the average pos\r\n  const sim_x = [];\r\n  const sim_y = [];\r\n  const sim_z = [];\r\n  let interimPoint;\r\n  for (const p of PosMap.keys()) {\r\n    interimPoint = PosMap.get(p)!;\r\n    sim_x.push(interimPoint.x);\r\n    sim_y.push(interimPoint.y);\r\n    sim_z.push(interimPoint.z);\r\n  }\r\n\r\n  const x_displacement = Utilities.calculateAverage(sim_x);\r\n  const y_displacement = Utilities.calculateAverage(sim_y);\r\n  const z_displacement = Utilities.calculateAverage(sim_z);\r\n  const dispacementVector = new Point(\r\n    -x_displacement,\r\n    -y_displacement,\r\n    -z_displacement\r\n  );\r\n\r\n  PosMap = MovePmap(PosMap, dispacementVector);\r\n  return PosMap;\r\n}\r\n\r\n// instanciate a random set of positions\r\nfunction InstanciateRandomPositions(G: Graph) {\r\n  const adjList = G.get_adjacency();\r\n  const PosMapX = new Map();\r\n  const PosMapY = new Map();\r\n  for (const node of adjList.keys()) {\r\n    PosMapX.set(node, Math.random() * 200);\r\n    PosMapY.set(node, Math.random() * 200);\r\n  }\r\n  let PosMap = new Map();\r\n  for (const p of PosMapX.keys()) {\r\n    PosMap.set(p, new Point(PosMapX.get(p), 0, PosMapY.get(p)));\r\n  }\r\n  G.apply_position_map(PosMap);\r\n  const lmap = DrawEdgeLines(G, 1);\r\n  return { pmap: PosMap, emap: lmap };\r\n}\r\n\r\n// draw the edge representations and then store them in the edge classes\r\nfunction DrawEdgeLines(G: Graph, divDistance: number) {\r\n  // this is the return map\r\n  const lineMap: Map<number, Line> = new Map();\r\n  let edge: Edge;\r\n  let start: Point;\r\n  let end: Point;\r\n  for (const key of G.edges.keys()) {\r\n    edge = G.edges.get(key)!;\r\n    // get the start pos\r\n    start = G.nodes.get(edge.start)!.data.pos;\r\n    end = G.nodes.get(edge.end)!.data.pos;\r\n    const Line = GeometryHelpers.line_from_start_end_distance(\r\n      start,\r\n      end,\r\n      divDistance\r\n    );\r\n    lineMap.set(key, Line);\r\n  }\r\n  return lineMap;\r\n}\r\n\r\n// now draw out the edge bundling thing\r\nasync function DrawEdgeBundling(\r\n  LineMap: Map<number, Line>,\r\n  iterations: number,\r\n  distance: number\r\n) {\r\n  const returnArray = LineMap;\r\n  // variables that are getting reused\r\n  let line: Line;\r\n  let otherLine: Line;\r\n  let x_s: number[];\r\n  let y_s: number[];\r\n  let z_s: number[];\r\n  let pnt: Point;\r\n  let otherpoint: Point;\r\n  let d: number;\r\n  let x_d: number;\r\n  let y_d: number;\r\n  let z_d: number;\r\n  let avgx: number;\r\n  let avgy: number;\r\n  let avgz: number;\r\n  // run it for whatever number of iterations\r\n  for (let i = 0; i < iterations; i++) {\r\n    // then iterate through every line\r\n    for (let key of returnArray.keys()) {\r\n      // then get the line that we are working with\r\n      line = returnArray.get(key)!;\r\n      // then for each point in the line we have to move it closer to the other points\r\n      for (let ii = 1; ii < line.points.length - 1; ii++) {\r\n        // then get the point that we need to work with\r\n        x_s = [];\r\n        y_s = [];\r\n        z_s = [];\r\n        pnt = line.points[ii];\r\n        // then run the point accumulation algoritm\r\n        for (let otherKey of returnArray.keys()) {\r\n          if (otherKey != key) {\r\n            // then get the other line\r\n            otherLine = returnArray.get(otherKey)!;\r\n            for (let iii = 1; iii < otherLine.points.length - 1; iii++) {\r\n              otherpoint = otherLine.points[iii];\r\n              d = Utilities.calculateSquaredDistance(pnt, otherpoint);\r\n              if (d <= Math.pow(distance, 2)) {\r\n                x_d = otherpoint.x - pnt.x;\r\n                y_d = otherpoint.y - pnt.y;\r\n                z_d = otherpoint.z - pnt.z;\r\n                x_s.push(x_d);\r\n                y_s.push(y_d);\r\n                z_s.push(z_d);\r\n              }\r\n            }\r\n          }\r\n        }\r\n        // now create a new displacement amount\r\n        avgx = pnt.x + 0.8 * (Utilities.calculateAverage(x_s) || 0);\r\n        avgy = pnt.y + 0.8 * (Utilities.calculateAverage(y_s) || 0);\r\n        avgz = pnt.z + 0.8 * (Utilities.calculateAverage(z_s) || 0);\r\n        const newPoint = new Point(avgx, avgy, avgz);\r\n        line.points[ii] = newPoint;\r\n      }\r\n    }\r\n  }\r\n  // now return that new map\r\n  return returnArray;\r\n}\r\n\r\n// displace the th edges\r\n// sorta like and arc in the middle of the thing\r\nfunction DisplaceEdgeInY(LineMap: Map<number, Line>, displacement: number) {\r\n  for (const key of LineMap.keys()) {\r\n    const line = LineMap.get(key)!;\r\n    // now for all the points in this\r\n    let pnt, ydisval;\r\n    for (let i = 0; i < line.points.length; i++) {\r\n      pnt = line.points[i];\r\n      ydisval =\r\n        displacement * Math.sin((Math.PI * i) / (line.points.length - 1));\r\n      pnt.y = pnt.y + ydisval;\r\n    }\r\n  }\r\n}\r\n\r\n// displace the graph by some measure\r\nfunction DisplaceVertices(\r\n  nodeMap: Map<number, _Node>,\r\n  parameter: string,\r\n  displacement: number\r\n) {\r\n  let max: number = 0;\r\n  let value: number, ydisplacement: number;\r\n  // go through the thing and set the min max values\r\n  for (let node of nodeMap.values()) {\r\n    value = eval(\"node.data.\" + parameter);\r\n    if (value >= max) {\r\n      max = value;\r\n    }\r\n  }\r\n  // go through the nodes again and set the values\r\n  for (const node of nodeMap.values()) {\r\n    value = eval(\"node.data.\" + parameter);\r\n    ydisplacement = (value / max) * displacement;\r\n    // now filter the values so that we know that the values are between a max and a min\r\n    ydisplacement = Math.max(0, ydisplacement); // this sets the lower bound to be something\r\n    ydisplacement = Math.min(displacement, ydisplacement); // this sets the upper bound of the thing\r\n    node.data.pos.y = ydisplacement;\r\n  }\r\n}\r\n\r\n// draw the circular vertical packing crypto like drawing\r\nasync function HivePlot(\r\n  G: Graph,\r\n  selectedNode: number,\r\n  step: number,\r\n  startP: Point\r\n) {\r\n  const adj = G.get_adjacency();\r\n  const DijkstraDepth = await GraphMethods.Dijkstra(G, selectedNode);\r\n  // calculate the number of steps that I am searching through\r\n  const steps = Math.max(...[...DijkstraDepth.values()]);\r\n  // step map\r\n  const stepMap = new Map();\r\n  // now create a stepped ring of stuff\r\n  for (let i = 0; i <= steps; i++) {\r\n    const ntier = [];\r\n    for (const nkey of DijkstraDepth.keys()) {\r\n      if (i == DijkstraDepth.get(nkey)) {\r\n        ntier.push(nkey);\r\n      }\r\n    }\r\n    stepMap.set(i, ntier);\r\n  }\r\n  // the returning pos map\r\n  const Pmap = new Map();\r\n  // now find the relevant node Positions\r\n  // get the start positions\r\n  const xoff = startP.x || 0;\r\n  const yoff = startP.y || 0;\r\n  const zoff = startP.z || 0;\r\n  // set the positions\r\n  for (const node of adj.keys()) {\r\n    const yval = DijkstraDepth.get(node)! * step;\r\n    const depthArr = stepMap.get(DijkstraDepth.get(node));\r\n    const angle = 2 * Math.PI * (depthArr.indexOf(node) / depthArr.length);\r\n    const xval = Math.sin(angle) * yval;\r\n    const zval = Math.cos(angle) * yval;\r\n    // construct a new point\r\n    const pnt = new Point(xval + xoff, -yval + yoff, zval + zoff);\r\n    Pmap.set(node, pnt);\r\n  }\r\n  // simulate the lines\r\n  G.apply_position_map(Pmap);\r\n  const lmap = DrawEdgeLines(G, 1);\r\n  const newLmap = await DrawEdgeBundling(lmap, 12, 5);\r\n  return { pmap: Pmap, emap: newLmap };\r\n}\r\n\r\n// move graph\r\nfunction MoveGraph(G: Graph, dispacement: Point) {\r\n  const Gmap = G.get_map();\r\n  const NewPmap = MovePmap(Gmap.pmap, dispacement);\r\n  const NewEmap = MoveEmap(Gmap.emap, dispacement);\r\n  G.apply_drawing_maps({ pmap: NewPmap, emap: NewEmap });\r\n}\r\n\r\n// move pmap\r\nfunction MovePmap(Pmap: Map<number, Point>, displacement: Point) {\r\n  const newPmap: Map<number, Point> = new Map();\r\n  for (let node of Pmap.keys()) {\r\n    const p = Pmap.get(node)!;\r\n    p.translate(displacement);\r\n    newPmap.set(node, p);\r\n  }\r\n  return newPmap;\r\n}\r\n\r\n// move the edges\r\nfunction MoveEmap(Emap: Map<number, Line>, dispacement: Point) {\r\n  const newEmap: Map<number, Line> = new Map();\r\n  // variables - instead of redeclaring\r\n  let interimPoints: Point[];\r\n  let interimLine: Line;\r\n  let newLine: Line;\r\n  for (let lineNumber of Emap.keys()) {\r\n    // reset the interim points\r\n    interimPoints = [];\r\n    // get the line\r\n    interimLine = Emap.get(lineNumber)!;\r\n    // move all the points\r\n    for (let pnt of interimLine.points) {\r\n      pnt.translate(dispacement);\r\n      // add this to the new stack of lines\r\n      interimPoints.push(pnt);\r\n    }\r\n    // create a new line\r\n    newLine = new Line(interimPoints);\r\n    // add this to the new map\r\n    newEmap.set(lineNumber, newLine);\r\n  }\r\n  return newEmap;\r\n}\r\n\r\n// THIS IS THE BIT THATS A BIT CONFUSING\r\n/*\r\nData for visualization is store in the graph under the elements data\r\nSo for example - the position data under a point in the graph is under \r\n- Graph.nodes.get(whatever node).data.pos \r\n*/\r\n// commenting out because appears to be redundant\r\n// update edge lines after moving points or something\r\n// this redraws the lines based on distance\r\nfunction UpdateEdgeLinesDist(G: Graph, divDistance: number) {\r\n  let edge: Edge;\r\n  let start: Point;\r\n  let end: Point;\r\n  let line: Line;\r\n  for (const key of G.edges.keys()) {\r\n    edge = G.edges.get(key)!;\r\n    // get the start pos\r\n    start = G.nodes.get(edge.start)!.data.pos;\r\n    end = G.nodes.get(edge.end)!.data.pos;\r\n    line = GeometryHelpers.line_from_start_end_distance(\r\n      start,\r\n      end,\r\n      divDistance\r\n    );\r\n    edge.data.ldata = line;\r\n  }\r\n}\r\n\r\n// function Update EdgeLines based on the number of divisions\r\n// redraw the line based on divisions\r\nfunction UpdateEdgeLinesDivs(G: Graph, Divs: number) {\r\n  let edge: Edge;\r\n  let start: Point;\r\n  let end: Point;\r\n  let line: Line;\r\n  for (const key of G.edges.keys()) {\r\n    edge = G.edges.get(key)!;\r\n    // get the start pos\r\n    start = G.nodes.get(edge.start)!.data.pos;\r\n    end = G.nodes.get(edge.end)!.data.pos;\r\n    line = GeometryHelpers.line_from_start_end_divisions(start, end, Divs);\r\n    edge.data.ldata = line;\r\n  }\r\n}\r\n\r\nexport default {\r\n  SimulateKamadaKawai,\r\n  DrawEdgeLines,\r\n  DrawEdgeBundling,\r\n  HivePlot,\r\n  DisplaceEdgeInY,\r\n  MoveGraph,\r\n  InstanciateRandomPositions,\r\n  DisplaceVertices,\r\n  // these two are special functions\r\n  UpdateEdgeLinesDist,\r\n  UpdateEdgeLinesDivs,\r\n};\r\n","import { Point } from \"./Point\";\r\n\r\n// Calculate average\r\nfunction calculateAverage(arr: number[]) {\r\n  let runningSum = 0;\r\n  for (let i = 0; i < arr.length; i++) {\r\n    runningSum = runningSum + arr[i];\r\n  }\r\n  const avg = runningSum / arr.length;\r\n  return avg;\r\n}\r\n\r\n// calculate distance between two points\r\nfunction calculateDistance(p1: Point, p2: Point) {\r\n  const d = Math.pow(\r\n    Math.pow(p1.x - p2.x, 2) +\r\n      Math.pow(p1.y - p2.y, 2) +\r\n      Math.pow(p1.z - p2.z, 2),\r\n    0.5\r\n  );\r\n  return d;\r\n}\r\n\r\n// calculate squared distance sometimes we dont really need\r\n// the actual root but just a rough idea\r\nfunction calculateSquaredDistance(p1: Point, p2: Point) {\r\n  const d =\r\n    Math.pow(p1.x - p2.x, 2) +\r\n    Math.pow(p1.y - p2.y, 2) +\r\n    Math.pow(p1.z - p2.z, 2);\r\n  return d;\r\n}\r\n\r\n// get a random subset of something from a array of things\r\n// must provide the number of things we want from that array\r\nfunction getRandomSubset(arr: any[], n: number) {\r\n  var result = new Array(n),\r\n    len = arr.length,\r\n    taken = new Array(len);\r\n  if (n > len)\r\n    throw new RangeError(\"getRandom: more elements taken than available\");\r\n  while (n--) {\r\n    var x = Math.floor(Math.random() * len);\r\n    result[n] = arr[x in taken ? taken[x] : x];\r\n    taken[x] = --len in taken ? taken[len] : len;\r\n  }\r\n  return result;\r\n}\r\n\r\nexport default {\r\n  calculateAverage,\r\n  calculateDistance,\r\n  calculateSquaredDistance,\r\n  getRandomSubset,\r\n};\r\n","import { Point } from \"./Point\";\r\nimport { Line } from \"./Line\";\r\nimport Utilities from \"./Utilities\";\r\n\r\nfunction line_from_start_end_divisions(start: Point, end: Point, divisions:number) {\r\n  // create a start and end time\r\n  const Start = new Point(start.x, start.y, start.z);\r\n  const End = new Point(end.x, end.y, end.z);\r\n  // interpolated points\r\n  const points: Point[] = [];\r\n  // divisions\r\n  for (let i = 0; i <= divisions; i++) {\r\n    const interVar = i / divisions;\r\n    const newx = interVar * Start.x + (1 - interVar) * End.x;\r\n    const newy = interVar * Start.y + (1 - interVar) * End.y;\r\n    const newz = interVar * Start.z + (1 - interVar) * End.z;\r\n    const newPoint = new Point(newx, newy, newz);\r\n    points.push(newPoint);\r\n  }\r\n  // create a new line\r\n  const SubdividedLine = new Line(points);\r\n  return SubdividedLine;\r\n}\r\n\r\nfunction line_from_start_end_distance(start:Point, end:Point, distance:number) {\r\n  const dist = Utilities.calculateDistance(start, end);\r\n  const divs = Math.round(dist / distance) + 2;\r\n  const subdivline = line_from_start_end_divisions(start, end, divs);\r\n  return subdivline;\r\n}\r\n\r\nfunction centroid(points:Point[]) {\r\n  let rx = 0;\r\n  let ry = 0;\r\n  let rz = 0;\r\n  points.forEach((element) => {\r\n    rx += element.x;\r\n    ry += element.y;\r\n    rz += element.z;\r\n  });\r\n  rx = rx / points.length;\r\n  ry = ry / points.length;\r\n  rz = rz / points.length;\r\n  const centroid = new Point(rx, ry, rz);\r\n  return centroid;\r\n}\r\n\r\nexport default {\r\n  line_from_start_end_divisions,\r\n  line_from_start_end_distance,\r\n  centroid,\r\n};\r\n","interface Point {\r\n  x: number;\r\n  y: number;\r\n  z: number;\r\n}\r\n\r\nclass Point {\r\n  constructor(x:number, y:number, z:number) {\r\n    this.x = x;\r\n    this.y = y;\r\n    this.z = z;\r\n  }\r\n\r\n  // Points are somewhat the same thing as a vector \r\n  // So im using the same type instead of redeclaring the \r\n  // Type\r\n  translate(Point:Point) {\r\n    this.x = this.x + Point.x;\r\n    this.y = this.y + Point.y;\r\n    this.z = this.z + Point.z;\r\n  }\r\n}\r\n\r\nexport { Point };\r\n","import { Point } from \"./Point\";\r\n\r\ninterface Line {\r\n  points: Point[];\r\n}\r\n\r\nclass Line {\r\n  constructor(points: Point[]) {\r\n    this.points = [];\r\n    points.forEach((p) => {\r\n      const point = new Point(p.x, p.y, p.z);\r\n      this.points.push(point);\r\n    });\r\n  }\r\n}\r\n\r\nexport { Line };\r\n","import { Edge } from \"../Core/Edge\";\r\nimport { Graph } from \"../Core/Graph\";\r\nimport { _Node } from \"../Core/_Node\";\r\n\r\n// do a BFS Search Starting from some point\r\n// searches the whole graph and returns a map of which node\r\n// was searched from where\r\n// to speed this up all the nodes are actually numbers\r\nasync function BFSSearch(G:Graph, node:number) {\r\n  const adj = G.get_adjacency();\r\n  const exploredFromMap:Map<number,number> = new Map();\r\n\r\n  const explored:number[] = [];\r\n  const stack:number[] = [];\r\n\r\n  // queue the first node\r\n  stack.push(node);\r\n  exploredFromMap.set(node, -1);\r\n\r\n  // search through the whole graph\r\n  while (stack.length > 0) {\r\n    const currentNode = stack.pop()!;\r\n    // add this current node to the explored list\r\n    explored.push(currentNode);\r\n    const neighbours = adj.get(currentNode);\r\n    for (let i = 0; i < neighbours!.length; i++) {\r\n      const neighbour = neighbours![i];\r\n      if (!explored.includes(neighbour)) {\r\n        stack.push(neighbour);\r\n        exploredFromMap.set(neighbour, currentNode);\r\n      }\r\n    }\r\n  }\r\n  // then return the explored from map\r\n  return exploredFromMap;\r\n}\r\n\r\n// do a dijkstra Search Distance map\r\nasync function Dijkstra(G:Graph, Node:number) {\r\n  const adj = G.get_adjacency();\r\n  const Dmap:Map<number, number> = new Map();\r\n  // get the explored from map\r\n  const exploredFromMap = await BFSSearch(G, Node);\r\n  // then for each element in the map go through\r\n  // contact trace where that element came from\r\n  for (const n of adj.keys()) {\r\n    let i = 0;\r\n    let exploredFrom = exploredFromMap.get(n)!;\r\n    while (exploredFrom != -1) {\r\n      exploredFrom = exploredFromMap.get(exploredFrom)!;\r\n      i += 1;\r\n    }\r\n    Dmap.set(n, i);\r\n  }\r\n  // now return this map\r\n  return Dmap;\r\n}\r\n\r\n// This file contains basic things like\r\n// Graph searches and stuff\r\n// this only returns one of the diameters that is the longest \r\n// not all of them\r\nasync function GraphDiameter(graph:Graph) {\r\n  // find the diameter of the graph\r\n  // start Dijkstra from some random node\r\n  let seed = Math.floor(Math.random() * graph.nodes.size);\r\n  let Dstart = await Dijkstra(graph, seed);\r\n  // iterate through all the values and then get\r\n  // the value that is the highest amongst the others\r\n  let currentDistance = -1;\r\n  for (const n of Dstart.keys()) {\r\n    const dval = Dstart.get(n)!;\r\n    if (dval > currentDistance) {\r\n      seed = n;\r\n      currentDistance = dval;\r\n    }\r\n  }\r\n  // then search from there to the furthest point again\r\n  const newStart = seed;\r\n  Dstart = await Dijkstra(graph, seed);\r\n  // repeat the thing\r\n  currentDistance = -1;\r\n  for (const n of Dstart.keys()) {\r\n    const dval = Dstart.get(n)!;\r\n    if (dval > currentDistance) {\r\n      seed = n;\r\n      currentDistance = dval;\r\n    }\r\n  }\r\n  const returnObj = {\r\n    start: newStart,\r\n    end: seed,\r\n    distance: currentDistance,\r\n  };\r\n  return returnObj;\r\n}\r\n\r\n// Select a subrgaph\r\n// you must specify a list of nodes that you passed in\r\nasync function SelectSubgraph(graph:Graph, nodeList:number[]) {\r\n  const prunedNodes:Map<number,_Node> = new Map();\r\n  const prunedEdges:Map<number, Edge> = new Map();\r\n  // set the prunded vertices list\r\n  nodeList.forEach((element) => {\r\n    // get the element from the graph and set that\r\n    // data element in the  prunded vertices map\r\n    const ndata = graph.nodes.get(element)!;\r\n    prunedNodes.set(element, ndata);\r\n  });\r\n\r\n  // set the pruned edges list\r\n  let i = 0;\r\n  for (const edge of graph.edges.keys()) {\r\n    const edgeData = graph.edges.get(edge)!;\r\n    if (nodeList.includes(edgeData.start) && nodeList.includes(edgeData.end)) {\r\n      prunedEdges.set(i, edgeData);\r\n      i += 1;\r\n    }\r\n  }\r\n\r\n  // construct a new graph that represents the new graph\r\n  const newGraph = await Graph.create(prunedNodes, prunedEdges);\r\n  return newGraph;\r\n}\r\n\r\n// this is where the exports happen\r\nexport default { GraphDiameter, Dijkstra, BFSSearch, SelectSubgraph };\r\n","import { Line } from \"../HelperClasses/Line\";\r\nimport { Point } from \"../HelperClasses/Point\";\r\nimport { _Node } from \"./_Node\";\r\nimport { Edge } from \"./Edge\";\r\n\r\ninterface Graph {\r\n  nodes: Map<number, _Node>;\r\n  edges: Map<number, Edge>;\r\n}\r\n\r\nclass Graph {\r\n  constructor(nodes: Map<number, _Node>, edges: Map<number, Edge>) {\r\n    this.nodes = nodes;\r\n    this.edges = edges;\r\n    // execute Internal methods\r\n    // this.printData();\r\n  }\r\n\r\n  // test function\r\n  printData() {\r\n    const message =\r\n      \"This is a graph with \" +\r\n      this.nodes.size +\r\n      \" nodes and \" +\r\n      this.edges.size +\r\n      \" edges\";\r\n    console.log(message);\r\n  }\r\n\r\n  // initialize\r\n  async initialize() {\r\n    await this.constructAdjacencyList();\r\n  }\r\n\r\n  // new create method\r\n  static async create(nodes: Map<number, _Node>, edges: Map<number, Edge>) {\r\n    const g = new Graph(nodes, edges);\r\n    await g.initialize();\r\n    return g;\r\n  }\r\n\r\n  // construct the adjacency list represntation\r\n  async constructAdjacencyList() {\r\n    // I'm constructing a Graph here so some of the stuff doesnt matter\r\n    this.edges.forEach((edge) => {\r\n      // get the start point\r\n      const start = edge.start;\r\n      const end = edge.end;\r\n      // set the node property\r\n      if (this.nodes.get(start)) {\r\n        const relevantSNode = this.nodes.get(start);\r\n        relevantSNode!.neighbours.push(end);\r\n      } else if (this.nodes.get(end)) {\r\n        const relevantENode = this.nodes.get(end);\r\n        relevantENode!.neighbours.push(start);\r\n      }\r\n    });\r\n    // then for each node then get the unique neighbours\r\n    for (const key of this.nodes.keys()) {\r\n      const neighs = this.nodes.get(key)!.neighbours;\r\n      const new_neigh = [...new Set(neighs)];\r\n      const selfIndex = new_neigh.indexOf(key);\r\n      if (selfIndex > -1) {\r\n        new_neigh.splice(selfIndex, 1); // 2nd parameter means remove one item only\r\n      }\r\n      this.nodes.get(key)!.neighbours = new_neigh;\r\n    }\r\n  }\r\n\r\n  // add a node\r\n  add_node(nodeID: number, data: _Node) {\r\n    this.nodes.set(nodeID, data);\r\n  }\r\n\r\n  // add an edge\r\n  add_edge(start: number, end: number, data: any) {\r\n    const newEdge = new Edge(start, end, data);\r\n    // this is a new edge that we add to the edges\r\n    this.edges.set(this.edges.size, newEdge);\r\n    // also add this to the node neighbours\r\n    const relevantNode = this.nodes.get(start);\r\n    relevantNode!.neighbours.push(end);\r\n  }\r\n\r\n  // get an adjacency list reprentation of the graph\r\n  // this onlu has the indices and not the actual data\r\n  // associated with the node to speed things up\r\n  get_adjacency() {\r\n    const SparseMap: Map<number, number[]> = new Map();\r\n    // iterate through the node list\r\n    for (const key of this.nodes.keys()) {\r\n      SparseMap.set(key, this.nodes.get(key)!.neighbours);\r\n    }\r\n    return SparseMap;\r\n  }\r\n\r\n  // set position based on an array of positions\r\n  // this could be anything (we use kamada kawai )\r\n  apply_position_map(data: Map<number, Point>) {\r\n    for (let n of data.keys()) {\r\n      this.nodes.get(n)!.data = {\r\n        ...this.nodes.get(n)!.data,\r\n        pos: data.get(n),\r\n      };\r\n    }\r\n  }\r\n\r\n  // create new edge pos representation\r\n  // same approach for applying the key data\r\n  apply_edge_pos_maps(data: Map<number, Line>) {\r\n    for (let key of data.keys()) {\r\n      this.edges.get(key)!.data = {\r\n        ...this.edges.get(key)!.data,\r\n        ldata: data.get(key),\r\n      };\r\n    }\r\n  }\r\n\r\n  // get the edge reps\r\n  // this returns all the edge map readings\r\n  get_edge_map() {\r\n    const lines: Map<number, Line> = new Map();\r\n    for (const key of this.edges.keys()) {\r\n      const edge = this.edges.get(key)!.data.ldata;\r\n      lines.set(key, edge);\r\n    }\r\n    return lines;\r\n  }\r\n\r\n  // graph apply pos and edge map\r\n  apply_drawing_maps(layout:{\r\n    pmap:Map<number,Point>\r\n    emap:Map<number,Line>\r\n  }) {\r\n    if (layout.pmap) {\r\n      this.apply_position_map(layout.pmap);\r\n    }\r\n    if (layout.emap) {\r\n      this.apply_edge_pos_maps(layout.emap);\r\n    }\r\n  }\r\n\r\n  // get the positon map of the graph\r\n  get_map() {\r\n    return {\r\n      pmap: this.get_position_map(),\r\n      emap: this.get_edge_map(),\r\n    };\r\n  }\r\n\r\n  get_position_map(){\r\n    const pmap: Map<number, Point> = new Map();\r\n    for (const node of this.nodes.keys()) {\r\n      pmap.set(node, this.nodes.get(node)!.data.pos);\r\n    }\r\n    return pmap\r\n  }\r\n}\r\n\r\n// Export the graph Library\r\nexport { Graph };\r\n","interface Edge {\r\n  start: number;\r\n  end: number;\r\n  data: any;\r\n}\r\n\r\nclass Edge {\r\n  constructor(start:number, end:number, data:any) {\r\n    this.start = start;\r\n    this.end = end;\r\n    this.data = { ...data };\r\n  }\r\n}\r\n\r\nexport { Edge };\r\n","import * as THREE from \"three\";\r\nimport { Point } from \"../HelperClasses/Point\";\r\nimport { Line } from \"../HelperClasses/Line\";\r\nimport {hexToRgb} from \"../HelperClasses/ColorHelper\"\r\nimport { Line2 } from \"three/examples/jsm/lines/Line2.js\";\r\nimport { LineMaterial } from \"three/examples/jsm/lines/LineMaterial\";\r\nimport { LineGeometry } from \"three/examples/jsm/lines/LineGeometry\";\r\nimport { vertexShader } from \"../Shaders/vertexShader.glsl\";\r\nimport { fragmentShader } from \"../Shaders/fragmentShader.glsl\";\r\nimport GraphMethods from \"../GraphAlgorithms/GraphMethods\";\r\nimport { Graph } from \"../Core/Graph\";\r\nimport { _Node } from \"../Core/_Node\";\r\n\r\n// Draw the graph out as a bunch of vertices\r\n// As like tiny squares\r\nfunction DrawTHREEGraphVertices(\r\n  Graph: Graph,\r\n  bounds: number,\r\n  size: number | number[] = 1,\r\n  color: number = 0xffffff,\r\n  alpha: number = 1\r\n) {\r\n  const positionAttribute: number[] = [];\r\n  // get the corresponding points list\r\n  const pmap = Graph.get_position_map();\r\n  // declare the sizes and colors\r\n  let sizes: number[];\r\n  let colors: number[];\r\n  if (typeof size == \"number\") {\r\n    sizes = Array(Graph.nodes.size).fill(size);\r\n  } else {\r\n    sizes = size;\r\n  }\r\n  colors = Array(Graph.nodes.size).fill(color);\r\n  const labels = [];\r\n  const colorVal = new THREE.Color();\r\n  colorVal.setRGB(255, 255, 255); // white as the default\r\n  // process the data set\r\n  let i = 0;\r\n  let nodeData: Point;\r\n  for (let node of Graph.nodes.keys()) {\r\n    nodeData = pmap.get(node)!;\r\n    positionAttribute.push(\r\n      nodeData.x * bounds,\r\n      nodeData.y * bounds,\r\n      nodeData.z * bounds\r\n    );\r\n\r\n    colorVal.toArray(colors, i * 3);\r\n    labels.push(node);\r\n    i += 1;\r\n  }\r\n\r\n  const geometry = new THREE.BufferGeometry();\r\n  // geometry attribute\r\n  geometry.setAttribute(\r\n    \"position\",\r\n    new THREE.Float32BufferAttribute(positionAttribute, 3)\r\n  );\r\n  // color attribute\r\n  geometry.setAttribute(\r\n    \"customColor\",\r\n    new THREE.Float32BufferAttribute(colors, 3)\r\n  );\r\n  // size attribute\r\n  geometry.setAttribute(\"size\", new THREE.Float32BufferAttribute(sizes, 1));\r\n  // label attribute\r\n  geometry.setAttribute(\"label\", new THREE.Int32BufferAttribute(labels, 1));\r\n  geometry.name = \"nodes\";\r\n\r\n  // example material\r\n  const PointMaterial = new THREE.ShaderMaterial({\r\n    uniforms: {\r\n      color: { value: new THREE.Color(0xffffff) }, // this is a base color dont mess with this\r\n      pointTexture: {\r\n        value: new THREE.TextureLoader().load(\"./Textures/Square.png\"),\r\n      },\r\n      alphaTest: { value: alpha },\r\n    },\r\n    vertexShader: vertexShader,\r\n    fragmentShader: fragmentShader,\r\n  });\r\n\r\n  const vertices = new THREE.Group();\r\n  vertices.add(new THREE.Points(geometry, PointMaterial));\r\n  return vertices;\r\n}\r\n\r\n// then make a thing which draws out all the edges (THICK)\r\nfunction DrawTHREEGraphEdgesThick(\r\n  G: Graph,\r\n  bounds: number,\r\n  thickness: number = 0.2,\r\n  color = 0xffffff\r\n) {\r\n  // add the interpolation function\r\n  const lineMap = G.get_edge_map();\r\n  return DrawThickEdgesFromEdgeMap(lineMap, bounds, thickness, color);\r\n}\r\n\r\n// draw a thing to draw out all the edges from the edge map stuff\r\nfunction DrawThickEdgesFromEdgeMap(\r\n  emap: Map<number, Line>,\r\n  bounds: number,\r\n  thickness: number = 0.2,\r\n  color: number = 0xffffff\r\n) {\r\n  // this is the line thing\r\n  const mat = new LineMaterial({\r\n    color: color,\r\n    linewidth: thickness, // in world units with size attenuation, pixels otherwise\r\n    vertexColors: true,\r\n\r\n    //resolution:  // to be set by renderer, eventually\r\n    dashed: false,\r\n    alphaToCoverage: true,\r\n  });\r\n\r\n  const meshes = new THREE.Group();\r\n  for (let lval of emap.values()) {\r\n    const mcolor = new THREE.Color();\r\n    // convert the color that we shall be using\r\n    mcolor.setHex(color);\r\n    const pnts: number[] = [];\r\n    const cols: number[] = [];\r\n\r\n    lval.points.forEach((pnt) => {\r\n      pnts.push(\r\n        pnt.x * bounds - bounds / 2,\r\n        pnt.y * bounds - bounds / 2,\r\n        pnt.z * bounds - bounds / 2\r\n      );\r\n      cols.push(mcolor.r, mcolor.g, mcolor.b);\r\n    });\r\n\r\n    const geo = new LineGeometry();\r\n    geo.setPositions(pnts);\r\n    geo.setColors(cols);\r\n    const line = new Line2(geo, mat);\r\n    line.computeLineDistances();\r\n    line.scale.set(1, 1, 1);\r\n    meshes.add(line);\r\n  }\r\n  return meshes;\r\n}\r\n\r\n// make a thing that draws out all the lines (Thin)\r\nfunction DrawTHREEGraphEdgesThin(\r\n  G: Graph,\r\n  bounds: number,\r\n  color: number = 0xffffff\r\n) {\r\n  // first get the edge map positions\r\n  const emap = G.get_edge_map();\r\n  return DrawThinEdgesFromEdgeMap(emap, bounds, color);\r\n}\r\n\r\n// function to draw edges from edge map\r\nfunction DrawThinEdgesFromEdgeMap(\r\n  emap: Map<number, Line>,\r\n  bounds: number,\r\n  color: number = 0xffffff\r\n) {\r\n  const material = new THREE.LineBasicMaterial({\r\n    color: color,\r\n  });\r\n  const lines = new THREE.Group();\r\n  let points: THREE.Vector3[];\r\n  for (const edge of emap.values()) {\r\n    points = [];\r\n    // get the edge data\r\n    const ldata = edge.points;\r\n    ldata.forEach((element) => {\r\n      points.push(\r\n        new THREE.Vector3(\r\n          element.x * bounds,\r\n          element.y * bounds,\r\n          element.z * bounds\r\n        )\r\n      );\r\n    });\r\n    // then make the line thing\r\n    const geometry = new THREE.BufferGeometry().setFromPoints(points);\r\n    const line = new THREE.Line(geometry, material);\r\n    lines.add(line);\r\n  }\r\n  return lines;\r\n}\r\n\r\n// draw the cube box graph here\r\nfunction AddBoxBasedImaging(\r\n  nodeMap: Map<number, Point>,\r\n  bounds: number,\r\n  color: number = 0xffffff,\r\n  size: number | number[] = 10\r\n) {\r\n  // precompute all the sizes\r\n  let sizes: any;\r\n  if (typeof size == \"number\") {\r\n    sizes = Array(nodeMap.size).fill(size);\r\n  } else {\r\n    sizes = size;\r\n  }\r\n  // returns a group\r\n  const group = new THREE.Group();\r\n  const material = new THREE.MeshBasicMaterial({ color: color });\r\n  let nodeData;\r\n  let geometry: THREE.BoxGeometry;\r\n  let nodeMesh: THREE.Mesh;\r\n  for (let i = 0; i < nodeMap.size; i++) {\r\n    nodeData = nodeMap.get(i)!;\r\n    geometry = new THREE.BoxGeometry(sizes[i]);\r\n    geometry.name = i.toString();\r\n    nodeMesh = new THREE.Mesh(geometry, material);\r\n    nodeMesh.position.set(\r\n      nodeData.x * bounds,\r\n      nodeData.y * bounds,\r\n      nodeData.z * bounds\r\n    );\r\n    group.add(nodeMesh);\r\n  }\r\n  return group;\r\n}\r\n\r\n// Draw BoxBased imaging from a graph\r\nfunction DrawTHREEBoxBasedVertices(\r\n  graph: Graph,\r\n  bounds: number,\r\n  color: number = 0xffffff,\r\n  size: number | number[] = 10\r\n) {\r\n  const pmap = graph.get_position_map();\r\n  const Bgroup = AddBoxBasedImaging(pmap, bounds, color, size);\r\n  return Bgroup;\r\n}\r\n\r\n// draw cylinders where required\r\nfunction AddCylinderBasedImaging(\r\n  nodeMap: Map<number, Point>,\r\n  divisonLength: number,\r\n  color: number = 0xffffff,\r\n  size: number | number[] = 10\r\n) {\r\n  // precompute all the sizes\r\n  let sizes: any;\r\n  if (typeof size == \"number\") {\r\n    sizes.Array(nodeMap.size).fill(size);\r\n  } else {\r\n    sizes = size;\r\n  }\r\n  // returns a group\r\n  const group = new THREE.Group();\r\n  const material = new THREE.MeshBasicMaterial({ color: color });\r\n  let radius, circumfurence, segments;\r\n  let nodeData: Point;\r\n  for (let i = 0; i < nodeMap.size; i++) {\r\n    nodeData = nodeMap.get(i)!;\r\n    radius = sizes[i];\r\n    circumfurence = 2 * radius * Math.PI;\r\n    segments = Math.ceil(circumfurence / divisonLength);\r\n    const geometry = new THREE.CylinderGeometry(radius, radius, 10, segments);\r\n    geometry.name = i.toString();\r\n    const nodeMesh = new THREE.Mesh(geometry, material);\r\n    nodeMesh.position.set(nodeData.x, nodeData.y, nodeData.z);\r\n    group.add(nodeMesh);\r\n  }\r\n  return group;\r\n}\r\n\r\n// draw the sparse graph as groups\r\n// this seperates all the points based on some or the other group\r\nasync function AddInModularityBasedPointGroups(\r\n  Graph: Graph,\r\n  propertyName: string\r\n) {\r\n  // returns an array of groups\r\n  const groups: Map<number, number[]> = new Map();\r\n  let ndata: _Node;\r\n  let modularity: number;\r\n  for (let node of Graph.nodes.keys()) {\r\n    ndata = Graph.nodes.get(node)!;\r\n    modularity = eval(`ndata.data.${propertyName}}`);\r\n    if (groups.has(modularity)) {\r\n      groups.get(modularity)!.push(node);\r\n    } else {\r\n      groups.set(modularity, [node]);\r\n    }\r\n  }\r\n  // then counstruct a bunch of subraphs\r\n  const meshGraphVertices: Map<number, THREE.Group> = new Map();\r\n  const meshGraphEdges: Map<number, THREE.Group> = new Map();\r\n  let subgraphGroup: number[];\r\n  let subgraph: Graph;\r\n  let pointRep: THREE.Group;\r\n  let edges: THREE.Group;\r\n  for (let modularityGroup of groups.keys()) {\r\n    subgraphGroup = groups.get(modularityGroup)!;\r\n    // returns an array\r\n    subgraph = await GraphMethods.SelectSubgraph(Graph, subgraphGroup);\r\n    // then make the vertex thing\r\n    pointRep = DrawTHREEGraphVertices(subgraph, 1);\r\n    meshGraphVertices.set(modularityGroup, pointRep);\r\n    // make the edges\r\n    edges = DrawSimplifiedEdges(subgraph, 0.03);\r\n    meshGraphEdges.set(modularityGroup, edges);\r\n  }\r\n  const ROBJ = {\r\n    nodeGroups: meshGraphVertices,\r\n    EdgeGroups: meshGraphEdges,\r\n  };\r\n  return ROBJ;\r\n}\r\n\r\nfunction DrawSimplifiedEdges(\r\n  G: Graph,\r\n  amount: number,\r\n  color: number = 0xffffff\r\n) {\r\n  const lineGroup = new THREE.Group();\r\n  const material = new THREE.LineBasicMaterial({ color: color });\r\n  let start: Point;\r\n  let end: Point;\r\n  let points: THREE.Vector3[];\r\n  for (let edge of G.edges.values()) {\r\n    if (Math.random() <= amount) {\r\n      start = G.nodes.get(edge.start)!.data.pos;\r\n      end = G.nodes.get(edge.end)!.data.pos;\r\n      points = [];\r\n      points.push(new THREE.Vector3(start.x, start.y, start.z));\r\n      points.push(new THREE.Vector3(end.x, end.y, end.z));\r\n      const geometry = new THREE.BufferGeometry().setFromPoints(points);\r\n      const line = new THREE.Line(geometry, material);\r\n      lineGroup.add(line);\r\n    }\r\n  }\r\n  return lineGroup;\r\n}\r\n\r\nfunction ChangeTheVertexColours(vertices:THREE.Points, indexArray:number[], color:number) {\r\n  let Attrib = vertices.geometry.attributes;\r\n  let k = 0;\r\n  const newCol = hexToRgb(color)!;\r\n  indexArray.forEach((node) => {\r\n    k = node * 3; // @ts-ignore\r\n    Attrib.customColor.array[k] = newCol.r; // @ts-ignore\r\n    Attrib.customColor.array[k + 1] = newCol.g; // @ts-ignore\r\n    Attrib.customColor.array[k + 2] = newCol.b;\r\n  });\r\n  Attrib.customColor.needsUpdate = true;\r\n}\r\n\r\nfunction ResetVertexColors(vertices:THREE.Points) {\r\n  let Attrib = vertices.geometry.attributes;\r\n  let k = 0;\r\n  for (let i = 0; i < Attrib.customColor.count; i++) {\r\n    k = i * 3; // @ts-ignore\r\n    Attrib.customColor.array[k] = 255; // @ts-ignore\r\n    Attrib.customColor.array[k + 1] = 255; // @ts-ignore\r\n    Attrib.customColor.array[k + 2] = 255;\r\n  }\r\n  Attrib.customColor.needsUpdate = true;\r\n}\r\n\r\nexport default {\r\n  DrawTHREEGraphVertices,\r\n  DrawTHREEGraphEdgesThick,\r\n  DrawTHREEGraphEdgesThin,\r\n  AddBoxBasedImaging,\r\n  AddInModularityBasedPointGroups,\r\n  DrawThinEdgesFromEdgeMap,\r\n  DrawThickEdgesFromEdgeMap,\r\n  AddCylinderBasedImaging,\r\n  DrawSimplifiedEdges,\r\n  ChangeTheVertexColours,\r\n  ResetVertexColors,\r\n  DrawTHREEBoxBasedVertices,\r\n};\r\n","///////////////\r\n// color convert by Tim Down\r\n// https://stackoverflow.com/questions/5623838/rgb-to-hex-and-hex-to-rgb\r\nfunction componentToHex(c:number) {\r\n  var hex = c.toString(16);\r\n  return hex.length == 1 ? \"0\" + hex : hex;\r\n}\r\n\r\nfunction rgbToHex(r:number, g:number, b:number) {\r\n  return \"#\" + componentToHex(r) + componentToHex(g) + componentToHex(b);\r\n}\r\n\r\nfunction hexToRgb(hex:string|number) {\r\n  // Expand shorthand form (e.g. \"03F\") to full form (e.g. \"0033FF\")\r\n  var shorthandRegex = /^#?([a-f\\d])([a-f\\d])([a-f\\d])$/i;\r\n  hex = hex.toString().replace(shorthandRegex, function (m, r, g, b) {\r\n    return r + r + g + g + b + b;\r\n  });\r\n\r\n  var result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\r\n  return result\r\n    ? {\r\n        r: parseInt(result[1], 16),\r\n        g: parseInt(result[2], 16),\r\n        b: parseInt(result[3], 16),\r\n      }\r\n    : null;\r\n}\r\n\r\n\r\nexport{\r\n    rgbToHex,\r\n    hexToRgb\r\n}","const vertexShader = `\r\nattribute float size;\r\nattribute vec3 customColor;\r\n\r\nvarying vec3 vColor;\r\n\r\nvoid main() {\r\n    vColor = customColor;\r\n    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\r\n    gl_PointSize = size * ( 300.0 / -mvPosition.z );\r\n    gl_Position = projectionMatrix * mvPosition;\r\n}\r\n`\r\n\r\nexport {vertexShader};","const fragmentShader = `\r\nuniform vec3 color;\r\nuniform sampler2D pointTexture;\r\nuniform float alphaTest;\r\n\r\nvarying vec3 vColor;\r\n\r\nvoid main() {\r\n    gl_FragColor = vec4( color * vColor, 1.0 );\r\n    gl_FragColor = gl_FragColor * texture2D( pointTexture, gl_PointCoord );\r\n    if ( gl_FragColor.a < alphaTest ) discard;\r\n}\r\n`;\r\n\r\nexport { fragmentShader };\r\n","export { Graph } from \"./Core/Graph\";\r\nexport { default as GraphMethods } from \"./GraphAlgorithms/GraphMethods\";\r\nexport { default as SampleData } from \"./SampleData/DataLoader\";\r\nexport { default as Constructors } from \"./HelperClasses/GraphConstructors\";\r\nexport { default as Drawing } from \"./Drawing/Drawing\";\r\nexport { default as Geometry } from \"./HelperClasses/GeometryHelpers\";\r\nexport { default as Utilities } from \"./HelperClasses/Utilities\";\r\nexport { default as threeDWrapper } from \"./Drawing/ThreeJSDrawer\";\r\nexport { default as GraphDrawer } from \"./Drawing/GraphDrawer\";","// load up the ZKC dataset\r\nimport { zkc } from \"./ZKC\";\r\nimport { zkc_simulated } from \"./ZKC_simulated\";\r\nimport GraphConstructors from \"../HelperClasses/GraphConstructors\";\r\nimport { Graph } from \"../Core/Graph\";\r\nimport { Point } from \"../HelperClasses/Point\";\r\nimport { _Node } from \"../Core/_Node\";\r\nimport { Edge } from \"../Core/Edge\";\r\nimport Drawing from \"../Drawing/Drawing\";\r\n\r\nasync function LoadZKC() {\r\n  // load up the dataset representation\r\n  const data = zkc;\r\n  const G = await GraphConstructors.ConstructGraphNodeEdgesList(data.nodes, data.edges);\r\n  return G;\r\n}\r\n\r\nasync function LoadZKCSimulated() {\r\n  // make a map\r\n  const data = zkc_simulated;\r\n  const nodes = new Map();\r\n  const edges = new Map();\r\n  // set the node map\r\n  data.nodes.forEach((node) => {\r\n    const id = node.id;\r\n    const pos = new Point(node.px*50, 0, node.py*50);\r\n    const modularity = node.member;\r\n    const n = new _Node({ pos: pos, size:10, info:\"Node Info\", modularity:modularity });\r\n    nodes.set(id, n);\r\n  });\r\n  // set the edge map\r\n  for (let i = 0; i < data.edges.length; i++) {\r\n    const edge = data.edges[i];\r\n    const start = edge[0];\r\n    const end = edge[1];\r\n    const e = new Edge(start, end, {});\r\n    edges.set(i, e);\r\n  }\r\n  // make a graph object\r\n  const G = await Graph.create(nodes, edges);\r\n  const lmap = Drawing.DrawEdgeLines(G, 10);\r\n  G.apply_edge_pos_maps(lmap);\r\n  return G;\r\n}\r\n\r\n// exports\r\nexport default { LoadZKC, LoadZKCSimulated };\r\n","const zkc = {\r\n  nodes: [\r\n    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20,\r\n    21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33,\r\n  ],\r\n  edges: [\r\n    [0, 1],\r\n    [0, 2],\r\n    [0, 3],\r\n    [0, 4],\r\n    [0, 5],\r\n    [0, 6],\r\n    [0, 7],\r\n    [0, 8],\r\n    [0, 10],\r\n    [0, 11],\r\n    [0, 12],\r\n    [0, 13],\r\n    [0, 17],\r\n    [0, 19],\r\n    [0, 21],\r\n    [0, 31],\r\n    [1, 2],\r\n    [1, 3],\r\n    [1, 7],\r\n    [1, 13],\r\n    [1, 17],\r\n    [1, 19],\r\n    [1, 21],\r\n    [1, 30],\r\n    [2, 3],\r\n    [2, 7],\r\n    [2, 8],\r\n    [2, 9],\r\n    [2, 13],\r\n    [2, 27],\r\n    [2, 28],\r\n    [2, 32],\r\n    [3, 7],\r\n    [3, 12],\r\n    [3, 13],\r\n    [4, 6],\r\n    [4, 10],\r\n    [5, 6],\r\n    [5, 10],\r\n    [5, 16],\r\n    [6, 16],\r\n    [8, 30],\r\n    [8, 32],\r\n    [8, 33],\r\n    [9, 33],\r\n    [13, 33],\r\n    [14, 32],\r\n    [14, 33],\r\n    [15, 32],\r\n    [15, 33],\r\n    [18, 32],\r\n    [18, 33],\r\n    [19, 33],\r\n    [20, 32],\r\n    [20, 33],\r\n    [22, 32],\r\n    [22, 33],\r\n    [23, 25],\r\n    [23, 27],\r\n    [23, 29],\r\n    [23, 32],\r\n    [23, 33],\r\n    [24, 25],\r\n    [24, 27],\r\n    [24, 31],\r\n    [25, 31],\r\n    [26, 29],\r\n    [26, 33],\r\n    [27, 33],\r\n    [28, 31],\r\n    [28, 33],\r\n    [29, 32],\r\n    [29, 33],\r\n    [30, 32],\r\n    [30, 33],\r\n    [31, 32],\r\n    [31, 33],\r\n    [32, 33],\r\n  ],\r\n};\r\n\r\nexport { zkc };\r\n","const zkc_simulated = {\r\n  nodes: [\r\n    { id: 0, px: 0.09083423378081436, py: 1.164162667707135, member: 0 },\r\n    { id: 1, px: -0.5395391223661004, py: 0.8787097882002372, member: 0 },\r\n    { id: 2, px: 0.25483951690897244, py: -0.011894166387290125, member: 0 },\r\n    { id: 3, px: 0.5292273814873625, py: 0.8137715604013231, member: 0 },\r\n    { id: 4, px: 0.6759740200024705, py: 2.010590015934319, member: 3 },\r\n    { id: 5, px: 0.6648725961138767, py: 2.3765595730406712, member: 3 },\r\n    { id: 6, px: -0.015476857282255526, py: 2.421851366492045, member: 3 },\r\n    { id: 7, px: 0.9923183157183725, py: 0.7358251458599251, member: 0 },\r\n    { id: 8, px: -0.6148021363450372, py: -0.03465499210385469, member: 1 },\r\n    { id: 9, px: 0.24714516178546894, py: -1.012380550604274, member: 0 },\r\n    { id: 10, px: 1.3293288757439443, py: 1.8641805845025743, member: 3 },\r\n    { id: 11, px: -0.6571791278403557, py: 2.2163816367270526, member: 0 },\r\n    { id: 12, px: 1.5181044222926994, py: 1.3282665066698078, member: 0 },\r\n    { id: 13, px: -0.2979203330003603, py: 0.18438685313887027, member: 0 },\r\n    { id: 14, px: -1.7502345807734376, py: -1.0935551887354324, member: 1 },\r\n    { id: 15, px: -1.630224787934251, py: -1.5015879850995024, member: 1 },\r\n    { id: 16, px: 0.5585243394360673, py: 3.5, member: 3 },\r\n    { id: 17, px: -0.9776584881745712, py: 1.799718659872538, member: 0 },\r\n    { id: 18, px: -1.385649185975611, py: -1.870388302312794, member: 1 },\r\n    { id: 19, px: -0.9638464461397331, py: 0.24226946279518707, member: 0 },\r\n    { id: 20, px: -1.0268125129631975, py: -2.1543990524894148, member: 1 },\r\n    { id: 21, px: -1.3061680833745626, py: 1.527228276383933, member: 0 },\r\n    { id: 22, px: -0.5552461198316926, py: -2.2498070887997685, member: 1 },\r\n    { id: 23, px: 0.8262268914348979, py: -1.804253160744954, member: 2 },\r\n    { id: 24, px: 1.9952840970427212, py: -1.0382885070400036, member: 2 },\r\n    { id: 25, px: 1.9207660053211613, py: -0.5823795272244723, member: 2 },\r\n    { id: 26, px: -0.1664715343791652, py: -2.6527209168204373, member: 1 },\r\n    { id: 27, px: 0.9961959436268844, py: -1.0143754028553023, member: 2 },\r\n    { id: 28, px: 0.6488880579857091, py: -1.024671500275854, member: 2 },\r\n    { id: 29, px: 0.2398196340697841, py: -2.171491081802323, member: 1 },\r\n    { id: 30, px: -1.3348117368940753, py: -0.31290471156377053, member: 1 },\r\n    { id: 31, px: 0.6901260074375327, py: -0.2526601933356052, member: 2 },\r\n    { id: 32, px: -0.6030949145287146, py: -1.0927507849665647, member: 1 },\r\n    { id: 33, px: -0.3533395323856202, py: -1.1887389845640028, member: 1 },\r\n  ],\r\n  edges: [\r\n    [0, 1],\r\n    [0, 2],\r\n    [0, 3],\r\n    [0, 4],\r\n    [0, 5],\r\n    [0, 6],\r\n    [0, 7],\r\n    [0, 8],\r\n    [0, 10],\r\n    [0, 11],\r\n    [0, 12],\r\n    [0, 13],\r\n    [0, 17],\r\n    [0, 19],\r\n    [0, 21],\r\n    [0, 31],\r\n    [1, 2],\r\n    [1, 3],\r\n    [1, 7],\r\n    [1, 13],\r\n    [1, 17],\r\n    [1, 19],\r\n    [1, 21],\r\n    [1, 30],\r\n    [2, 3],\r\n    [2, 7],\r\n    [2, 8],\r\n    [2, 9],\r\n    [2, 13],\r\n    [2, 27],\r\n    [2, 28],\r\n    [2, 32],\r\n    [3, 7],\r\n    [3, 12],\r\n    [3, 13],\r\n    [4, 6],\r\n    [4, 10],\r\n    [5, 6],\r\n    [5, 10],\r\n    [5, 16],\r\n    [6, 16],\r\n    [8, 30],\r\n    [8, 32],\r\n    [8, 33],\r\n    [9, 33],\r\n    [13, 33],\r\n    [14, 32],\r\n    [14, 33],\r\n    [15, 32],\r\n    [15, 33],\r\n    [18, 32],\r\n    [18, 33],\r\n    [19, 33],\r\n    [20, 32],\r\n    [20, 33],\r\n    [22, 32],\r\n    [22, 33],\r\n    [23, 25],\r\n    [23, 27],\r\n    [23, 29],\r\n    [23, 32],\r\n    [23, 33],\r\n    [24, 25],\r\n    [24, 27],\r\n    [24, 31],\r\n    [25, 31],\r\n    [26, 29],\r\n    [26, 33],\r\n    [27, 33],\r\n    [28, 31],\r\n    [28, 33],\r\n    [29, 32],\r\n    [29, 33],\r\n    [30, 32],\r\n    [30, 33],\r\n    [31, 32],\r\n    [31, 33],\r\n    [32, 33],\r\n  ],\r\n};\r\n\r\nexport { zkc_simulated };\r\n","import { Graph } from \"../Core/Graph\";\r\nimport { _Node } from \"../Core/_Node\";\r\nimport { Edge } from \"../Core/Edge\";\r\n\r\n// construct a graph based on an edge list etc\r\nasync function ConstructGraphNodeEdgesList(nodes:any[], edges:any[]) {\r\n  // make a node OBJ\r\n  const nodeOBJ = new Map();\r\n  for (let i = 0; i < nodes.length; i++) {\r\n    const n = new _Node(nodes[i].data);\r\n    nodeOBJ.set(nodes[i], n);\r\n  }\r\n  // make an edge object\r\n  const edgeOBJ = new Map();\r\n  for (let i = 0; i < edges.length; i++) {\r\n    const e = new Edge(edges[i][0], edges[i][1], edges[i].data);\r\n    edgeOBJ.set(i, e);\r\n  }\r\n  // make a graph object\r\n  const G = await Graph.create(nodeOBJ, edgeOBJ);\r\n  return G;\r\n}\r\n\r\nexport default { ConstructGraphNodeEdgesList };\r\n","// note this file is always reffered to as\r\n// _Node to not confuse with node (js) and\r\n// Vertices which are another 3d object that\r\n// can be changed in three js\r\ninterface _Node {\r\n  data: any;\r\n  neighbours: number[];\r\n}\r\n\r\nclass _Node {\r\n  constructor(data:any) {\r\n    // this data is an arbitrary thing with which I can create any object\r\n    this.data = { ...data };\r\n    // the neighbours bit is explicity set from the code outside\r\n    this.neighbours = [];\r\n  }\r\n}\r\n\r\nexport { _Node };\r\n","import * as THREE from \"three\";\r\nimport { OrbitControls } from \"three/examples/jsm/controls/OrbitControls\";\r\nimport PGLTHREEWrapper from \"./ThreeJSDrawer\";\r\nimport { Graph } from \"../Core/Graph\";\r\n\r\n// interface for the graph drawing class\r\ninterface GraphDrawer3d {\r\n  canvas: HTMLCanvasElement;\r\n  width: number;\r\n  height: number;\r\n  geometryMap: Map<any, any>;\r\n  materialMap: Map<any, any>;\r\n  meshMap: Map<any, any>;\r\n  controls: OrbitControls;\r\n  renderer: THREE.WebGLRenderer;\r\n  camera: THREE.PerspectiveCamera;\r\n  scene: THREE.Scene;\r\n  bounds: number;\r\n  graphs: Map<number, Graph>;\r\n}\r\n\r\n// this is the 3d graph drawing class with three js\r\nclass GraphDrawer3d {\r\n  constructor(\r\n    GraphDrawerOptions3d: {\r\n      canvas: HTMLCanvasElement;\r\n      width: number;\r\n      height: number;\r\n      geometryMap: Map<any, any>;\r\n      materialMap: Map<any, any>;\r\n      meshMap: Map<any, any>;\r\n      controls: OrbitControls;\r\n      renderer: THREE.WebGLRenderer;\r\n      camera: THREE.PerspectiveCamera;\r\n      scene: THREE.Scene;\r\n      bounds: number;\r\n    },\r\n    graphs: Graph[]\r\n  ) {\r\n    this.canvas = GraphDrawerOptions3d.canvas;\r\n    this.width = GraphDrawerOptions3d.width;\r\n    this.height = GraphDrawerOptions3d.height;\r\n    // these maps are optional\r\n    // ive kepth them in as a way of managing all the\r\n    // geometry in the scene\r\n    this.geometryMap = new Map();\r\n    this.materialMap = new Map();\r\n    this.meshMap = new Map();\r\n    this.controls;\r\n    this.renderer;\r\n    this.camera;\r\n    this.scene;\r\n    // bounds is a global parameter that we change (think about this as scale)\r\n    this.bounds = GraphDrawerOptions3d.bounds;\r\n    // graph map is the hash map that holds all the\r\n    // graphs that we are working with together\r\n    this.graphs = new Map();\r\n    // add the default graph to the graph map\r\n    for (let i = 0; i < graphs.length; i++) {\r\n      const g = graphs[i];\r\n      this.graphs.set(i, g);\r\n    }\r\n  }\r\n\r\n  async init() {\r\n    const t1 = performance.now();\r\n\r\n    this.camera = new THREE.PerspectiveCamera();\r\n\r\n    // start up a new scene\r\n    this.scene = new THREE.Scene();\r\n\r\n    // set up a renderer\r\n    this.renderer = new THREE.WebGLRenderer({\r\n      canvas: this.canvas,\r\n      antialias: true,\r\n    });\r\n    this.renderer.setSize(this.width, this.height);\r\n    this.renderer.setClearColor(0xff00ff, 0);\r\n\r\n    // add in a light\r\n    this.scene.add(new THREE.AmbientLight(0xffffff));\r\n    // add a spotlight\r\n    const DirectionalLight = new THREE.DirectionalLight(0xffffff, 1);\r\n    DirectionalLight.position.set(0, 10, 0);\r\n    this.scene.add(DirectionalLight);\r\n\r\n    // set up the control system\r\n    this.controls = new OrbitControls(this.camera, this.renderer.domElement);\r\n    this.camera.position.set(0, 100, 100);\r\n    this.controls.autoRotate = true;\r\n    this.controls.maxPolarAngle = Math.PI * 0.5;\r\n    this.controls.maxDistance = 1000;\r\n    this.controls.minDistance = 10;\r\n    this.controls.update();\r\n\r\n    // add in the graph that we wanted this.graphs.get('ProvidedGraph')\r\n    for (const graph of this.graphs.keys()) {\r\n      const GeoGraph = PGLTHREEWrapper.DrawTHREEBoxBasedVertices(\r\n        this.graphs.get(graph)!,\r\n        this.bounds\r\n      );\r\n      this.scene.add(GeoGraph);\r\n      const ThickEdges = PGLTHREEWrapper.DrawTHREEGraphEdgesThick(\r\n        this.graphs.get(graph)!,\r\n        this.bounds\r\n      );\r\n      this.scene.add(ThickEdges);\r\n    }\r\n\r\n    // edges\r\n\r\n    // finally print out that the initialization has finished\r\n    const t2 = performance.now();\r\n    console.log(\"initialization has finished\");\r\n    console.log(`Time to initialize ${t2 - t1} milliseconds`);\r\n  }\r\n\r\n  // this stuff renders out one specific instances\r\n  rendercall() {\r\n    // this is the render draw call\r\n    this.renderer.render(this.scene, this.camera);\r\n    this.controls.update();\r\n  }\r\n}\r\n\r\nexport default {\r\n  GraphDrawer3d,\r\n};\r\n"],"names":[],"version":3,"file":"pgl.js.map"}