{"mappings":"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AC;YAAG;SAAE;QACN;YAAC;YAAG;SAAE;QACN;YAAC;YAAG;SAAE;QACN;YAAC;YAAG;SAAG;QACP;YAAC;YAAG;SAAG;QACP;YAAC;YAAG;SAAG;QACP;YAAC;YAAG;SAAG;QACP;YAAC;YAAG;SAAG;QACP;YAAC;YAAG;SAAE;QACN;YAAC;YAAG;SAAE;QACN;YAAC;YAAG;SAAE;QACN;YAAC;YAAG;SAAE;QACN;YAAC;YAAG;SAAG;QACP;YAAC;YAAG;SAAG;QACP;YAAC;YAAG;SAAG;QACP;YAAC;YAAG;SAAG;QACP;YAAC;YAAG;SAAE;QACN;YAAC;YAAG;SAAG;QACP;YAAC;YAAG;SAAG;QACP;YAAC;YAAG;SAAE;QACN;YAAC;YAAG;SAAG;QACP;YAAC;YAAG;SAAE;QACN;YAAC;YAAG;SAAG;QACP;YAAC;YAAG;SAAG;QACP;YAAC;YAAG;SAAG;QACP;YAAC;YAAG;SAAG;QACP;YAAC;YAAG;SAAG;QACP;YAAC;YAAG;SAAG;QACP;YAAC;YAAG;SAAG;QACP;YAAC;YAAI;SAAG;QACR;YAAC;YAAI;SAAG;QACR;YAAC;YAAI;SAAG;QACR;YAAC;YAAI;SAAG;QACR;YAAC;YAAI;SAAG;QACR;YAAC;YAAI;SAAG;QACR;YAAC;YAAI;SAAG;QACR;YAAC;YAAI;SAAG;QACR;YAAC;YAAI;SAAG;QACR;YAAC;YAAI;SAAG;QACR;YAAC;YAAI;SAAG;QACR;YAAC;YAAI;SAAG;QACR;YAAC;YAAI;SAAG;QACR;YAAC;YAAI;SAAG;QACR;YAAC;YAAI;SAAG;QACR;YAAC;YAAI;SAAG;QACR;YAAC;YAAI;SAAG;QACR;YAAC;YAAI;SAAG;QACR;YAAC;YAAI;SAAG;QACR;YAAC;YAAI;SAAG;QACR;YAAC;YAAI;SAAG;QACR;YAAC;YAAI;SAAG;QACR;YAAC;YAAI;SAAG;QACR;YAAC;YAAI;SAAG;QACR;YAAC;YAAI;SAAG;QACR;YAAC;YAAI;SAAG;QACR;YAAC;YAAI;SAAG;QACR;YAAC;YAAI;SAAG;QACR;YAAC;YAAI;SAAG;QACR;YAAC;YAAI;SAAG;QACR;YAAC;YAAI;SAAG;QACR;YA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,CAAC,aAAa,EAAE;IACtB;AACD;IAED,2CAAe;;;;;A,I,kC,a,U,a,S,O,E,U,E,C,E,S;I,S,M,K;Q,O,iB,I,Q,I,E,S,O;Y,Q;Q;I;I,O,I,C,K,C,I,O,C,E,S,O,E,M;Q,S,U,K;Y,I;gB,K,U,K;Y,E,O,G;gB,O;Y;Q;Q,S,S,K;Y,I;gB,K,S,C,Q,C;Y,E,O,G;gB,O;Y;Q;Q,S,K,M;Y,O,O,Q,O,S,M,O,O,K,W;Q;Q,K,A,C,Y,U,M,S,c,E,C,E;I;A;ADvBf,8CAA8C;AAC9C;;;;;CAKG,GACH,SAAe,kDAA4B,KAAW,EAAE,KAAW;I,O,gC,I,E,K,G,K,G;QACjE,kBAAkB;QAClB,MAAM,UAAU,IAAI;QACpB,IAAK,IAAI,IAAI,GAAG,IAAI,MAAM,QAAQ,IAAK;YACrC,MAAM,IAAI,IAAI,CAAA,GAAA,wCAAA,EAAM,KAAK,CAAC,EAAE,CAAC;YAC7B,QAAQ,IAAI,KAAK,CAAC,EAAE,EAAE;QACvB;QACD,sBAAsB;QACtB,MAAM,UAAU,IAAI;QACpB,IAAK,IAAI,IAAI,GAAG,IAAI,MAAM,QAAQ,IAAK;YACrC,MAAM,IAAI,IAAI,CAAA,GAAA,cAAA,EAAK,KAAK,CAAC,EAAE,CAAC,EAAE,EAAE,KAAK,CAAC,EAAE,CAAC,EAAE,EAAE,KAAK,CAAC,EAAE,CAAC;YACtD,QAAQ,IAAI,GAAG;QAChB;QACD,sBAAsB;QACtB,MAAM,IAAI,MAAM,CAAA,GAAA,cAAA,EAAM,OAAO,SAAS;QACtC,OAAO;IACT;AAAC;IAED,2CAAe;iCAAE;AAA2B;;;;;;;;;;;;A,I,kC,a,U,a,S,O,E,U,E,C,E,S;I,S,M,K;Q,O,iB,I,Q,I,E,S,O;Y,Q;Q;I;I,O,I,C,K,C,I,O,C,E,S,O,E,M;Q,S,U,K;Y,I;gB,K,U,K;Y,E,O,G;gB,O;Y;Q;Q,S,S,K;Y,I;gB,K,S,C,Q,C;Y,E,O,G;gB,O;Y;Q;Q,S,K,M;Y,O,O,Q,O,S,M,O,O,K,W;Q;Q,K,A,C,Y,U,M,S,c,E,C,E;I;A;AHnB5C;;;CAGG,GACH,SAAe;I,O,gC,I,E,K,G,K,G;QACb,qCAAqC;QACrC,MAAM,OAAO,CAAA,GAAA,yCAAA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","sources":["Src/Drawing/Drawing.ts","Src/HelperClasses/Utilities.ts","Src/HelperClasses/GeometryHelpers.ts","Src/HelperClasses/Point.ts","Src/HelperClasses/Line.ts","Src/GraphAlgorithms/GraphMethods.ts","Src/Core/Graph.ts","Src/Core/Edge.ts","Src/Drawing/ThreeJSDrawer.ts","Src/HelperClasses/ColorHelper.ts","Src/Shaders/vertexShader.glsl.ts","Src/Shaders/fragmentShader.glsl.ts","Src/index.ts","Src/SampleData/DataLoader.ts","Src/SampleData/ZKC.ts","Src/SampleData/ZKC_simulated.ts","Src/HelperClasses/GraphConstructors.ts","Src/Core/_Node.ts","Src/Drawing/GraphDrawer.ts","Src/Models/ErdosRenyiModel.ts"],"sourcesContent":["import Utilities from \"../HelperClasses/Utilities\";\nimport GeometryHelpers from \"../HelperClasses/GeometryHelpers\";\nimport Point from \"../HelperClasses/Point\";\nimport Line from \"../HelperClasses/Line\";\nimport Edge from \"../Core/Edge\";\nimport GraphMethods from \"../GraphAlgorithms/GraphMethods\";\nimport Graph from \"../Core/Graph\";\nimport _Node from \"../Core/_Node\";\n\n/**\n * Simulates Kamada kawai for a network in 2d. 3d is not supported yet\n * Note: This is an async function as it take time for some of the large graphs\n *\n * @param Graph - The first input number\n * @param iterations - The second input number\n *  @param simulationBound - The bounds of simulation (Mostly a global number to scale the graph up or down)\n *  @param cohesionValue - How sticky the nodes are i.r. how much they cluster together\n * @returns And node map of all the nodes and their simulated positions - Please note: position maps have to to be applied to the graph!\n *\n */\nasync function SimulateKamadaKawai(\n  Graph: Graph,\n  iterations: number,\n  simulationBound: number = 200,\n  cohesionValue: number = 1\n) {\n  const adjList = Graph.get_adjacency();\n  // pos map\n  const PosMapX: Map<number, number> = new Map();\n  const PosMapY: Map<number, number> = new Map();\n  let rx, ry;\n  for (const node of adjList.keys()) {\n    rx = Math.random() * simulationBound;\n    ry = Math.random() * simulationBound;\n    PosMapX.set(node, rx);\n    PosMapY.set(node, ry);\n  }\n  // start simulation\n  for (let i = 0; i < iterations; i++) {\n    // calculate the clustering force\n    // these two keep track of the node being simulated's\n    // position - redeclaring is sorta unncessary\n    let nodeX: number;\n    let nodeY: number;\n    // also keep track of all the x_s and y_s\n    let x_s: number[];\n    let y_s: number[];\n    // also the same thing for the clustering force\n    let y_r: number[];\n    let x_r: number[];\n    // same thing for the cohesion values that get recalculated\n    let new_c_xpos_dispacement: number;\n    let new_c_ypos_dispacement: number;\n\n    for (const node of adjList.keys()) {\n      // this chunk is for the attraction force\n      // get the node pos\n      const neighbours = adjList.get(node)!;\n      // remember always declare this nodes details\n      nodeX = PosMapX.get(node)!;\n      nodeY = PosMapY.get(node)!;\n      // get the set of x's\n      x_s = [];\n      // get the set of y's\n      y_s = [];\n      // now iterate through the pos list and append\n      neighbours.forEach((n_s) => {\n        const n_pos_x = PosMapX.get(n_s)!;\n        const n_pos_y = PosMapY.get(n_s)!;\n        x_s.push(n_pos_x);\n        y_s.push(n_pos_y);\n      });\n      // now average out the values\n      const new_c_xpos = Utilities.calculateAverage(x_s);\n      const new_c_ypos = Utilities.calculateAverage(y_s);\n\n      // this chunk is for the repelling force\n      y_r = [];\n      x_r = [];\n      let diffx: number;\n      let diffy: number;\n      let othernodeX: number;\n      let othernodeY: number;\n\n      // then find the element\n      for (const otherNode of Graph.nodes.keys()) {\n        // get the position of all the other nodes\n        if (otherNode != node) {\n          // calculate inverse distance\n          othernodeX = PosMapX.get(otherNode)!;\n          othernodeY = PosMapY.get(otherNode)!;\n          diffx = othernodeX - nodeX;\n          diffy = othernodeY - nodeY;\n          // get the inverse square value\n          // add that to the *_r arrays\n          x_r.push(diffx);\n          y_r.push(diffy);\n        }\n      }\n      // this is the repulsion value\n      const A_mult = 2;\n      const new_x_r_pos =\n        (A_mult * 1) /\n        (Utilities.calculateAverage(x_r) * Utilities.calculateAverage(x_r));\n      const new_y_r_pos =\n        (A_mult * 1) /\n        (Utilities.calculateAverage(y_r) * Utilities.calculateAverage(y_r));\n\n      // calculate the dispacement amount in c/y pos\n      // this is the cohesion value\n      const new_c_xpos_dispacement = cohesionValue * (new_c_xpos - nodeX);\n      const new_c_ypos_dispacement = cohesionValue * (new_c_ypos - nodeY);\n\n      // then add the x and y components of the two vectors\n      const new_xpos = new_x_r_pos + new_c_xpos_dispacement + nodeX;\n      const new_ypos = new_y_r_pos + new_c_ypos_dispacement + nodeY;\n\n      // now set these positions\n      PosMapX.set(node, new_xpos);\n      PosMapY.set(node, new_ypos);\n    }\n  }\n  // return the position\n  // keep in mind three JS works with Y upwards and not Z\n  // in my head I work the other way round so Im swapping the Z and Y values here\n  let PosMap: Map<number, Point> = new Map();\n  for (const p of PosMapX.keys()) {\n    PosMap.set(p, new Point(PosMapX.get(p)!, 0, PosMapY.get(p)!));\n  }\n  // get / set positions\n  // move the points\n  // Since this simulation might have moved the whole graph off screen\n  // get the average pos\n  const sim_x = [];\n  const sim_y = [];\n  const sim_z = [];\n  let interimPoint;\n  for (const p of PosMap.keys()) {\n    interimPoint = PosMap.get(p)!;\n    sim_x.push(interimPoint.x);\n    sim_y.push(interimPoint.y);\n    sim_z.push(interimPoint.z);\n  }\n\n  const x_displacement = Utilities.calculateAverage(sim_x);\n  const y_displacement = Utilities.calculateAverage(sim_y);\n  const z_displacement = Utilities.calculateAverage(sim_z);\n  const dispacementVector = new Point(\n    -x_displacement,\n    -y_displacement,\n    -z_displacement\n  );\n\n  PosMap = MovePmap(PosMap, dispacementVector);\n  return PosMap;\n}\n\n/**\n *\n * Randomly sets all the positions for a graph\n * Not really very useful but I've used it in some cases and have kept it around\n *\n *  @param Graph - The graph who's nodes you would want to reposition\n *\n * @return A position map of all the nodes and its corresponding positions\n */\nfunction InstanciateRandomPositions(Graph: Graph) {\n  const adjList = Graph.get_adjacency();\n  const PosMapX: Map<number, number> = new Map();\n  const PosMapY: Map<number, number> = new Map();\n  for (const node of adjList.keys()) {\n    PosMapX.set(node, Math.random() * 200);\n    PosMapY.set(node, Math.random() * 200);\n  }\n  const PosMap: Map<number, Point> = new Map();\n  for (const p of PosMapX.keys()) {\n    PosMap.set(p, new Point(PosMapX.get(p)!, 0, PosMapY.get(p)!));\n  }\n  return PosMap;\n}\n\n/**\n *\n * Constructs the edges as lines, Note: these are just a representation of the lines\n * they then have to be visulized using one of the Three JS Drawer functions like\n * draw a thick line or a thin line\n *\n * @param Graph - The graph whos edges are getting drawn\n * @param divDistance - How many divisions to make along the edge\n * @returns A line map - which holds a map of all the edge indices and the corresponding line representations\n */\nfunction DrawEdgeLines(Graph: Graph, divDistance: number) {\n  // this is the return map\n  const lineMap: Map<number, Line> = new Map();\n  let edge: Edge;\n  let start: Point;\n  let end: Point;\n  for (const key of Graph.edges.keys()) {\n    edge = Graph.edges.get(key)!;\n    // get the start pos\n    start = Graph.nodes.get(edge.start)!.data.pos;\n    end = Graph.nodes.get(edge.end)!.data.pos;\n    const Line = GeometryHelpers.line_from_start_end_distance(\n      start,\n      end,\n      divDistance\n    );\n    lineMap.set(key, Line);\n  }\n  return lineMap;\n}\n\n/**\n *\n * Edge bundling - this isnt as fast as the current KDE based methods - but it provides a basic  method of\n * Visualizing large edge flows. Note: This is an aysnc function as it takes a while for the edge bundling to happen\n *\n * @param LineMap - The map of edges as a line map\n * @param iterations - The number of iterations to run edge bundling\n * @param distance - A shorthand for how close together the vertices need to be before they get influnced by each other\n * @returns A line map with all the updated positions of the line (Where they are bundled together) Again - this needs to be applied to the graph!\n */\nasync function DrawEdgeBundling(\n  LineMap: Map<number, Line>,\n  iterations: number,\n  distance: number\n) {\n  const returnArray = LineMap;\n  // variables that are getting reused\n  let line: Line;\n  let otherLine: Line;\n  let x_s: number[];\n  let y_s: number[];\n  let z_s: number[];\n  let pnt: Point;\n  let otherpoint: Point;\n  let d: number;\n  let x_d: number;\n  let y_d: number;\n  let z_d: number;\n  let avgx: number;\n  let avgy: number;\n  let avgz: number;\n  // run it for whatever number of iterations\n  for (let i = 0; i < iterations; i++) {\n    // then iterate through every line\n    for (let key of returnArray.keys()) {\n      // then get the line that we are working with\n      line = returnArray.get(key)!;\n      // then for each point in the line we have to move it closer to the other points\n      for (let ii = 1; ii < line.points.length - 1; ii++) {\n        // then get the point that we need to work with\n        x_s = [];\n        y_s = [];\n        z_s = [];\n        pnt = line.points[ii];\n        // then run the point accumulation algoritm\n        for (let otherKey of returnArray.keys()) {\n          if (otherKey != key) {\n            // then get the other line\n            otherLine = returnArray.get(otherKey)!;\n            for (let iii = 1; iii < otherLine.points.length - 1; iii++) {\n              otherpoint = otherLine.points[iii];\n              d = Utilities.calculateSquaredDistance(pnt, otherpoint);\n              if (d <= Math.pow(distance, 2)) {\n                x_d = otherpoint.x - pnt.x;\n                y_d = otherpoint.y - pnt.y;\n                z_d = otherpoint.z - pnt.z;\n                x_s.push(x_d);\n                y_s.push(y_d);\n                z_s.push(z_d);\n              }\n            }\n          }\n        }\n        // now create a new displacement amount\n        avgx = pnt.x + 0.8 * (Utilities.calculateAverage(x_s) || 0);\n        avgy = pnt.y + 0.8 * (Utilities.calculateAverage(y_s) || 0);\n        avgz = pnt.z + 0.8 * (Utilities.calculateAverage(z_s) || 0);\n        const newPoint = new Point(avgx, avgy, avgz);\n        line.points[ii] = newPoint;\n      }\n    }\n  }\n  // now return that new map\n  return returnArray;\n}\n\n/**\n *\n * Displace the edges vertically, almost akin to the Deck.gl arcs\n * The displacement is done in a sin curve with the ends still touching the nodes\n * Note: This is an inplace modification of the edges\n *\n * @param LineMap - The map of edges as a line map\n * @param displacement - the amount of vertical displacement\n */\nfunction DisplaceEdgeInY(LineMap: Map<number, Line>, displacement: number) {\n  for (const key of LineMap.keys()) {\n    const line = LineMap.get(key)!;\n    // now for all the points in this\n    let pnt, ydisval;\n    for (let i = 0; i < line.points.length; i++) {\n      pnt = line.points[i];\n      ydisval =\n        displacement * Math.sin((Math.PI * i) / (line.points.length - 1));\n      pnt.y = pnt.y + ydisval;\n    }\n  }\n}\n\n/**\n *\n * Displace the vertices vertically based on some prameter (For example degree or modularity)\n *\n * @param Graph - the graph whos nodes have to be displaced\n * @param parameter - the prameter based on which you want to modify the\n * @param displacement - the maximum amunt of displacement, all the other values are rescaled linerly\n */\nfunction DisplaceVertices(\n  Graph: Graph,\n  parameter: string,\n  displacement: number\n) {\n  let max: number = 0;\n  let value: number, ydisplacement: number;\n  // go through the thing and set the min max values\n  for (let node of Graph.nodes.values()) {\n    value = eval(\"node.data.\" + parameter);\n    if (value >= max) {\n      max = value;\n    }\n  }\n  // go through the nodes again and set the values\n  for (const node of Graph.nodes.values()) {\n    value = eval(\"node.data.\" + parameter);\n    ydisplacement = (value / max) * displacement;\n    // now filter the values so that we know that the values are between a max and a min\n    ydisplacement = Math.max(0, ydisplacement); // this sets the lower bound to be something\n    ydisplacement = Math.min(displacement, ydisplacement); // this sets the upper bound of the thing\n    node.data.pos.y = ydisplacement;\n  }\n}\n\n/**\n *\n * Generates a hive plot for a graph, this includes the option to displace the graph vertically based on degrees and how far away each node is\n *\n * @param Graph - The graph\n * @param selectedNode - the node around which the hive plot is generated\n * @param step - If the hive should step up or down if yes then by what increments\n * @param startPosition - Starting position\n * @returns\n */\nasync function HivePlot(\n  Graph: Graph,\n  selectedNode: number,\n  step: number,\n  startPosition: Point\n) {\n  const adj = Graph.get_adjacency();\n  const DijkstraDepth = await GraphMethods.Dijkstra(Graph, selectedNode);\n  // calculate the number of steps that I am searching through\n  const steps = Math.max(...[...DijkstraDepth.values()]);\n  // step map\n  const stepMap = new Map();\n  // now create a stepped ring of stuff\n  for (let i = 0; i <= steps; i++) {\n    const ntier = [];\n    for (const nkey of DijkstraDepth.keys()) {\n      if (i == DijkstraDepth.get(nkey)) {\n        ntier.push(nkey);\n      }\n    }\n    stepMap.set(i, ntier);\n  }\n  // the returning pos map\n  const Pmap = new Map();\n  // now find the relevant node Positions\n  // get the start positions\n  const xoff = startPosition.x || 0;\n  const yoff = startPosition.y || 0;\n  const zoff = startPosition.z || 0;\n  // set the positions\n  for (const node of adj.keys()) {\n    const yval = DijkstraDepth.get(node)! * step;\n    const depthArr = stepMap.get(DijkstraDepth.get(node));\n    const angle = 2 * Math.PI * (depthArr.indexOf(node) / depthArr.length);\n    const xval = Math.sin(angle) * yval;\n    const zval = Math.cos(angle) * yval;\n    // construct a new point\n    const pnt = new Point(xval + xoff, -yval + yoff, zval + zoff);\n    Pmap.set(node, pnt);\n  }\n  // simulate the lines\n  Graph.apply_position_map(Pmap);\n  const lmap = DrawEdgeLines(Graph, 1);\n  const newLmap = await DrawEdgeBundling(lmap, 12, 5);\n  return { pmap: Pmap, emap: newLmap };\n}\n\n/**\n * Move a graph somewhere (like the physical location) - This is an inplace movement and overwrites existing values\n *\n * @param Graph - The graph that has to be moved\n * @param dispacement - This is a point and I end up using Point and Vector interchangably. So here the xyz values from the point are used to displace the nodes\n */\nfunction MoveGraph(Graph: Graph, dispacement: Point) {\n  const Gmap = Graph.get_map();\n  const NewPmap = MovePmap(Gmap.pmap, dispacement);\n  const NewEmap = MoveEmap(Gmap.emap, dispacement);\n  Graph.apply_drawing_maps({ pmap: NewPmap, emap: NewEmap });\n}\n\n/**\n *\n * Move the nodes somewhere (Or the nodemap corresponding to the graph) - This is not an overwrite rather returns a new position map for the nodes to moved\n *\n * @param NodeM\n * ap - The Current position map of the graph\n * @param displacement - The Displacement vector\n * @returns - A new position map\n */\nfunction MovePmap(NodeMap: Map<number, Point>, displacement: Point) {\n  const newPmap: Map<number, Point> = new Map();\n  for (let node of NodeMap.keys()) {\n    const p = NodeMap.get(node)!;\n    p.translate(displacement);\n    newPmap.set(node, p);\n  }\n  return newPmap;\n}\n\n/**\n *\n * Move the edges somewhere (the edgemap corresponding to the graph) - This is not an overwrite and returns a new edge map for the edges to be moved too\n *\n * @param LineMap - The current line map, this is made up of lines\n * @param dispacement - The displacement vector\n * @returns - The new line map\n */\nfunction MoveEmap(LineMap: Map<number, Line>, dispacement: Point) {\n  const newEmap: Map<number, Line> = new Map();\n  // variables - instead of redeclaring\n  let interimPoints: Point[];\n  let interimLine: Line;\n  let newLine: Line;\n  for (let lineNumber of LineMap.keys()) {\n    // reset the interim points\n    interimPoints = [];\n    // get the line\n    interimLine = LineMap.get(lineNumber)!;\n    // move all the points\n    for (let pnt of interimLine.points) {\n      pnt.translate(dispacement);\n      // add this to the new stack of lines\n      interimPoints.push(pnt);\n    }\n    // create a new line\n    newLine = new Line(interimPoints);\n    // add this to the new map\n    newEmap.set(lineNumber, newLine);\n  }\n  return newEmap;\n}\n\n// THIS IS THE BIT THATS A BIT CONFUSING\n/*\nData for visualization is store in the graph under the elements data\nSo for example - the position data under a point in the graph is under \n- Graph.nodes.get(whatever node).data.pos \n*/\n// commenting out because appears to be redundant\n// update edge lines after moving points or something\n// this redraws the lines based on distance\n/**\n *\n *  Draw new lines from edges, and draw them based on the distance of divisions (i.e. divide the line up every 10 units) Note: This is an in place update that takes place on the graph - it overwrites the existing data.\n *\n * @param Graph - The grapht who's edges have to be updated\n * @param divDistance - The distance by which the divisions are made\n */\nfunction UpdateEdgeLinesDist(Graph: Graph, divDistance: number) {\n  let edge: Edge;\n  let start: Point;\n  let end: Point;\n  let line: Line;\n  for (const key of Graph.edges.keys()) {\n    edge = Graph.edges.get(key)!;\n    // get the start pos\n    start = Graph.nodes.get(edge.start)!.data.pos;\n    end = Graph.nodes.get(edge.end)!.data.pos;\n    line = GeometryHelpers.line_from_start_end_distance(\n      start,\n      end,\n      divDistance\n    );\n    edge.data.ldata = line;\n  }\n}\n\n/**\n * \n * Draw new lines from edges, and draw them based on divisions (i.e. divide the line into 10 units) Note: This is an in place update that takes place on the graph - it overwrites the existing data.\n\n * @param Graph - The grapht who's edges have to be updated\n * @param Divs - The number of divisions to be made\n */\nfunction UpdateEdgeLinesDivs(Graph: Graph, Divs: number) {\n  let edge: Edge;\n  let start: Point;\n  let end: Point;\n  let line: Line;\n  for (const key of Graph.edges.keys()) {\n    edge = Graph.edges.get(key)!;\n    // get the start pos\n    start = Graph.nodes.get(edge.start)!.data.pos;\n    end = Graph.nodes.get(edge.end)!.data.pos;\n    line = GeometryHelpers.line_from_start_end_divisions(start, end, Divs);\n    edge.data.ldata = line;\n  }\n}\n\nexport default {\n  SimulateKamadaKawai,\n  DrawEdgeLines,\n  DrawEdgeBundling,\n  HivePlot,\n  DisplaceEdgeInY,\n  MoveGraph,\n  InstanciateRandomPositions,\n  DisplaceVertices,\n  // these two are special functions\n  UpdateEdgeLinesDist,\n  UpdateEdgeLinesDivs,\n};\n","import Point from \"./Point\";\n\n// Calculate average\n/**\n * calculate the average of an array of numberss\n * @param arr an array of number whose average has to be calculated \n * @returns the average \n */\nfunction calculateAverage(arr: number[]) {\n  let runningSum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    runningSum = runningSum + arr[i];\n  }\n  const avg = runningSum / arr.length;\n  return avg;\n}\n\n// calculate distance between two points\n/**\n * Calculate the distance betweeen two points\n * @param p1 the first point \n * @param p2 the second point\n * @returns the distance between the points\n */\nfunction calculateDistance(p1: Point, p2: Point) {\n  const d = Math.pow(\n    Math.pow(p1.x - p2.x, 2) +\n      Math.pow(p1.y - p2.y, 2) +\n      Math.pow(p1.z - p2.z, 2),\n    0.5\n  );\n  return d;\n}\n\n// calculate squared distance sometimes we dont really need\n// the actual root but just a rough idea\n/**\n * Calculate the squared distance between two points\n * @param p1 the first point\n * @param p2 the second point\n * @returns the squared distance between the two points\n */\nfunction calculateSquaredDistance(p1: Point, p2: Point) {\n  const d =\n    Math.pow(p1.x - p2.x, 2) +\n    Math.pow(p1.y - p2.y, 2) +\n    Math.pow(p1.z - p2.z, 2);\n  return d;\n}\n\n// get a random subset of something from a array of things\n// must provide the number of things we want from that array\n/**\n * get a random subset of something from a array of things must provide the number of things we want from that array\n * @param arr the array from which the subset has to be made \n * @param n number of items to select\n * @returns a new array made up of a random sample from the original array\n */\nfunction getRandomSubset(arr: any[], n: number) {\n  var result = new Array(n),\n    len = arr.length,\n    taken = new Array(len);\n  if (n > len)\n    throw new RangeError(\"getRandom: more elements taken than available\");\n  while (n--) {\n    var x = Math.floor(Math.random() * len);\n    result[n] = arr[x in taken ? taken[x] : x];\n    taken[x] = --len in taken ? taken[len] : len;\n  }\n  return result;\n}\n\nexport default {\n  calculateAverage,\n  calculateDistance,\n  calculateSquaredDistance,\n  getRandomSubset,\n};\n","import Point from \"./Point\";\nimport Line  from \"./Line\";\nimport Utilities from \"./Utilities\";\n\n/**\n * Creates a line based on the number of divisons\n *\n * @param start the start point\n * @param end the end point\n * @param divisions the number of divisions\n * @returns the line object\n */\nfunction line_from_start_end_divisions(\n  start: Point,\n  end: Point,\n  divisions: number\n) {\n  // create a start and end time\n  const Start = new Point(start.x, start.y, start.z);\n  const End = new Point(end.x, end.y, end.z);\n  // interpolated points\n  const points: Point[] = [];\n  // divisions\n  for (let i = 0; i <= divisions; i++) {\n    const interVar = i / divisions;\n    const newx = interVar * Start.x + (1 - interVar) * End.x;\n    const newy = interVar * Start.y + (1 - interVar) * End.y;\n    const newz = interVar * Start.z + (1 - interVar) * End.z;\n    const newPoint = new Point(newx, newy, newz);\n    points.push(newPoint);\n  }\n  // create a new line\n  const SubdividedLine = new Line(points);\n  return SubdividedLine;\n}\n\n/**\n * Divides the line into a number of divisions based on distance\n * @param start - the start point\n * @param end - the end point\n * @param distance - the distance at which this line must be divided\n * @returns A line object with the right number of points\n */\nfunction line_from_start_end_distance(\n  start: Point,\n  end: Point,\n  distance: number\n) {\n  const dist = Utilities.calculateDistance(start, end);\n  const divs = Math.round(dist / distance) + 2;\n  const subdivline = line_from_start_end_divisions(start, end, divs);\n  return subdivline;\n}\n\n/**\n * Calculates the centroid of an array of points\n * @param points An array of points\n * @returns the central point of the array of points\n */\nfunction centroid(points: Point[]) {\n  let rx = 0;\n  let ry = 0;\n  let rz = 0;\n  points.forEach((element) => {\n    rx += element.x;\n    ry += element.y;\n    rz += element.z;\n  });\n  rx = rx / points.length;\n  ry = ry / points.length;\n  rz = rz / points.length;\n  const centroid = new Point(rx, ry, rz);\n  return centroid;\n}\n\nexport default {\n  line_from_start_end_divisions,\n  line_from_start_end_distance,\n  centroid,\n};\n","interface Point {\n  x: number;\n  y: number;\n  z: number;\n}\n\nclass Point {\n  /**\n   * Constructs a point based on the x y z values\n   * @param x x value \n   * @param y y value\n   * @param z z value \n   */\n  constructor(x:number, y:number, z:number) {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n  }\n\n  // Points are somewhat the same thing as a vector \n  // So im using the same type instead of redeclaring the \n  // Type\n  /**\n   * Displaces a point - note this method moves the existing point\n   * @param Point This is the displacement vactor, used as a point but the same idea holds\n   */\n  translate(Point:Point) {\n    this.x = this.x + Point.x;\n    this.y = this.y + Point.y;\n    this.z = this.z + Point.z;\n  }\n}\n\nexport default Point;\n","import Point from \"./Point\";\n\ninterface Line {\n  points: Point[];\n}\n\nclass Line {\n  /**\n   * Constructs a line from an array of points\n   * @param points an array of points\n   */\n  constructor(points: Point[]) {\n    this.points = [];\n    points.forEach((p) => {\n      const point = new Point(p.x, p.y, p.z);\n      this.points.push(point);\n    });\n  }\n}\n\nexport default Line;\n","import Edge from \"../Core/Edge\";\nimport Graph from \"../Core/Graph\";\nimport _Node from \"../Core/_Node\";\n\n// do a BFS Search Starting from some point\n// searches the whole graph and returns a map of which node\n// was searched from where\n// to speed this up all the nodes are actually numbers\n/**\n * \n * Performs a BFS search on a graph - Async because it takes a while on large graphs\n * \n * @param Graph - The graph which has to be searched using the BFS algorithm\n * @param node - The node form which to start \n * @returns - A map of which node was explored from which other node\n */\nasync function BFSSearch(Graph:Graph, node:number) {\n  const adj = Graph.get_adjacency();\n  const exploredFromMap:Map<number,number> = new Map();\n\n  const explored:number[] = [];\n  const stack:number[] = [];\n\n  // queue the first node\n  stack.push(node);\n  exploredFromMap.set(node, -1);\n\n  // search through the whole graph\n  while (stack.length > 0) {\n    const currentNode = stack.pop()!;\n    // add this current node to the explored list\n    explored.push(currentNode);\n    const neighbours = adj.get(currentNode);\n    for (let i = 0; i < neighbours!.length; i++) {\n      const neighbour = neighbours![i];\n      if (!explored.includes(neighbour)) {\n        stack.push(neighbour);\n        exploredFromMap.set(neighbour, currentNode);\n      }\n    }\n  }\n  // then return the explored from map\n  return exploredFromMap;\n}\n\n// do a dijkstra Search Distance map\n/**\n * \n * Performs a dijkstra search on a graph\n * \n * @param Graph - The graph on which to perform the Dijkstra search \n * @param Node - The node from which to start\n * @returns - Map from which each one of the nodes was searched from\n */\nasync function Dijkstra(Graph:Graph, Node:number) {\n  const adj = Graph.get_adjacency();\n  const Dmap:Map<number, number> = new Map();\n  // get the explored from map\n  const exploredFromMap = await BFSSearch(Graph, Node);\n  // then for each element in the map go through\n  // contact trace where that element came from\n  for (const n of adj.keys()) {\n    let i = 0;\n    let exploredFrom = exploredFromMap.get(n)!;\n    while (exploredFrom != -1) {\n      exploredFrom = exploredFromMap.get(exploredFrom)!;\n      i += 1;\n    }\n    Dmap.set(n, i);\n  }\n  // now return this map\n  return Dmap;\n}\n\n// This file contains basic things like\n// Graph searches and stuff\n// this only returns one of the diameters that is the longest \n// not all of them\n/**\n * \n * Finds the diameter of the graph\n * \n * @param Graph \n * @returns returns an object with a start, end - the two points of a graph and the diameter of the graph\n */\nasync function GraphDiameter(Graph:Graph) {\n  // find the diameter of the graph\n  // start Dijkstra from some random node\n  let seed = Math.floor(Math.random() * Graph.nodes.size);\n  let Dstart = await Dijkstra(Graph, seed);\n  // iterate through all the values and then get\n  // the value that is the highest amongst the others\n  let currentDistance = -1;\n  for (const n of Dstart.keys()) {\n    const dval = Dstart.get(n)!;\n    if (dval > currentDistance) {\n      seed = n;\n      currentDistance = dval;\n    }\n  }\n  // then search from there to the furthest point again\n  const newStart = seed;\n  Dstart = await Dijkstra(Graph, seed);\n  // repeat the thing\n  currentDistance = -1;\n  for (const n of Dstart.keys()) {\n    const dval = Dstart.get(n)!;\n    if (dval > currentDistance) {\n      seed = n;\n      currentDistance = dval;\n    }\n  }\n  const returnObj = {\n    start: newStart,\n    end: seed,\n    distance: currentDistance,\n  };\n  return returnObj;\n}\n\n// Select a subrgaph\n// you must specify a list of nodes that you passed in\n/**\n * \n * Select a subgraph\n * \n * @param graph - The main graph to select from\n * @param nodeList - The selection of nodes that we want to select from this graph\n * @returns A graph object that contains this subgraph\n */\nasync function SelectSubgraph(graph:Graph, nodeList:number[]) {\n  const prunedNodes:Map<number,_Node> = new Map();\n  const prunedEdges:Map<number, Edge> = new Map();\n  // set the prunded vertices list\n  nodeList.forEach((element) => {\n    // get the element from the graph and set that\n    // data element in the  prunded vertices map\n    const ndata = graph.nodes.get(element)!;\n    prunedNodes.set(element, ndata);\n  });\n\n  // set the pruned edges list\n  let i = 0;\n  for (const edge of graph.edges.keys()) {\n    const edgeData = graph.edges.get(edge)!;\n    if (nodeList.includes(edgeData.start) && nodeList.includes(edgeData.end)) {\n      prunedEdges.set(i, edgeData);\n      i += 1;\n    }\n  }\n\n  // construct a new graph that represents the new graph\n  const newGraph = await Graph.create(prunedNodes, prunedEdges);\n  return newGraph;\n}\n\n// this is where the exports happen\nexport default { GraphDiameter, Dijkstra, BFSSearch, SelectSubgraph };\n","import Line from \"../HelperClasses/Line\";\nimport Point from \"../HelperClasses/Point\";\nimport _Node from \"./_Node\";\nimport Edge from \"./Edge\";\n\ninterface Graph {\n  nodes: Map<number, _Node>;\n  edges: Map<number, Edge>;\n}\n\n/**\n * The main graph object - this contrains nodes and edges that get modified with different \n * Operations etc.\n */\nclass Graph {\n  /**\n   *\n   * Construct a graph object (no initializing)\n   *\n   * @param nodes - Map of all the nodes associated with the graph\n   * @param edges - Map of all the edges assocaiated with the graph\n   */\n  constructor(nodes: Map<number, _Node>, edges: Map<number, Edge>) {\n    this.nodes = nodes;\n    this.edges = edges;\n    // execute Internal methods\n    // this.printData();\n  }\n\n  // test function\n  /**\n   * Prints out a snapshot of data associated with this graph like how many nodes and how many edges\n   */\n  printData() {\n    const message =\n      \"This is a graph with \" +\n      this.nodes.size +\n      \" nodes and \" +\n      this.edges.size +\n      \" edges\";\n    console.log(message);\n  }\n\n  // initialize\n  /**\n   *  Initializes the graph and constructs a node adajaceny list list\n   */\n  async initialize() {\n    await this.constructAdjacencyList();\n  }\n\n  // new create method\n  /**\n   *\n   * This is the official create method to make a graph based on a set of nodes and edges\n   * It also auto initializes the graph and sets all the adjaceny lists in the memory\n   *\n   * @param nodes - map of nodes\n   * @param edges - map of edges\n   * @returns\n   */\n  static async create(nodes: Map<number, _Node>, edges: Map<number, Edge>) {\n    const g = new Graph(nodes, edges);\n    await g.initialize();\n    return g;\n  }\n\n  // construct the adjacency list represntation\n  /**\n   * Constructs the adjacency associated with the graph\n   */\n  async constructAdjacencyList() {\n    // I'm constructing a Graph here so some of the stuff doesnt matter\n    this.edges.forEach((edge) => {\n      // get the start point\n      const start = edge.start;\n      const end = edge.end;\n      // set the node property\n      if (this.nodes.get(start)) {\n        const relevantSNode = this.nodes.get(start);\n        relevantSNode!.neighbours.push(end);\n      } else if (this.nodes.get(end)) {\n        const relevantENode = this.nodes.get(end);\n        relevantENode!.neighbours.push(start);\n      }\n    });\n    // then for each node then get the unique neighbours\n    for (const key of this.nodes.keys()) {\n      const neighs = this.nodes.get(key)!.neighbours;\n      const new_neigh = [...new Set(neighs)];\n      const selfIndex = new_neigh.indexOf(key);\n      if (selfIndex > -1) {\n        new_neigh.splice(selfIndex, 1); // 2nd parameter means remove one item only\n      }\n      this.nodes.get(key)!.neighbours = new_neigh;\n    }\n  }\n\n  // add a node\n  /**\n   * Add a noce to the graph\n   * @param nodeID - the node ID\n   * @param data - data associated with the node\n   */\n  add_node(nodeID: number, data: _Node) {\n    this.nodes.set(nodeID, data);\n  }\n\n  // add an edge\n  /**\n   * Add an edge to the graph\n   * @param start - Starting index of the edge\n   * @param end - The end index of the edge\n   * @param data - data associated with the edge\n   */\n  add_edge(start: number, end: number, data: any) {\n    const newEdge = new Edge(start, end, data);\n    // this is a new edge that we add to the edges\n    this.edges.set(this.edges.size, newEdge);\n    // also add this to the node neighbours\n    const relevantNode = this.nodes.get(start);\n    relevantNode!.neighbours.push(end);\n  }\n\n  // get an adjacency list reprentation of the graph\n  // this onlu has the indices and not the actual data\n  // associated with the node to speed things up\n  /**\n   *\n   * @returns Get the adjaceny (adjacency lists) associated with the graph\n   */\n  get_adjacency() {\n    const SparseMap: Map<number, number[]> = new Map();\n    // iterate through the node list\n    for (const key of this.nodes.keys()) {\n      SparseMap.set(key, this.nodes.get(key)!.neighbours);\n    }\n    return SparseMap;\n  }\n\n  // set position based on an array of positions\n  // this could be anything (we use kamada kawai )\n  /**\n   * Apply a position map based on some data\n   * @param data - the position map that has to be applied to the graph\n   */\n  apply_position_map(data: Map<number, Point>) {\n    for (let n of data.keys()) {\n      this.nodes.get(n)!.data = {\n        ...this.nodes.get(n)!.data,\n        pos: data.get(n),\n      };\n    }\n  }\n\n  // create new edge pos representation\n  // same approach for applying the key data\n  /**\n   * Apply an line map to a graph\n   * @param data Line data that has to be applied to the graph\n   */\n  apply_edge_pos_maps(data: Map<number, Line>) {\n    for (let key of data.keys()) {\n      this.edges.get(key)!.data = {\n        ...this.edges.get(key)!.data,\n        ldata: data.get(key),\n      };\n    }\n  }\n\n  // get the edge reps\n  // this returns all the edge map readings\n  /**\n   * get the current edge map\n   * @returns The current set of edges associated with the graph\n   */\n  get_edge_map() {\n    const lines: Map<number, Line> = new Map();\n    for (const key of this.edges.keys()) {\n      const edge = this.edges.get(key)!.data.ldata;\n      lines.set(key, edge);\n    }\n    return lines;\n  }\n\n  // graph apply pos and edge map\n  /**\n   * Applies all the maps to the graph\n   * @param layout - Applies an object of maps associated with with a graph is made up of {pmap:(the position map), emap:{the edge map}}\n   */\n  apply_drawing_maps(layout: {\n    pmap: Map<number, Point>;\n    emap: Map<number, Line>;\n  }) {\n    if (layout.pmap) {\n      this.apply_position_map(layout.pmap);\n    }\n    if (layout.emap) {\n      this.apply_edge_pos_maps(layout.emap);\n    }\n  }\n\n  // get the positon map of the graph\n  /**\n   * Gets the position map and the edge map respectively\n   * @returns the positon map and the edge map as pmap and emap\n   */\n  get_map() {\n    return {\n      pmap: this.get_position_map(),\n      emap: this.get_edge_map(),\n    };\n  }\n\n  /**\n   * get the postion of the nodes in the graph\n   * @returns the position map\n   */\n  get_position_map() {\n    const pmap: Map<number, Point> = new Map();\n    for (const node of this.nodes.keys()) {\n      pmap.set(node, this.nodes.get(node)!.data.pos);\n    }\n    return pmap;\n  }\n}\n\n// Export the graph Library\nexport default Graph;\n","interface Edge {\n  start: number;\n  end: number;\n  data: any;\n}\n\n/**\n * The edge class, edges have a start and end but they can also have data associated with that edge\n */\nclass Edge {\n  /**\n   * \n   * Construct an edge\n   * \n   * @param start Start index of the edge based on the array of nodes\n   * @param end End index of the edge based on the array of nodes\n   * @param data Data associated, note that ldata is reserved for how to draw the lines associated with the edge\n   */\n  constructor(start:number, end:number, data:any) {\n    this.start = start;\n    this.end = end;\n    this.data = { ...data };\n  }\n}\n\nexport default Edge;\n","import * as THREE from \"three\";\nimport Point from \"../HelperClasses/Point\";\nimport Line from \"../HelperClasses/Line\";\nimport { hexToRgb } from \"../HelperClasses/ColorHelper\";\nimport { Line2 } from \"three/examples/jsm/lines/Line2.js\";\nimport { LineMaterial } from \"three/examples/jsm/lines/LineMaterial\";\nimport { LineGeometry } from \"three/examples/jsm/lines/LineGeometry\";\nimport { vertexShader } from \"../Shaders/vertexShader.glsl\";\nimport { fragmentShader } from \"../Shaders/fragmentShader.glsl\";\nimport GraphMethods from \"../GraphAlgorithms/GraphMethods\";\nimport Graph from \"../Core/Graph\";\nimport _Node from \"../Core/_Node\";\n\n// Draw the graph out as a bunch of vertices\n// As like tiny squares\n/**\n *\n * Draw the veritces of the graph out as a point cloud\n *\n * @param Graph - the graph that has to be drawn out\n * @param bounds - A global scaling parameter defaults to 1 but change to scale up a garph\n * @param size - The size of all the nodes - either input an array the same length of the number of nodes decribing how big each node is, or a global node value as a number or defaults to 1\n * @param color - the color of the node defaults to white\n * @param alpha - the alpha value of the node defaults to 1 (opaque)\n * @returns a three JS group that contains all the vertices as a point cloud or a three js points object that can be added to the scene\n */\nfunction DrawTHREEGraphVertices(\n  Graph: Graph,\n  bounds: number = 1,\n  size: number | number[] = 1,\n  color: number = 0xffffff,\n  alpha: number = 1\n) {\n  const positionAttribute: number[] = [];\n  // get the corresponding points list\n  const pmap = Graph.get_position_map();\n  // declare the sizes and colors\n  let sizes: number[];\n  let colors: number[];\n  if (typeof size == \"number\") {\n    sizes = Array(Graph.nodes.size).fill(size);\n  } else {\n    sizes = size;\n  }\n  colors = Array(Graph.nodes.size).fill(color);\n  const labels = [];\n  const colorVal = new THREE.Color();\n  colorVal.setRGB(255, 255, 255); // white as the default\n  // process the data set\n  let i = 0;\n  let nodeData: Point;\n  for (let node of Graph.nodes.keys()) {\n    nodeData = pmap.get(node)!;\n    positionAttribute.push(\n      nodeData.x * bounds,\n      nodeData.y * bounds,\n      nodeData.z * bounds\n    );\n\n    colorVal.toArray(colors, i * 3);\n    labels.push(node);\n    i += 1;\n  }\n\n  const geometry = new THREE.BufferGeometry();\n  // geometry attribute\n  geometry.setAttribute(\n    \"position\",\n    new THREE.Float32BufferAttribute(positionAttribute, 3)\n  );\n  // color attribute\n  geometry.setAttribute(\n    \"customColor\",\n    new THREE.Float32BufferAttribute(colors, 3)\n  );\n  // size attribute\n  geometry.setAttribute(\"size\", new THREE.Float32BufferAttribute(sizes, 1));\n  // label attribute\n  geometry.setAttribute(\"label\", new THREE.Int32BufferAttribute(labels, 1));\n  geometry.name = \"nodes\";\n\n  // example material\n  const PointMaterial = new THREE.ShaderMaterial({\n    uniforms: {\n      color: { value: new THREE.Color(0xffffff) }, // this is a base color dont mess with this\n      pointTexture: {\n        value: new THREE.TextureLoader().load(\"./Textures/Square.png\"),\n      },\n      alphaTest: { value: alpha },\n    },\n    vertexShader: vertexShader,\n    fragmentShader: fragmentShader,\n  });\n\n  const vertices = new THREE.Group();\n  vertices.add(new THREE.Points(geometry, PointMaterial));\n  return vertices;\n}\n\n// then make a thing which draws out all the edges (THICK)\n/**\n *\n * Draws out all the edges (Thick edges of a graph)\n *\n * @param Graph - The graph whose edges have to be drawn\n * @param bounds - the global scale for all the edges to be drawn defaults to 1\n * @param color - color of the edges defaults to white\n * @param thickness - thickness of the edges (defaults to 0.2)\n * @returns a Three Js group of edges that can be added to the scene\n */\nfunction DrawTHREEGraphEdgesThick(\n  Graph: Graph,\n  bounds: number = 1,\n  color = 0xffffff,\n  thickness: number = 0.2\n) {\n  // add the interpolation function\n  const lineMap = Graph.get_edge_map();\n  return DrawThickEdgesFromEdgeMap(lineMap, bounds, color, thickness);\n}\n\n// draw a thing to draw out all the edges from the edge map stuff\n/**\n *\n * Draw thick edges from an edge map\n *\n * @param EdgeMap - The edge map associated with the graph\n * @param bounds - The global scale of the graph - defaults to 1\n * @param color - The color of the edges - defaults to white\n * @param thickness - thickness of the edges - defaults to 0.2\n * @returns\n */\nfunction DrawThickEdgesFromEdgeMap(\n  EdgeMap: Map<number, Line>,\n  bounds: number,\n  color: number = 0xffffff,\n  thickness: number = 0.2\n) {\n  // this is the line thing\n  const mat = new LineMaterial({\n    color: color,\n    linewidth: thickness, // in world units with size attenuation, pixels otherwise\n    vertexColors: true,\n\n    //resolution:  // to be set by renderer, eventually\n    dashed: false,\n    alphaToCoverage: true,\n  });\n\n  const meshes = new THREE.Group();\n  for (let lval of EdgeMap.values()) {\n    const mcolor = new THREE.Color();\n    // convert the color that we shall be using\n    mcolor.setHex(color);\n    const pnts: number[] = [];\n    const cols: number[] = [];\n\n    lval.points.forEach((pnt) => {\n      pnts.push(\n        pnt.x * bounds - bounds / 2,\n        pnt.y * bounds - bounds / 2,\n        pnt.z * bounds - bounds / 2\n      );\n      cols.push(mcolor.r, mcolor.g, mcolor.b);\n    });\n\n    const geo = new LineGeometry();\n    geo.setPositions(pnts);\n    geo.setColors(cols);\n    const line = new Line2(geo, mat);\n    line.computeLineDistances();\n    line.scale.set(1, 1, 1);\n    meshes.add(line);\n  }\n  return meshes;\n}\n\n// make a thing that draws out all the lines (Thin)\n/**\n *\n * Draw thin lines for all the edges given a graph\n *\n * @param Graph - The graph that has to be drawn\n * @param bounds - The global scale factor for the the edges - defaults to 1\n * @param color - color of the lines - defaults to white\n * @returns\n */\nfunction DrawTHREEGraphEdgesThin(\n  Graph: Graph,\n  bounds: number = 1,\n  color: number = 0xffffff\n) {\n  // first get the edge map positions\n  const emap = Graph.get_edge_map();\n  return DrawThinEdgesFromEdgeMap(emap, bounds, color);\n}\n\n// function to draw edges from edge map\n/**\n *\n * Draw Line map as lines given the edge map assocaited with the graph\n *\n * @param LineMap - The edge map that has to be drawn out\n * @param bounds - Global scale for the edges to be drawn defaults to 1\n * @param color - Color of the edges defaults to 1\n * @returns\n */\nfunction DrawThinEdgesFromEdgeMap(\n  LineMap: Map<number, Line>,\n  bounds: number = 1,\n  color: number = 0xffffff\n) {\n  const material = new THREE.LineBasicMaterial({\n    color: color,\n  });\n  const lines = new THREE.Group();\n  let points: THREE.Vector3[];\n  for (const edge of LineMap.values()) {\n    points = [];\n    // get the edge data\n    const ldata = edge.points;\n    ldata.forEach((element) => {\n      points.push(\n        new THREE.Vector3(\n          element.x * bounds,\n          element.y * bounds,\n          element.z * bounds\n        )\n      );\n    });\n    // then make the line thing\n    const geometry = new THREE.BufferGeometry().setFromPoints(points);\n    const line = new THREE.Line(geometry, material);\n    lines.add(line);\n  }\n  return lines;\n}\n\n// draw the cube box graph here\n/**\n *\n * Adde boxes where all the boxes are\n *\n * @param nodeMap - a map of all the nodes\n * @param bounds - global scale of the edges to be drawn, defaults to 1\n * @param color - default color of the edges, defaults to white\n * @param size - size of the nodes defaults to 10\n * @returns a group of vertices that contains all of the boxes associated with each one of the vertices\n */\nfunction AddBoxBasedImaging(\n  nodeMap: Map<number, Point>,\n  bounds: number = 1,\n  color: number = 0xffffff,\n  size: number | number[] = 10\n) {\n  // precompute all the sizes\n  let sizes: any;\n  if (typeof size == \"number\") {\n    sizes = Array(nodeMap.size).fill(size);\n  } else {\n    sizes = size;\n  }\n  // returns a group\n  const group = new THREE.Group();\n  const material = new THREE.MeshBasicMaterial({ color: color });\n  let nodeData;\n  let geometry: THREE.BoxGeometry;\n  let nodeMesh: THREE.Mesh;\n  for (let i = 0; i < nodeMap.size; i++) {\n    nodeData = nodeMap.get(i)!;\n    geometry = new THREE.BoxGeometry(sizes[i], sizes[i], sizes[i]);\n    geometry.name = i.toString();\n    nodeMesh = new THREE.Mesh(geometry, material);\n    nodeMesh.position.set(\n      nodeData.x * bounds,\n      nodeData.y * bounds,\n      nodeData.z * bounds\n    );\n    group.add(nodeMesh);\n  }\n  return group;\n}\n\n// Draw BoxBased imaging from a graph\n/**\n *\n * Draw box based verices given a graph\n *\n * @param Graph - The graph that needs its vertices drawn\n * @param bounds - A global scale for the graph, defaults to one\n * @param color - Default color of the boxes defaults to white\n * @param size - Default size of the nodes defaults to 10\n * @returns\n */\nfunction DrawTHREEBoxBasedVertices(\n  Graph: Graph,\n  bounds: number = 1,\n  color: number = 0xffffff,\n  size: number | number[] = 10\n) {\n  const pmap = Graph.get_position_map();\n  const Bgroup = AddBoxBasedImaging(pmap, bounds, color, size);\n  return Bgroup;\n}\n\n// draw cylinders where required\n/**\n *\n * Draw cylinders where all the vertices are based on a node map\n *\n * @param nodeMap - the node map assiciate with the graph that has to be drawn out\n * @param divisonLength - the length of the divisions that are there in each one of the cylinder (this is a circumfurence amount), defaults to 16\n * @param color - the default color of the cylinder, defaults to white\n * @param size - the default size of the cylinder, defaults to 10\n * @returns\n */\nfunction AddCylinderBasedImaging(\n  nodeMap: Map<number, Point>,\n  divisonLength: number = 16,\n  color: number = 0xffffff,\n  size: number | number[] = 10\n) {\n  // precompute all the sizes\n  let sizes: any;\n  if (typeof size == \"number\") {\n    sizes.Array(nodeMap.size).fill(size);\n  } else {\n    sizes = size;\n  }\n  // returns a group\n  const group = new THREE.Group();\n  const material = new THREE.MeshBasicMaterial({ color: color });\n  let radius, circumfurence, segments;\n  let nodeData: Point;\n  for (let i = 0; i < nodeMap.size; i++) {\n    nodeData = nodeMap.get(i)!;\n    radius = sizes[i];\n    circumfurence = 2 * radius * Math.PI;\n    segments = Math.ceil(circumfurence / divisonLength);\n    const geometry = new THREE.CylinderGeometry(radius, radius, 10, segments);\n    geometry.name = i.toString();\n    const nodeMesh = new THREE.Mesh(geometry, material);\n    nodeMesh.position.set(nodeData.x, nodeData.y, nodeData.z);\n    group.add(nodeMesh);\n  }\n  return group;\n}\n\n// draw the sparse graph as groups\n// this seperates all the points based on some or the other group\n/**\n *\n * Split up a graph and return an boject containing a bunch of node groups and edge groups based on some parameterS\n *\n * @param Graph - the graph that you want to split up\n * @param propertyName - the property that you want to split them on\n * @returns - an object that hasa set of node vertices and a set of edge lines based on the splitting factor\n */\nasync function AddInModularityBasedPointGroups(\n  Graph: Graph,\n  propertyName: string\n) {\n  // returns an array of groups\n  const groups: Map<number, number[]> = new Map();\n  let ndata: _Node;\n  let modularity: number;\n  for (let node of Graph.nodes.keys()) {\n    ndata = Graph.nodes.get(node)!;\n    modularity = eval(`ndata.data.${propertyName}}`);\n    if (groups.has(modularity)) {\n      groups.get(modularity)!.push(node);\n    } else {\n      groups.set(modularity, [node]);\n    }\n  }\n  // then counstruct a bunch of subraphs\n  const meshGraphVertices: Map<number, THREE.Group> = new Map();\n  const meshGraphEdges: Map<number, THREE.Group> = new Map();\n  let subgraphGroup: number[];\n  let subgraph: Graph;\n  let pointRep: THREE.Group;\n  let edges: THREE.Group;\n  for (let modularityGroup of groups.keys()) {\n    subgraphGroup = groups.get(modularityGroup)!;\n    // returns an array\n    subgraph = await GraphMethods.SelectSubgraph(Graph, subgraphGroup);\n    // then make the vertex thing\n    pointRep = DrawTHREEGraphVertices(subgraph, 1);\n    meshGraphVertices.set(modularityGroup, pointRep);\n    // make the edges\n    edges = DrawSimplifiedEdges(subgraph, 0.03);\n    meshGraphEdges.set(modularityGroup, edges);\n  }\n  const ROBJ = {\n    nodeGroups: meshGraphVertices,\n    EdgeGroups: meshGraphEdges,\n  };\n  return ROBJ;\n}\n\n/**\n *\n * Draw simplified line edges (thin based) based on some number. This number is a fraction of the total number of edges (so if you specify 0.1 it would draw 10% of the edges)\n *\n * @param Graph - The graph that has to be drawn out\n * @param amount - The fraction of edges to be drawn\n * @param color - color of these edges - defaults to 0.1\n * @returns - a group of simple lines based on all the edges supplied to it\n */\nfunction DrawSimplifiedEdges(\n  Graph: Graph,\n  amount: number,\n  color: number = 0xffffff\n) {\n  const lineGroup = new THREE.Group();\n  const material = new THREE.LineBasicMaterial({ color: color });\n  let start: Point;\n  let end: Point;\n  let points: THREE.Vector3[];\n  for (let edge of Graph.edges.values()) {\n    if (Math.random() <= amount) {\n      start = Graph.nodes.get(edge.start)!.data.pos;\n      end = Graph.nodes.get(edge.end)!.data.pos;\n      points = [];\n      points.push(new THREE.Vector3(start.x, start.y, start.z));\n      points.push(new THREE.Vector3(end.x, end.y, end.z));\n      const geometry = new THREE.BufferGeometry().setFromPoints(points);\n      const line = new THREE.Line(geometry, material);\n      lineGroup.add(line);\n    }\n  }\n  return lineGroup;\n}\n\n/**\n *\n * Change all the vertex colors based on some array of properties\n *\n * @param vertices - ThreeJS Points object, be sure to pass in the points object and not the group that the points belong too\n * @param indexArray - The array of the indices of all the nodes whose values that have to be changed\n * @param color - The color that they have to be changed too\n */\nfunction ChangeTheVertexColours(\n  vertices: THREE.Points,\n  indexArray: number[],\n  color: number\n) {\n  let Attrib = vertices.geometry.attributes;\n  let k = 0;\n  const newCol = hexToRgb(color)!;\n  indexArray.forEach((node) => {\n    k = node * 3; // @ts-ignore\n    Attrib.customColor.array[k] = newCol.r; // @ts-ignore\n    Attrib.customColor.array[k + 1] = newCol.g; // @ts-ignore\n    Attrib.customColor.array[k + 2] = newCol.b;\n  });\n  Attrib.customColor.needsUpdate = true;\n}\n\n/**\n *\n * This resets all the colors to white\n *\n * @param vertices - ThreeJS Points object, be sure to pass in the points object and not the group that the points belong too\n */\nfunction ResetVertexColors(vertices: THREE.Points) {\n  let Attrib = vertices.geometry.attributes;\n  let k = 0;\n  for (let i = 0; i < Attrib.customColor.count; i++) {\n    k = i * 3; // @ts-ignore\n    Attrib.customColor.array[k] = 255; // @ts-ignore\n    Attrib.customColor.array[k + 1] = 255; // @ts-ignore\n    Attrib.customColor.array[k + 2] = 255;\n  }\n  Attrib.customColor.needsUpdate = true;\n}\n\nexport default {\n  DrawTHREEGraphVertices,\n  DrawTHREEGraphEdgesThick,\n  DrawTHREEGraphEdgesThin,\n  AddBoxBasedImaging,\n  AddInModularityBasedPointGroups,\n  DrawThinEdgesFromEdgeMap,\n  DrawThickEdgesFromEdgeMap,\n  AddCylinderBasedImaging,\n  DrawSimplifiedEdges,\n  ChangeTheVertexColours,\n  ResetVertexColors,\n  DrawTHREEBoxBasedVertices,\n};\n","///////////////\n// color convert by Tim Down\n// https://stackoverflow.com/questions/5623838/rgb-to-hex-and-hex-to-rgb\n/**\n * \n * converts hex to RGB\n * \n * @param c Hex ccomponent\n * @returns returns an object with r g b component values\n */\nfunction componentToHex(c:number) {\n  var hex = c.toString(16);\n  return hex.length == 1 ? \"0\" + hex : hex;\n}\n\n/**\n * \n * Converts Rgb to hex\n * \n * @param r red value\n * @param g green value\n * @param b blue value\n * @returns the hex value\n */\nfunction rgbToHex(r:number, g:number, b:number) {\n  return \"#\" + componentToHex(r) + componentToHex(g) + componentToHex(b);\n}\n\n/**\n * \n * @param hex the hex color code\n * @returns RGB values as r, g, b values \n */\nfunction hexToRgb(hex:string|number) {\n  // Expand shorthand form (e.g. \"03F\") to full form (e.g. \"0033FF\")\n  var shorthandRegex = /^#?([a-f\\d])([a-f\\d])([a-f\\d])$/i;\n  hex = hex.toString().replace(shorthandRegex, function (m, r, g, b) {\n    return r + r + g + g + b + b;\n  });\n\n  var result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n  return result\n    ? {\n        r: parseInt(result[1], 16),\n        g: parseInt(result[2], 16),\n        b: parseInt(result[3], 16),\n      }\n    : null;\n}\n\n\nexport{\n    rgbToHex,\n    hexToRgb\n}","const vertexShader = `\nattribute float size;\nattribute vec3 customColor;\n\nvarying vec3 vColor;\n\nvoid main() {\n    vColor = customColor;\n    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n    gl_PointSize = size * ( 300.0 / -mvPosition.z );\n    gl_Position = projectionMatrix * mvPosition;\n}\n`\n\nexport {vertexShader};","const fragmentShader = `\nuniform vec3 color;\nuniform sampler2D pointTexture;\nuniform float alphaTest;\n\nvarying vec3 vColor;\n\nvoid main() {\n    gl_FragColor = vec4( color * vColor, 1.0 );\n    gl_FragColor = gl_FragColor * texture2D( pointTexture, gl_PointCoord );\n    if ( gl_FragColor.a < alphaTest ) discard;\n}\n`;\n\nexport { fragmentShader };\n","export { default as Graph } from \"./Core/Graph\";\nexport { default as GraphMethods } from \"./GraphAlgorithms/GraphMethods\";\nexport { default as SampleData } from \"./SampleData/DataLoader\";\nexport { default as Constructors } from \"./HelperClasses/GraphConstructors\";\nexport { default as Drawing } from \"./Drawing/Drawing\";\nexport { default as Geometry } from \"./HelperClasses/GeometryHelpers\";\nexport { default as Utilities } from \"./HelperClasses/Utilities\";\nexport { default as ThreeWrapper } from \"./Drawing/ThreeJSDrawer\";\nexport { default as GraphDrawer } from \"./Drawing/GraphDrawer\";\nexport { default as GenerateErdosReyni_n_p } from \"./Models/ErdosRenyiModel\";\n","// load up the ZKC dataset\nimport { zkc } from \"./ZKC\";\nimport { zkc_simulated } from \"./ZKC_simulated\";\nimport GraphConstructors from \"../HelperClasses/GraphConstructors\";\nimport Graph from \"../Core/Graph\";\nimport Point from \"../HelperClasses/Point\";\nimport _Node from \"../Core/_Node\";\nimport Edge from \"../Core/Edge\";\nimport Drawing from \"../Drawing/Drawing\";\n\n/**\n * \n * @returns the raw ZKC dataset\n */\nasync function LoadZKC() {\n  // load up the dataset representation\n  const data = zkc;\n  const G = await GraphConstructors.ConstructGraphNodeEdgesList(data.nodes, data.edges);\n  return G;\n}\n\n/**\n * \n * @returns the ZKC dataset with the positons simulated before hand\n */\nasync function LoadZKCSimulated() {\n  // make a map\n  const data = zkc_simulated;\n  const nodes = new Map();\n  const edges = new Map();\n  // set the node map\n  data.nodes.forEach((node) => {\n    const id = node.id;\n    const pos = new Point(node.px*50, 0, node.py*50);\n    const modularity = node.member;\n    const n = new _Node({ pos: pos, size:10, info:\"Node Info\", modularity:modularity });\n    nodes.set(id, n);\n  });\n  // set the edge map\n  for (let i = 0; i < data.edges.length; i++) {\n    const edge = data.edges[i];\n    const start = edge[0];\n    const end = edge[1];\n    const e = new Edge(start, end, {});\n    edges.set(i, e);\n  }\n  // make a graph object\n  const G = await Graph.create(nodes, edges);\n  const lmap = Drawing.DrawEdgeLines(G, 10);\n  G.apply_edge_pos_maps(lmap);\n  return G;\n}\n\n// exports\nexport default { LoadZKC, LoadZKCSimulated };\n","const zkc = {\n  nodes: [\n    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20,\n    21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33,\n  ],\n  edges: [\n    [0, 1],\n    [0, 2],\n    [0, 3],\n    [0, 4],\n    [0, 5],\n    [0, 6],\n    [0, 7],\n    [0, 8],\n    [0, 10],\n    [0, 11],\n    [0, 12],\n    [0, 13],\n    [0, 17],\n    [0, 19],\n    [0, 21],\n    [0, 31],\n    [1, 2],\n    [1, 3],\n    [1, 7],\n    [1, 13],\n    [1, 17],\n    [1, 19],\n    [1, 21],\n    [1, 30],\n    [2, 3],\n    [2, 7],\n    [2, 8],\n    [2, 9],\n    [2, 13],\n    [2, 27],\n    [2, 28],\n    [2, 32],\n    [3, 7],\n    [3, 12],\n    [3, 13],\n    [4, 6],\n    [4, 10],\n    [5, 6],\n    [5, 10],\n    [5, 16],\n    [6, 16],\n    [8, 30],\n    [8, 32],\n    [8, 33],\n    [9, 33],\n    [13, 33],\n    [14, 32],\n    [14, 33],\n    [15, 32],\n    [15, 33],\n    [18, 32],\n    [18, 33],\n    [19, 33],\n    [20, 32],\n    [20, 33],\n    [22, 32],\n    [22, 33],\n    [23, 25],\n    [23, 27],\n    [23, 29],\n    [23, 32],\n    [23, 33],\n    [24, 25],\n    [24, 27],\n    [24, 31],\n    [25, 31],\n    [26, 29],\n    [26, 33],\n    [27, 33],\n    [28, 31],\n    [28, 33],\n    [29, 32],\n    [29, 33],\n    [30, 32],\n    [30, 33],\n    [31, 32],\n    [31, 33],\n    [32, 33],\n  ],\n};\n\nexport { zkc };\n","const zkc_simulated = {\n  nodes: [\n    { id: 0, px: 0.09083423378081436, py: 1.164162667707135, member: 0 },\n    { id: 1, px: -0.5395391223661004, py: 0.8787097882002372, member: 0 },\n    { id: 2, px: 0.25483951690897244, py: -0.011894166387290125, member: 0 },\n    { id: 3, px: 0.5292273814873625, py: 0.8137715604013231, member: 0 },\n    { id: 4, px: 0.6759740200024705, py: 2.010590015934319, member: 3 },\n    { id: 5, px: 0.6648725961138767, py: 2.3765595730406712, member: 3 },\n    { id: 6, px: -0.015476857282255526, py: 2.421851366492045, member: 3 },\n    { id: 7, px: 0.9923183157183725, py: 0.7358251458599251, member: 0 },\n    { id: 8, px: -0.6148021363450372, py: -0.03465499210385469, member: 1 },\n    { id: 9, px: 0.24714516178546894, py: -1.012380550604274, member: 0 },\n    { id: 10, px: 1.3293288757439443, py: 1.8641805845025743, member: 3 },\n    { id: 11, px: -0.6571791278403557, py: 2.2163816367270526, member: 0 },\n    { id: 12, px: 1.5181044222926994, py: 1.3282665066698078, member: 0 },\n    { id: 13, px: -0.2979203330003603, py: 0.18438685313887027, member: 0 },\n    { id: 14, px: -1.7502345807734376, py: -1.0935551887354324, member: 1 },\n    { id: 15, px: -1.630224787934251, py: -1.5015879850995024, member: 1 },\n    { id: 16, px: 0.5585243394360673, py: 3.5, member: 3 },\n    { id: 17, px: -0.9776584881745712, py: 1.799718659872538, member: 0 },\n    { id: 18, px: -1.385649185975611, py: -1.870388302312794, member: 1 },\n    { id: 19, px: -0.9638464461397331, py: 0.24226946279518707, member: 0 },\n    { id: 20, px: -1.0268125129631975, py: -2.1543990524894148, member: 1 },\n    { id: 21, px: -1.3061680833745626, py: 1.527228276383933, member: 0 },\n    { id: 22, px: -0.5552461198316926, py: -2.2498070887997685, member: 1 },\n    { id: 23, px: 0.8262268914348979, py: -1.804253160744954, member: 2 },\n    { id: 24, px: 1.9952840970427212, py: -1.0382885070400036, member: 2 },\n    { id: 25, px: 1.9207660053211613, py: -0.5823795272244723, member: 2 },\n    { id: 26, px: -0.1664715343791652, py: -2.6527209168204373, member: 1 },\n    { id: 27, px: 0.9961959436268844, py: -1.0143754028553023, member: 2 },\n    { id: 28, px: 0.6488880579857091, py: -1.024671500275854, member: 2 },\n    { id: 29, px: 0.2398196340697841, py: -2.171491081802323, member: 1 },\n    { id: 30, px: -1.3348117368940753, py: -0.31290471156377053, member: 1 },\n    { id: 31, px: 0.6901260074375327, py: -0.2526601933356052, member: 2 },\n    { id: 32, px: -0.6030949145287146, py: -1.0927507849665647, member: 1 },\n    { id: 33, px: -0.3533395323856202, py: -1.1887389845640028, member: 1 },\n  ],\n  edges: [\n    [0, 1],\n    [0, 2],\n    [0, 3],\n    [0, 4],\n    [0, 5],\n    [0, 6],\n    [0, 7],\n    [0, 8],\n    [0, 10],\n    [0, 11],\n    [0, 12],\n    [0, 13],\n    [0, 17],\n    [0, 19],\n    [0, 21],\n    [0, 31],\n    [1, 2],\n    [1, 3],\n    [1, 7],\n    [1, 13],\n    [1, 17],\n    [1, 19],\n    [1, 21],\n    [1, 30],\n    [2, 3],\n    [2, 7],\n    [2, 8],\n    [2, 9],\n    [2, 13],\n    [2, 27],\n    [2, 28],\n    [2, 32],\n    [3, 7],\n    [3, 12],\n    [3, 13],\n    [4, 6],\n    [4, 10],\n    [5, 6],\n    [5, 10],\n    [5, 16],\n    [6, 16],\n    [8, 30],\n    [8, 32],\n    [8, 33],\n    [9, 33],\n    [13, 33],\n    [14, 32],\n    [14, 33],\n    [15, 32],\n    [15, 33],\n    [18, 32],\n    [18, 33],\n    [19, 33],\n    [20, 32],\n    [20, 33],\n    [22, 32],\n    [22, 33],\n    [23, 25],\n    [23, 27],\n    [23, 29],\n    [23, 32],\n    [23, 33],\n    [24, 25],\n    [24, 27],\n    [24, 31],\n    [25, 31],\n    [26, 29],\n    [26, 33],\n    [27, 33],\n    [28, 31],\n    [28, 33],\n    [29, 32],\n    [29, 33],\n    [30, 32],\n    [30, 33],\n    [31, 32],\n    [31, 33],\n    [32, 33],\n  ],\n};\n\nexport { zkc_simulated };\n","import Graph from \"../Core/Graph\";\nimport _Node from \"../Core/_Node\";\nimport Edge from \"../Core/Edge\";\n\n// construct a graph based on an edge list etc\n/**\n * construct a graph based on an edge list and node list\n * @param nodes nodes as a list\n * @param edges edges as a list \n * @returns A graph that was construct from the list of nodes and edges\n */\nasync function ConstructGraphNodeEdgesList(nodes:any[], edges:any[]) {\n  // make a node OBJ\n  const nodeOBJ = new Map();\n  for (let i = 0; i < nodes.length; i++) {\n    const n = new _Node(nodes[i].data);\n    nodeOBJ.set(nodes[i], n);\n  }\n  // make an edge object\n  const edgeOBJ = new Map();\n  for (let i = 0; i < edges.length; i++) {\n    const e = new Edge(edges[i][0], edges[i][1], edges[i].data);\n    edgeOBJ.set(i, e);\n  }\n  // make a graph object\n  const G = await Graph.create(nodeOBJ, edgeOBJ);\n  return G;\n}\n\nexport default { ConstructGraphNodeEdgesList };\n","// note this file is always reffered to as\n// _Node to not confuse with node (js) and\n// Vertices which are another 3d object that\n// can be changed in three js\ninterface _Node {\n  data: any;\n  neighbours: number[];\n}\n\n/**\n * This is the node class - they have an ID which is \n * essentially an index and some data associated with it \n * The data also contains the position of the \n */\nclass _Node {\n  /**\n   * \n   * @param data Data associated with the node, be sure to be careful to pass in any \"pos\" data as they correspond to position of the nodes in the visuals of the graph\n   */\n  constructor(data:any) {\n    // this data is an arbitrary thing with which I can create any object\n    this.data = { ...data };\n    // the neighbours bit is explicity set from the code outside\n    this.neighbours = [];\n  }\n}\n\nexport default _Node;\n","import * as THREE from \"three\";\nimport { OrbitControls } from \"three/examples/jsm/controls/OrbitControls\";\nimport Graph from \"../Core/Graph\";\n\n// interface for the graph drawing class\ninterface GraphDrawer3d {\n  canvas: HTMLCanvasElement;\n  width: number;\n  height: number;\n  geometryMap: Map<any, any>;\n  materialMap: Map<any, any>;\n  meshMap: Map<any, any>;\n  controls: OrbitControls;\n  renderer: THREE.WebGLRenderer;\n  camera: THREE.PerspectiveCamera;\n  scene: THREE.Scene;\n  graphs: Map<number, Graph>;\n}\n\n/**\n * This is the main graph drawer class\n */\nclass GraphDrawer3d {\n  /**\n   * To initialize the graph drawer there are a set of graph drawing settings that have to be set.\n   * Here are the details to do the same:\n   * canvas - the html canvas element that you would like to render \n   * height - the the height of the initialized canvas\n   * width - the width of the initialized canvas\n   * geometry map - a map that keeps track of all the geometry in the scene (Optional)\n   * material map - a mapt that keeps track of all the materials in the scene (Optional)\n   * controls - Controls that define how one can navigate this 3d space (Self initialized)\n   * renderer - Renderer element form the three JS library\n   * camera -  A perspective camera from the threeJS library \n   * scene - The three JS scene that gets define automatically\n   * \n   * @param GraphDrawerOptions3d - These above options are construdeted into a single object and passed into the Options elem\n   */\n  constructor(GraphDrawerOptions3d: {\n    canvas: HTMLCanvasElement;\n    width: number;\n    height: number;\n    geometryMap: Map<any, any>;\n    materialMap: Map<any, any>;\n    meshMap: Map<any, any>;\n    controls: OrbitControls;\n    renderer: THREE.WebGLRenderer;\n    camera: THREE.PerspectiveCamera;\n    scene: THREE.Scene;\n  }) {\n    this.canvas = GraphDrawerOptions3d.canvas;\n    this.width = GraphDrawerOptions3d.width;\n    this.height = GraphDrawerOptions3d.height;\n    // these maps are optional\n    // ive kepth them in as a way of managing all the\n    // geometry in the scene\n    this.geometryMap = new Map();\n    this.materialMap = new Map();\n    this.meshMap = new Map();\n    this.controls;\n    this.renderer;\n    this.camera;\n    this.scene;\n    // graph map is the hash map that holds all the\n    // graphs that we are working with together\n    this.graphs = new Map();\n  }\n\n  /**\n   * This essentially initializes the drawing element based on the settings\n   * Remember to do this since if if its not done the scene will not render\n   */\n  async init() {\n    const t1 = performance.now();\n\n    this.camera = new THREE.PerspectiveCamera();\n\n    // start up a new scene\n    this.scene = new THREE.Scene();\n\n    // set up a renderer\n    this.renderer = new THREE.WebGLRenderer({\n      canvas: this.canvas,\n      antialias: true,\n    });\n    this.renderer.setSize(this.width, this.height);\n    this.renderer.setClearColor(0xff00ff, 0);\n\n    // add in a light\n    this.scene.add(new THREE.AmbientLight(0xffffff));\n    // add a spotlight\n    const DirectionalLight = new THREE.DirectionalLight(0xffffff, 1);\n    DirectionalLight.position.set(0, 10, 0);\n    this.scene.add(DirectionalLight);\n\n    // set up the control system\n    this.controls = new OrbitControls(this.camera, this.renderer.domElement);\n    this.camera.position.set(0, 100, 100);\n    this.controls.autoRotate = true;\n    this.controls.maxPolarAngle = Math.PI * 0.5;\n    this.controls.maxDistance = 1000;\n    this.controls.minDistance = 10;\n    this.controls.update();\n\n    // finally print out that the initialization has finished\n    const t2 = performance.now();\n    console.log(\"initialization has finished\");\n    console.log(`Time to initialize ${t2 - t1} milliseconds`);\n  }\n\n  //add graph\n  // this adds a graph to the current visualizer\n  /**\n   * \n   * This is the main way to add elements to the viewer window that gets initialized\n   * \n   * @param element A geomerty element + material element to add to the scene as a group line or point cloud\n   */\n  addVisElement(element: THREE.Group | THREE.Line | THREE.Points) {\n    this.scene.add(element);\n  }\n\n  // this stuff renders out one specific instances\n  /**\n   * This is the render call that is called every frame to update the rendering of the canvas\n   * Remember to do this since this is a common are for bugs to occur\n   */\n  rendercall() {\n    // this is the render draw call\n    this.renderer.render(this.scene, this.camera);\n    this.controls.update();\n  }\n}\n\nexport default {\n  GraphDrawer3d,\n};\n","// This essentially generates a erdos reyni graph\n// Super useful for juszt getting a random graph and studying\n// graph structure. Read more https://en.wikipedia.org/wiki/Erd%C5%91s%E2%80%93R%C3%A9nyi_model\n\nimport Edge from \"../Core/Edge\";\nimport Graph from \"../Core/Graph\";\nimport _Node from \"../Core/_Node\";\n\n/**\n * The G ( n , p ) G(n,p) model, a graph is constructed by connecting labeled nodes randomly. Each edge is included in the graph with probability p p, independently from every other edge.\n * https://en.wikipedia.org/wiki/Erd%C5%91s%E2%80%93R%C3%A9nyi_model\n * @param n Number of nodes\n * @param p Probability of two edges to eb connected\n * @returns A Erdos Reyni graph\n */\nfunction GenerateErdosReyni_n_p(n: number, p: number) {\n  // first create a list of nodes\n  const nodes = new Map();\n  const edges = new Map();\n  let node; // define once use many times basically\n  for (let i = 0; i < n; i++) {\n    node = new _Node({});\n    // set this node\n    nodes.set(i, node);\n  }\n  // now that all the nodes have been created\n  // now loop all the node combinations and then\n  // create the edge\n  let interimP;\n  let edge;\n  let index = 0;\n  for (let i = 0; i < n; i++) {\n    for (let ii = 0; ii < n; ii++) {\n      // im skipping self loops so just make sure there is\n      // an if statement for the settings\n      if (i != ii) {\n        interimP = Math.random();\n        if (p > interimP) {\n          // then create and edge and add that edge to the list of edges\n          edge = new Edge(i, ii, {});\n          edges.set(index, edge);\n          index += 1;\n        }\n      }\n    }\n  }\n  // now create the actual graph\n  const G = new Graph(nodes, edges);\n  // lastly return the graph\n  return G;\n}\n\nexport default { GenerateErdosReyni_n_p };\n"],"names":[],"version":3,"file":"pgl.js.map"}