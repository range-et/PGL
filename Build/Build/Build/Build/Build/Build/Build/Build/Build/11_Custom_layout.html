<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="stylesheet" href="MasterStyle.css" />
  <title>Example 11 – Custom layout from matrix math</title>
</head>

<body class="example-page">
  <header class="example-header">
    <a href="examples.html" class="back-link">← All examples</a>
    <h1>Example 11 – Custom layout from matrix math</h1>
    <p class="example-desc">Adjacency matrix → power iteration for two vectors → use as X/Z coordinates. Full pipeline: get_adjacency_matrix(), matrixVectorMultiply, apply_position_map.</p>
    <a href="https://github.com/range-et/PGL/blob/main/Examples/11_Custom_layout.html" class="code-link" target="_blank" rel="noopener">View code</a>
  </header>
  <div class="canvas-wrap">
    <canvas id="displayCanvas" class="displayCanvas"></canvas>
    <script type="module">
      import * as PGL from "../Build/pgl_module.js";

      const G = await PGL.Models.GenerateErdosReyni_n_p(120, 0.05);
      await G.initialize();
      G.printData();

      const { matrix, nodeIds } = G.get_adjacency_matrix();
      const n = nodeIds.length;
      const out = new Float32Array(n);

      function powerIteration(seed) {
        const x = new Float32Array(n);
        for (let i = 0; i < n; i++) x[i] = seed(i);
        PGL.normalizeVector(x);
        for (let iter = 0; iter < 15; iter++) {
          PGL.matrixVectorMultiply(matrix, n, x, out);
          x.set(out);
          PGL.normalizeVector(x);
        }
        return x;
      }

      const xCoord = powerIteration(() => Math.random());
      const zCoord = powerIteration((i) => (i % 2 === 0 ? 1 : -1));

      let minX = Infinity, maxX = -Infinity, minZ = Infinity, maxZ = -Infinity;
      for (let i = 0; i < n; i++) {
        if (xCoord[i] < minX) minX = xCoord[i];
        if (xCoord[i] > maxX) maxX = xCoord[i];
        if (zCoord[i] < minZ) minZ = zCoord[i];
        if (zCoord[i] > maxZ) maxZ = zCoord[i];
      }
      const scale = 80;
      const rx = maxX - minX || 1;
      const rz = maxZ - minZ || 1;
      const posMap = new Map();
      nodeIds.forEach((id, i) => {
        posMap.set(id, {
          x: scale * (xCoord[i] - minX) / rx,
          y: 0,
          z: scale * (zCoord[i] - minZ) / rz,
        });
      });
      G.apply_position_map(posMap);

      const lmap = PGL.Drawing.DrawEdgeLinesDivisions(G, 1);
      G.apply_edge_pos_maps(lmap);

      const width = 800;
      const height = 700;
      const canvas = document.getElementById("displayCanvas");
      const graph3d = new PGL.GraphDrawer.GraphDrawer3d({ graph: G, width, height, canvas });
      await graph3d.init();

      const bounds = 0.1;
      graph3d.addVisElement(PGL.ThreeWrapper.DrawTHREEGraphVertices(G, bounds, 1, 0xffffff, 1));
      graph3d.addVisElement(PGL.ThreeWrapper.DrawTHREEGraphEdgesThin(G, bounds, 0xffafcc));

      function animate() {
        requestAnimationFrame(animate);
        graph3d.rendercall();
      }
      animate();
    </script>
  </div>
</body>

</html>
